<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Azure on kentxxq Blog</title><link>https://kentxxq.com/tags/azure/</link><description>Recent content in Azure on kentxxq Blog</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Thu, 04 Jul 2019 11:08:00 +0000</lastBuildDate><atom:link href="https://kentxxq.com/tags/azure/index.xml" rel="self" type="application/rss+xml"/><item><title>我的k8s之路1-基本概念</title><link>https://kentxxq.com/contents/%E6%88%91%E7%9A%84k8s%E4%B9%8B%E8%B7%AF1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link><pubDate>Thu, 04 Jul 2019 11:08:00 +0000</pubDate><guid>https://kentxxq.com/contents/%E6%88%91%E7%9A%84k8s%E4%B9%8B%E8%B7%AF1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid><description>我现在服务器上的微信，博客笔记，redis等等服务都是用的docker部署。在之前写过部署web服务（可拓展），从现在的观点来看，还是比较落伍的，几乎没有自动化。代码部署/系统维护等等的问题没有考虑进去。而docker就解决了这些问题。
而k8s则是docker在企业实践中的事实标准。
我就用大白话来说说自己的理解和使用吧。
关于k8s 每当出现一个问题，就会出现对应的解决方法。下面是我个人的理解的简化版。
openstack是把一堆硬件资源，整合到一起变成一台超级计算机。在此基础上，虚拟出各种资源。对硬件资源进行了整合。同时方便扩容。
docker解决的是app应用的环境问题。
k8s解决了docker编排，负载均衡，自动拓展等等问题。
openstack是为了让vm无忧无虑的健康运行。k8s则是为你的docker提供完美的环境。
概念 这里我仅列出来我暂时用到的概念。总不能一上来，把文档从头看到尾吧～
Pod Pod是k8s的最小计算单元。最常用的情况就是一个docker容器（同时入门使用也推荐此用法）。
如果像是redis集群这样的应用，每个pod之间可以使用卷功能来进行共享数据。
通常在大型应用的场景下，docker的部署很多都是一台机器运行一个docker容器。
而如果你只有3个节点的k8s集群，你也可以运行3个以上的pod。虽然不推荐这样子，但是k8s首要目的是为了让你的部署方案能成功。
pod中的Controller通过Template来创建pod。
Service Service是pod的逻辑集合。对内进行pod的负载均衡。对外提供访问地址。
Volume Volume为pod提供共享数据卷。
Lable Lable用来区分service/pod等资源。LableSelector用来service/pod之间的对应。
Deployment Deployment它管理ReplicaSets和Pod，并提供声明式更新等功能。
一个pod挂了，应用就挂了。而通过Deployment设置用几个pod来提供服务，确保应用正常运作。
web应用 win10的激活可以自己搭建kms服务器。而并不需要数据库来存储任何信息。 StatefulSet StatefulSet用于持久性的应用程序，有唯一的网络标识符（IP），持久存储，有序的部署、扩展、删除和滚动更新。
redis集群 部署应用后一键回滚，且不影响运行中的应用 Job Job用来执行一次性的任务。可定时。
比如开启100个pod来执行一个cpu密集型的应用。完了存到数据库以后，直接销毁。 示例 apiVersion: apps/v1 kind: Deployment metadata: name: azure-vote-back spec: replicas: 1 selector: matchLabels: app: azure-vote-back template: metadata: labels: app: azure-vote-back spec: nodeSelector: &amp;#34;beta.kubernetes.io/os&amp;#34;: linux containers: - name: azure-vote-back image: redis resources: requests: cpu: 100m memory: 128Mi limits: cpu: 250m memory: 256Mi ports: - containerPort: 6379 name: redis --- apiVersion: v1 kind: Service metadata: name: azure-vote-back spec: ports: - port: 6379 selector: app: azure-vote-back --- apiVersion: apps/v1 kind: Deployment metadata: name: azure-vote-front spec: replicas: 1 selector: matchLabels: app: azure-vote-front template: metadata: labels: app: azure-vote-front spec: nodeSelector: &amp;#34;beta.</description></item></channel></rss>