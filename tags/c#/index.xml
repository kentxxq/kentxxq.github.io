<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C# on kentxxq Blog</title><link>https://kentxxq.com/tags/c#/</link><description>Recent content in C# on kentxxq Blog</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Tue, 17 Dec 2019 11:45:00 +0800</lastBuildDate><atom:link href="https://kentxxq.com/tags/c#/index.xml" rel="self" type="application/rss+xml"/><item><title>csv转xlsx文件</title><link>https://kentxxq.com/contents/csv%E8%BD%ACxlsx%E6%96%87%E4%BB%B6/</link><pubDate>Tue, 17 Dec 2019 11:45:00 +0800</pubDate><guid>https://kentxxq.com/contents/csv%E8%BD%ACxlsx%E6%96%87%E4%BB%B6/</guid><description>Excel是大家办公最常遇到的文件之一。一旦需要具体数据的时候，客户都要求这个文件。
而我用plsql从oracle数据库中查出来以后，一般都是直接导出csv文件。需要手动去wps导入csv，转换成xlsx文件。有时候文件实在是太多了，麻烦。
于是就有了这个文章。
python代码 pyexcel版本 这个版本代码最简单的，缺点就是非常慢。100W行的数据[1,2,3,4][2,3,4,5]&amp;hellip;需要2分钟！
# 你还需要安装pyexcel-xlsx from pyexcel import get_sheet sheet = get_sheet(file_name=&amp;#39;/Users/kentxxq/test.csv&amp;#39;) sheet.save_as(filename=&amp;#39;/Users/kentxxq/test.xlsx&amp;#39;) print(sheet.number_of_rows()) print(&amp;#39;ok&amp;#39;) pyexcelerate版本 这个看了一个它在测试，确实很快。大概60s。还是不太理想。
import time from pyexcelerate import Workbook import csv import os from multiprocessing.pool import Pool def csv_to_xlsx(file): start = time.time() print(&amp;#39;开始处理:&amp;#39;+os.path.split(file)[1]) with open(file, &amp;#39;r&amp;#39;, encoding=&amp;#39;gbk&amp;#39;) as f: lines = list(csv.reader(f)) wb = Workbook() wb.new_sheet(&amp;#39;sheet1&amp;#39;, data=lines) wb.save(file + &amp;#39;.xlsx&amp;#39;) end = time.time() duration = end-start print(os.path.split(file)[1] + &amp;#39;处理完成:&amp;#39; + str(duration) + &amp;#39;秒&amp;#39;) if __name__ == &amp;#39;__main__&amp;#39;: start = time.</description></item><item><title>AspNetCore的初步了解</title><link>https://kentxxq.com/contents/aspnetcore%E7%9A%84%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3/</link><pubDate>Thu, 13 Jun 2019 10:21:00 +0800</pubDate><guid>https://kentxxq.com/contents/aspnetcore%E7%9A%84%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3/</guid><description>应用无论实现了怎样的效果，总是需要展示的。而web是最方便的展示方法。让我来搭建一个web项目。那我肯定采用前后端分离。
如果要选择用什么语言来进行后端开发。快速开发我一定选择python。而需要性能且服务器数量少的时候，静态语言我会选c#。
所以就选择来初步了解一下net core以及一些语法特性。
文章中很多都只是给到了文档的链接，是因为官方文档非常详细。自己抄过来没有意义，同时链接到的地址也会有最新变化。要学好编程，官方文档是必看的。哪怕是英文版
安装所需工具 Visual Studio是宇宙第一ide这句话，大家也多多少少有过了解了。安装好以后，开发环境就弄好了。
初步搭建 看官方文档的Web API就ok。
C#开发的方便之处 models模块直接自动生成！直接可以配合linq使用。 新增控制器，直接把增删改查都做好了。只需要加入一丢丢的业务逻辑即可！ 如果使用的是Azure云服务，还可以一键上云，也太方便了。。 上面的几点，让我觉得比python开发速度还要快。
C#的委托 根据一点基础的了解。我认为委托让C#有了把函数作为参数传递的解决方案。
C#的匿名函数其实是委托的一种简写。
C#的箭头函数其实就是匿名函数的另一种表达方式。
C#的linq语法可以完全等价转换到箭头函数，也可以说是基于委托实现的。
C#的事件是特殊的委托。
我所遇到的问题 从oracle生成models Scaffold-DbContext &amp;#34;Data Source=(DESCRIPTION =(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST = db_host)(PORT = 1521)))(CONNECT_DATA =(SERVICE_NAME = orcl)));User ID=kentxxq;Password=123456;&amp;#34; Oracle.EntityFrameworkCore -OutputDir Models 如果上面的命令无法识别，执行下面的操作
Install-Package Microsoft.EntityFrameworkCore.Tools 测试API 一直用postman来对后端测试。老是切换来切换去。还得自己一个一个路径来写文档。
然后发现有Swagger。神器啊！
用Nuget安装依赖Swashbuckle.AspNetCore后，在Startup.cs的ConfigureServices加入代码
services.AddSwaggerGen(c =&amp;gt; { c.SwaggerDoc(&amp;#34;v1&amp;#34;, new Info { Title = &amp;#34;My API&amp;#34;, Version = &amp;#34;v1&amp;#34; }); // 还可以给openapi添加xml注释 // 什么是xml注释？就是函数的中文名、每个参数的含义等等。PS: 1591忽略没有写xml注释的警告 // 编辑&amp;lt; project_name&amp;gt;.</description></item><item><title>入坑Xamarin初探</title><link>https://kentxxq.com/contents/%E5%85%A5%E5%9D%91xamarin%E5%88%9D%E6%8E%A2/</link><pubDate>Fri, 10 May 2019 00:46:00 +0800</pubDate><guid>https://kentxxq.com/contents/%E5%85%A5%E5%9D%91xamarin%E5%88%9D%E6%8E%A2/</guid><description>在之前无意中了解到了linq，被超级方便的语法吸引到了。开始认真了解C#以及微软的现状。
github被微软收购以后开放了免费的无限量私人仓库。C#自举且一系列生态代码完全开源。net core跨平台且目标是替代framework系列。浏览器开始使用chrome相同的内核且融合了ie模式，却被谷歌摆了一道。还有云平台，ide等等一系列的动作。
这些做法让我对微软的好感度急剧攀升。无意间了解到Xamarin，更是让我不得不想叫一句：微软爸爸。
为什么会有这篇文章 在最近了解了一系列微软的技术发展动态后，一个不能停止学习的程序员应该体会到，如果不去了解它(微软的技术栈)，沉溺在公司现有的技术栈，会导致视野越来越小。甚至几年以后，与公司外部世界技术脱轨。
从技术方面来说，微软有这些值得注意的点:
c#/c++/xaramin等等技术的全面开源。可以在使用微软技术栈的同时，更好的学习知识(或者排坑)。 积极拥抱社区，为Chromium内核项目提交代码。发布WSL2支持原生linux内核，秒级启动！同时支持docker技术！ 从net5的blog来看，以后windows会放弃net framework，而使用net core。 随着vs/vsc和微软服务绑定增多，开发越来越方便。vsc remote等理念非常前沿，甚至可以说是未来的开发模式！ 从上面可以得出，学好了微软技术栈在开发中可以有以下优势:
类似java，可以跨平台运行。同时在windows上，可以不用安装运行环境！ 对于普通用户来说，跨平台就是一个伪需求。在xp电脑上能双击打开的exe才是王道。 xaramin可以开发移动端app(iOS/Android)，且拥有庞大的社区。 对比js写的windows客户端，C#性能不用担心。 Xamarin初步了解 一个跨平台UI开发的解决方案。
对比原生语言。同时开发iOS，Android应用，且代码的复用率高。
对比js跨平台。性能有优势。
对比flutter技术。dart是一个不主流的语言。且如果flutter胎死腹中(指fuchsia无法代替安卓)，那你学了dart语言以后，几乎没有用武之地！因为几乎没有公司用dart来编写除flutter以外的项目。
前期准备工作 只需要傻瓜化安装vs，即可完成整个开发环境的搭建。vs官方文档是最好的教程了。且中文！
参见Xamarin官方文档，数据线连接在安卓手机上开启debug模式。点击即可运行。
而iOS则属于排坑之旅了。
排坑之旅 iOS开发 你需要一个mac电脑。或者参考云mac，我没用过，也不推荐这样。 最好有一个iPhone，因为模拟器耗资源，且不方便操作。 装好xcode 新建跨平台应用的时候注意你的应用名称和组织标识符 用Apple ID申请成为开发者。如果你有付费的开发者账号可以按照Xamarin官网的方法来，否则继续往下看。 Xcode随便新建一个项目，关键Bundle Identifier要一致。打开Xcode=&amp;gt;Preferences=&amp;gt;Accounts，。然后添加你自己的账号。Manage Certificates。 7. 回到General，钩上自动signing。team选择自己personal team。等一会就ojbk了！ 8. 回到vs=&amp;gt;左上角kentxxq_app.iOS=&amp;gt;Debug=&amp;gt;你的iPhone,启动项目吧！
生成apk 在生成apk文件的时候，记得选择release来生成。否则apk的大小会非常惊人。
笑容逐渐展露 开始写代码。参考官方文档，试一下闪光灯和语音功能！
为什么呢？因为我记得好久以前iPhone没有自带手电筒的功能，我是通过app下载的。而且一个调用了硬件，语音功能则调用了软件。
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;ContentPage xmlns=&amp;#34;http://xamarin.com/schemas/2014/forms&amp;#34; xmlns:x=&amp;#34;http://schemas.microsoft.com/winfx/2009/xaml&amp;#34; xmlns:local=&amp;#34;clr-namespace:kentxxq_app&amp;#34; x:Class=&amp;#34;kentxxq_app.MainPage&amp;#34;&amp;gt; &amp;lt;StackLayout&amp;gt; &amp;lt;!</description></item></channel></rss>