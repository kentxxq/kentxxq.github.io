<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>python on kentxxq Blog</title><link>https://kentxxq.com/tags/python/</link><description>Recent content in python on kentxxq Blog</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Tue, 17 Dec 2019 11:45:00 +0800</lastBuildDate><atom:link href="https://kentxxq.com/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>csv转xlsx文件</title><link>https://kentxxq.com/contents/csv%E8%BD%ACxlsx%E6%96%87%E4%BB%B6/</link><pubDate>Tue, 17 Dec 2019 11:45:00 +0800</pubDate><guid>https://kentxxq.com/contents/csv%E8%BD%ACxlsx%E6%96%87%E4%BB%B6/</guid><description>Excel是大家办公最常遇到的文件之一。一旦需要具体数据的时候，客户都要求这个文件。
而我用plsql从oracle数据库中查出来以后，一般都是直接导出csv文件。需要手动去wps导入csv，转换成xlsx文件。有时候文件实在是太多了，麻烦。
于是就有了这个文章。
python代码 pyexcel版本 这个版本代码最简单的，缺点就是非常慢。100W行的数据[1,2,3,4][2,3,4,5]&amp;hellip;需要2分钟！
# 你还需要安装pyexcel-xlsx from pyexcel import get_sheet sheet = get_sheet(file_name=&amp;#39;/Users/kentxxq/test.csv&amp;#39;) sheet.save_as(filename=&amp;#39;/Users/kentxxq/test.xlsx&amp;#39;) print(sheet.number_of_rows()) print(&amp;#39;ok&amp;#39;) pyexcelerate版本 这个看了一个它在测试，确实很快。大概60s。还是不太理想。
import time from pyexcelerate import Workbook import csv import os from multiprocessing.pool import Pool def csv_to_xlsx(file): start = time.time() print(&amp;#39;开始处理:&amp;#39;+os.path.split(file)[1]) with open(file, &amp;#39;r&amp;#39;, encoding=&amp;#39;gbk&amp;#39;) as f: lines = list(csv.reader(f)) wb = Workbook() wb.new_sheet(&amp;#39;sheet1&amp;#39;, data=lines) wb.save(file + &amp;#39;.xlsx&amp;#39;) end = time.time() duration = end-start print(os.path.split(file)[1] + &amp;#39;处理完成:&amp;#39; + str(duration) + &amp;#39;秒&amp;#39;) if __name__ == &amp;#39;__main__&amp;#39;: start = time.</description></item><item><title>python技巧-类</title><link>https://kentxxq.com/contents/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/</link><pubDate>Tue, 26 Nov 2019 00:00:00 +0800</pubDate><guid>https://kentxxq.com/contents/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/</guid><description>最近把手上的事情都忙完了。准备来好好巩固自己的python知识。为什么标题是技巧呢，因为这部分是它和其他语言最大的不同，或者说特点。要玩得6，不熟这一些知识点，肯定是不行。
python的类 python可以用函数式编程。也支持面向对象编程。
在使用函数式编程的时候，多数都是用来写脚本。同时这也是python最开始发光发亮的点。但是在处理结构性数据以及架构项目的时候，面向对象的优势就会凸显出来。同时也有很多的黑魔法让你快速完成原型的构造。
先说type函数 我们经常用type函数来查看对象的类型信息。但还有一个用法，就是用type来生成对象。当你在写python class代码的时候，解析器遇到class代码块，就会解析class结构，然后用type来构造对象。
# name代表类名，base代表父类或者说基类，attrs为字典形式，代表属性值。 type(name, base, attrs) type和元类 class TMetaClass(type): def __new__(cls, name, base, attrs): print(&amp;#39;in TMetaClass new&amp;#39;) return type.__new__(cls, name, base, attrs) def __init__(self, object_or_name, bases, dict): print(&amp;#39;in TMetaClass init&amp;#39;) super().__init__(object_or_name, bases, dict) class Person(metaclass=TMetaClass): def __new__(cls): print(&amp;#39;in Person&amp;#39;) return object.__new__(cls) def __init__(self): print(self.__class__.__name__) super().__init__() def test(self): print(&amp;#39;Person test..&amp;#39;) class Man(Person): def __new__(cls): print(&amp;#39;in Man&amp;#39;) return object.__new__(cls) def test(self): print(&amp;#39;Man test..&amp;#39;) print(&amp;#39;-&amp;#39;*20) kentxxq1 = Person() kentxxq1.</description></item><item><title>poetry_更好的python包管理</title><link>https://kentxxq.com/contents/poetry_%E6%9B%B4%E5%A5%BD%E7%9A%84python%E5%8C%85%E7%AE%A1%E7%90%86/</link><pubDate>Tue, 05 Mar 2019 23:41:00 +0800</pubDate><guid>https://kentxxq.com/contents/poetry_%E6%9B%B4%E5%A5%BD%E7%9A%84python%E5%8C%85%E7%AE%A1%E7%90%86/</guid><description>我在学习python过程中，一直想要寻求到最佳实践。
因为它意味着当你拿到一份你没有见过的代码时，这种事实标准会帮助到你。
使用包管理的原因 pip和python包管理问题 单个项目中要把需要的包独立出来，方便部署 不同的项目要求不同的包版本，不能混乱 py2和py3或者具体的小版本，区分开来 pipenv vs venv(py3) vs poetry pipenv pipenv在github上有15000+的star，commit次数达6000+，这代表着很多人看好它,足够大用户群,完善程度较高。
但是它也存在有问题：
lock太慢。在国内特别特别慢，你需要修改Pipfile的source才能加速(还是会慢)。 只是单纯用来替代requirements.txt文件，没有综合解决setup.py等工具的打包问题 venv 它是python官方推荐的工具。所以(PyCharm，vscode等)对它的支持也会是最好的。
虽然之前官方包pyvenv被弃用了。但是它支持最好，它只有一些基本的功能。
poetry 使用的人不多，知名度也不高。
但是没有pipenv的一些问题。这是我比较推荐的一个。
但也有一个问题。那就是PyCharm等等工具是不支持的。
最终选择 使用poetry,要素:
简单，快速 综合了setup.py，所以极有可能以后成为事实标准，对任何开发者都更加方便。 PyCharm不是你的常用首选工具 为什么我加上第三点呢？因为PyCharm(vscode对它的支持个人觉得不实用)支持pipenv。在ide内安装包，很方便啊。而且我没有遇到速度慢的问题,不清楚是不是ide自己做了处理。
PyCharm默认的情况下，是使用virtualvenv，它和venv几乎没有什么区别。方便就好啊!
poetry在PyCharm呢？去命令行里装。虽然更直接。但是你可能记不清具体的包名？想看看最新的版本号？PyCharm都给你解决了。
杂谈 requests的确是个很好用的库。
那是因为python标准库在一开始没有设计好，而后有很多的开发者加入了requests的贡献行列，所以很厉害。
但是并不是他开发的所有东西都是最适合你的。你需要自己去体验它。
他的库，总有用for humans来标榜自己。其他人写的难道就不是给人用的啦？
虽然很多人都这样创造了好用的工具，但是pipenv显然还不是那么好。</description></item><item><title>python导出qq空间到博客</title><link>https://kentxxq.com/contents/%E5%AF%BC%E5%87%BAqq%E7%A9%BA%E9%97%B4%E5%88%B0%E5%8D%9A%E5%AE%A2/</link><pubDate>Sun, 13 Jan 2019 00:00:00 +0800</pubDate><guid>https://kentxxq.com/contents/%E5%AF%BC%E5%87%BAqq%E7%A9%BA%E9%97%B4%E5%88%B0%E5%8D%9A%E5%AE%A2/</guid><description>既然有了自己的博客，把以前的黑历史啥的都搬过来吧。毕竟这个网站我是打算用很久很久的。我只保存了所有的照片，所有的留言板都是对我单独的对话，所有的说说都是我的一个日记。
先用一个老哥的开源代码把数据跑下来 把照片都传到google相册 把留言板弄成md，然后把e101类似的表情手动对比替换了。。。主要是没有文档，还不如手动来得快 # coding:utf-8 import os import json import arrow import re head = &amp;#34;&amp;#34;&amp;#34; --- title: qq空间黑历史 date: 2019-01-14 00:00:00 +0800 categories: [&amp;#34;黑历史&amp;#34;] tags: [&amp;#34;留言板&amp;#34;] --- &amp;#34;&amp;#34;&amp;#34; path = &amp;#39;/Users/kentxxq/kent_code/QzoneExporter/805429509/msg_board&amp;#39; files = os.listdir(path) files = sorted(files) p_html = re.compile(&amp;#39;\[.*?\]&amp;#39;) with open(&amp;#39;/Users/kentxxq/kent_code/blog/site/content/posts/lines/qq空间黑历史.md&amp;#39;, &amp;#39;w&amp;#39;) as f: f.write(head) f.write(&amp;#39;\n&amp;#39;) f.write(&amp;#39;\n&amp;#39;) for file in files: with open(path + &amp;#39;/&amp;#39; + file, &amp;#39;r&amp;#39;) as m: datas = json.load(m)[&amp;#39;data&amp;#39;][&amp;#39;commentList&amp;#39;] for data in datas: pubtime = data[&amp;#39;pubtime&amp;#39;] f.</description></item><item><title>python二进制和位运算</title><link>https://kentxxq.com/contents/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/</link><pubDate>Wed, 29 Aug 2018 00:00:00 +0800</pubDate><guid>https://kentxxq.com/contents/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/</guid><description>简介 一直以来，我对二进制啊，8进制啊，16进制啊不太了解，没有系统学习过。 今天来补习一下c的知识，同时做一下笔记，以后忘了就看这里好了。
进制 2进制：逢2进1
8进制：逢8进1
16进制：逢16进1
在C程序中的表示(python中也一样)：
0b101 /*2进制 0b开头*/ 0115 /*8进制 0开头*/ 0xFFF /*16进制 0x开头*/ 转换十进制方法:个位直接加，十位是进制数的1次方，百位是进制数的2次方，高位以此类推即可
0b101 = 1 + 0*2 + 1*2*2
0115 = 5 + 1*8 + 1*8*8
0xFAF = 15 + 10*15 + 15*15*15
位运算符 我其实用的不是特别多，见的也不多。但是在很多的官方案例中出现过，比如python人脸识别中的跳出循环
if cv2.waitKey(1) &amp;amp; 0xFF == ord(&amp;#39;q&amp;#39;): break 所以首先总结一下：
&amp;lt;&amp;lt; #左移 &amp;gt;&amp;gt; #右移 | #位或 &amp;amp; #位与 ^ #位异或 ~ #非 &amp;lt;&amp;lt; #左移 将所有的0和1的位置进行左移，移位之后将空位补0 左移操作相当于乘以2**n，以5 &amp;lt;&amp;lt; 3 为例，相当于5(2*3),结果为40 0b101 变成了 0b101000 # 一个int是4个字节，一个字节是8位(bit)，它存储的大小就是32位 # 如果加了0，超出了32位边界，那么就是溢出了 &amp;gt;&amp;gt; #右移 将所有的0和1的位置进行右移(直接舍弃)，空位正数补0，负数补1 右移操作相当于除以2**n，8 &amp;gt;&amp;gt; 3 相当于8/(2**3)=1 | #位或 0b110 | 0b101 #输出7,即0b111 只要有一位有1就为1，可以用在综合条件 &amp;amp; #位与 0b110 &amp;amp; 0b011 #输出2，即0b010 相同的位才为1，可以用在linux权限 ^ #位异或 0b1010 ^ 0b1111 #输出5，即0b0101 异或常用于将所有的位反转，相同的位置是0，否则其他的位置变1， ~ #非 ~0b101 #输出2，即0b010 这个是单独运算的，直接就把所有的反转了 理解cv2.</description></item><item><title>python的文件项目打包</title><link>https://kentxxq.com/contents/python%E7%9A%84%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/</link><pubDate>Thu, 19 Oct 2017 00:00:00 +0800</pubDate><guid>https://kentxxq.com/contents/python%E7%9A%84%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/</guid><description>在自己的机器还有服务器上面，都应该搭建好pyenv 网络上的教程太多了，但是说的又很乱。所以自己稍微整理一下。 这次的目的是写一个及其简单的过程，所以如果有具体问题，请看官方文档。
先看目录结构 $ tree . ├── MANIFEST.in ├── README.md ├── myapp │ ├── 1.txt │ ├── __init__.py │ ├── __pycache__ │ │ ├── __init__.cpython-36.pyc │ │ └── test.cpython-36.pyc │ ├── test.py │ └── txt │ └── 1.txt ├── myapp2 │ └── test222.py └── setup.py 4 directories, 10 files MANIFEST.in用来记录除了py文件外，需要打包的文件 # 包含文件 include README.md # 递归-包含 recursive-include myapp/txt * README.md一个用来简单介绍的文档
myapp和myapp2都是存放代码
setup.</description></item><item><title>python的pip出现故障</title><link>https://kentxxq.com/contents/python%E7%9A%84pip%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C/</link><pubDate>Tue, 05 Sep 2017 00:00:00 +0800</pubDate><guid>https://kentxxq.com/contents/python%E7%9A%84pip%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C/</guid><description> 今天在使用的过程中macOS，想要用命令更新一下python的所有包。 使用命令如下：
# 把所有的过期包找出来，使用-U来更新 pip3 list --outdated | grep &amp;#39;^[a-z]* (&amp;#39; | cut -d &amp;#34; &amp;#34; -f 1 | xargs pip3 install -U 出现报错 ImportError: cannot import name &amp;#39;IncompleteRead&amp;#39; 解决问题 # 1...在官网下载新的python安装包，然后进行安装。 并不会影响到你之前的python3环境！例如xlrd等工具包，并不会被覆盖丢失！ wget https://www.python.org/ftp/python/3.6.2/python-3.6.2-macosx10.6.pkg --no-check-certificate # 2...wget下载这一个python文件--这个地址可以自动识别python版本 https://bootstrap.pypa.io/get-pip.py wget https://bootstrap.pypa.io/3.2/get-pip.py --no-check-certificate # 3...执行此文件 sudo python3 get-pip.py 心得 操作起来特别容易的事情，而我不经常写笔记。为什么要记录下来呢？
我是一个python新手，希望能帮到新手。 我的macOS自带是油python2.7的，但是我自己学的是python3.6。两个版本都不能用了，有可能影响到系统！ 要抓紧学习了！！</description></item></channel></rss>