<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>oracle on kentxxq Blog</title><link>https://kentxxq.com/tags/oracle/</link><description>Recent content in oracle on kentxxq Blog</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Sun, 05 Jan 2020 15:42:00 +0800</lastBuildDate><atom:link href="https://kentxxq.com/tags/oracle/index.xml" rel="self" type="application/rss+xml"/><item><title>oracle数据导入导出</title><link>https://kentxxq.com/contents/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/</link><pubDate>Sun, 05 Jan 2020 15:42:00 +0800</pubDate><guid>https://kentxxq.com/contents/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/</guid><description>虽然现在的互联网公司都流行mysql这样的免费数据库。但是在各行各业oracle还是非常主流的选择。无论是否有授权，很多的数据迁移都是在oracle之间进行的。
所以这篇文章用来迁移一下自己的笔记，并进行梳理。
开篇说明 我喜欢东西精简而不出错。所以尽量不给自己找麻烦。
所以很多的命令参数，但是我都没有用上。主要是因为在我的使用过程中，没有解决多余的问题，或者说没有提升体验。
plsql_develop plsql是一个收费软件。但是国内你懂的，非常多的破解和绿色版。在我遇到的公司中，都是统一使用的工具。
特点 适用于数据量不大的操作。非常简便。如果只是几千条数据，甚至我经常复制粘贴来处理日常工作。 有自己的pde格式。可以导出导入tables数据。 同时支持文本导入器。例如打开一个csv文件。然后通过字段映射，导入oracle。 exp和imp 一个历史悠长的工具。但是操作简单，oracle自带。
在我交接数据的过程中，生成dmp结尾文件几乎是统一标准。
特点 适合统一的oracle的环境操作。 你需要关注字符集问题(源数据库字符集、导出端字符集、导入端字符集、目标数据库字符集)。 高版本兼容低版本，但是反之则不然！ exp表模式 # 导出数据。不导出索引。指定导出表名 exp user/pawd rows=y indexes=n file=path/exp.dmp log=exp.log tables=tab1,tab2,tab3 exp用户模式 # 指定导出用户 exp user/pawd owner=user rows=y indexes=n file=exp.dmp log=exp.log exp完全模式 # 需要用高权限用户，然后导出全库。用到的极少。 exp user/pawd rows=y indexes=n full=y file=exp.dmp log=exp.log imp导入方法 # 指定以前的用户名，导入到现在的用户名。不导入索引 # 可以指定导入的表名 # ignore=n 可以忽略创建错误，直接追加数据 # commit=y 可以定量提交。否则会占用大量的回滚空间后一次性提交 # 不加表名默认导入所有。适合用户模式。如果再加上full=y，那么就是全库导入了 imp user/pawd fromuser=user touser=pawd rows=y indexes=n commit=y file=exp.</description></item><item><title>oracle批量更新数据</title><link>https://kentxxq.com/contents/%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE/</link><pubDate>Sat, 05 Jan 2019 20:49:21 +0800</pubDate><guid>https://kentxxq.com/contents/%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE/</guid><description> 在工作中经常需要对已有的表结构进行改变，或者改动。所以总结了一些常用的技巧
新增字段 给定一个默认值。这样会非常快的加好新字段。
修改超级大表 下面是批量更新，delete操作也可以同理操作。这样可以让sql不会因为长时间执行，而出现各种网络问题干扰。且更好控制。
declare cursor update_cursor is select a.*, a.rowid row_id from t_com_outpatient_info a order by a.rowid; begin for v_cusor in update_cursor loop if v_cusor.fenqu is null then update t_com_outpatient_info set fenqu=substr(center_no,0,6) where rowid = v_cusor.row_id; end if; if mod(update_cursor%rowcount,10000)=0 then commit; end if; end loop; commit; end;</description></item><item><title>oracle普通表转分区表</title><link>https://kentxxq.com/contents/%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/</link><pubDate>Thu, 20 Dec 2018 00:00:00 +0800</pubDate><guid>https://kentxxq.com/contents/%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/</guid><description>分析一波
oracle有很多的版本，现在的话，常用的有11g，12cR1/R2。都有不同的方法
对于数据库，我是不推荐使用外键，存储过程，或者触发器的。除非对数据需要超高度的一致性要求，同时不规范的数据，是属于不允许的
数据库的拓展需要添加新的集群存储，新的机器部署oracle服务，很难像应用服务器一样动态部署，相反拓展服务器更加简单。承担了这一部分的数据库压力 外键是也是有性能消耗的，同时内部加锁，更容易出现死锁问题 尽量少的数据库约束，越方便数据之间的解耦合。否则你会发现所有的表都互相依赖。牵一发而动全身 应用应该知道自己的操作是在干嘛，而不是考虑不周，让写在数据库里的潜规则告诉你必须如何 方便读写分离，更好的解决了数据库写方面的压力，而读数据的锁几乎没有压力 操作前提 主键 拥有自己的逻辑id，而不是业务id主键。否则不方便以后的水平拓展 使用oracle提供的包来检测是否可行 12cR1和11g --检查可用性 EXEC DBMS_REDEFINITION.can_redef_table(UNAME =&amp;gt; &amp;#39;QX_HENGSHAN&amp;#39;,TNAME =&amp;gt; &amp;#39;A20181220_2&amp;#39;); --开始重定义 DBMS_REDEFINITION.START_REDEF_TABLE( uname =&amp;gt; &amp;#39;STEVE&amp;#39;, orig_table =&amp;gt; &amp;#39;salestable&amp;#39;, int_table =&amp;gt; &amp;#39;int_salestable1, int_salestable2, int_salestable3&amp;#39;, col_mapping =&amp;gt; NULL, options_flag =&amp;gt; DBMS_REDEFINITION.CONS_USE_ROWID, part_name =&amp;gt; &amp;#39;sal03q1,sal03q2,sal03q3&amp;#39;, continue_after_errors =&amp;gt; TRUE); --开始拷贝数据 DBMS_REDEFINITION.COPY_TABLE_DEPENDENTS( uname =&amp;gt; &amp;#39;AKAHALI&amp;#39;, orig_table =&amp;gt; &amp;#39;ST1&amp;#39;, int_table =&amp;gt; &amp;#39;T1&amp;#39;, num_errors =&amp;gt; lvn_errs ); --完成重定义 dbms_redefinition.finish_redef_table( uname =&amp;gt; &amp;#39;AKAHALI&amp;#39;, orig_table =&amp;gt; &amp;#39;ST1&amp;#39;, int_table =&amp;gt; &amp;#39;T1&amp;#39; ); 12cR2 ALTER TABLE table_name MODIFY table_partitioning_clauses [ filter_condition ] [ ONLINE ] [ UPDATE INDEXES [ ( index { local_partitioned_index | global_partitioned_index | GLOBAL } [, index { local_partitioned_index | global_partitioned_index | GLOBAL } ].</description></item><item><title>DML_Error_Logging特性</title><link>https://kentxxq.com/contents/dml_error_logging%E7%89%B9%E6%80%A7/</link><pubDate>Wed, 19 Jul 2017 00:00:00 +0800</pubDate><guid>https://kentxxq.com/contents/dml_error_logging%E7%89%B9%E6%80%A7/</guid><description> 在工作中，常常要进行数据的临时备份，还有导入数据的需求。但是却因为在源数据中个别数据不合法，导致无法插入。 功能效果：
把合法的数据导入进入目标表 把不合法的数据插入一张指定的表，并且记录下原因 需要用到dbms包(10gR2后版本支持) SQL&amp;gt; DESC dbms_errlog.create_error_log Parameter Type Mode Default? ------------------- -------- ---- -------- DML_TABLE_NAME VARCHAR2 IN ERR_LOG_TABLE_NAME VARCHAR2 IN Y ERR_LOG_TABLE_OWNER VARCHAR2 IN Y ERR_LOG_TABLE_SPACE VARCHAR2 IN Y SKIP_UNSUPPORTED BOOLEAN IN Y SQL&amp;gt; --默认会创建ERR$_SOURCE表，在``第二个``参数可以自己输入表名 创建源表source的目标表dest BEGIN DBMS_ERRLOG.create_error_log (dml_table_name =&amp;gt; &amp;#39;SOURCE&amp;#39;); END; 在insert语句后按照固定格式填写 INSERT INTO dest SELECT * FROM source LOG ERRORS INTO err$_source(&amp;#39;INSERT&amp;#39;) REJECT LIMIT UNLIMITED;</description></item></channel></rss>