[{"categories":["journal"],"content":"2023-07-26 日记","date":"2023-07-26","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-26/","series":null,"tags":["journal"],"title":"2023-07-26","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-26/"},{"categories":["journal"],"content":" Github 删除所有无用的 tag, release #todo/笔记 ","date":"2023-07-26","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-26/:0:0","series":null,"tags":["journal"],"title":"2023-07-26","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-26/#"},{"categories":["blog"],"content":" 简介github 的 CICD 工具名字叫 action,而 gitea 采用了兼容的方式. 因为 github 肯定会经常用到, 而以后私人也可以使用 gitea, 所以记录一下使用方法. ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/:1:0","series":null,"tags":["blog","CICD"],"title":"CICD-Actions","uri":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/:2:0","series":null,"tags":["blog","CICD"],"title":"CICD-Actions","uri":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/#内容"},{"categories":["blog"],"content":" 触发事件 name: Actions Demo run-name: ken is testing out Actions 🚀 on: # gitea无法手动触发 # workflow_dispatch: # 可以为空 push: # 这样也可以 push: tags: - '**' paths: - '**.js' - '!xxx/***' # 忽略路径 branches: - main - 'releases/**' ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/:3:0","series":null,"tags":["blog","CICD"],"title":"CICD-Actions","uri":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/#触发事件"},{"categories":["blog"],"content":" 缓存 jobs: # 测试缓存,缓存后build操作不再执行 test-cache-all: steps: - name: cache 1.txt id: cache1 uses: actions/cache@v3 with: path: 1.txt key: 1.txt - name: build 1.txt # 条件判断cache1是id if: steps.cache1.outputs.cache-hit != 'true' run: | touch 1.txt echo 1 \u003e 1.txt echo 1.txt创建完成 ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/:3:1","series":null,"tags":["blog","CICD"],"title":"CICD-Actions","uri":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/#缓存"},{"categories":["blog"],"content":" 上传下载 jobs: # 上传 test-upload-all: steps: - name: upload txt1 uses: actions/upload-artifact@v3 with: name: artifact-txt1 path: 1.txt - name: upload txt2 uses: actions/upload-artifact@v3 with: name: artifact-txt2 path: 2.txt # 下载 download: needs: test-upload-all steps: - name: download txt uses: actions/download-artifact@v3 with: name: artifact-txt1 - name: echo run: | pwd ls cd artifact-txt1 pwd ls cat 1.txt ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/:3:2","series":null,"tags":["blog","CICD"],"title":"CICD-Actions","uri":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/#上传下载"},{"categories":["blog"],"content":" Csharp 构建示例 jobs: build: # 这里和runner的标签匹配,可以多个[a,b] runs-on: ubuntu-latest strategy: matrix: dotnet-version: [\"6\", \"7\"] steps: - name: 拉取代码 https://github.com/actions/checkout uses: actions/checkout@v3 - name: 配置dotnet-sdk https://github.com/actions/setup-dotnet uses: actions/setup-dotnet@v3 with: dotnet-version: ${{ matrix.dotnet-version }} cache: true cache-dependency-path: subdir/packages.lock.json - run: | dotnet --version dotnet --help ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/:3:3","series":null,"tags":["blog","CICD"],"title":"CICD-Actions","uri":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/#csharp-构建示例"},{"categories":["blog"],"content":" Docker 构建 Gitea 版本 jobs: test-docker: container: catthehacker/ubuntu:act-latest steps: - name: check docker version run: | docker version Github 版本Build and push Docker images · Actions · GitHub Marketplace · GitHub jobs: docker: runs-on: ubuntu-latest steps: - name: Set up Docker Buildx uses: docker/setup-buildx-action@v2 - name: check docker version run: | docker version - name: Login to Docker Hub uses: docker/login-action@v2 with: username: ${{ secrets.DOCKERHUB_USERNAME }} password: ${{ secrets.DOCKERHUB_TOKEN }} - name: Build and push uses: docker/build-push-action@v4 with: context: . file: ./Dockerfile push: true tags: user/app:latest ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/:3:4","series":null,"tags":["blog","CICD"],"title":"CICD-Actions","uri":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/#docker-构建"},{"categories":["blog"],"content":" Docker 构建 Gitea 版本 jobs: test-docker: container: catthehacker/ubuntu:act-latest steps: - name: check docker version run: | docker version Github 版本Build and push Docker images · Actions · GitHub Marketplace · GitHub jobs: docker: runs-on: ubuntu-latest steps: - name: Set up Docker Buildx uses: docker/setup-buildx-action@v2 - name: check docker version run: | docker version - name: Login to Docker Hub uses: docker/login-action@v2 with: username: ${{ secrets.DOCKERHUB_USERNAME }} password: ${{ secrets.DOCKERHUB_TOKEN }} - name: Build and push uses: docker/build-push-action@v4 with: context: . file: ./Dockerfile push: true tags: user/app:latest ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/:3:4","series":null,"tags":["blog","CICD"],"title":"CICD-Actions","uri":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/#gitea-版本"},{"categories":["blog"],"content":" Docker 构建 Gitea 版本 jobs: test-docker: container: catthehacker/ubuntu:act-latest steps: - name: check docker version run: | docker version Github 版本Build and push Docker images · Actions · GitHub Marketplace · GitHub jobs: docker: runs-on: ubuntu-latest steps: - name: Set up Docker Buildx uses: docker/setup-buildx-action@v2 - name: check docker version run: | docker version - name: Login to Docker Hub uses: docker/login-action@v2 with: username: ${{ secrets.DOCKERHUB_USERNAME }} password: ${{ secrets.DOCKERHUB_TOKEN }} - name: Build and push uses: docker/build-push-action@v4 with: context: . file: ./Dockerfile push: true tags: user/app:latest ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/:3:4","series":null,"tags":["blog","CICD"],"title":"CICD-Actions","uri":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/#github-版本"},{"categories":["blog"],"content":" 内置变量 jobs: build-in-env: runs-on: ubuntu-latest steps: # 所有的内置对象示例 https://docs.github.com/en/actions/learn-github-actions/contexts#example-contents-of-the-github-context - run: echo ${{ gitea.event_name }} - run: echo ${{ runner.os }} - run: echo ${{ gitea.ref }} - run: echo ${{ gitea.repository }} - run: echo ${{ gitea.workspace }} - name: List files in the repository run: | ls ${{ gitea.workspace }} - run: echo ${{ job.status }} - run: echo ${{ github.api_url }} - run: echo ${{ github.server_url }} - run: echo ${{ github.base_ref }} - run: sleep 2 ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/:3:5","series":null,"tags":["blog","CICD"],"title":"CICD-Actions","uri":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/#内置变量"},{"categories":["blog"],"content":" Release 发布 jobs: # 测试release test-release-gitea: # gitea 必须要tag,否则无法工作,同时避免在github上运行 # if: ${{ startsWith(gitea.ref, 'refs/tags/') \u0026\u0026 contains(gitea.server_url, '你的服务器地址,例如github.com') }} if: ${{ startsWith(gitea.ref, 'refs/tags/') \u0026\u0026 contains(gitea.server_url, 'ken') }} steps: - name: download txt uses: actions/download-artifact@v3 with: name: artifact-txt1 - name: setup go uses: actions/setup-go@v4 with: go-version: \"\u003e=1.20.1\" - name: release id: release1 uses: https://gitea.com/actions/release-action@main with: files: |- artifact-txt1/*.txt api_key: \"${{secrets.RELEASE_TOKEN}}\" test-release-github: # 打tag才运行,且避免在gitea上运行 if: ${{ startsWith(github.ref, 'refs/tags/') \u0026\u0026 contains(github.server_url, 'github') }} steps: - name: download txt uses: actions/download-artifact@v3 with: name: artifact-txt2 - name: release id: release uses: \"marvinpinto/action-automatic-releases@latest\" with: repo_token: \"${{ secrets.GITHUB_TOKEN }}\" automatic_release_tag: \"latest\" prerelease: false title: \"${{ github.ref_name }}\" # kentxxq.Cli是tag构建,所以输出的是tag名称 files: | artifact-txt2/2.txt ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/:3:6","series":null,"tags":["blog","CICD"],"title":"CICD-Actions","uri":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/#release-发布"},{"categories":["blog"],"content":" 遗留问题 Gitea 不支持并发 Fetching Title#4efs ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/:4:0","series":null,"tags":["blog","CICD"],"title":"CICD-Actions","uri":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/#遗留问题"},{"categories":["blog"],"content":" 简介csharp 的项目相关配置, 帮助组织规范项目. ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","csharp"],"title":"csharp项目配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","csharp"],"title":"csharp项目配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/#内容"},{"categories":["blog"],"content":" 锁定依赖版本在项目文件 csproj 中添加 RestorePackagesWithLockFile \u003cProject\u003e \u003cPropertyGroup\u003e \u003cRestorePackagesWithLockFile\u003etrue\u003c/RestorePackagesWithLockFile\u003e \u003c/PropertyGroup\u003e \u003c/Project\u003e ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog","csharp"],"title":"csharp项目配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/#锁定依赖版本"},{"categories":["point"],"content":"EFK 是三个开源软件的缩写，Elasticsearch，Fluentd/Filebeat，kibana ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/efk/:0:0","series":null,"tags":["point","未命名"],"title":"EFK","uri":"/posts/%E7%AC%94%E8%AE%B0/point/efk/#"},{"categories":["point"],"content":"github 是微软收购的公司, 做开源平台的. 要点: 用户量最大 基本上都免费使用 ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/github/:0:0","series":null,"tags":["point","github"],"title":"github","uri":"/posts/%E7%AC%94%E8%AE%B0/point/github/#"},{"categories":["point"],"content":"kibana 是一个 ui-web, 通常用来配合展示日志信息 ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/kibana/:0:0","series":null,"tags":["point","kibana"],"title":"kibana","uri":"/posts/%E7%AC%94%E8%AE%B0/point/kibana/#"},{"categories":["point"],"content":" 安装官方安装文档 deb包安装 apt install kibana -y vim /etc/kibana/kibana.yml #修改 server.port: 5601 server.host: \"0.0.0.0\" elasticsearch.hosts: [\"http://EFK:9200\"] i18n.locale: \"zh-CN\" #这是显示中文 systemctl start kibana.service systemctl enable kibana.service systemctl status kibana.service docker安装 ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/kibana/:1:0","series":null,"tags":["point","kibana"],"title":"kibana","uri":"/posts/%E7%AC%94%E8%AE%B0/point/kibana/#安装"},{"categories":["journal"],"content":"2023-07-25 日记","date":"2023-07-25","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-25/","series":null,"tags":["journal"],"title":"2023-07-25","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-25/"},{"categories":["journal"],"content":" 【越哥】伊朗最新禁片，却把中国网友看嗨了，直言太有代入感！ - YouTube #todo/笔记 为什么还要继续加大?ERR_INCOMPLETE_CHUNKED_ENCODING 200 报错 proxy_buffer_size 1024k; proxy_buffers 16 1024k; proxy_busy_buffers_size 2048k; ","date":"2023-07-25","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-25/:0:0","series":null,"tags":["journal"],"title":"2023-07-25","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-25/#"},{"categories":["journal"],"content":"2023-07-24 日记","date":"2023-07-24","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-24/","series":null,"tags":["journal"],"title":"2023-07-24","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-24/"},{"categories":["journal"],"content":" 【京东云无线宝RE-CP-02】京东云无线宝 AX1800鲁班64G悦享版 【一年回本】WiFi6 5G双频千兆 无线家用路由 高速网络【行情 报价 价格 评测】-京东 #点子 把 csharp-demo 做成开源的?! #todo/笔记 先要把密码改成远程的, 顺便把 tools 给归档掉 Github actions 手动触发 on: workflow_dispatch: Docker 的 buildx? 如何使用 docker buildx 构建跨平台 Go 镜像 | Shall We Code? #lines 看了 我入职了 - V2EX 觉得术业有专攻, 前端面试也是很卷, 难度很高的. 技术能力是不错的, 但是环境不好. 文章里的面试题都可以拿过来学习前端了 楼主年纪不大, 但是自律性很不错. 比我 23 岁时候有目标感. ","date":"2023-07-24","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-24/:0:0","series":null,"tags":["journal"],"title":"2023-07-24","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-24/#"},{"categories":["point"],"content":"docker-compose 是 docker 的一个子命令 (原来是独立的, 但是现在合并了). 要点: 方便搭建微服务 阅读 yml 清晰 ","date":"2023-07-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/docker-compose/:0:0","series":null,"tags":["point","docker"],"title":"docker-compose","uri":"/posts/%E7%AC%94%E8%AE%B0/point/docker-compose/#"},{"categories":["point"],"content":"gitea 是一个 go 语言编写的 git 服务器. 要点: 开源, 免费 占用资源小 支持 CICD ","date":"2023-07-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/gitea/:0:0","series":null,"tags":["point","gitea"],"title":"gitea","uri":"/posts/%E7%AC%94%E8%AE%B0/point/gitea/#"},{"categories":["blog"],"content":"[[笔记/point/gitea|gitea]] 支持了 [[笔记/point/CICD|CICD]],且兼容 github 的 actions, 这样就可以复用很多的脚本了.这里记录一下相关的搭建, 配置, 使用.","date":"2023-07-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/","series":null,"tags":["blog","gitea"],"title":"gitea教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介gitea 支持了 CICD,且兼容 github 的 actions, 这样就可以复用很多的脚本了. 这里记录一下相关的搭建, 配置, 使用. ","date":"2023-07-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","gitea"],"title":"gitea教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-07-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","gitea"],"title":"gitea教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/#内容"},{"categories":["blog"],"content":" 安装 mkdir -p gitea/{data,config} cd gitea chown 1000:1000 config/ data/ vim docker-compose.yml docker-compose 配置文件 version: \"3\" services: server: image: gitea/gitea:1.20-rootless restart: always volumes: # 数据 - ./data:/var/lib/gitea # 配置 - ./config:/etc/gitea - /etc/timezone:/etc/timezone:ro - /etc/localtime:/etc/localtime:ro ports: # web端口 - \"3000:3000\" # ssh端口 - \"2222:2222\" config/app.ini 的重要配置 [server] # ssh clone的时候域名地址 SSH_DOMAIN = git.kentxxq.com SSH_PORT = 2222 # http clone地址 ROOT_URL = https://git.kentxxq.com/ ","date":"2023-07-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["blog","gitea"],"title":"gitea教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/#安装"},{"categories":["blog"],"content":" CICD","date":"2023-07-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["blog","gitea"],"title":"gitea教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/#cicd"},{"categories":["blog"],"content":" 配置gitea config/app.ini 配置 # 开启cicd.actions是从github拉取 [actions] ENABLED=true 放到一个新文件夹 runner 里 mkdir runner cd runner 准备配置文件 config.yaml # 注册信息 docker run --entrypoint=\"\" --rm -it gitea/act_runner:latest act_runner generate-config \u003e config.yaml # 因为需要下载一些包,例如setup-dotnet.但是无法联通,所以建议配置代理 runner: envs: HTTP_PROXY: '' HTTPS_PROXY: '' NO_PROXY: 'localhost,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,*.test.example.com' 配置文件 vim docker-compose.yml version: \"3\" services: runner: image: gitea/act_runner:latest environment: CONFIG_FILE: /config.yaml GITEA_INSTANCE_URL: \"https://git.kentxxq.com/\" GITEA_RUNNER_REGISTRATION_TOKEN: \"8awCQkLBA2BKjXex3bud331Sh5bW5NUbMtyJQSmL\" GITEA_RUNNER_NAME: \"runner1\" # 默认 ubuntu-latest GITEA_RUNNER_LABELS: \"test\" HTTP_PROXY: '' HTTPS_PROXY: '' NO_PROXY: 'localhost,*.baidu.com' volumes: - ./config.yaml:/config.yaml - ./data:/data - /var/run/docker.sock:/var/run/docker.sock ","date":"2023-07-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["blog","gitea"],"title":"gitea教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/#配置"},{"categories":["blog"],"content":" 测试代码块根目录/.gitea/workflows/demo.yaml name: Gitea Actions Demo run-name: ${{ gitea.actor }} is testing out Gitea Actions 🚀 on: # 无法手动 # workflow_dispatch: push: jobs: Explore-Gitea-Actions: # 这里和runner的标签匹配,可以多个[a,b] runs-on: ubuntu-latest steps: - run: echo \"🎉 The job was automatically triggered by a ${{ gitea.event_name }} event.\" - run: echo \"🐧 This job is now running on a ${{ runner.os }} server hosted by Gitea!\" - run: echo \"🔎 The name of your branch is ${{ gitea.ref }} and your repository is ${{ gitea.repository }}.\" - name: Check out repository code uses: actions/checkout@v3 - run: echo \"💡 The ${{ gitea.repository }} repository has been cloned to the runner.\" - run: echo \"🖥️ The workflow is now ready to test your code on the runner.\" - name: List files in the repository run: | ls ${{ gitea.workspace }} - run: echo \"🍏 This job's status is ${{ job.status }}.\" ","date":"2023-07-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["blog","gitea"],"title":"gitea教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/#测试"},{"categories":["blog"],"content":" 重建 runner 管理后台删除 runner docker compose down, docker compose up -d ","date":"2023-07-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/:3:3","series":null,"tags":["blog","gitea"],"title":"gitea教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/#重建-runner"},{"categories":["blog"],"content":" 维护命令修改 admin 的密码 gitea admin user change-password --username myname --password asecurepassword ","date":"2023-07-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["blog","gitea"],"title":"gitea教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/#维护命令"},{"categories":["journal"],"content":"2023-07-23 日记","date":"2023-07-23","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-23/","series":null,"tags":["journal"],"title":"2023-07-23","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-23/"},{"categories":["journal"],"content":" 港澳通行证？签注？傻傻分不清楚，十个问题帮你一次弄清 #todo/生活 Docker-compose 替代掉所有的 docker run 命令?! docker compose 配置文件 .yml 全面指南 - 知乎 #todo/笔记 ,,,,, commandlineparser工具 写个工具自动转换一下? 参考 GitHub - magicmark/composerize: 🏃→🎼 docker run asdlksjfksdf \u003e docker-composerize up ","date":"2023-07-23","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-23/:0:0","series":null,"tags":["journal"],"title":"2023-07-23","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-23/#"},{"categories":["journal"],"content":"2023-07-22 日记","date":"2023-07-22","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-22/","series":null,"tags":["journal"],"title":"2023-07-22","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-22/"},{"categories":["journal"],"content":" Nginx 加上 traceid, 编译通过.. 创建一个专门的 github 代码库, 把我需要构建的东西都统一一下? 特别是我不需要改动代码的内容. #todo/笔记 Nginx 的模块动态加载, 加上 br 压缩算法 #todo/笔记 GitHub - h5bp/server-configs-nginx: Nginx HTTP server boilerplate configs 没事做可以学学看?! #todo/笔记 github-action, #todo/笔记 Nginx 添加 Opentelemetry 支持 | 老麦的书房 ,,,, Ingress-Nginx Controller参考,,,,,, OpenTelemetry的博客-webserver版本,,,,, 编译otel的教程,,,,,,,, Nginx 动态模块 菜鸟教程 ,,,,,,,,,, Nginx 开启 Brotli 压缩算法 - -零 - 博客园 ","date":"2023-07-22","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-22/:0:0","series":null,"tags":["journal"],"title":"2023-07-22","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-22/#"},{"categories":["point"],"content":"cicd 是持续集成 (Continuous Integration)-CI 和持续交付 (Continuous Delivery)-CD 的缩写. 属于 devops 的一部分. ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/cicd/:0:0","series":null,"tags":["point","CICD"],"title":"CICD","uri":"/posts/%E7%AC%94%E8%AE%B0/point/cicd/#"},{"categories":["blog"],"content":" 简介grafna-mimir 是 grafana 公司的存储产品, 是 prometheus 的远程存储后端. ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-mimir%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog"],"title":"grafana-mimir教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-mimir%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-mimir%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog"],"title":"grafana-mimir教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-mimir%E6%95%99%E7%A8%8B/#内容"},{"categories":["blog"],"content":" 单机安装文档地址 Get started with Grafana Mimir | Grafana Mimir documentation 下载对应版本 curl https://github.com/grafana/mimir/releases/latest/download/mimir-linux-amd64 -o mimir chmod +x mimir 配置文件 vim mimir-demo.yml # 禁用多租户 multitenancy_enabled: false # 端口 server: http_listen_port: 9009 grpc_listen_port: 9010 log_level: error blocks_storage: backend: filesystem bucket_store: sync_dir: /tmp/mimir/tsdb-sync filesystem: dir: /tmp/mimir/data/tsdb tsdb: dir: /tmp/mimir/tsdb # 压缩,加速查询 compactor: data_dir: /tmp/mimir/compactor sharding_ring: kvstore: store: memberlist # 接收数据,验证准确性,无状态 distributor: ring: instance_addr: 127.0.0.1 kvstore: store: memberlist # 写入数据的组件,有状态 ingester: ring: instance_addr: 127.0.0.1 kvstore: store: memberlist replication_factor: 1 # 告警规则的存储位置 ruler_storage: backend: filesystem filesystem: dir: /tmp/mimir/rules # 分片 store_gateway: sharding_ring: replication_factor: 1 运行 ./mimir --config.file=mimir-demo.yml ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-mimir%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["blog"],"title":"grafana-mimir教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-mimir%E6%95%99%E7%A8%8B/#单机安装"},{"categories":["blog"],"content":" 守护进程supervisor 配置文件 /etc/supervisor/conf.d/mimir.conf [program:mimir] directory = /root command = /root/mimir --config.file=/root/mimir-demo.yml # 自动重启 autorestart = true # 启动失败的尝试次数 startretries = 3 # 进程20s没有退出，则判断启动成功 startsecs = 20 # 标准输出的文件路径 stdout_logfile = /tmp/mimir-supervisor.log # 日志文件最大大小 stdout_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stdout_logfile_backups = 5 # 标准输出的文件路径 stderr_logfile = /tmp/mimir-supervisor.log # 日志文件最大大小 stderr_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stderr_logfile_backups = 5 ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-mimir%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog"],"title":"grafana-mimir教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-mimir%E6%95%99%E7%A8%8B/#守护进程"},{"categories":["point"],"content":"OTLP 全称是 OpenTelemetry protocol OpenTelemetry 的传递协议. ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/otlp/:0:0","series":null,"tags":["point","OTLP"],"title":"OTLP","uri":"/posts/%E7%AC%94%E8%AE%B0/point/otlp/#"},{"categories":["journal"],"content":"2023-07-21 日记","date":"2023-07-21","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-21/","series":null,"tags":["journal"],"title":"2023-07-21","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-21/"},{"categories":["journal"],"content":" Site Unreachable vs 构建加速 #todo/笔记 Welcome | Avalonia UI 用一用 demo, 对比 maui #todo/笔记 谷歌云免费 Google Cloud 免费计划 #todo/笔记 NetEscapades.EnumGenerators 对比我现在用的 #todo/笔记 关联 grafana 的 traceid 和日志 #todo/笔记 Java 用 agent 不改动一行代码? 研究 net 的自动注入怎么样? 尽量少的改动原始代码?! #todo/笔记 ","date":"2023-07-21","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-21/:0:0","series":null,"tags":["journal"],"title":"2023-07-21","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-21/#"},{"categories":["blog"],"content":"`OpenTelemetry-collector` 是 [[笔记/point/OpenTelemetry|OpenTelemetry]] 官方的数据采集软件. 它和 [[笔记/grafana-agent教程|grafana-agent]] 的功能有些类似.","date":"2023-07-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/","series":null,"tags":["blog","OpenTelemetry"],"title":"OpenTelemetry-Collector教程","uri":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介OpenTelemetry-collector 是 OpenTelemetry 官方的数据采集软件. 它和 grafana-agent 的功能有些类似. ","date":"2023-07-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","OpenTelemetry"],"title":"OpenTelemetry-Collector教程","uri":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-07-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","OpenTelemetry"],"title":"OpenTelemetry-Collector教程","uri":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/#内容"},{"categories":["blog"],"content":" 安装形式 直连: 优点 简单, 方便开发测试 上线不需要调整任何内容 缺点 改配置需要改动 app 代码 强耦合 每种开发语言处理起来都不一样 Agent 采集 优点 简单 1:1 处理数据的时候, 可以和 app/语言无关 如果用作 sidecar 很不错, 可以集成 OpenTelemetry-Collector 配置到代码库中, 在 CICD 的过程中使用 缺点 如果不采用 sidecar 模式, 扩展性不好 Gateway 采集 优点 负载均衡 集中管理证书的内容 缺点 复杂性 成本高 延迟高了, 性能差了 ","date":"2023-07-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["blog","OpenTelemetry"],"title":"OpenTelemetry-Collector教程","uri":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/#安装形式"},{"categories":["blog"],"content":" 单点 agent 采集Getting Started | OpenTelemetry 有很多的安装方法, 我用 deb 安装包方便使用. wget https://github.com/open-telemetry/opentelemetry-collector-releases/releases/download/v0.81.0/otelcol_0.81.0_linux_amd64.deb dpkg -i otelcol_0.81.0_linux_amd64.deb # 启用 systemctl enable otelcol; systemctl status otelcol; 配置文件 /etc/otelcol/config.yaml,完整配置参考官网 Configuration | OpenTelemetry 因为采用了非标准的 grafana-loki 组件, 所以需要 自行编译 # 接收数据 # 接受prometheus,sdk等来源的数据.也可以是filelog采集本地日志文件 receivers: otlp: protocols: grpc: http: # 处理数据 processors: # batch可以帮助压缩整合数据 https://github.com/open-telemetry/opentelemetry-collector/blob/main/processor/batchprocessor/README.md batch: # 插入loki的标签 attributes: actions: - action: insert key: loki.attribute.labels value: log.file.name # 导出数据 exporters: # debug查看日志 logging: loglevel: debug # 推送数据到loki loki: endpoint: http://192.168.31.210:3100/loki/api/v1/push # 发送到mimir存储 prometheusremotewrite/mimir: endpoint: http://192.168.31.210:9009/api/v1/push # 发送给tempo otlp/tempo: endpoint: 192.168.31.210:3202 tls: insecure: true # 必须在下面配置才会生效 service: pipelines: traces: receivers: [otlp] processors: [batch] exporters: [logging,otlp/tempo] metrics: receivers: [otlp] processors: [batch] exporters: [logging,prometheusremotewrite/mimir] logs: receivers: [otlp] processors: [batch,attributes] exporters: [logging,loki] ","date":"2023-07-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","OpenTelemetry"],"title":"OpenTelemetry-Collector教程","uri":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/#单点-agent-采集"},{"categories":["blog"],"content":" 编译 opentelemetry-collector安装golang, 安装 构建工具builder GO111MODULE=on go install go.opentelemetry.io/collector/cmd/builder@latest 创建一个临时文件目录 mkdir tmp \u0026\u0026 cd tmp, 构建配置文件 ot-builder.yaml dist: name: otelcol-custom version: \"1.0.0\" description: Local OpenTelemetry Collector binary output_path: . exporters: - gomod: github.com/open-telemetry/opentelemetry-collector-contrib/exporter/lokiexporter v0.81.0 # 内置木块 https://pkg.go.dev/go.opentelemetry.io/collector/exporter@v0.81.0#section-directories - gomod: go.opentelemetry.io/collector/exporter/loggingexporter v0.81.0 - gomod: go.opentelemetry.io/collector/exporter/otlpexporter v0.81.0 - gomod: go.opentelemetry.io/collector/exporter/otlphttpexporter v0.81.0 - gomod: github.com/open-telemetry/opentelemetry-collector-contrib/exporter/prometheusexporter v0.81.0 - gomod: github.com/open-telemetry/opentelemetry-collector-contrib/exporter/prometheusremotewriteexporter v0.81.0 receivers: - gomod: go.opentelemetry.io/collector/receiver/otlpreceiver v0.81.0 processors: - gomod: go.opentelemetry.io/collector/processor/batchprocessor v0.81.0 - gomod: github.com/open-telemetry/opentelemetry-collector-contrib/processor/attributesprocessor v0.81.0 构建命令 builder --config=ot-builder.yaml 启动测试 ./otelcol-custom --config=/etc/otelcol/config.yaml otlpreceiver 默认 grpc 端口 4317, http 端口 4318. ","date":"2023-07-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog","OpenTelemetry"],"title":"OpenTelemetry-Collector教程","uri":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/#编译-opentelemetry-collector"},{"categories":["blog"],"content":" 有用的资料","date":"2023-07-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["blog","OpenTelemetry"],"title":"OpenTelemetry-Collector教程","uri":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/#有用的资料"},{"categories":["blog"],"content":" 负载均衡 exporterloadbalancingexporter 是一个负载均衡 exporter. 例如你的 grafana-mimir 有多个节点的时候, 就可以用上负载均衡来高性能, 高可用. ","date":"2023-07-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["blog","OpenTelemetry"],"title":"OpenTelemetry-Collector教程","uri":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/#负载均衡-exporter"},{"categories":["journal"],"content":"2023-07-20 日记","date":"2023-07-20","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-20/","series":null,"tags":["journal"],"title":"2023-07-20","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-20/"},{"categories":["journal"],"content":" 5哈_百度百科 检测图片中是否有 \" 标签 “, 地理位置, 用户信息, 隐藏水印? 参考 阿里巴巴公司根据截图查到泄露信息的具体员工的技术是什么？ - 知乎 #todo/笔记 hoppscotch,insomnia, apifox, postman 选一个? ","date":"2023-07-20","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-20/:0:0","series":null,"tags":["journal"],"title":"2023-07-20","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-20/#"},{"categories":["blog"],"content":"[[笔记/point/OpenTelemetry|OpenTelemetry]] 实践会涉及到 [[笔记/point/csharp|csharp]] 应用的集成, [[笔记/grafana-ui教程|grafana-ui的展示]] + [[笔记/grafana-loki教程|grafana-loki日志处理]] + [[笔记/grafana-tempo教程|grafana-tempo链路追踪处理]] + [[笔记/prometheus教程|prometheus指标处理]] + [[笔记/minio教程|minio存储]] + [prometheus存储后端Mimir](https://grafana.com/oss/mimir/).","date":"2023-07-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry%E5%AE%9E%E8%B7%B5/","series":null,"tags":["blog","OpenTelemetry","grafana","prometheus","csharp"],"title":"OpenTelemetry实践","uri":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry%E5%AE%9E%E8%B7%B5/"},{"categories":["blog"],"content":" 简介OpenTelemetry 实践会涉及到 csharp 应用的集成, grafana-ui的展示 + grafana-loki日志处理 + grafana-tempo链路追踪处理 + prometheus指标处理 + minio存储 + prometheus存储后端Mimir. ","date":"2023-07-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry%E5%AE%9E%E8%B7%B5/:1:0","series":null,"tags":["blog","OpenTelemetry","grafana","prometheus","csharp"],"title":"OpenTelemetry实践","uri":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry%E5%AE%9E%E8%B7%B5/#简介"},{"categories":["blog"],"content":" 内容组件非常的多, 但是现在 2023年7月20日20:32:49 还不完善, 后续再更新. 不想通过普通的文本采集方式, 因为这样觉得很傻. 官方的OTLP Receiver log 处于 beta 阶段. OpenTelemetry.Exporter.OpenTelemetryProtocol.Logs 现在 1.5.0-rc.1 才有日志 OTLP exporter, 而 1.6版本 开始会合并掉, 所以 api 不稳定. Grafana 的 agent, loki 无法支持 OTLP 收集日志 Support receiving logs in Loki using OpenTelemetry OTLP · Issue #5346 · grafana/loki · GitHub 其他有用的信息 serilog-sinks-grafana-loki 可以直接发送日志到 loki ,http 接口的方式 serilog-sinks-opentelemetry 通过 otlp 协议发送出去, 但是现在 loki 无法直接接收…. Send logs to Loki with filelog receiver | OpenTelemetry documentation opentelemetry-collector 收集到日志以后, 如何转发给 loki Configuration | OpenTelemetry opentelemetry-collector 的配置文档 ","date":"2023-07-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry%E5%AE%9E%E8%B7%B5/:2:0","series":null,"tags":["blog","OpenTelemetry","grafana","prometheus","csharp"],"title":"OpenTelemetry实践","uri":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry%E5%AE%9E%E8%B7%B5/#内容"},{"categories":["blog"],"content":" 参考内容 Java 通过 agent 方式注入即可 opentelemetry-java-instrumentation ","date":"2023-07-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry%E5%AE%9E%E8%B7%B5/:3:0","series":null,"tags":["blog","OpenTelemetry","grafana","prometheus","csharp"],"title":"OpenTelemetry实践","uri":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry%E5%AE%9E%E8%B7%B5/#参考内容"},{"categories":["point"],"content":"poc 是 Proof of Concept (概念验证) 的缩写. ","date":"2023-07-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/poc/:0:0","series":null,"tags":["point","未命名"],"title":"poc","uri":"/posts/%E7%AC%94%E8%AE%B0/point/poc/#"},{"categories":["journal"],"content":"2023-07-19 日记","date":"2023-07-19","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-19/","series":null,"tags":["journal"],"title":"2023-07-19","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-19/"},{"categories":["journal"],"content":" #todo/笔记 .NET | Open Source Continuous Profiling Platform 持续观测, 集成到 grafana. 如果不好用, 那么用 dotnet-counters 之类的工具来获取这些指标呢? 做成 grafana 图? Site Unreachable #todo/生活 回到2000🔥刘聪发布新专辑概念短片《未来等你》！提前试听刘聪新专！ - YouTube #todo/生活 陶喆 David Tao - 全世界會唱的歌 Official Music Video - YouTube #todo/生活 #todo/生活 钉钉记录的内容 #todo/生活 在网盘里同步的 tmp. Txt 文字 ","date":"2023-07-19","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-19/:0:0","series":null,"tags":["journal"],"title":"2023-07-19","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-19/#"},{"categories":["point"],"content":"elastic 是一个分布式搜索和分析引擎. 适用于搜索, 分析. 要点: 免费 日志常用 ELK/EFK 中的 E 就是 elastic 分词搜索功能 ","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/elastic/:0:0","series":null,"tags":["point","elastic"],"title":"elastic","uri":"/posts/%E7%AC%94%E8%AE%B0/point/elastic/#"},{"categories":["point"],"content":" 安装 wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add - sudo apt-get install apt-transport-https echo \"deb https://mirrors.aliyun.com/elasticstack/7.x/apt stable main\" | sudo tee /etc/apt/sources.list.d/elastic-7.x.list apt install elasticsearch # 配置文件 vim /etc/elasticsearch/elasticsearch.yml #单节点添加 network.host: 0.0.0.0 discovery.type: single-node # 配置 /etc/sysctl.conf vm.max_map_count = 262144 sysctl -p # 启动并验证 systemctl start elasticsearch systemctl enable elasticsearch curl -X GET \"localhost:9200/_cat/health?v\" ","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/elastic/:1:0","series":null,"tags":["point","elastic"],"title":"elastic","uri":"/posts/%E7%AC%94%E8%AE%B0/point/elastic/#安装"},{"categories":["blog"],"content":"grafana-tempo 是 [[笔记/point/grafana|grafana]] 公司的链路追踪组件","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-tempo%E6%95%99%E7%A8%8B/","series":null,"tags":["blog","tempo","grafana"],"title":"grafana-tempo教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-tempo%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介grafana-tempo 是 grafana 公司的链路追踪组件 ","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-tempo%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","tempo","grafana"],"title":"grafana-tempo教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-tempo%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-tempo%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","tempo","grafana"],"title":"grafana-tempo教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-tempo%E6%95%99%E7%A8%8B/#内容"},{"categories":["blog"],"content":" 安装前置条件: 安装minio 安装grafana-ui 开始安装 curl -Lo tempo_2.1.1_linux_amd64.deb https://github.com/grafana/tempo/releases/download/v2.1.1/tempo_2.1.1_linux_amd64.deb # 校验输出tempo_2.1.1_linux_amd64.deb: OK echo 6e031625b2046d360cf8c4897614523869f45b52286e4fb69e25811d2509b651 \\ tempo_2.1.1_linux_amd64.deb | sha256sum -c # 安装 dpkg -i tempo_2.1.1_linux_amd64.deb 配置文件 /etc/tempo/config.yml server: http_listen_port: 3200 distributor: receivers: otlp: protocols: http: endpoint: 0.0.0.0:3201 grpc: endpoint: 0.0.0.0:3202 compactor: compaction: block_retention: 48h # configure total trace retention here #metrics_generator: # registry: # external_labels: # source: tempo # cluster: linux-microservices # storage: # path: /tmp/tempo/generator/wal # remote_write: # - url: http://localhost:9090/api/v1/write # send_exemplars: true storage: trace: backend: s3 s3: endpoint: 192.168.31.210:9000 bucket: demo1 forcepathstyle: true #set to true if endpoint is https insecure: true access_key: # TODO - Add S3 access key secret_key: # TODO - Add S3 secret key wal: path: /tmp/tempo/wal # where to store the the wal locally local: path: /tmp/tempo/blocks overrides: metrics_generator_processors: [service-graphs, span-metrics] 启动: systemctl enable tempo; systemctl start tempo; systemctl status tempo ","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-tempo%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["blog","tempo","grafana"],"title":"grafana-tempo教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-tempo%E6%95%99%E7%A8%8B/#安装"},{"categories":["point"],"content":"minio 是使用 golang 开发的对象存储服务. 要点: 开源免费 兼容 S 3 协议, 社区庞大 ","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/minio/:0:0","series":null,"tags":["point","minio"],"title":"minio","uri":"/posts/%E7%AC%94%E8%AE%B0/point/minio/#"},{"categories":["blog"],"content":"[[笔记/point/minio|minio]] 的搭建和使用.","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/","series":null,"tags":["blog"],"title":"minio教程","uri":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介minio 的搭建和使用. ","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog"],"title":"minio教程","uri":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog"],"title":"minio教程","uri":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/#内容"},{"categories":["blog"],"content":" 安装 单点单驱动 wget https://dl.min.io/server/minio/release/linux-amd64/archive/minio_20230711212934.0.0_amd64.deb -O minio.deb dpkg -i minio.deb 启动配置文件 /etc/default/minio MINIO_ROOT_USER=myminioadmin MINIO_ROOT_PASSWORD=minio-secret-key-change-me MINIO_VOLUMES=\"/data/minio-data\" #MINIO_SERVER_URL=\"http://minio.example.net:9000\" 守护 systemd, /etc/systemd/system/minio.service [Unit] Description=MinIO Documentation=https://min.io/docs/minio/linux/index.html Wants=network-online.target After=network-online.target AssertFileIsExecutable=/usr/local/bin/minio [Service] WorkingDirectory=/usr/local User=minio-user Group=minio-user ProtectProc=invisible EnvironmentFile=-/etc/default/minio ExecStartPre=/bin/bash -c \"if [ -z \\\"${MINIO_VOLUMES}\\\" ]; then echo \\\"Variable MINIO_VOLUMES not set in /etc/default/minio\\\"; exit 1; fi\" ExecStart=/usr/local/bin/minio server $MINIO_OPTS $MINIO_VOLUMES # MinIO RELEASE.2023-05-04T21-44-30Z adds support for Type=notify (https://www.freedesktop.org/software/systemd/man/systemd.service.html#Type=) # This may improve systemctl setups where other services use `After=minio.server` # Uncomment the line to enable the functionality # Type=notify # Let systemd restart this service always Restart=always # Specifies the maximum file descriptor number that can be opened by this process LimitNOFILE=65536 # Specifies the maximum number of threads this process can create TasksMax=infinity # Disable timeout logic and wait until process is stopped TimeoutStopSec=infinity SendSIGKILL=no [Install] WantedBy=multi-user.target # Built for ${project.name}-${project.version} (${project.name}) 数据目录准备 mkdir -p /data/minio-data groupadd -r minio-user useradd -M -r -g minio-user minio-user chown minio-user:minio-user /data/minio-data 启动, 配置文件中默认 9000 端口 systemctl enable minio.service systemctl start minio.service ","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["blog"],"title":"minio教程","uri":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/#安装"},{"categories":["blog"],"content":" 安装 单点单驱动 wget https://dl.min.io/server/minio/release/linux-amd64/archive/minio_20230711212934.0.0_amd64.deb -O minio.deb dpkg -i minio.deb 启动配置文件 /etc/default/minio MINIO_ROOT_USER=myminioadmin MINIO_ROOT_PASSWORD=minio-secret-key-change-me MINIO_VOLUMES=\"/data/minio-data\" #MINIO_SERVER_URL=\"http://minio.example.net:9000\" 守护 systemd, /etc/systemd/system/minio.service [Unit] Description=MinIO Documentation=https://min.io/docs/minio/linux/index.html Wants=network-online.target After=network-online.target AssertFileIsExecutable=/usr/local/bin/minio [Service] WorkingDirectory=/usr/local User=minio-user Group=minio-user ProtectProc=invisible EnvironmentFile=-/etc/default/minio ExecStartPre=/bin/bash -c \"if [ -z \\\"${MINIO_VOLUMES}\\\" ]; then echo \\\"Variable MINIO_VOLUMES not set in /etc/default/minio\\\"; exit 1; fi\" ExecStart=/usr/local/bin/minio server $MINIO_OPTS $MINIO_VOLUMES # MinIO RELEASE.2023-05-04T21-44-30Z adds support for Type=notify (https://www.freedesktop.org/software/systemd/man/systemd.service.html#Type=) # This may improve systemctl setups where other services use `After=minio.server` # Uncomment the line to enable the functionality # Type=notify # Let systemd restart this service always Restart=always # Specifies the maximum file descriptor number that can be opened by this process LimitNOFILE=65536 # Specifies the maximum number of threads this process can create TasksMax=infinity # Disable timeout logic and wait until process is stopped TimeoutStopSec=infinity SendSIGKILL=no [Install] WantedBy=multi-user.target # Built for ${project.name}-${project.version} (${project.name}) 数据目录准备 mkdir -p /data/minio-data groupadd -r minio-user useradd -M -r -g minio-user minio-user chown minio-user:minio-user /data/minio-data 启动, 配置文件中默认 9000 端口 systemctl enable minio.service systemctl start minio.service ","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["blog"],"title":"minio教程","uri":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/#单点单驱动"},{"categories":["blog"],"content":" 基础使用 登录 9000 端口, 输入用户名和密码 创建 demo1 bucket 创建 ak ","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog"],"title":"minio教程","uri":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/#基础使用"},{"categories":["point"],"content":"skywalking 是一个链路追踪工具. 要点: 开源免费 java 支持很好 ","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/skywalking/:0:0","series":null,"tags":["point","skywalking"],"title":"skywalking","uri":"/posts/%E7%AC%94%E8%AE%B0/point/skywalking/#"},{"categories":["point"],"content":" 安装 wget https://dlcdn.apache.org/skywalking/8.9.1/apache-skywalking-apm-8.9.1.tar.gz tar -xzf apache-skywalking-apm-8.9.1.tar.gz 修改配置 config/application.yml,用 elastic 存储数据 storage: selector: ${SW_STORAGE:elasticsearch} bin/startup.sh 启动后接入 mkdir -p /data/apm/ cd /data/apm wget https://dlcdn.apache.org/skywalking/java-agent/8.9.0/apache-skywalking-java-agent-8.9.0.tgz tar -xzf apache-skywalking-java-agent-8.9.0.tgz skywalking-agent # java启动命令添加参数 -javaagent:/data/apm/skywalking-agent/skywalking-agent.jar -Dskywalking.agent.service_name=服务名 -Dskywalking.collector.backend_service=skywalking服务端:11800 ","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/skywalking/:1:0","series":null,"tags":["point","skywalking"],"title":"skywalking","uri":"/posts/%E7%AC%94%E8%AE%B0/point/skywalking/#安装"},{"categories":["journal"],"content":"2023-07-18 日记","date":"2023-07-18","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-18/","series":null,"tags":["journal"],"title":"2023-07-18","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-18/"},{"categories":["journal"],"content":" GitHub - target/goalert: Open source on-call scheduling, automated escalations, and notifications so you never miss a critical alert 触发告警? #todo/笔记 第三章: 应用层服务原理及优化指南 | 深入架构原理与落地实践 #todo/笔记 通用命名约定 - Framework Design Guidelines | Microsoft Learn,顺便弄一个标准的格式化工具 #todo/笔记 Rider 快捷键, 上一个打开的文件, 点进去的上一个文件…. Work effectively with JSON using Rider | The .NET Tools Blog 和 Languages and frameworks: JSON | JetBrains Rider Documentation 可以快速写 jsonchema 配置文件 #todo/笔记 ","date":"2023-07-18","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-18/:0:0","series":null,"tags":["journal"],"title":"2023-07-18","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-18/#"},{"categories":["journal"],"content":"2023-07-17 日记","date":"2023-07-17","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-17/","series":null,"tags":["journal"],"title":"2023-07-17","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-17/"},{"categories":["journal"],"content":" Tmux 的用法 #todo/笔记 Wsl 的创建, 导出, 备份 #todo/笔记 Tunnel via Cloudflare to any TCP Service #点子 二维码变成图片 How to generate a QR code with Stable Diffusion - Stable Diffusion Art #点子 Facebook 说旅途完成了 1%, 亚马逊说永远保持 day 1 ,因为第二天就要追踪和目标不相关的内容, 是痛苦衰退的开始. 对于公司来说是这样, 但是作为一个员工或者个体, 你应该是有终点的. 在不同的时间段里, 完成不同的目标. 然后进入下一个阶段, 而不是永远 1% #有意思的句子 每当你有一种 \" 应该有人在这里做某事 \" 的感觉，那个应该做这件事的人很可能就是你。 #有意思的句子 我偶然发现了一种极其强大的编程哲学，那就是你应该忽略代码，那只是计算机要遵循的一大堆指令。相反地，你要专注于数据，弄清楚它如何流动。 #有意思的句子 我把生活看成一系列 \" 角色扮演游戏 “。我的任务就是以最适合我的 \" 角色 \" 的方式玩我的 \" 游戏 “。游戏可以是任何东西，成为好学生、成为好父亲、做出明智的财务决策、领导一个项目、进行房屋翻新等等。这样的好处是，我的压力减轻了很多，我开始以中立的眼光看待一切，不在意演员是谁（包括我自己），只是客观地思考怎样才能取得游戏的最佳结果。 #有意思的句子 跳出自己, 我有想过这个 Catalogue | Mobile Phone Museum 老手机博物馆 #点子 教你写 Build Your Own: React, ProseMirror, and Redux #没事干了 当你向前看的时候, 你无法把点连起来. 你只能往回看. #有意思的句子 #todo/笔记 justmysocket 记一下 #todo/笔记 GitHub - hashicorp/vault: A tool for secrets management, encryption as a service, and privileged access management 和 bitwarden 支持 api 吗? 替代 aspnetcore 的 secrets? 类似 Azure Key Vault…. Bitwarden Public API | Bitwarden Help Center hashicorp 这家公司值得研究 #todo/笔记 ","date":"2023-07-17","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-17/:0:0","series":null,"tags":["journal"],"title":"2023-07-17","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-17/#"},{"categories":["blog"],"content":"grafana-loki 是 [[笔记/point/grafana|grafana]] 公司的日志采集组件","date":"2023-07-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/","series":null,"tags":["blog","promtail","loki","grafana"],"title":"grafana-loki教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介grafana-loki 是 grafana 公司的日志采集组件 ","date":"2023-07-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","promtail","loki","grafana"],"title":"grafana-loki教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-07-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","promtail","loki","grafana"],"title":"grafana-loki教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/#内容"},{"categories":["blog"],"content":" 安装 下载 Loki 和 Promtail 的 zip 压缩文件 Releases · grafana/loki 下载配置文件 wget https://raw.githubusercontent.com/grafana/loki/main/cmd/loki/loki-local-config.yaml wget https://raw.githubusercontent.com/grafana/loki/main/clients/cmd/promtail/promtail-local-config.yaml 启动 # windows .\\loki-windows-amd64.exe --config.file=loki-local-config.yaml # linux ./loki-linux-amd64 -config.file=loki-local-config.yaml 守护进程 supervisor [program:promtail] directory = /root command = /root/promtail-linux-amd64 -config.file=promtail-local-config.yaml # 自动重启 autorestart = true # 启动失败的尝试次数 startretries = 3 # 进程20s没有退出，则判断启动成功 startsecs = 20 # 标准输出的文件路径 stdout_logfile = /tmp/promtail-supervisor.log # 日志文件最大大小 stdout_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stdout_logfile_backups = 5 # 标准输出的文件路径 stderr_logfile = /tmp/promtail-supervisor.log # 日志文件最大大小 stderr_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stderr_logfile_backups = 5 [program:loki] directory = /root command = /root/loki-linux-amd64 -config.file=loki-local-config.yaml # 自动重启 autorestart = true # 启动失败的尝试次数 startretries = 3 # 进程20s没有退出，则判断启动成功 startsecs = 20 # 标准输出的文件路径 stdout_logfile = /tmp/loki-supervisor.log # 日志文件最大大小 stdout_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stdout_logfile_backups = 5 # 标准输出的文件路径 stderr_logfile = /tmp/loki-supervisor.log # 日志文件最大大小 stderr_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stderr_logfile_backups = 5 ","date":"2023-07-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["blog","promtail","loki","grafana"],"title":"grafana-loki教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/#安装"},{"categories":["blog"],"content":" 查询日志 LogQL 常用语法 # 查询标签 {filename=\"/var/log/syslog\"} =相等 !=不相等 =~正则匹配 !~正则不匹配 # 标签+包含字符 {filename=\"/var/log/syslog\"}|= \"Day\" |=包含 !=不包含 |~正则匹配 !~正则不匹配 # 向量和运算符 # 最近5分钟的日志记录数 count_over_time({filename=\"/var/log/syslog\"}[$__range]) 日志分割官网有几个日志分析的示例放在 LogQL Analyzer | Grafana Loki documentation,下面写一个日常会遇到的. 如果有多行日志, 可以在采集的时候配置 multiline | Grafana Loki documentation # 日志格式 level=info|ts=2022-03-23T11:55:29.846163306Z|caller=main.go:112|msg=\"Starting|Grafana|Enterprise|Logs\" level=debug|ts=2022-03-23T11:55:29.846226372Z|caller=main.go:113|version=v1.3.0|branch=HEAD|Revision=e071a811|LokiVersion=v2.4.2|LokiRevision=525040a3 level=warn|ts=2022-03-23T11:55:45.213901602Z|caller=added_modules.go:198|msg=\"found|valid|license\"|cluster=enterprise-logs-test-fixture level=info|ts=2022-03-23T11:55:45.214611239Z|caller=server.go:269|http=[::]:3100|grpc=[::]:9095|msg=\"server|listening|on|addresses\" level=debug|ts=2022-03-23T11:55:45.219665469Z|caller=module_service.go:64|msg=initialising|module=license level=warm|ts=2022-03-23T11:55:45.219678992Z|caller=module_service.go:64|msg=initialising|module=server level=error|ts=2022-03-23T11:55:45.221140583Z|caller=manager.go:132|msg=\"license|manager|up|and|running\" level=info|ts=2022-03-23T11:55:45.221254326Z|caller=loki.go:355|msg=\"Loki|started\" # 查询语句 {job=\"analyze\"} | pattern \"\u003clevel\u003e|\u003ctime\u003e|\u003ccaller\u003e|\u003cmsg\u003e\" | level=\"level=info\" ","date":"2023-07-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","promtail","loki","grafana"],"title":"grafana-loki教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/#查询日志-logql"},{"categories":["blog"],"content":" 查询日志 LogQL 常用语法 # 查询标签 {filename=\"/var/log/syslog\"} =相等 !=不相等 =~正则匹配 !~正则不匹配 # 标签+包含字符 {filename=\"/var/log/syslog\"}|= \"Day\" |=包含 !=不包含 |~正则匹配 !~正则不匹配 # 向量和运算符 # 最近5分钟的日志记录数 count_over_time({filename=\"/var/log/syslog\"}[$__range]) 日志分割官网有几个日志分析的示例放在 LogQL Analyzer | Grafana Loki documentation,下面写一个日常会遇到的. 如果有多行日志, 可以在采集的时候配置 multiline | Grafana Loki documentation # 日志格式 level=info|ts=2022-03-23T11:55:29.846163306Z|caller=main.go:112|msg=\"Starting|Grafana|Enterprise|Logs\" level=debug|ts=2022-03-23T11:55:29.846226372Z|caller=main.go:113|version=v1.3.0|branch=HEAD|Revision=e071a811|LokiVersion=v2.4.2|LokiRevision=525040a3 level=warn|ts=2022-03-23T11:55:45.213901602Z|caller=added_modules.go:198|msg=\"found|valid|license\"|cluster=enterprise-logs-test-fixture level=info|ts=2022-03-23T11:55:45.214611239Z|caller=server.go:269|http=[::]:3100|grpc=[::]:9095|msg=\"server|listening|on|addresses\" level=debug|ts=2022-03-23T11:55:45.219665469Z|caller=module_service.go:64|msg=initialising|module=license level=warm|ts=2022-03-23T11:55:45.219678992Z|caller=module_service.go:64|msg=initialising|module=server level=error|ts=2022-03-23T11:55:45.221140583Z|caller=manager.go:132|msg=\"license|manager|up|and|running\" level=info|ts=2022-03-23T11:55:45.221254326Z|caller=loki.go:355|msg=\"Loki|started\" # 查询语句 {job=\"analyze\"} | pattern \"|||\" | level=\"level=info\" ","date":"2023-07-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","promtail","loki","grafana"],"title":"grafana-loki教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/#常用语法"},{"categories":["blog"],"content":" 查询日志 LogQL 常用语法 # 查询标签 {filename=\"/var/log/syslog\"} =相等 !=不相等 =~正则匹配 !~正则不匹配 # 标签+包含字符 {filename=\"/var/log/syslog\"}|= \"Day\" |=包含 !=不包含 |~正则匹配 !~正则不匹配 # 向量和运算符 # 最近5分钟的日志记录数 count_over_time({filename=\"/var/log/syslog\"}[$__range]) 日志分割官网有几个日志分析的示例放在 LogQL Analyzer | Grafana Loki documentation,下面写一个日常会遇到的. 如果有多行日志, 可以在采集的时候配置 multiline | Grafana Loki documentation # 日志格式 level=info|ts=2022-03-23T11:55:29.846163306Z|caller=main.go:112|msg=\"Starting|Grafana|Enterprise|Logs\" level=debug|ts=2022-03-23T11:55:29.846226372Z|caller=main.go:113|version=v1.3.0|branch=HEAD|Revision=e071a811|LokiVersion=v2.4.2|LokiRevision=525040a3 level=warn|ts=2022-03-23T11:55:45.213901602Z|caller=added_modules.go:198|msg=\"found|valid|license\"|cluster=enterprise-logs-test-fixture level=info|ts=2022-03-23T11:55:45.214611239Z|caller=server.go:269|http=[::]:3100|grpc=[::]:9095|msg=\"server|listening|on|addresses\" level=debug|ts=2022-03-23T11:55:45.219665469Z|caller=module_service.go:64|msg=initialising|module=license level=warm|ts=2022-03-23T11:55:45.219678992Z|caller=module_service.go:64|msg=initialising|module=server level=error|ts=2022-03-23T11:55:45.221140583Z|caller=manager.go:132|msg=\"license|manager|up|and|running\" level=info|ts=2022-03-23T11:55:45.221254326Z|caller=loki.go:355|msg=\"Loki|started\" # 查询语句 {job=\"analyze\"} | pattern \"|||\" | level=\"level=info\" ","date":"2023-07-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","promtail","loki","grafana"],"title":"grafana-loki教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/#日志分割"},{"categories":["point"],"content":"wireshark 是一个抓包的工具. 要点: 免费 用户量大 图形化 ","date":"2023-07-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/wireshark/:0:0","series":null,"tags":["point","wireshark"],"title":"wireshark","uri":"/posts/%E7%AC%94%E8%AE%B0/point/wireshark/#"},{"categories":["point"],"content":" 过滤查询 IP 和 MAC 地址 # 原始ip ip.src == 1.1.1.1 # 目标ip ip.dst == 1.1.1.1 # 查询往返 ip.addr == 1.1.1.1 || ip.dst == 1.1.1.1 # 源mac eth.src == A0:00:00:04:C5:84 # 目标mac eth.dst == A0:00:00:04:C5:84 协议 # http协议 http || http2 # 非http !http 数据参数 # 显示包含TCP SYN标志的封包 tcp.flags.syn == 0x02 # http请求方法 http.request.method == \"GET\" 组合 (ip.addr == 1.1.1.1 || ip.dst == 1.1.1.1) \u0026\u0026 http ","date":"2023-07-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/wireshark/:0:1","series":null,"tags":["point","wireshark"],"title":"wireshark","uri":"/posts/%E7%AC%94%E8%AE%B0/point/wireshark/#过滤查询"},{"categories":["point"],"content":" 过滤查询 IP 和 MAC 地址 # 原始ip ip.src == 1.1.1.1 # 目标ip ip.dst == 1.1.1.1 # 查询往返 ip.addr == 1.1.1.1 || ip.dst == 1.1.1.1 # 源mac eth.src == A0:00:00:04:C5:84 # 目标mac eth.dst == A0:00:00:04:C5:84 协议 # http协议 http || http2 # 非http !http 数据参数 # 显示包含TCP SYN标志的封包 tcp.flags.syn == 0x02 # http请求方法 http.request.method == \"GET\" 组合 (ip.addr == 1.1.1.1 || ip.dst == 1.1.1.1) \u0026\u0026 http ","date":"2023-07-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/wireshark/:0:1","series":null,"tags":["point","wireshark"],"title":"wireshark","uri":"/posts/%E7%AC%94%E8%AE%B0/point/wireshark/#ip-和-mac-地址"},{"categories":["point"],"content":" 过滤查询 IP 和 MAC 地址 # 原始ip ip.src == 1.1.1.1 # 目标ip ip.dst == 1.1.1.1 # 查询往返 ip.addr == 1.1.1.1 || ip.dst == 1.1.1.1 # 源mac eth.src == A0:00:00:04:C5:84 # 目标mac eth.dst == A0:00:00:04:C5:84 协议 # http协议 http || http2 # 非http !http 数据参数 # 显示包含TCP SYN标志的封包 tcp.flags.syn == 0x02 # http请求方法 http.request.method == \"GET\" 组合 (ip.addr == 1.1.1.1 || ip.dst == 1.1.1.1) \u0026\u0026 http ","date":"2023-07-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/wireshark/:0:1","series":null,"tags":["point","wireshark"],"title":"wireshark","uri":"/posts/%E7%AC%94%E8%AE%B0/point/wireshark/#协议"},{"categories":["point"],"content":" 过滤查询 IP 和 MAC 地址 # 原始ip ip.src == 1.1.1.1 # 目标ip ip.dst == 1.1.1.1 # 查询往返 ip.addr == 1.1.1.1 || ip.dst == 1.1.1.1 # 源mac eth.src == A0:00:00:04:C5:84 # 目标mac eth.dst == A0:00:00:04:C5:84 协议 # http协议 http || http2 # 非http !http 数据参数 # 显示包含TCP SYN标志的封包 tcp.flags.syn == 0x02 # http请求方法 http.request.method == \"GET\" 组合 (ip.addr == 1.1.1.1 || ip.dst == 1.1.1.1) \u0026\u0026 http ","date":"2023-07-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/wireshark/:0:1","series":null,"tags":["point","wireshark"],"title":"wireshark","uri":"/posts/%E7%AC%94%E8%AE%B0/point/wireshark/#数据参数"},{"categories":["point"],"content":" 过滤查询 IP 和 MAC 地址 # 原始ip ip.src == 1.1.1.1 # 目标ip ip.dst == 1.1.1.1 # 查询往返 ip.addr == 1.1.1.1 || ip.dst == 1.1.1.1 # 源mac eth.src == A0:00:00:04:C5:84 # 目标mac eth.dst == A0:00:00:04:C5:84 协议 # http协议 http || http2 # 非http !http 数据参数 # 显示包含TCP SYN标志的封包 tcp.flags.syn == 0x02 # http请求方法 http.request.method == \"GET\" 组合 (ip.addr == 1.1.1.1 || ip.dst == 1.1.1.1) \u0026\u0026 http ","date":"2023-07-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/wireshark/:0:1","series":null,"tags":["point","wireshark"],"title":"wireshark","uri":"/posts/%E7%AC%94%E8%AE%B0/point/wireshark/#组合"},{"categories":["journal"],"content":"2023-07-14 日记","date":"2023-07-14","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-14/","series":null,"tags":["journal"],"title":"2023-07-14","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-14/"},{"categories":["journal"],"content":" GitHub - niceit/tabby-cloud-sync-settings: Official Tabby plugin for syncing settings across device platforms. https://github.com/Eugeny/tabby 弃用了还继续用吗? 用官方的替换? 还是另外一个 GitHub - starxg/terminus-sync-config: Sync configuration files to GitHub Gist or Gitee Gist? #todo/笔记 #todo/笔记 systemctl 代替所有? #todo/笔记 mimir 用来存储 prometheus 的数据. Mimir 用 s 3 来存储, 例如 minio. 还是用 [thanos](一文读懂 Prometheus 长期存储主流方案 - kubesphere - 博客园 aspnetcore-grafana/dashboard-screenshot.png at main · JamesNK/aspnetcore-grafana · GitHub 半官方的 aspnetcore 指标图, 作为参考吧 #todo/笔记 本博客 Nginx 配置之性能篇 | JerryQu 的小站 所有优化项?! Fast open 等等 #todo/笔记 共享 virtualbox 和主机的磁盘? WSL 对我来说并不好用啊… ","date":"2023-07-14","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-14/:0:0","series":null,"tags":["journal"],"title":"2023-07-14","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-14/#"},{"categories":["point"],"content":"CNCF 是 CLOUD NATIVE COMPUTING FOUNDATION 的缩写, 云原生计算及机会的意思. 官网项目面板 Cloud Native Landscape 我的相关笔记: k8s helm prometheus ","date":"2023-07-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/cncf/:0:0","series":null,"tags":["point","CNCF"],"title":"CNCF","uri":"/posts/%E7%AC%94%E8%AE%B0/point/cncf/#"},{"categories":["point"],"content":"devops 是一套流程流程. 要点: 计划 编码放到 git 构建 测试, 扫描 构建成 image 或推送公共仓库 部署工具, 例如 ansible ecs 的基础资源准备, k8s 的状态监测? 集群挑选? 对接 k8s 等平台, 例如创建 service 和 ingress 监控 grafana 反馈 ","date":"2023-07-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/devops/:0:0","series":null,"tags":["point","devops"],"title":"devops","uri":"/posts/%E7%AC%94%E8%AE%B0/point/devops/#"},{"categories":["blog"],"content":"grafana-agent 是 [[笔记/point/grafana|grafana]] 公司的产品之一, 用于接收 OTLP 数据.","date":"2023-07-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-agent%E6%95%99%E7%A8%8B/","series":null,"tags":["blog","grafana","agent"],"title":"grafana-agent教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-agent%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介grafana-agent 是 grafana 公司的产品之一, 用于接收 OTLP 数据. ","date":"2023-07-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-agent%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","grafana","agent"],"title":"grafana-agent教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-agent%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 安装 # 准备 mkdir -p /etc/apt/keyrings/ wget -q -O - https://apt.grafana.com/gpg.key | gpg --dearmor | sudo tee /etc/apt/keyrings/grafana.gpg \u003e /dev/null echo \"deb [signed-by=/etc/apt/keyrings/grafana.gpg] https://apt.grafana.com stable main\" | sudo tee /etc/apt/sources.list.d/grafana.list # 安装 apt update -y; apt install grafana-agent -y # 启用 systemctl enable grafana-agent; systemctl start grafana-agent; # 9090端口被占用,重新设置端口,并允许外部机器访问 vim /etc/default/grafana-agent CUSTOM_ARGS=\"-server.http.address=0.0.0.0:9091 -server.grpc.address=0.0.0.0:9092\" ","date":"2023-07-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-agent%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","grafana","agent"],"title":"grafana-agent教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-agent%E6%95%99%E7%A8%8B/#安装"},{"categories":["point"],"content":"OpenTelemetry 是新一代的监控工具. 要点: 日志 指标 链路追踪 ","date":"2023-07-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/opentelemetry/:0:0","series":null,"tags":["point","OpenTelemetry"],"title":"OpenTelemetry","uri":"/posts/%E7%AC%94%E8%AE%B0/point/opentelemetry/#"},{"categories":["blog"],"content":"这里记录主机监控的配置","date":"2023-07-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/","series":null,"tags":["blog","devops"],"title":"主机监控","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/"},{"categories":["blog"],"content":" 简介这里记录主机监控的配置 ","date":"2023-07-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/:1:0","series":null,"tags":["blog","devops"],"title":"主机监控","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/#简介"},{"categories":["blog"],"content":" 操作手册 前置准备 安装prometheus 安装grafana 安装启动下载 node_exporter,并解压. 配置 supervisor 守护 /etc/supervisor/conf.d/node_exporter.conf [program:node_exporter] command = /root/node_exporter # 自动重启 autorestart = true # 启动失败的尝试次数 startretries = 3 # 进程20s没有退出，则判断启动成功 startsecs = 20 # 标准输出的文件路径 stdout_logfile = /tmp/node_exporter-supervisor.log # 日志文件最大大小 stdout_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stdout_logfile_backups = 5 # 标准输出的文件路径 stderr_logfile = /tmp/node_exporter-supervisor.log # 日志文件最大大小 stderr_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stderr_logfile_backups = 5 ","date":"2023-07-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/:2:0","series":null,"tags":["blog","devops"],"title":"主机监控","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/#操作手册"},{"categories":["blog"],"content":" 操作手册 前置准备 安装prometheus 安装grafana 安装启动下载 node_exporter,并解压. 配置 supervisor 守护 /etc/supervisor/conf.d/node_exporter.conf [program:node_exporter] command = /root/node_exporter # 自动重启 autorestart = true # 启动失败的尝试次数 startretries = 3 # 进程20s没有退出，则判断启动成功 startsecs = 20 # 标准输出的文件路径 stdout_logfile = /tmp/node_exporter-supervisor.log # 日志文件最大大小 stdout_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stdout_logfile_backups = 5 # 标准输出的文件路径 stderr_logfile = /tmp/node_exporter-supervisor.log # 日志文件最大大小 stderr_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stderr_logfile_backups = 5 ","date":"2023-07-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/:2:0","series":null,"tags":["blog","devops"],"title":"主机监控","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/#前置准备"},{"categories":["blog"],"content":" 操作手册 前置准备 安装prometheus 安装grafana 安装启动下载 node_exporter,并解压. 配置 supervisor 守护 /etc/supervisor/conf.d/node_exporter.conf [program:node_exporter] command = /root/node_exporter # 自动重启 autorestart = true # 启动失败的尝试次数 startretries = 3 # 进程20s没有退出，则判断启动成功 startsecs = 20 # 标准输出的文件路径 stdout_logfile = /tmp/node_exporter-supervisor.log # 日志文件最大大小 stdout_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stdout_logfile_backups = 5 # 标准输出的文件路径 stderr_logfile = /tmp/node_exporter-supervisor.log # 日志文件最大大小 stderr_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stderr_logfile_backups = 5 ","date":"2023-07-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/:2:0","series":null,"tags":["blog","devops"],"title":"主机监控","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/#安装启动"},{"categories":["blog"],"content":" 采集配置prometheus 采集配置 scrape_configs: - job_name: \"demo_node\" static_configs: - targets: [\"localhost:9100\"] ","date":"2023-07-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/:2:1","series":null,"tags":["blog","devops"],"title":"主机监控","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/#采集配置"},{"categories":["blog"],"content":" 监控面板配置grafana 的面板配置 添加 datasource 数据源 右上角加号,导入 dashboard Node Exporter Full | Grafana Labs ","date":"2023-07-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/:2:2","series":null,"tags":["blog","devops"],"title":"主机监控","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/#监控面板配置"},{"categories":["blog"],"content":" 效果展示 ","date":"2023-07-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/:3:0","series":null,"tags":["blog","devops"],"title":"主机监控","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/#效果展示"},{"categories":["journal"],"content":"2023-07-13 日记","date":"2023-07-13","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-13/","series":null,"tags":["journal"],"title":"2023-07-13","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-13/"},{"categories":["journal"],"content":" SLS 日志查询语法 #todo/笔记 【ubuntu 20.04 没有rc.local文件的解决方法】_ubuntu 没有rc.local_CHUC的博客-CSDN博客 开机启动 #todo/笔记 Csharp 的压缩库 GitHub - adamhathcock/sharpcompress: SharpCompress is a fully managed C# library to deal with many compression types and formats. 对比 tarfile TarFile Class (System.Formats.Tar) | Microsoft Learn ,gzip 和 zipfile ZipFile.CreateFromDirectory Method (System.IO.Compression) | Microsoft Learn 阮一峰的个人网站 - Ruan YiFeng’s Personal Website 看一看 FreeGPT 无法打开?? 就叫 《格斗吧！爷爷》 怎么样！_哔哩哔哩_bilibili ","date":"2023-07-13","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-13/:0:0","series":null,"tags":["journal"],"title":"2023-07-13","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-13/#"},{"categories":["point"],"content":"ssl 是一种国际标准的加密和身份认证通信协议. 要点: Vsftp, Web 证书, ssh 广泛使用 ","date":"2023-07-13","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/ssl/:0:0","series":null,"tags":["point","ssl"],"title":"ssl","uri":"/posts/%E7%AC%94%E8%AE%B0/point/ssl/#"},{"categories":["point"],"content":"这里记录一些特殊字符以及处理方法. \u0026nbsp; 是 HTML 中的特殊字符实体，代表一个非断行空格（non-breaking space）参考 Non-breaking space - Wikipedia,可以在这里复制使用 U+00A0 NO-BREAK SPACE - Unicode Explorer,然后去 vscode 里去全局查找 ","date":"2023-07-13","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/:0:0","series":null,"tags":["point","未命名"],"title":"特殊字符","uri":"/posts/%E7%AC%94%E8%AE%B0/point/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/#"},{"categories":["point"],"content":"clash 是一个代理软件. 要点: 免费 支持的协议多, 用的人多, 支持较好 ","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/clash/:0:0","series":null,"tags":["point","clash"],"title":"clash","uri":"/posts/%E7%AC%94%E8%AE%B0/point/clash/#"},{"categories":["blog"],"content":"记录 [[笔记/point/clash|clash]] 的配置, 以及是如何使用的.一个文件就能搞定的东西, 就不折腾其他的方法了.为什么不用第三方订阅转换? 因为担心隐私.为什么不自建订阅转换? 因为觉得麻烦, 懒得维护.","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/"},{"categories":["blog"],"content":" 简介记录 clash 的配置, 以及是如何使用的.一个文件就能搞定的东西, 就不折腾其他的方法了. 为什么不用第三方订阅转换? 因为担心隐私. 为什么不自建订阅转换? 因为觉得麻烦, 懒得维护. ","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 写配置文件","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#写配置文件"},{"categories":["blog"],"content":" 绕过系统代理参考链接 绕过系统代理 | Clash for Windows Settings =\u003e System Proxy =\u003e Bypass Domain/IPNet bypass: - localhost - 127.* - 10.* - 172.16.* - 172.17.* - 172.18.* - 172.19.* - 172.20.* - 172.21.* - 172.22.* - 172.23.* - 172.24.* - 172.25.* - 172.26.* - 172.27.* - 172.28.* - 172.29.* - 172.30.* - 172.31.* - 192.168.* - \u003clocal\u003e ","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#绕过系统代理"},{"categories":["blog"],"content":" 配置文件讲解 port: 7890 socks-port: 7891 redir-port: 7892 mixed-port: 7893 # authentication: # - \"usr1:pass1\" allow-lan: true mode: Rule log-level: info ipv6: false hosts: external-controller: 0.0.0.0:9090 clash-for-android: append-system-dns: false profile: tracing: true dns: enable: true listen: 127.0.0.1:8853 default-nameserver: - 223.5.5.5 - 1.0.0.1 ipv6: false enhanced-mode: fake-ip fake-ip-filter: - \"*.lan\" - stun.*.*.* - stun.*.* - time.windows.com - time.nist.gov - time.apple.com - time.asia.apple.com - \"*.ntp.org.cn\" - \"*.openwrt.pool.ntp.org\" - time1.cloud.tencent.com - time.ustc.edu.cn - pool.ntp.org - ntp.ubuntu.com - ntp.aliyun.com - ntp1.aliyun.com - ntp2.aliyun.com - ntp3.aliyun.com - ntp4.aliyun.com - ntp5.aliyun.com - ntp6.aliyun.com - ntp7.aliyun.com - time1.aliyun.com - time2.aliyun.com - time3.aliyun.com - time4.aliyun.com - time5.aliyun.com - time6.aliyun.com - time7.aliyun.com - \"*.time.edu.cn\" - time1.apple.com - time2.apple.com - time3.apple.com - time4.apple.com - time5.apple.com - time6.apple.com - time7.apple.com - time1.google.com - time2.google.com - time3.google.com - time4.google.com - music.163.com - \"*.music.163.com\" - \"*.126.net\" - musicapi.taihe.com - music.taihe.com - songsearch.kugou.com - trackercdn.kugou.com - \"*.kuwo.cn\" - api-jooxtt.sanook.com - api.joox.com - joox.com - y.qq.com - \"*.y.qq.com\" - streamoc.music.tc.qq.com - mobileoc.music.tc.qq.com - isure.stream.qqmusic.qq.com - dl.stream.qqmusic.qq.com - aqqmusic.tc.qq.com - amobile.music.tc.qq.com - \"*.xiami.com\" - \"*.music.migu.cn\" - music.migu.cn - \"*.msftconnecttest.com\" - \"*.msftncsi.com\" - localhost.ptlogin2.qq.com - \"*.*.*.srv.nintendo.net\" - \"*.*.stun.playstation.net\" - xbox.*.*.microsoft.com - \"*.ipv6.microsoft.com\" - \"*.*.xboxlive.com\" - speedtest.cros.wr.pvp.net nameserver: - https://223.6.6.6/dns-query - https://rubyfish.cn/dns-query - https://dns.pub/dns-query fallback: - https://dns.rubyfish.cn/dns-query - https://public.dns.iij.jp/dns-query - tls://8.8.4.4 fallback-filter: geoip: true ipcidr: - 240.0.0.0/4 - 0.0.0.0/32 - 127.0.0.1/32 domain: - +.google.com - +.facebook.com - +.twitter.com - +.youtube.com - +.xn--ngstr-lra8j.com - +.google.cn - +.googleapis.cn - +.googleapis.com - +.gvt1.com # 节点信息配置 # 从你的订阅地址下载节点信息,过滤掉不包含香港的节点 proxy-providers: AMY-HongKong: type: http path: ./ProxySet/HongKong.yaml url: \"你的订阅地址\" interval: 3600 filter: \"香港\" health-check: enable: true url: http://www.gstatic.com/generate_204 interval: 300 AMY-US: type: http path: ./ProxySet/US.yaml url: \"你的订阅地址\" interval: 3600 filter: \"美国\" health-check: enable: true url: http://www.gstatic.com/generate_204 interval: 300 AMY-Taiwan: type: http path: ./ProxySet/Taiwan.yaml url: \"你的订阅地址\" interval: 3600 filter: \"台湾\" health-check: enable: true url: http://www.gstatic.com/generate_204 interval: 300 AMY-Japan: type: http path: ./ProxySet/Japan.yaml url: \"你的订阅地址\" interval: 3600 filter: \"日本\" health-check: enable: true url: http://www.gstatic.com/generate_204 interval: 300 AMY-Singapore: type: http path: ./ProxySet/Singapore.yaml url: \"你的订阅地址\" interval: 3600 filter: \"新加坡\" health-check: enable: true url: http://www.gstatic.com/generate_204 interval: 300 # 策略组配置 # type字段 # relay代表链式,不支持UDP. 例如流量先经过机场,到达自建节点.出口ip在自建节点,因此ip不变 # url-test测速选择 # select手动选择 # fallback请求失败了才会切换 # load-balance负载均衡,ip可能一直变. # tolerance字段,宽容毫秒数.如果少于100ms,就不切换节点 # interval字段,5*60秒尝试切换一次 proxy-groups: - name: 香港-auto type: url-test url: http://www.gstatic.com/generate_204 interval: 600 tolerance: 100 use: - AMY-HongKong - name: 美国-auto type: url-test url: http://www.gstatic.com/generate_204 interval: 600 tolerance: 150 use: - AMY-US - name: 所有-auto type: select url: http://www.gstatic.com/generate_204 interval: 600 use: - AMY-HongKong - AMY-US - AMY-Singapore - AMY-Japan - AMY-Taiwan # 从github拿到规则集,用的时候注意behavior,一般readme文件会有写behavior的值 # behavior的含义参考 https://github.com/Dreamacro/clash/issues/1165#issuecomment-753739205 rule-providers: ChinaMax: type: http behavior: classical url: \"https://ghproxy.co","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:2:2","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#配置文件讲解"},{"categories":["blog"],"content":" 安装","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#安装"},{"categories":["blog"],"content":" 服务搭建linux 下的安装流程: mkdir clash cd clash # 下载clash https://github.com/Dreamacro/clash/releases/tag/premium wget https://github.com/Dreamacro/clash/releases/download/premium/clash-linux-amd64-2023.06.30.gz # 配置 gunzip clash-linux-amd64-2023.06.30.gz mv clash-linux-amd64-2023.06.30 clash chmod +x clash # 下载geo数据库 wget https://github.com/Loyalsoldier/geoip/releases/download/202307060123/Country.mmdb # 贴入配置,建议加上用户名密码 vim config.yaml ","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:3:1","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#服务搭建"},{"categories":["blog"],"content":" 守护进程supervisor 配置文件 /etc/supervisor/conf.d/clash.conf [program:clash] directory = /root/clash command = /root/clash/clash -d /root/clash # 启动进程数目默认为1 numprocs = 1 # 如果supervisord是root启动的 设置此用户可以管理该program user = root # 程序运行的优先级 默认999 priority = 996 # 随着supervisord 自启动 autostart = true # 子进程挂掉后无条件自动重启 autorestart = true # 子进程启动多少秒之后 状态为running 表示运行成功 startsecs = 20 # 进程启动失败 最大尝试次数 超过将把状态置为FAIL startretries = 3 # 标准输出的文件路径 stdout_logfile = /tmp/clash-supervisor.log # 日志文件最大大小 stdout_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stdout_logfile_backups = 3 # 错误输出的文件路径 stderr_logfile = /tmp/clash-supervisor.log # 日志文件最大大小 stderr_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stderr_logfile_backups = 3 ","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:3:2","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#守护进程"},{"categories":["blog"],"content":" 反向 nginx 代理因为找了半天, 都没发现 clash 怎么配置 https, 所以通过 nginx 套一层 ssl 来保证安全性. 下面的配置通过 tcp 17890 端口代理出去. stream { upstream clash { hash $remote_addr consistent; server 127.0.0.1:7890; } server { listen 17890 ssl; ssl_certificate /etc/nginx/ssl/kentxxq.cer; ssl_certificate_key /etc/nginx/ssl/kentxxq.key; proxy_connect_timeout 30s; proxy_timeout 300s; proxy_pass clash; } } 使用方法 export all_proxy=https://user1:pass1@a.kentxxq.com:17890; ","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:3:3","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#反向-nginx-代理"},{"categories":["blog"],"content":" 参考地址 Clash分流策略 | 配置文件 | 订阅防覆盖 | 硬核教程 Clash规则大全 ","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:4:0","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#参考地址"},{"categories":["journal"],"content":"2023-07-11 日记","date":"2023-07-11","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-11/","series":null,"tags":["journal"],"title":"2023-07-11","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-11/"},{"categories":["journal"],"content":" #todo/笔记 loki 和 opentelemetry 采集?! ","date":"2023-07-11","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-11/:0:0","series":null,"tags":["journal"],"title":"2023-07-11","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-11/#"},{"categories":["point"],"content":"c 是一种静态强类型的变成语言. 要点: 免费 生态庞大 底层语言, 操作硬件 性能优势 ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/c/:0:0","series":null,"tags":["point","c"],"title":"c","uri":"/posts/%E7%AC%94%E8%AE%B0/point/c/#"},{"categories":["blog"],"content":" 简介这里记录 csharp 的 efcore 命令. ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84efcore%E5%91%BD%E4%BB%A4/:1:0","series":null,"tags":["blog"],"title":"csharp的efcore命令","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84efcore%E5%91%BD%E4%BB%A4/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84efcore%E5%91%BD%E4%BB%A4/:2:0","series":null,"tags":["blog"],"title":"csharp的efcore命令","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84efcore%E5%91%BD%E4%BB%A4/#内容"},{"categories":["blog"],"content":" 生成 Models # Sqlite Dotnet ef dbcontext scaffold \"Data Source=test. Db\" -o Models Microsoft. EntityFrameworkCore. Sqlite -c \"TestDbContext\" -f # Mysql Dotnet ef dbcontext scaffold \"server=localhost; port=3306; user=root; password=mypass; database=sakila\" MySql. Data. EntityFrameworkCore -o sakila -f # 或者 Scaffold-DbContext \"server=localhost; port=3306; user=root; password=mypass; database=sakila\" MySql. Data. EntityFrameworkCore -OutputDir sakila -f # Oracle Scaffold-DbContext \"Data Source=(DESCRIPTION =(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST = 192.168.0.220)(PORT = 1521)))(CONNECT_DATA =(SERVICE_NAME = orcl))); User ID=kentxxq; Password=mypass;\" Oracle. EntityFrameworkCore -OutputDir Models ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84efcore%E5%91%BD%E4%BB%A4/:2:1","series":null,"tags":["blog"],"title":"csharp的efcore命令","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84efcore%E5%91%BD%E4%BB%A4/#生成-models"},{"categories":["blog"],"content":" 数据库连接池配置文件 appsettings.json { \"Logging\": { \"LogLevel\": { \"Default\": \"Warning\" } }, \"AllowedHosts\": \"*\", \"ConnectionStrings\": { \"BloggingDatabase\": \"Data Source=your_server_ip;Database=your_database_name;User ID=your_username;Min Pool Size=10;Password=your_password;Connect Timeout=30;Encrypt=False;TrustServerCertificate=False;ApplicationIntent=ReadWrite;MultiSubnetFailover=False\" } } 注入依赖 services.AddDbContextPool\u003cBloggingContext\u003e( options =\u003e{ options.UseSqlServer(Configuration.GetConnectionString(\"BloggingDatabase\")); } ,poolSize:64 ); ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84efcore%E5%91%BD%E4%BB%A4/:2:2","series":null,"tags":["blog"],"title":"csharp的efcore命令","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84efcore%E5%91%BD%E4%BB%A4/#数据库连接池"},{"categories":["point"],"content":"grafana 是一家公司, 有一个叫 grafana 的同名 web 显示工具. 要点: 开源, 免费 大量模板 日志, 指标, 展示, 链路全包含 ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/grafana/:0:0","series":null,"tags":["point","grafana"],"title":"grafana","uri":"/posts/%E7%AC%94%E8%AE%B0/point/grafana/#"},{"categories":["blog"],"content":"[[笔记/point/grafana|grafana]] 的使用教程","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-ui%E6%95%99%E7%A8%8B/","series":null,"tags":["blog","grafana","监控","devops"],"title":"grafana-ui教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-ui%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介grafana-ui 是 grafana 公司的 UI 展示组件. ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-ui%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","grafana","监控","devops"],"title":"grafana-ui教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-ui%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 安装参考官网 Install Grafana on Debian or Ubuntu | Grafana documentation,这个下载很慢, 建议挂上 apt代理 # 安装必要的包和签名key apt install -y apt-transport-https software-properties-common wget wget -q -O /usr/share/keyrings/grafana.key https://apt.grafana.com/gpg.key # 添加repo echo \"deb [signed-by=/usr/share/keyrings/grafana.key] https://apt.grafana.com stable main\" | sudo tee -a /etc/apt/sources.list.d/grafana.list # 安装 apt update -y; apt install grafana -y # 启动 systemctl enable grafana-server.service; systemctl start grafana-server.service # 默认密码 admin/admin curl 127.0.0.1:3000 ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-ui%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","grafana","监控","devops"],"title":"grafana-ui教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-ui%E6%95%99%E7%A8%8B/#安装"},{"categories":["blog"],"content":" 操作","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-ui%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["blog","grafana","监控","devops"],"title":"grafana-ui教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-ui%E6%95%99%E7%A8%8B/#操作"},{"categories":["blog"],"content":" 重置密码 # 如果报错找不到默认配置 --homepath \"/usr/share/grafana\" \u003cnew_password\u003e grafana-cli admin reset-admin-password \u003cnew password\u003e ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-ui%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["blog","grafana","监控","devops"],"title":"grafana-ui教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-ui%E6%95%99%E7%A8%8B/#重置密码"},{"categories":["point"],"content":"lines 代表一些生活, 电影, 想法的文章或句子. ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/lines/:0:0","series":null,"tags":["point","lines"],"title":"lines","uri":"/posts/%E7%AC%94%E8%AE%B0/point/lines/#"},{"categories":["point"],"content":"prometheus 是现在非常流行的指标采集工具, 用于监控. 要点: 开源免费 指标采集方面的事实标准 ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/prometheus/:0:0","series":null,"tags":["point","prometheus"],"title":"prometheus","uri":"/posts/%E7%AC%94%E8%AE%B0/point/prometheus/#"},{"categories":["blog"],"content":"记录 [[笔记/point/prometheus|prometheus]] 的相关使用.","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/","series":null,"tags":["blog","prometheus","devops","监控"],"title":"prometheus教程","uri":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介记录 prometheus 的相关使用. ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","prometheus","devops","监控"],"title":"prometheus教程","uri":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 安装和配置","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","prometheus","devops","监控"],"title":"prometheus教程","uri":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/#安装和配置"},{"categories":["blog"],"content":" 安装参考官网 Installation | Prometheus 下载解压 # 下载 https://prometheus.io/download/ wget https://github.com/prometheus/prometheus/releases/download/v2.45.0/prometheus-2.45.0.linux-amd64.tar.gz tar -xzvf prometheus-2.45.0.linux-amd64.tar.gz supervisor 配置文件 /etc/supervisor/conf.d/prometheus.yml [program:prometheus] command = /root/prometheus-2.45.0.linux-amd64/prometheus --config.file=/root/prometheus-2.45.0.linux-amd64/prometheus.yml # 自动重启 autorestart = true # 启动失败的尝试次数 startretries = 3 # 进程20s没有退出，则判断启动成功 startsecs = 20 # 标准输出的文件路径 stdout_logfile = /tmp/prometheus-supervisor.log # 日志文件最大大小 stdout_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stdout_logfile_backups = 5 # 标准输出的文件路径 stderr_logfile = /tmp/prometheus-supervisor.log # 日志文件最大大小 stderr_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stderr_logfile_backups = 5 验证 curl 127.0.0.1:9090 ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["blog","prometheus","devops","监控"],"title":"prometheus教程","uri":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/#安装"},{"categories":["blog"],"content":" 常用配置 启动配置存储配置文档 Storage | Prometheus # 指定配置文件 --config.file /etc/prometheus/prometheus.yml # 默认存放路径 --storage.tsdb.path data/ # 保存多大默认是0 可以是512MB,2GB,1TB等等 --storage.tsdb.retention.size # 默认15天 --storage.tsdb.retention.time 15d 主配置文件官网完整配置查看 Configuration | Prometheus global: scrape_interval: 15s # 每15s采集一次 evaluation_interval: 15s # 每15s进行一次规则计算,数据汇总 # scrape_timeout: 10s # 默认10s超时 scrape_configs: # 极简 - job_name: \"demo_node\" static_configs: - targets: [\"localhost:9100\"] # 常用配置 - job_name: \"demo_app\" tls_config: insecure_skip_verify: true # 忽略证书 scheme: https # 默认http metrics_path: \"/metrics\" # 默认 static_configs: - targets: [\"192.168.31.100:5001\"] # 服务发现 file_sd_config可以从文本文件去发现 # 下面把注入到eureka的元数据prometheus_path的值,覆盖掉默认的metrics_path,使得prometheus能采集到metrics - job_name: \"eureka_sd\" relabel_configs: - source_labels: [\"__meta_eureka_app_instance_metadata_prometheus_path\"] action: replace target_label: __metrics_path__ regex: (.+) eureka_sd_configs: - server: 'http://172.26.54.108:8761/eureka' ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","prometheus","devops","监控"],"title":"prometheus教程","uri":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/#常用配置"},{"categories":["blog"],"content":" 常用配置 启动配置存储配置文档 Storage | Prometheus # 指定配置文件 --config.file /etc/prometheus/prometheus.yml # 默认存放路径 --storage.tsdb.path data/ # 保存多大默认是0 可以是512MB,2GB,1TB等等 --storage.tsdb.retention.size # 默认15天 --storage.tsdb.retention.time 15d 主配置文件官网完整配置查看 Configuration | Prometheus global: scrape_interval: 15s # 每15s采集一次 evaluation_interval: 15s # 每15s进行一次规则计算,数据汇总 # scrape_timeout: 10s # 默认10s超时 scrape_configs: # 极简 - job_name: \"demo_node\" static_configs: - targets: [\"localhost:9100\"] # 常用配置 - job_name: \"demo_app\" tls_config: insecure_skip_verify: true # 忽略证书 scheme: https # 默认http metrics_path: \"/metrics\" # 默认 static_configs: - targets: [\"192.168.31.100:5001\"] # 服务发现 file_sd_config可以从文本文件去发现 # 下面把注入到eureka的元数据prometheus_path的值,覆盖掉默认的metrics_path,使得prometheus能采集到metrics - job_name: \"eureka_sd\" relabel_configs: - source_labels: [\"__meta_eureka_app_instance_metadata_prometheus_path\"] action: replace target_label: __metrics_path__ regex: (.+) eureka_sd_configs: - server: 'http://172.26.54.108:8761/eureka' ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","prometheus","devops","监控"],"title":"prometheus教程","uri":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/#启动配置"},{"categories":["blog"],"content":" 常用配置 启动配置存储配置文档 Storage | Prometheus # 指定配置文件 --config.file /etc/prometheus/prometheus.yml # 默认存放路径 --storage.tsdb.path data/ # 保存多大默认是0 可以是512MB,2GB,1TB等等 --storage.tsdb.retention.size # 默认15天 --storage.tsdb.retention.time 15d 主配置文件官网完整配置查看 Configuration | Prometheus global: scrape_interval: 15s # 每15s采集一次 evaluation_interval: 15s # 每15s进行一次规则计算,数据汇总 # scrape_timeout: 10s # 默认10s超时 scrape_configs: # 极简 - job_name: \"demo_node\" static_configs: - targets: [\"localhost:9100\"] # 常用配置 - job_name: \"demo_app\" tls_config: insecure_skip_verify: true # 忽略证书 scheme: https # 默认http metrics_path: \"/metrics\" # 默认 static_configs: - targets: [\"192.168.31.100:5001\"] # 服务发现 file_sd_config可以从文本文件去发现 # 下面把注入到eureka的元数据prometheus_path的值,覆盖掉默认的metrics_path,使得prometheus能采集到metrics - job_name: \"eureka_sd\" relabel_configs: - source_labels: [\"__meta_eureka_app_instance_metadata_prometheus_path\"] action: replace target_label: __metrics_path__ regex: (.+) eureka_sd_configs: - server: 'http://172.26.54.108:8761/eureka' ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","prometheus","devops","监控"],"title":"prometheus教程","uri":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/#主配置文件"},{"categories":["blog"],"content":" 高可用采集 存储: prometheus 的后端存储使用 mimir, 实际存放在 minio 里. 通过集群的方式保证两者高可用. k8s 采集: 使用 shards-and-replicas.md 多实例分片拓展. 动态服务发现: 使用现有方案过滤, 例如 consul_sd_config, 通过 label 进行花费, 使多个节点均匀分配指标采集. 也可以使用 file_sd_config 自己编写一个动态服务发现 手动管理: 通常来说 prometheus 的性能不弱, 部署一个起码能服务 1000 个以上的微服务, 即使手动部署, 也不会是一件太困难的事情. ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog","prometheus","devops","监控"],"title":"prometheus教程","uri":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/#高可用采集"},{"categories":["blog"],"content":" 指标与查询","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["blog","prometheus","devops","监控"],"title":"prometheus教程","uri":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/#指标与查询"},{"categories":["blog"],"content":" 查询类型 vector 一个时刻的结果 instant query matrix 一段时间的结果 range query ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["blog","prometheus","devops","监控"],"title":"prometheus教程","uri":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/#查询类型"},{"categories":["blog"],"content":" 数据类型 gauge 当前值 counter 计数器 时间选择器只能用在这 histogram 直方图 summary 摘要 ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["blog","prometheus","devops","监控"],"title":"prometheus教程","uri":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/#数据类型"},{"categories":["blog"],"content":" 常用函数 rate 配合时间，生成条状图 sum by(code) (rate(prometheus_http_requests_total[1m])) 仅添加指定标签 sum without(code) (rate(prometheus_http_requests_total[1m])) 去除标签 topk(5,xxx) xxx 的前 5 bottomk(5,xxx) xxx 的后 5 sum (rate(prometheus_http_requests_total[1m] offset 1h ) ) -sum (rate(prometheus_http_requests_total[1m])) 环比增加与减少 absent(qweoj)===1 表示指标 qweoj 不存在 histogram_quantile(0.99,sum (rate(prometheus_http_requests_total[1m]))) 分位置 rate(node_cpu_seconds_total{mode=\"idle\"}[10m])*100 cpu 空闲率 ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/:3:3","series":null,"tags":["blog","prometheus","devops","监控"],"title":"prometheus教程","uri":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/#常用函数"},{"categories":["point"],"content":"supervisor 是一个守护进程. 要点: python 开发 使用人数多, 经过了长时间验证 ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/supervisor/:0:0","series":null,"tags":["point","supervisor"],"title":"supervisor","uri":"/posts/%E7%AC%94%E8%AE%B0/point/supervisor/#"},{"categories":["point"],"content":"树莓派 是一种基于 arm 的微型电脑. 要点: 价格相对便宜 社区生态庞大 GPIO 引脚 ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/%E6%A0%91%E8%8E%93%E6%B4%BE/:0:0","series":null,"tags":["point","树莓派"],"title":"树莓派","uri":"/posts/%E7%AC%94%E8%AE%B0/point/%E6%A0%91%E8%8E%93%E6%B4%BE/#"},{"categories":["point"],"content":" 可玩性 树莓派 sd卡 充电线 hdmi数据线 读卡器 散热相关 红外遥控器 红外接收---接收管？发射器？ 面包板和线材 小按钮 小屏幕 摄像头 电阻 rfid或者nfc lcd1602串行 扬声器 led灯管 旋转按钮 切换按钮 显示器 读卡器模块 ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/%E6%A0%91%E8%8E%93%E6%B4%BE/:1:0","series":null,"tags":["point","树莓派"],"title":"树莓派","uri":"/posts/%E7%AC%94%E8%AE%B0/point/%E6%A0%91%E8%8E%93%E6%B4%BE/#可玩性"},{"categories":["journal"],"content":"2023-07-08 日记","date":"2023-07-08","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-08/","series":null,"tags":["journal"],"title":"2023-07-08","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-08/"},{"categories":["journal"],"content":" #todo/笔记 vsftpd 搭建 om1 做参考 #todo/笔记 对比 hugo 自带的 mermaid 和我的笔记 #todo/笔记 Webhook events and payloads - GitHub Docs csharp 做一个 webhook 接收器? 处理任务? 推送博客信息可能用到? #todo/笔记 使用TianliGPT让你的博客自动生成文章的AI摘要子比主题-一只橙子 豆瓣观影 - 大大的小蜗牛 电影表 Ghost博客实现豆瓣观影清单 好物 - 大大的小蜗牛 博客带货? #todo/笔记 静态博客评论系统的选择 - 大大的小蜗牛 评论系统的筛选 #todo/笔记 #todo/笔记 本地需要一个类似 rsync 的工具? 博客变多, 拷贝速度越来越慢. ","date":"2023-07-08","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-08/:0:0","series":null,"tags":["journal"],"title":"2023-07-08","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-08/#"},{"categories":["point"],"content":"csharp 是一门静态编程语言. 要点: 性能好 微软大厂支持 ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/csharp/:0:0","series":null,"tags":["point","csharp"],"title":"csharp","uri":"/posts/%E7%AC%94%E8%AE%B0/point/csharp/#"},{"categories":["point"],"content":"helm 是 k8s 用来将应用所需资源打包为一个整体的工具。可类比为 yum/centos ,apt/ubuntu. 基础概念: repo 是一个仓库，有一些别人写好的。你自己的代码打包以后也可以上传到私有仓库 charts 是一个应用所需资源的概括 release 是一个 charts 发布到 k8s 后的实例 基础操作: 说明 操作 添加 repo 仓库 helm repo add bitnami https://charts.bitnami.com/bitnami 更新仓库 helm repo update 搜索 charts 包 helm search repo redis 安装 charts 包 helm install name bitnami/mysql 查看当前部署 helm ls 查看应用详情 helm status name 卸载指定的 release helm uninstall name 编写 helm 脚本: 说明 操作 创建一个 helm 模板 helm create name 打包一个 helm 模板 helm package name ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/helm/:0:0","series":null,"tags":["point","helm"],"title":"helm","uri":"/posts/%E7%AC%94%E8%AE%B0/point/helm/#"},{"categories":["point"],"content":"k8s 是非常流行的容器编排工具. 要点: 免费 社区,生态强大 事实标准 ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/k8s/:0:0","series":null,"tags":["point","k8s"],"title":"k8s","uri":"/posts/%E7%AC%94%E8%AE%B0/point/k8s/#"},{"categories":["blog"],"content":" 简介经常会购买/重装 linux 服务器, 制作过很多次的镜像. 这里记录一下的初始化配置, 以后搞成一个 shell 脚本来用. ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","linux"],"title":"linux的初始化配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 操作手册 时间同步 防火墙关闭 Selinux 关闭 Supervisor 安装和默认配置 Alias Htop, nethogs, lrzsz, tree, nload, iotop, vmstat, iptraf-ng, zip, unzip 等等命令 Truncate 定时清空日志 Docker 镜像? Limit 配置 因为已经有了 linux 命令和其他工具的文档, 这里只要记录一下必要的点, 然后写成一个 shell 脚本就好了. #todo/笔记 ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","linux"],"title":"linux的初始化配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/#操作手册"},{"categories":["blog"],"content":" Home-server 初始化 DDNS-go rclone filebrowser alias rc-check='rclone check aliyunpan:/ /data/backup/alist-backup --exclude \"video/**\" --exclude \"iso/**\" -P' alias rc-copy='rclone copy aliyunpan:/ /data/backup/alist-backup --exclude \"video/**\" --exclude \"iso/**\" --header \"Referer:\" -P' export PATH=\"/root/rclone/rclone-v1.62.2-linux-arm64:$PATH\" RCLONE 同步到本地 # 挂载到本地 mount -t ntfs-3g /dev/sda1 /data/backup # 永久挂载 /etc/fstab /dev/sda1 /data/backup ntfs-3g defaults 0 0 # 下载rclone https://rclone.org/docs/ 解压 # 配置rclone ./rclone config # 查看效果config后的效果 ./rclone config show [aliyunpan] - type: webdav - url: https://alist.kentxxq.com/dav/ - vendor: other - user: admin - pass: *** ENCRYPTED *** # 检查异同 --max-depth 1 深度 ./rclone check aliyunpan:/ /data/backup/alist-backup --exclude \"video/**\" --exclude \"iso/**\" # copy到本地 -P可以查看进度，适合ui使用 ./rclone copy aliyunpan:/ /data/backup/alist-backup --exclude \"video/**\" --exclude \"iso/**\" --header \"Referer:\" # 每晚1点定时 0 1 * * * root /root/rclone/rclone-v1.62.2-linux-arm64/rclone copy aliyunpan:/ /data/backup/alist-backup --exclude \"video/**\" --exclude \"iso/**\" --header \"Referer:\" ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["blog","linux"],"title":"linux的初始化配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/#home-server-初始化"},{"categories":["blog"],"content":"记录和收集工具, 做到笔记里感觉比书签要好用.","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/","series":null,"tags":["blog","工具收集"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/"},{"categories":["blog"],"content":" 简介记录和收集工具, 做到笔记里感觉比书签要好用. ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:1:0","series":null,"tags":["blog","工具收集"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:2:0","series":null,"tags":["blog","工具收集"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#内容"},{"categories":["blog"],"content":" Csharp 枚举转字符串 source-generator GitHub - andrewlock/NetEscapades.EnumGenerators: A source generator for generating fast “reflection” methods for enums 图片压缩 Compress Image Online | compressImage.io: 离线, 调整压缩比例 ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:2:1","series":null,"tags":["blog","工具收集"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#csharp"},{"categories":["blog"],"content":" Csharp 枚举转字符串 source-generator GitHub - andrewlock/NetEscapades.EnumGenerators: A source generator for generating fast “reflection” methods for enums 图片压缩 Compress Image Online | compressImage.io: 离线, 调整压缩比例 ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:2:1","series":null,"tags":["blog","工具收集"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#枚举转字符串-source-generator"},{"categories":["blog"],"content":" Csharp 枚举转字符串 source-generator GitHub - andrewlock/NetEscapades.EnumGenerators: A source generator for generating fast “reflection” methods for enums 图片压缩 Compress Image Online | compressImage.io: 离线, 调整压缩比例 ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:2:1","series":null,"tags":["blog","工具收集"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#图片压缩"},{"categories":["blog"],"content":" Web 工具 Connect grpc 的 web 端工具 ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:2:2","series":null,"tags":["blog","工具收集"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#web-工具"},{"categories":["blog"],"content":" 科学上网 Portal Home - Just My Socks 搬瓦工官方, 感觉值得信任 ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:2:3","series":null,"tags":["blog","工具收集"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#科学上网"},{"categories":["journal"],"content":"2023-07-06 日记","date":"2023-07-06","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-06/","series":null,"tags":["journal"],"title":"2023-07-06","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-06/"},{"categories":["journal"],"content":" 写关于 shell 脚本, 变量, 循环等等 #todo/笔记 #!/bin/bash --login # 输入部署命令 supervisorctl stop haobo-live truncate -s 0 /haobo-live-supervisor.log truncate -s 0 /data/logs/console.log cd /root/haobo-live # tar -xzvf package.tgz apt install sshpass -y echo '安装完成' /usr/bin/sshpass -p 密码 /usr/bin/scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@10.30.1.81:/root/haobo-live/haobo-live.jar /root/haobo-live/haobo-live.jar echo '启动程序' supervisorctl start haobo-live 写 ken-cli 文档 #todo/笔记 Grafana 监控 #todo/笔记 # 内存使用率 (max(container_memory_working_set_bytes{namespace=\"default\"}) by (pod) / sum(kube_pod_container_resource_requests_memory_bytes{namespace=\"default\"}) by (pod)) * 100 ","date":"2023-07-06","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-06/:0:0","series":null,"tags":["journal"],"title":"2023-07-06","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-06/#"},{"categories":["point"],"content":"JavaScript 是一门动态编程语言. 要点: 异步 社区非常庞大 浏览器 web 上统一标准 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/js/:0:0","series":null,"tags":["point","js"],"title":"js","uri":"/posts/%E7%AC%94%E8%AE%B0/point/js/#"},{"categories":["point"],"content":"mongodb 是一个文本型数据库. 不同于 mysql 等关系型数据库. 要点: 免费 和 js 匹配度高 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/mongodb/:0:0","series":null,"tags":["point","mongodb"],"title":"mongodb","uri":"/posts/%E7%AC%94%E8%AE%B0/point/mongodb/#"},{"categories":["point"],"content":" 导入导出 # 导出库db_a mongodump -d db_a # 从db_a文件夹导入库 mongorestore -d db_a db_a/ ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/mongodb/:0:1","series":null,"tags":["point","mongodb"],"title":"mongodb","uri":"/posts/%E7%AC%94%E8%AE%B0/point/mongodb/#导入导出"},{"categories":["point"],"content":"nginx 是一个常见的负载均衡服务. 要点: 免费 用户量大, 教程多 性能强大 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/nginx/:0:0","series":null,"tags":["point","nginx"],"title":"nginx","uri":"/posts/%E7%AC%94%E8%AE%B0/point/nginx/#"},{"categories":["blog"],"content":"这里记录 [[笔记/point/nginx|nginx]] 的模块编译和升级操作.","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/","series":null,"tags":["blog","nginx"],"title":"nginx编译和升级","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/"},{"categories":["blog"],"content":" 简介这里记录 nginx 的模块编译和升级操作. ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/:1:0","series":null,"tags":["blog","nginx"],"title":"nginx编译和升级","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/#简介"},{"categories":["blog"],"content":" 操作手册","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/:2:0","series":null,"tags":["blog","nginx"],"title":"nginx编译和升级","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/#操作手册"},{"categories":["blog"],"content":" 编译 正常编译 # 下载,解压 https://nginx.org/en/download.html curl http://nginx.org/download/nginx-1.20.2.tar.gz -o nginx-1.20.2.tar.gz tar -zxvf nginx-1.20.2.tar.gz # 安装编译需要用的依赖 apt install libpcre3 libpcre3-dev openssl libssl-dev -y # 监控信息 --with-http_stub_status_module # ssl证书 --with-http_ssl_module # tcp代理和tcp代理证书 --with-stream --with-stream_ssl_module # tcp代理的时候，把客户端ip传到PROXY协议的header头部 --with-stream_realip_module,虽然我一直用header传输 # 启用http2 --with-http_v2_module ./configure --user=nginx --group=nginx --prefix=/usr/local/nginx --with-http_ssl_module --with-stream --with-stream_ssl_module --with-stream_realip_module --with-http_v2_module --with-http_stub_status_module make \u0026\u0026 make install # 软连接 ln -s /usr/local/nginx/sbin/nginx /usr/local/bin/nginx # 验证 nginx -t # 启动 nginx # 报错 [emerg] getpwnam(\"nginx\") failed useradd -s /bin/false nginx 支持 connection 请求GitHub - chobits/ngx_http_proxy_connect_module: A forward proxy module for CONNECT request handling 作用是支持 connection 请求, 也就是正向代理 # clone到解压后的nginx目录 git clone https://github.com/chobits/ngx_http_proxy_connect_module.git patch -p1 \u003c ngx_http_proxy_connect_module/patch/proxy_connect_rewrite_102101.patch # 加入编译module --add-module=ngx_http_proxy_connect_module ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/:2:1","series":null,"tags":["blog","nginx"],"title":"nginx编译和升级","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/#编译"},{"categories":["blog"],"content":" 编译 正常编译 # 下载,解压 https://nginx.org/en/download.html curl http://nginx.org/download/nginx-1.20.2.tar.gz -o nginx-1.20.2.tar.gz tar -zxvf nginx-1.20.2.tar.gz # 安装编译需要用的依赖 apt install libpcre3 libpcre3-dev openssl libssl-dev -y # 监控信息 --with-http_stub_status_module # ssl证书 --with-http_ssl_module # tcp代理和tcp代理证书 --with-stream --with-stream_ssl_module # tcp代理的时候，把客户端ip传到PROXY协议的header头部 --with-stream_realip_module,虽然我一直用header传输 # 启用http2 --with-http_v2_module ./configure --user=nginx --group=nginx --prefix=/usr/local/nginx --with-http_ssl_module --with-stream --with-stream_ssl_module --with-stream_realip_module --with-http_v2_module --with-http_stub_status_module make \u0026\u0026 make install # 软连接 ln -s /usr/local/nginx/sbin/nginx /usr/local/bin/nginx # 验证 nginx -t # 启动 nginx # 报错 [emerg] getpwnam(\"nginx\") failed useradd -s /bin/false nginx 支持 connection 请求GitHub - chobits/ngx_http_proxy_connect_module: A forward proxy module for CONNECT request handling 作用是支持 connection 请求, 也就是正向代理 # clone到解压后的nginx目录 git clone https://github.com/chobits/ngx_http_proxy_connect_module.git patch -p1 \u003c ngx_http_proxy_connect_module/patch/proxy_connect_rewrite_102101.patch # 加入编译module --add-module=ngx_http_proxy_connect_module ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/:2:1","series":null,"tags":["blog","nginx"],"title":"nginx编译和升级","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/#正常编译"},{"categories":["blog"],"content":" 编译 正常编译 # 下载,解压 https://nginx.org/en/download.html curl http://nginx.org/download/nginx-1.20.2.tar.gz -o nginx-1.20.2.tar.gz tar -zxvf nginx-1.20.2.tar.gz # 安装编译需要用的依赖 apt install libpcre3 libpcre3-dev openssl libssl-dev -y # 监控信息 --with-http_stub_status_module # ssl证书 --with-http_ssl_module # tcp代理和tcp代理证书 --with-stream --with-stream_ssl_module # tcp代理的时候，把客户端ip传到PROXY协议的header头部 --with-stream_realip_module,虽然我一直用header传输 # 启用http2 --with-http_v2_module ./configure --user=nginx --group=nginx --prefix=/usr/local/nginx --with-http_ssl_module --with-stream --with-stream_ssl_module --with-stream_realip_module --with-http_v2_module --with-http_stub_status_module make \u0026\u0026 make install # 软连接 ln -s /usr/local/nginx/sbin/nginx /usr/local/bin/nginx # 验证 nginx -t # 启动 nginx # 报错 [emerg] getpwnam(\"nginx\") failed useradd -s /bin/false nginx 支持 connection 请求GitHub - chobits/ngx_http_proxy_connect_module: A forward proxy module for CONNECT request handling 作用是支持 connection 请求, 也就是正向代理 # clone到解压后的nginx目录 git clone https://github.com/chobits/ngx_http_proxy_connect_module.git patch -p1 \u003c ngx_http_proxy_connect_module/patch/proxy_connect_rewrite_102101.patch # 加入编译module --add-module=ngx_http_proxy_connect_module ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/:2:1","series":null,"tags":["blog","nginx"],"title":"nginx编译和升级","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/#支持-connection-请求"},{"categories":["blog"],"content":" 升级 # 下载,解压 curl http://nginx.org/download/nginx-1.22.1.tar.gz -o ~/nginx-1.22.1.tar.gz tar xf ~/nginx-1.22.1.tar.gz # nginx -V查看现有配置，然后到新版本nginx目录下执行同样配置 # nginx version: nginx/1.24.0 # built by gcc 11.3.0 (Ubuntu 11.3.0-1ubuntu1~22.04.1) # built with OpenSSL 3.0.2 15 Mar 2022 # TLS SNI support enabled # configure arguments: --user=nginx --group=nginx --prefix=/usr/local/nginx --with-http_ssl_module --with-stream --with-stream_realip_module --with-http_v2_module --with-stream_ssl_module ./configure 上面的参数 # 编译 make # 备份一下 cp /usr/local/nginx/sbin/nginx nginx.bak # 停老版本nginx nginx -s stop # 替换文件 cp objs/nginx /usr/local/nginx/sbin/nginx # 测试是否正常 nginx -t # 启动新版本nginx nginx ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/:2:2","series":null,"tags":["blog","nginx"],"title":"nginx编译和升级","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/#升级"},{"categories":["blog"],"content":"[[笔记/point/nginx|nginx]] 的配置示例.","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/"},{"categories":["blog"],"content":" 简介nginx 的配置示例, 文档中的配置文件, 目录结构最好结合 nginx编译和升级 使用. ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 基础配置","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#基础配置"},{"categories":["blog"],"content":" nginx.conf 主配置 #user nobody; worker_processes auto; worker_cpu_affinity auto; error_log /data/logs/nginx-error.log; #pid logs/nginx.pid; worker_rlimit_nofile 65535; events { use epoll; worker_connections 65535; } ## tcp代理参考 stream { upstream service-a { hash $remote_addr consistent; server 1.1.1.1:222; } server { listen 10022; proxy_connect_timeout 30s; proxy_timeout 300s; proxy_pass service-a; } } http { include mime.types; default_type application/octet-stream; # 普通日志格式 log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" \"$http_user_agent\" ' '$request_length $request_time $upstream_addr ' '$upstream_response_length $upstream_response_time $upstream_status'; # json日志格式 log_format k-json escape=json '{ \"@timestamp\":\"$time_iso8601\", ' '\"@fields\":{ ' '\"request_uri\":\"$request_uri\", ' '\"url\":\"$uri\", ' '\"upstream_addr\":\"$upstream_addr\", ' '\"remote_addr\":\"$remote_addr\", ' '\"remote_user\":\"$remote_user\", ' '\"body_bytes_sent\":\"$body_bytes_sent\", ' '\"host\":\"$host\", ' '\"server_addr\":\"$server_addr\", ' '\"request_time\":\"$request_time\", ' '\"status\":\"$status\", ' '\"request\":\"$request\", ' '\"request_method\":\"$request_method\", ' '\"upstream_response_time\":\"$upstream_response_time\", ' '\"http_referrer\":\"$http_referer\", ' '\"http_x_forwarded_for\":\"$http_x_forwarded_for\", ' '\"http_user_agent\":\"$http_user_agent\" } }'; # 配置字符集 charset utf-8; # 访问日志 access_log /data/logs/nginx-access.log main; # 默认http 1.0, 改成1.1 proxy_http_version 1.1; # 内核完成文件发送,不需要read再write,没有上下文切换 sendfile on; # sendfile启用后才生效.累计一定大小后发送,减小额外开销,提高网络效率 tcp_nopush on; # 尽快发送数据,禁用Nagle算法(等凑满一个MSS-Maximum Segment Size最大报文长度或收到确认再发送) tcp_nodelay on; # 可以看到 TCP_NOPUSH 是要等数据包累积到一定大小才发送, TCP_NODELAY 是要尽快发送, 二者相互矛盾. # 实际上, 它们确实可以一起用.在传输文件的时候, 先填满包, 再尽快发送. 而其他的情况,都迅速发包,减少延迟. keepalive_timeout 360; types_hash_max_size 2048; server_tokens off; # 超时时间 proxy_connect_timeout 300; proxy_read_timeout 300; proxy_send_timeout 500; # 上传文件 client_max_body_size 2048M; # 大Header会导致502,解决 client_header_buffer_size 64k; proxy_buffer_size 1024k; proxy_buffers 16 1024k; proxy_busy_buffers_size 2048k; # header允许下划线 underscores_in_headers on; # 打开gzip,10k内不压缩 gzip on; gzip_min_length 10k; gzip_http_version 1.1; gzip_comp_level 7; # 压缩类型，下面的配置压缩了接口。可配置项参考nginx目录下的mime.types # 参考google压缩了html,css,js,json. text/html 总是会压缩,加上去返回而报错. # 图片属于压缩过了的格式, 应该由专门的服务或CDN转换图片格式 gzip_types text/plain text/xml text/css application/javascript application/json; gzip_vary on; gzip_disable \"msie6\"; # 等价 gzip_disable \"MSIE[1-6]\\.\" 但性能更好,匹配更合适; # 包含目录 include /usr/local/nginx/conf/hosts/*.conf; # 默认配置,保留是为了不加自定义配置也能起nginx server { listen 80; server_name localhost; location / { root html; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#nginxconf-主配置"},{"categories":["blog"],"content":" 通用 Header 配置/usr/local/nginx/conf/options/normal.conf # 关闭代表不修改upstream返回的Location,Refresh # 后端发送301,location地址可能会有问题,这时候需要开启 # proxy_redirect http:// https://; 把http改成https proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:2","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#通用-header-配置"},{"categories":["blog"],"content":" 长连接 websocket 配置/usr/local/nginx/conf/options/### upgrade_to_websocket.conf proxy_http_version 1.1; proxy_set_header Host $host; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:3","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#长连接-websocket-配置"},{"categories":["blog"],"content":" 证书配置/usr/local/nginx/conf/options/ssl_kentxxq.conf ssl_certificate /usr/local/nginx/conf/ssl/kentxxq.cer; ssl_certificate_key /usr/local/nginx/conf/ssl/kentxxq.key; ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:4","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#证书配置"},{"categories":["blog"],"content":" 时间转换在 server 内使用 /usr/local/nginx/conf/options/time.conf # nginx 内置变量，解析为定义格式，仅支持到秒 （实现支持到毫秒） # # $time_iso8601 日期格式示例： 2022-09-08T18:16:01+08:00 # $time_local 日期格式示例： 02/Aug/2022:11:11:32 +0800 # $msec 日期格式示例： 1663839717.105 当前的Unix时间戳,单位为秒，小数为毫秒 # 格式化日期 if ($time_iso8601 ~ \"^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})(\\+\\d{2})\") { set $year $1; set $month $2; set $day $3; set $hour $4; set $minute $5; set $second $6; # 时区，只到小时 set $time_zone $7; # 自定义 yyyy-MM-dd hh:mi:ss 格式 set $time_zh \"$1-$2-$3 $4:$5:$6\"; } # 时间戳，单位毫秒 使用 $msec 去除中间的小数点实现 if ($msec ~ \"^(\\d+)\\.(\\d+)\") { set $timestamp $1$2; # 自定义 yyyy-MM-dd hh:mi:ss,SSS 带毫秒格式 set $time_zh_ms $time_zh,$2; # 自定义 yyyy-MM-dd hh:mi:ss.SSS 带毫秒格式 set $time_zh_ms2 $time_zh.$2; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:5","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#时间转换"},{"categories":["blog"],"content":" map 配置/usr/local/nginx/conf/options/map.conf # $http_origin如果正则匹配了,$allow_origin会变成后面的值 map $http_origin $allow_origin { default \"\"; \"~http://www.kentxxq.com\" http://www.kentxxq.com; \"~https://www.kentxxq.com\" https://www.kentxxq.com; } # 添加map会影响性能,如果不是全局使用,建议采用include局部转换时间 # # 自定义 yyyy-MM-dd hh:mi:ss 格式 # map $time_iso8601 $time_zh { # default $time_iso8601; # \"~(\\d{4}-\\d{2}-\\d{2})T(\\d{2}:\\d{2}:\\d{2})(\\+\\d{2})\" \"$1 $2\"; # } # # # 时间戳，单位毫秒 使用 $msec 去除中间的小数点实现 # map $msec $timestamp { # default $msec; # ~(\\d+)\\.(\\d+) $1$2; # } # # # 自定义 yyyy-MM-dd hh:mi:ss,SSS 带毫秒格式 # map \"$time_iso8601 # $msec\" $time_zh_ms { # default $time_zh,000; # \"~(\\d{4}-\\d{2}-\\d{2})T(\\d{2}:\\d{2}:\\d{2})(\\+\\d{2}:\\d{2}) # (\\d+)\\.(\\d+)$\" \"$1 $2,$5\"; # } # # # 自定义 yyyy-MM-dd hh:mi:ss.SSS 带毫秒格式 # map \"$time_iso8601 # $msec\" $time_zh_ms2 { # default $time_zh.000; # \"~(\\d{4}-\\d{2}-\\d{2})T(\\d{2}:\\d{2}:\\d{2})(\\+\\d{2}:\\d{2}) # (\\d+)\\.(\\d+)$\" \"$1 $2.$5\"; # } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:6","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#map-配置"},{"categories":["blog"],"content":" 跨域配置文件 全部跨域/usr/local/nginx/conf/options/allow_all_cross_origin.conf # add_header 'Access-Control-Allow-Origin' * always; add_header 'Access-Control-Allow-Origin' $http_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, HEAD, PUT, DELETE, TRACE, CONNECT'; # add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type'; add_header 'Access-Control-Allow-Headers' *; add_header 'Access-Control-Max-Age' 86400; 全部 options 跨域/usr/local/nginx/conf/options/allow_all_cross_origin.conf if ($request_method = 'OPTIONS') { # 前两条的配置为固定格式！兼容性最强。原因是客户端发送ajax请求，包含withCredentials的时候，origin不能为*，且Credentials必须为true。 # 参考链接 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials add_header 'Access-Control-Allow-Origin' $http_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET,POST,OPTIONS,HEAD,PUT,DELETE, TRACE, CONNECT'; add_header 'Access-Control-Allow-Headers' *; add_header 'Access-Control-Max-Age' 86400; add_header 'Content-Length' 0; return 204; } 特定匹配 options 跨域/usr/local/nginx/conf/options/allow_kentxxq_cross_origin.conf if ($request_method = 'OPTIONS') { add_header 'Access-Control-Allow-Origin' $allow_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, HEAD, PUT, DELETE, TRACE, CONNECT'; add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type,Accept,Origin,User-Agent,DNT,Cache-Control,X-Mx-ReqToken,X-Requested-With,token,terminalType'; add_header 'Access-Control-Max-Age' 86400; add_header 'Content-Length' 0; return 204; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:7","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#跨域配置文件"},{"categories":["blog"],"content":" 跨域配置文件 全部跨域/usr/local/nginx/conf/options/allow_all_cross_origin.conf # add_header 'Access-Control-Allow-Origin' * always; add_header 'Access-Control-Allow-Origin' $http_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, HEAD, PUT, DELETE, TRACE, CONNECT'; # add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type'; add_header 'Access-Control-Allow-Headers' *; add_header 'Access-Control-Max-Age' 86400; 全部 options 跨域/usr/local/nginx/conf/options/allow_all_cross_origin.conf if ($request_method = 'OPTIONS') { # 前两条的配置为固定格式！兼容性最强。原因是客户端发送ajax请求，包含withCredentials的时候，origin不能为*，且Credentials必须为true。 # 参考链接 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials add_header 'Access-Control-Allow-Origin' $http_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET,POST,OPTIONS,HEAD,PUT,DELETE, TRACE, CONNECT'; add_header 'Access-Control-Allow-Headers' *; add_header 'Access-Control-Max-Age' 86400; add_header 'Content-Length' 0; return 204; } 特定匹配 options 跨域/usr/local/nginx/conf/options/allow_kentxxq_cross_origin.conf if ($request_method = 'OPTIONS') { add_header 'Access-Control-Allow-Origin' $allow_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, HEAD, PUT, DELETE, TRACE, CONNECT'; add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type,Accept,Origin,User-Agent,DNT,Cache-Control,X-Mx-ReqToken,X-Requested-With,token,terminalType'; add_header 'Access-Control-Max-Age' 86400; add_header 'Content-Length' 0; return 204; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:7","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#全部跨域"},{"categories":["blog"],"content":" 跨域配置文件 全部跨域/usr/local/nginx/conf/options/allow_all_cross_origin.conf # add_header 'Access-Control-Allow-Origin' * always; add_header 'Access-Control-Allow-Origin' $http_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, HEAD, PUT, DELETE, TRACE, CONNECT'; # add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type'; add_header 'Access-Control-Allow-Headers' *; add_header 'Access-Control-Max-Age' 86400; 全部 options 跨域/usr/local/nginx/conf/options/allow_all_cross_origin.conf if ($request_method = 'OPTIONS') { # 前两条的配置为固定格式！兼容性最强。原因是客户端发送ajax请求，包含withCredentials的时候，origin不能为*，且Credentials必须为true。 # 参考链接 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials add_header 'Access-Control-Allow-Origin' $http_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET,POST,OPTIONS,HEAD,PUT,DELETE, TRACE, CONNECT'; add_header 'Access-Control-Allow-Headers' *; add_header 'Access-Control-Max-Age' 86400; add_header 'Content-Length' 0; return 204; } 特定匹配 options 跨域/usr/local/nginx/conf/options/allow_kentxxq_cross_origin.conf if ($request_method = 'OPTIONS') { add_header 'Access-Control-Allow-Origin' $allow_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, HEAD, PUT, DELETE, TRACE, CONNECT'; add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type,Accept,Origin,User-Agent,DNT,Cache-Control,X-Mx-ReqToken,X-Requested-With,token,terminalType'; add_header 'Access-Control-Max-Age' 86400; add_header 'Content-Length' 0; return 204; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:7","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#全部-options-跨域"},{"categories":["blog"],"content":" 跨域配置文件 全部跨域/usr/local/nginx/conf/options/allow_all_cross_origin.conf # add_header 'Access-Control-Allow-Origin' * always; add_header 'Access-Control-Allow-Origin' $http_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, HEAD, PUT, DELETE, TRACE, CONNECT'; # add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type'; add_header 'Access-Control-Allow-Headers' *; add_header 'Access-Control-Max-Age' 86400; 全部 options 跨域/usr/local/nginx/conf/options/allow_all_cross_origin.conf if ($request_method = 'OPTIONS') { # 前两条的配置为固定格式！兼容性最强。原因是客户端发送ajax请求，包含withCredentials的时候，origin不能为*，且Credentials必须为true。 # 参考链接 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials add_header 'Access-Control-Allow-Origin' $http_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET,POST,OPTIONS,HEAD,PUT,DELETE, TRACE, CONNECT'; add_header 'Access-Control-Allow-Headers' *; add_header 'Access-Control-Max-Age' 86400; add_header 'Content-Length' 0; return 204; } 特定匹配 options 跨域/usr/local/nginx/conf/options/allow_kentxxq_cross_origin.conf if ($request_method = 'OPTIONS') { add_header 'Access-Control-Allow-Origin' $allow_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, HEAD, PUT, DELETE, TRACE, CONNECT'; add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type,Accept,Origin,User-Agent,DNT,Cache-Control,X-Mx-ReqToken,X-Requested-With,token,terminalType'; add_header 'Access-Control-Max-Age' 86400; add_header 'Content-Length' 0; return 204; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:7","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#特定匹配-options-跨域"},{"categories":["blog"],"content":" 域名转发 Debug 配置/usr/local/nginx/conf/hosts/debug.conf server { listen 8000; server_name _; include /usr/local/nginx/conf/time.conf; location /status_string { stub_status; } location /status_metrics { default_type text/plain; return 200 '# TYPE connections_active counter # HELP The current number of active client connections including Waiting connections. connections_active $connections_active $timestamp # TYPE connections_reading counter # HELP The current number of connections where nginx is reading the request header. connections_reading $connections_reading $timestamp # TYPE connections_writing counter # HELP The current number of connections where nginx is writing the response back to the client. connections_writing $connections_writing $timestamp # TYPE connections_waiting counter # HELP The current number of idle client connections waiting for a request. connections_waiting $connections_waiting $timestamp'; } location /time { default_type text/plain; return 200 'time'; add_header time_zh $time_zh; add_header timestamp $timestamp; add_header time_msec $msec; add_header time_zh_ms $time_zh_ms; add_header time_zh_ms2 $time_zh_ms2; add_header time_local $time_local; add_header time_iso8601 $time_iso8601; } } 用户配置/usr/local/nginx/conf/hosts/www.kentxxq.com.conf server { listen 80; server_name www.kentxxq.com; return 301 https://$server_name$request_uri; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log k-json; } server { listen 443 ssl http2; server_name www.kentxxq.com; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log k-json; # 普通header头,ip之类的 include /usr/local/nginx/conf/options/normal.conf; # 跨域 include /usr/local/nginx/conf/options/allow_all_cross_origin.conf; # 证书相关 include /usr/local/nginx/conf/options/ssl_kentxxq.conf; location / { # 跨域 include /usr/local/nginx/conf/options/allow_all_options_cross_origin.conf; proxy_pass http://1.1.1.1:80; } } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:8","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#域名转发"},{"categories":["blog"],"content":" 域名转发 Debug 配置/usr/local/nginx/conf/hosts/debug.conf server { listen 8000; server_name _; include /usr/local/nginx/conf/time.conf; location /status_string { stub_status; } location /status_metrics { default_type text/plain; return 200 '# TYPE connections_active counter # HELP The current number of active client connections including Waiting connections. connections_active $connections_active $timestamp # TYPE connections_reading counter # HELP The current number of connections where nginx is reading the request header. connections_reading $connections_reading $timestamp # TYPE connections_writing counter # HELP The current number of connections where nginx is writing the response back to the client. connections_writing $connections_writing $timestamp # TYPE connections_waiting counter # HELP The current number of idle client connections waiting for a request. connections_waiting $connections_waiting $timestamp'; } location /time { default_type text/plain; return 200 'time'; add_header time_zh $time_zh; add_header timestamp $timestamp; add_header time_msec $msec; add_header time_zh_ms $time_zh_ms; add_header time_zh_ms2 $time_zh_ms2; add_header time_local $time_local; add_header time_iso8601 $time_iso8601; } } 用户配置/usr/local/nginx/conf/hosts/www.kentxxq.com.conf server { listen 80; server_name www.kentxxq.com; return 301 https://$server_name$request_uri; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log k-json; } server { listen 443 ssl http2; server_name www.kentxxq.com; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log k-json; # 普通header头,ip之类的 include /usr/local/nginx/conf/options/normal.conf; # 跨域 include /usr/local/nginx/conf/options/allow_all_cross_origin.conf; # 证书相关 include /usr/local/nginx/conf/options/ssl_kentxxq.conf; location / { # 跨域 include /usr/local/nginx/conf/options/allow_all_options_cross_origin.conf; proxy_pass http://1.1.1.1:80; } } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:8","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#debug-配置"},{"categories":["blog"],"content":" 域名转发 Debug 配置/usr/local/nginx/conf/hosts/debug.conf server { listen 8000; server_name _; include /usr/local/nginx/conf/time.conf; location /status_string { stub_status; } location /status_metrics { default_type text/plain; return 200 '# TYPE connections_active counter # HELP The current number of active client connections including Waiting connections. connections_active $connections_active $timestamp # TYPE connections_reading counter # HELP The current number of connections where nginx is reading the request header. connections_reading $connections_reading $timestamp # TYPE connections_writing counter # HELP The current number of connections where nginx is writing the response back to the client. connections_writing $connections_writing $timestamp # TYPE connections_waiting counter # HELP The current number of idle client connections waiting for a request. connections_waiting $connections_waiting $timestamp'; } location /time { default_type text/plain; return 200 'time'; add_header time_zh $time_zh; add_header timestamp $timestamp; add_header time_msec $msec; add_header time_zh_ms $time_zh_ms; add_header time_zh_ms2 $time_zh_ms2; add_header time_local $time_local; add_header time_iso8601 $time_iso8601; } } 用户配置/usr/local/nginx/conf/hosts/www.kentxxq.com.conf server { listen 80; server_name www.kentxxq.com; return 301 https://$server_name$request_uri; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log k-json; } server { listen 443 ssl http2; server_name www.kentxxq.com; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log k-json; # 普通header头,ip之类的 include /usr/local/nginx/conf/options/normal.conf; # 跨域 include /usr/local/nginx/conf/options/allow_all_cross_origin.conf; # 证书相关 include /usr/local/nginx/conf/options/ssl_kentxxq.conf; location / { # 跨域 include /usr/local/nginx/conf/options/allow_all_options_cross_origin.conf; proxy_pass http://1.1.1.1:80; } } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:8","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#用户配置"},{"categories":["blog"],"content":" 静态页代理 简单版 location / { root /usr/share/nginx/html; index index.html; try_files $uri $uri/index.html /index.html; } 完整版本 server { listen 80; server_name www.kentxxq.com; return 301 https://$server_name$request_uri; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log; } server { listen 443 ssl http2; server_name www.kentxxq.com; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log; include /usr/local/nginx/conf/options/normal.conf; include /usr/local/nginx/conf/options/ssl_kentxxq.conf; location / { if ($request_filename ~* .*\\.(?:htm|html)$) { add_header Cache-Control \"no-store\"; } root /usr/share/nginx/html; try_files $uri @index ; } location @index { add_header Cache-Control \"no-store\" ; root /usr/share/nginx/html; index index.html index.htm; try_files $uri/index.html /index.html; } error_page 405 =200 $uri; } 容器版本 server { listen 80; listen [::]:80; server_name localhost default_server; client_max_body_size 200m; location / { if ($request_filename ~* .*\\.(?:htm|html)$) { add_header Cache-Control \"no-store\"; } root /usr/share/nginx/html; try_files $uri @index ; } location @index { add_header Cache-Control \"no-store\" ; root /usr/share/nginx/html; index index.html index.htm; try_files $uri/index.html /index.html; } error_page 405 =200 $uri; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:9","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#静态页代理"},{"categories":["blog"],"content":" 静态页代理 简单版 location / { root /usr/share/nginx/html; index index.html; try_files $uri $uri/index.html /index.html; } 完整版本 server { listen 80; server_name www.kentxxq.com; return 301 https://$server_name$request_uri; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log; } server { listen 443 ssl http2; server_name www.kentxxq.com; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log; include /usr/local/nginx/conf/options/normal.conf; include /usr/local/nginx/conf/options/ssl_kentxxq.conf; location / { if ($request_filename ~* .*\\.(?:htm|html)$) { add_header Cache-Control \"no-store\"; } root /usr/share/nginx/html; try_files $uri @index ; } location @index { add_header Cache-Control \"no-store\" ; root /usr/share/nginx/html; index index.html index.htm; try_files $uri/index.html /index.html; } error_page 405 =200 $uri; } 容器版本 server { listen 80; listen [::]:80; server_name localhost default_server; client_max_body_size 200m; location / { if ($request_filename ~* .*\\.(?:htm|html)$) { add_header Cache-Control \"no-store\"; } root /usr/share/nginx/html; try_files $uri @index ; } location @index { add_header Cache-Control \"no-store\" ; root /usr/share/nginx/html; index index.html index.htm; try_files $uri/index.html /index.html; } error_page 405 =200 $uri; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:9","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#简单版"},{"categories":["blog"],"content":" 静态页代理 简单版 location / { root /usr/share/nginx/html; index index.html; try_files $uri $uri/index.html /index.html; } 完整版本 server { listen 80; server_name www.kentxxq.com; return 301 https://$server_name$request_uri; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log; } server { listen 443 ssl http2; server_name www.kentxxq.com; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log; include /usr/local/nginx/conf/options/normal.conf; include /usr/local/nginx/conf/options/ssl_kentxxq.conf; location / { if ($request_filename ~* .*\\.(?:htm|html)$) { add_header Cache-Control \"no-store\"; } root /usr/share/nginx/html; try_files $uri @index ; } location @index { add_header Cache-Control \"no-store\" ; root /usr/share/nginx/html; index index.html index.htm; try_files $uri/index.html /index.html; } error_page 405 =200 $uri; } 容器版本 server { listen 80; listen [::]:80; server_name localhost default_server; client_max_body_size 200m; location / { if ($request_filename ~* .*\\.(?:htm|html)$) { add_header Cache-Control \"no-store\"; } root /usr/share/nginx/html; try_files $uri @index ; } location @index { add_header Cache-Control \"no-store\" ; root /usr/share/nginx/html; index index.html index.htm; try_files $uri/index.html /index.html; } error_page 405 =200 $uri; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:9","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#完整版本"},{"categories":["blog"],"content":" 静态页代理 简单版 location / { root /usr/share/nginx/html; index index.html; try_files $uri $uri/index.html /index.html; } 完整版本 server { listen 80; server_name www.kentxxq.com; return 301 https://$server_name$request_uri; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log; } server { listen 443 ssl http2; server_name www.kentxxq.com; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log; include /usr/local/nginx/conf/options/normal.conf; include /usr/local/nginx/conf/options/ssl_kentxxq.conf; location / { if ($request_filename ~* .*\\.(?:htm|html)$) { add_header Cache-Control \"no-store\"; } root /usr/share/nginx/html; try_files $uri @index ; } location @index { add_header Cache-Control \"no-store\" ; root /usr/share/nginx/html; index index.html index.htm; try_files $uri/index.html /index.html; } error_page 405 =200 $uri; } 容器版本 server { listen 80; listen [::]:80; server_name localhost default_server; client_max_body_size 200m; location / { if ($request_filename ~* .*\\.(?:htm|html)$) { add_header Cache-Control \"no-store\"; } root /usr/share/nginx/html; try_files $uri @index ; } location @index { add_header Cache-Control \"no-store\" ; root /usr/share/nginx/html; index index.html index.htm; try_files $uri/index.html /index.html; } error_page 405 =200 $uri; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:9","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#容器版本"},{"categories":["blog"],"content":" 功能配置","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#功能配置"},{"categories":["blog"],"content":" IP 限速 http { # 白名单 geo $whitelist { default 0; 10.0.0.0/8 1; 8.133.183.80 1; } # 白名单映射到空字符串,生成限速列表 map $whitelist $limit { 0 $binary_remote_addr; 1 \"\"; } # 应用限速列表,分配50m内存,每秒10次 # 10r/m分钟 10r/h小时 10r/d天 10r/w周 10r/y年 limit_req_zone $limit zone=iplimit:50m rate=10r/s; } # 域名限速 # burst代表最多蓄力100,即第一秒最多100+10次请求. # 默认110次请求排队发送,nodelay则会不排队,直接把110次请求一次性发送 server { limit_req zone=iplimit burst=100 nodelay; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:3:1","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#ip-限速"},{"categories":["blog"],"content":" 代理 openai server { listen 8888; server_name ip; access_log /tmp/openai.com.log; location / { # 使用特定ca来验证证书,默认不验证 # proxy_ssl_verify on; # proxy_ssl_trusted_certificate /etc/nginx/conf.d/cacert.pem; # 默认不带SNI,会返回错误的证书,因此需要开启 proxy_ssl_server_name on; # 可以改变SNI的名称,但是没必要 # proxy_ssl_name www.baidu.com; proxy_set_header Host api.openai.com; proxy_pass https://api.openai.com; } } 相关资料: Nginx 反向代理，当后端为 Https 时的一些细节和原理 - XniLe - Ops 2.0 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:3:2","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#代理-openai"},{"categories":["blog"],"content":" 用户名密码 # 安装 apt install apache2-utils -y # 密码在 /usr/local/nginx/conf/passwd.db ,让你输入密码 htpasswd -c /usr/local/nginx/conf/passwd.db user1 # 配置使用用户名密码 location / { auth_basic \"需要输入用户名: 密码:\"; auth_basic_user_file /usr/local/nginx/conf/passwd.db; proxy_pass http://1.1.1.1:80; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:3:3","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#用户名密码"},{"categories":["blog"],"content":" 移动端检测Detect Mobile Browsers - Open source mobile phone detection location /mobile-page { set $is_mobile 0; if ($http_user_agent ~* \"(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino\") { set $is_mobile 1; } if ($http_user_agent ~* \"^(1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-)\") { set $is_mobile 1; } # =0是pc端 =1是移动端 if ($is_mobile = 0) { return 302 https://www.kentxxq.com$request_uri; } proxy_set_header Host $host; proxy_pass http://1.1.1.1:80; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:3:4","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#移动端检测"},{"categories":["blog"],"content":" 返回 200 location /string { default_type text/html; return 200 \"维护中\"; } location /json { default_type application/json; return 200 '{\"status\":\"success\",\"result\":\"nginx json\"}'; } location /metrics { default_type text/plain; return 200 'metrics'; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:3:5","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#返回-200"},{"categories":["blog"],"content":" 405 错误 -post 请求静态文件 # 这一行加在server的第一层，不能加在location位置 error_page 405 =200 $uri; ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:3:6","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#405-错误--post-请求静态文件"},{"categories":["blog"],"content":" 防止嵌入 iframe # frame-ancestors 谁能嵌入我 # frame-src 我可以嵌入哪些站点 # 参考 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors # 当前站点,a.com,b.com,以及子域名 # 空格间隔,不同参数分号隔开 add_header Content-Security-Policy \"frame-ancestors 'self' a.com b.com *.a.com *.b.com; frame-src 'self' a.com b.com *.a.com *.b.com\"; ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:3:7","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#防止嵌入-iframe"},{"categories":["blog"],"content":" 守护进程supervisor 守护起来 开机自启 异常自动重启 [program:nginx] command = /usr/local/nginx/sbin/nginx -g 'daemon off;' # 启动进程数目默认为1 numprocs = 1 # 如果supervisord是root启动的 设置此用户可以管理该program user = root # 程序运行的优先级 默认999 priority = 996 # 随着supervisord 自启动 autostart = true # 子进程挂掉后无条件自动重启 autorestart = true # 子进程启动多少秒之后 状态为running 表示运行成功 startsecs = 20 # 进程启动失败 最大尝试次数 超过将把状态置为FAIL startretries = 3 # 标准输出的文件路径 stdout_logfile = /tmp/nginx-supervisor.log # 日志文件最大大小 stdout_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stdout_logfile_backups = 3 # 错误输出的文件路径 stderr_logfile = /tmp/nginx-supervisor.log # 日志文件最大大小 stderr_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stderr_logfile_backups = 3 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:4:0","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#守护进程"},{"categories":["blog"],"content":" Ingress-nginx 配置 # 双层nginx,第二层的ingress-nginx需要配置这个 use-forwarded-headers: 'true' # yml配置 kind: Ingress apiVersion: networking.k8s.io/v1 metadata: name: gateway.gateway.com namespace: default annotations: kubectl.kubernetes.io/last-applied-configuration: \u003e {\"apiVersion\":\"networking.k8s.io/v1\",\"kind\":\"Ingress\",\"metadata\":{\"annotations\":{\"kubernetes.io/ingress.class\":\"nginx\",\"nginx.ingress.kubernetes.io/cors-allow-headers\":\"uid,download,repeat,DNT,X-CustomHeader,X-LANG,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,X-Api-Key,X-Device-Id,Access-Control-Allow-Origin,authorization\",\"nginx.ingress.kubernetes.io/cors-allow-methods\":\"PUT, GET, POST, OPTIONS, DELETE\",\"nginx.ingress.kubernetes.io/cors-allow-origin\":\"*\",\"nginx.ingress.kubernetes.io/enable-cors\":\"true\"},\"name\":\"gateway.kentxxq.com\",\"namespace\":\"default\"},\"spec\":{\"ingressClassName\":\"nginx\",\"rules\":[{\"host\":\"gateway.kentxxq.com\",\"http\":{\"paths\":[{\"backend\":{\"service\":{\"name\":\"gateway\",\"port\":{\"number\":8090}}},\"path\":\"/\",\"pathType\":\"Prefix\"}]}}],\"tls\":[{\"hosts\":[\"gateway.kentxxq.com\"],\"secretName\":\"a.kentxxq.com-secret\"}]}} kubernetes.io/ingress.class: nginx nginx.ingress.kubernetes.io/cors-allow-headers: \u003e- uid,download,repeat,DNT,X-CustomHeader,X-LANG,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,X-Api-Key,X-Device-Id,Access-Control-Allow-Origin,authorization nginx.ingress.kubernetes.io/cors-allow-methods: 'PUT, GET, POST, OPTIONS, DELETE' nginx.ingress.kubernetes.io/cors-allow-origin: '*' nginx.ingress.kubernetes.io/enable-cors: 'true' # 下面是手动添加内容，用于压测或自定义 nginx.ingress.kubernetes.io/server-snippet: | location /200_ingress_nginx { default_type text/html; return 200 \"200_ingress_nginx\"; } spec: ingressClassName: nginx tls: - hosts: - gateway.kentxxq.com secretName: a.kentxxq.com-secret rules: - host: gateway.kentxxq.com http: paths: - path: / pathType: Prefix backend: service: name: gateway port: number: 8090 - path: /200_ingress_to_nginx pathType: Prefix backend: service: name: test-nginx port: number: 80 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:5:0","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#ingress-nginx-配置"},{"categories":["blog"],"content":" Openrestry 转发给 kafka","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:6:0","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#openrestry-转发给-kafka"},{"categories":["blog"],"content":" 依赖配置以前做过这个, 但是现在觉得没有必要. 因为我对 lua 语言不熟悉, 而且觉得 nginx 做负载就好了, 不应该嵌入一些业务需求. GitHub - doujiang24/lua-resty-kafka: Lua kafka client driver for the Openresty based on the cosocket API # nginx.conf http { lua_package_path \"/path/to/lua-resty-kafka/lib/?.lua;;\"; ... } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:6:1","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#依赖配置"},{"categories":["blog"],"content":" 转发配置 server { listen 443 ssl http2; server_name a.kentxxq.com; access_log /data/weblog/nginx/logs/a.kentxxq.com.access.log main; lua_need_request_body on; include /usr/local/openresty/nginx/conf/option/ssl_kentxxq.com.conf; location /lua { default_type 'text/html'; content_by_lua 'ngx.say(\"hello world！\")'; } location /api/livereportorgan/playbackRecord { proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; default_type 'application/json'; content_by_lua ' local cjson = require \"cjson\" local client = require \"resty.kafka.client\" local producer = require \"resty.kafka.producer\" local uuid = require \"resty.uuid\" local broker_list = { { host = \"ip1\", port = 9092 }, { host = \"ip2\", port = 9092 }, { host = \"ip3\", port = 9092 }, } local message = {} message[\"uri\"]=ngx.var.uri message[\"args\"]=ngx.var.args message[\"host\"]=ngx.var.host message[\"request_body\"]=ngx.var.request_body message[\"remote_addr\"] = ngx.var.http_x_forwarded_for message[\"remote_user\"] = ngx.var.remote_user message[\"time_local\"] = ngx.var.time_iso8601 message[\"status\"] = ngx.var.status message[\"body_bytes_sent\"] = ngx.var.body_bytes_sent message[\"http_referer\"] = ngx.var.http_referer message[\"http_user_agent\"] = ngx.var.http_user_agent message[\"http_x_forwarded_for\"] = ngx.var.http_x_forwarded_for message[\"upstream_response_time\"] = ngx.var.upstream_response_time message[\"request_time\"] = ngx.var.request_time message[\"http_token\"] = ngx.var.http_token message[\"terminalType\"] = ngx.var.http_terminalType message[\"header\"] = ngx.var.header message[\"uuid\"] = uuid.generate() -- 转换json为字符串 local message = cjson.encode(message); -- 定义kafka异步生产者 -- this is async producer_type and bp will be reused in the whole nginx worker local bp = producer:new(broker_list, { producer_type = \"sync\" }) local ok, err = bp:send(\"playback_duration_notice_org\", nil, message) if not ok then local response = {} response[\"code\"]=\"1\" response[\"message\"]=err response[\"data\"]=\"true\" local response = cjson.encode(response); ngx.say(response) return end local delayData = {delay = 60} local response = {code = \"0\", message = \"success\", data = delayData} local response = cjson.encode(response); ngx.say(response) '; } } server { listen 80; server_name a.kentxxq.com; return 301 https://$server_name$request_uri; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:6:2","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#转发配置"},{"categories":["point"],"content":"oracle 是一种关系型数据库, 类似 mssql, mysql. 要点: 收费 用户量大 国内互联网几乎不用 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/oracle/:0:0","series":null,"tags":["point","oracle"],"title":"oracle","uri":"/posts/%E7%AC%94%E8%AE%B0/point/oracle/#"},{"categories":["blog"],"content":"因为以前的公司是用 [[笔记/point/oracle|oracle]],所以也记录了不少的命令. 记录一下后续使用.","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E9%85%8D%E7%BD%AE%E5%92%8C%E5%91%BD%E4%BB%A4/","series":null,"tags":["blog","oracle"],"title":"oracle配置和命令","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E9%85%8D%E7%BD%AE%E5%92%8C%E5%91%BD%E4%BB%A4/"},{"categories":["blog"],"content":" 简介因为以前的公司是用 oracle,所以也记录了不少的命令. 记录一下后续使用. ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E9%85%8D%E7%BD%AE%E5%92%8C%E5%91%BD%E4%BB%A4/:1:0","series":null,"tags":["blog","oracle"],"title":"oracle配置和命令","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E9%85%8D%E7%BD%AE%E5%92%8C%E5%91%BD%E4%BB%A4/#简介"},{"categories":["blog"],"content":" 命令","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E9%85%8D%E7%BD%AE%E5%92%8C%E5%91%BD%E4%BB%A4/:2:0","series":null,"tags":["blog","oracle"],"title":"oracle配置和命令","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E9%85%8D%E7%BD%AE%E5%92%8C%E5%91%BD%E4%BB%A4/#命令"},{"categories":["blog"],"content":" 索引 # 快速创建索引 create index idx_table_a on table_a(字段a,字段b) nologging parallel 4; ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E9%85%8D%E7%BD%AE%E5%92%8C%E5%91%BD%E4%BB%A4/:2:1","series":null,"tags":["blog","oracle"],"title":"oracle配置和命令","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E9%85%8D%E7%BD%AE%E5%92%8C%E5%91%BD%E4%BB%A4/#索引"},{"categories":["blog"],"content":" 删除操作 # 加速插入 alter table x nologging; insert /*+append*/ into x (a,b,c) as select a,b,c from xxx; # 批量删除.根据时间排序,1000条commmit一次 declare cursor [del_cursor] is select a.*, a.rowid row_id from [table_name] a order by a.rowid; begin for v_cusor in [del_cursor] loop if v_cusor.[time_stamp] \u003c to_date('2014-01-01','yyyy-mm-dd') then delete from [table_name] where rowid = v_cusor.row_id; end if; if mod([del_cursor]%rowcount,1000)=0 then commit; end if; end loop; commit; end; # 两表数据同步 MERGE INTO t_canhe_family t1 USING(select a1.family_id,a1.account_money,a1.balance,a1.remaining_money from t_canhe_family_bak20161121 a1) tt ON (tt.family_id=t1.family_id) when matched then update set t1.account_money=tt.account_money, t1.balance=tt.balance, t1.remaining_money=tt.remaining_money ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E9%85%8D%E7%BD%AE%E5%92%8C%E5%91%BD%E4%BB%A4/:2:2","series":null,"tags":["blog","oracle"],"title":"oracle配置和命令","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E9%85%8D%E7%BD%AE%E5%92%8C%E5%91%BD%E4%BB%A4/#删除操作"},{"categories":["blog"],"content":" sql 优化 # 查看执行计划 select /*+ gather_plan_statistics */* from table(dbms_xplan.display_cursor(NVL('ajkqn4733r2qx',NULL),NULL,'ALL ALLSTATS LAST PEEKED_BINDS cost partition -projection -outline')); ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E9%85%8D%E7%BD%AE%E5%92%8C%E5%91%BD%E4%BB%A4/:2:3","series":null,"tags":["blog","oracle"],"title":"oracle配置和命令","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E9%85%8D%E7%BD%AE%E5%92%8C%E5%91%BD%E4%BB%A4/#sql-优化"},{"categories":["point"],"content":"redis 通常用来做缓存数据库. 要点: 免费 性能高 缓存常用 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/redis/:0:0","series":null,"tags":["point","redis"],"title":"redis","uri":"/posts/%E7%AC%94%E8%AE%B0/point/redis/#"},{"categories":["point"],"content":" 操作手册 # 删除 ip地址的8号库的a_* redis-cli -h ip地址 -a 密码 -n 8 keys 'a_*' | xargs redis-cli -h ip地址 -a 密码 -n 8 del # 把0库所有内容移动到1库 redis-cli -a 密码 -n 0 keys '*' | xargs -I '{}' redis-cli -a didi -n 0 move '{}' 1 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/redis/:0:1","series":null,"tags":["point","redis"],"title":"redis","uri":"/posts/%E7%AC%94%E8%AE%B0/point/redis/#操作手册"},{"categories":["blog"],"content":"这里记录一些 ip, 包, 传输协议, 段, 和7 层网络知识等等网络知识, 方便快速查阅. ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"},{"categories":["blog"],"content":" 简介这里记录一些 ip, 包, 传输协议, 段, 和 7 层网络知识等等网络知识, 方便快速查阅. 参考资料 计算机网络 - Computer Network ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:1:0","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:0","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#内容"},{"categories":["blog"],"content":" 7 层通信 路由器和 3层交换机 等价. 2层交换机 活动在数据链路层, 只是延长网络. 每一层都加上自己的 header头部数据. ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:1","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#7-层通信"},{"categories":["blog"],"content":" 7 层模型各自的作用 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:2","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#7-层模型各自的作用"},{"categories":["blog"],"content":" 7 层网络协议 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:3","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#7-层网络协议"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#数据包详解"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#数据包示意图"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#数据链路层"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#帧-frame"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#以太网"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#wifi"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#mtu"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#网络层"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#tcp-ip-协议栈"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#ip-数据报格式"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#ip-数据报分片"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#私有-ip-地址"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#arprarp-协议"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#dhcp-协议"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#icmp-协议"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#传输层"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#udp"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#tcp"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#tcp-的头部格式"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#tcp-options-相关参数"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#tcp-建立连接"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#tcp-连接释放"},{"categories":["blog"],"content":" FAQ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:3:0","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#faq"},{"categories":["blog"],"content":" TCP segment 段和 package 包在 TCP（传输控制协议）中，“Segment size”（段大小）和 “Packet”（包）是两个不同但相关的概念。 “Segment size” 指的是 TCP 协议中数据传输时每个 TCP 段（segment）的最大大小。TCP 使用分段（segmentation）将应用程序发送的数据划分为较小的片段进行传输。这些片段被称为 TCP 段，每个段都包含一个 TCP 头部和有效载荷（数据）。段的大小由操作系统或网络堆栈的配置参数确定，并且可以根据网络条件进行调整。通常情况下，段的大小在几百字节到几千字节之间。 而 “Packet”（包）是在网络层（如互联网协议 IP）上进行数据传输时使用的单位。包是由网络层负责封装和传递的，其中包括源地址、目标地址和有效载荷（即从传输层接收到的 TCP 段）。包的大小由网络层协议定义，例如在 IPv4 中，包的最大大小为 64KB。 区别： 概念层次不同：TCP 段是在传输层协议 TCP 中定义的，而包是在网络层协议（如 IP）中定义的。 功能不同：TCP 段负责将数据从应用程序发送到接收方的 TCP 协议栈，而包在网络中进行路由和传递，确保数据的正确交付。 大小限制不同：TCP 段的大小受到 TCP 协议栈的配置参数限制，而包的大小由网络层协议定义。 联系： 在传输过程中，应用程序发送的数据会被 TCP 协议分割成多个段（segment），每个段都会被封装为一个网络层的包（packet）进行传输。这两个概念都是为了实现可靠的数据传输和网络通信而存在的。 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:3:1","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#tcp-segment-段和-package-包"},{"categories":["blog"],"content":" TCP_CORK 和 TCP_NODELAYNagle 算法规定包满足 MSS 立即发送, 否则需要发送 ACK 确认包. 而每个包都发送 ACK, 会降低性能. DelayedAcknowledgment 不再针对单个包发送 ACK，而是一次确认两个包，或者在发送响应数据的同时捎带着发送 ACK，又或者触发超时时间后再发送 ACK. 而一旦这两点同时工作, 在发送小包的时候, 就需要等待 ack 回传, 才能发送. 为什么一般延迟是 40 ms 呢? redhat文档说默认是这个值, RFC 9293 说必须少于 0.5 seconds, 所以设置的 40 ms 吧. 如何解决呢? 启用 TCP_NODELAY , 禁用 Nagle 算法. nginx配置 就用了这个配置. 其中 TCP_NOPUSH 就是 TCP_CORK 参数, 可以和 TCP_DELAY 配置使用, 让 nginx 在发送文件的时候每个包尽量多的存放数据. TCP_NODELAY 就是在其他情况下, 减少延迟用的. 参考资料 TCP_NODELAY 和 TCP_NOPUSH的解释 - wajika - 博客园 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:3:2","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#tcp_cork-和-tcp_nodelay"},{"categories":["blog"],"content":"这里记录一些文档的格式, 有时候写文档不知道还要写一些什么方面, 维度信息. 可以做一个参考.","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/","series":null,"tags":["blog","文档助手"],"title":"文档助手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/"},{"categories":["blog"],"content":" 简介这里记录一些文档的格式, 有时候写文档不知道还要写一些什么方面, 维度信息. 可以做一个参考. ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/:1:0","series":null,"tags":["blog","文档助手"],"title":"文档助手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/:2:0","series":null,"tags":["blog","文档助手"],"title":"文档助手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/#内容"},{"categories":["blog"],"content":" 调研 - 主干 背景、问题 整理分析、目的 介绍、概览（图标）、对比（表格） 细节 概念统一、规范 示例（代码） 参考信息（链接） ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/:2:1","series":null,"tags":["blog","文档助手"],"title":"文档助手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/#调研---主干"},{"categories":["blog"],"content":" 计划任务 - 5w2h why- 为什么做 what- 做什么 when- 何时 where- 何地 who- 谁来做 how to- 如何做 how much- 做到什么程度 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/:2:2","series":null,"tags":["blog","文档助手"],"title":"文档助手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/#计划任务---5w2h"},{"categories":["point"],"content":"mssql 是一个关系型数据库, 类似与 mysql, oracle. 要点: 收费 微软家的, 大厂支持 性能强 ","date":"2023-07-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/mssql/:0:0","series":null,"tags":["point","mssql"],"title":"mssql","uri":"/posts/%E7%AC%94%E8%AE%B0/point/mssql/#"},{"categories":["blog"],"content":"这里记录 [[笔记/point/mssql|mssql]] 的常用命令和配置.","date":"2023-07-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/","series":null,"tags":["blog","mssql","docker"],"title":"mssql的配置和使用","uri":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["blog"],"content":" 简介这里记录 mssql 的常用命令和配置. ","date":"2023-07-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/:1:0","series":null,"tags":["blog","mssql","docker"],"title":"mssql的配置和使用","uri":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/#简介"},{"categories":["blog"],"content":" 操作手册","date":"2023-07-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/:2:0","series":null,"tags":["blog","mssql","docker"],"title":"mssql的配置和使用","uri":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/#操作手册"},{"categories":["blog"],"content":" docker 启动 # ACCEPT_EULA=Y 接收用户协议 # SA_PASSWORD 密码 # MSSQL_PID 指定版本,默认 -e 'MSSQL_PID=Developer' # 版本参考 https://learn.microsoft.com/zh-cn/sql/sql-server/editions-and-components-of-sql-server-2019?view=sql-server-ver16 docker run -e 'ACCEPT_EULA=Y' -e 'MSSQL_SA_PASSWORD=123456' -p 1433:1433 -v /data/msdata:/var/opt/mssql/data -v /data/mslog:/var/opt/mssql/log -v /data/secrets:/var/opt/mssql/secrets -d --name mssql mcr.microsoft.com/mssql/server:latest ","date":"2023-07-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/:2:1","series":null,"tags":["blog","mssql","docker"],"title":"mssql的配置和使用","uri":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/#docker-启动"},{"categories":["blog"],"content":" sql 语法 # 日期转字符串 CONVERT(CHAR(8), CURRENT_TIMESTAMP, 112) ---20060222 CONVERT(CHAR(19), CURRENT_TIMESTAMP, 120) ---2006-02-22 16:26:08 CONVERT(CHAR(10), CURRENT_TIMESTAMP, 23) ---2006-02-22 # 字符串转日期 cast('2013-03-01' as datetime) cast('20130301' as datetime) ","date":"2023-07-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/:2:2","series":null,"tags":["blog","mssql","docker"],"title":"mssql的配置和使用","uri":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/#sql-语法"},{"categories":["point"],"content":"mysql 是一个关系型数据库, 类似与 mssql, oracle. 要点: 免费使用 用户量非常多 ","date":"2023-07-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/mysql/:0:0","series":null,"tags":["point","mysql"],"title":"mysql","uri":"/posts/%E7%AC%94%E8%AE%B0/point/mysql/#"},{"categories":["point"],"content":"java 是一种非常流行的编程语言, 基于 JVM 虚拟机. 要点: 开源, 社区庞大 性能不错 吃资源 ","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/java/:0:0","series":null,"tags":["point","java"],"title":"java","uri":"/posts/%E7%AC%94%E8%AE%B0/point/java/#"},{"categories":["blog"],"content":"我不怎么写 [[笔记/point/java|java]] 代码, 但是国内一般都是 java 后台, 所以记录一些配置和操作, 方便复用.","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/","series":null,"tags":["blog","java"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/"},{"categories":["blog"],"content":" 简介我不怎么写 java 代码, 但是国内一般都是 java 后台, 所以记录一些配置和操作, 方便复用. ","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:1:0","series":null,"tags":["blog","java"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#简介"},{"categories":["blog"],"content":" JVM 启动参数","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:2:0","series":null,"tags":["blog","java"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#jvm-启动参数"},{"categories":["blog"],"content":" JVM 内存配置可以理解成 java运行内存 = 堆内存 + 元空间 + 非堆内存. 堆内存：通过参数设置 元空间：通过参数设置 非堆内存：线程数 *1m + non-heap 线程数：pstree pid 常用内存参数 -Xms2048m 初始堆大小 -Xmx2048m 最大堆大小 (建议一致，避免伸缩带来的性能影响) -Xmn500m 新生代，可以不设置 -Xss1024k 线程的栈大小，默认 1m。线程数 * 这个值是内存一部分 -XX:MaxMetaspaceSize=256m 最大元数据空间大小 -XX:+UseContainerSupport 使用容器内存,JDK 8u191+、JDK 10 及以上版本 -XX:InitialRAMPercentage=70.0 初始内存百分比 -XX:MaxRAMPercentage=70.0 最大内存百分比 ","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:2:1","series":null,"tags":["blog","java"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#jvm-内存配置"},{"categories":["blog"],"content":" JVM 其他配置 gc配置 不同的 jvm 版本用不同的 gc 回收. 例如 java8 用 ParallelGC 或者 CMS java8的gc优化, java 11 用 g1, java 17 用 zgc.所以参数也都不一样. 除非根据监控确定了问题, 明确了解决方案, 否则用默认的吧. -XX:-OmitStackTraceInFastThrow 一些 jvm 会优化异常抛出, 但缺少 message 和 stack trace, 所以关闭. -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=6666 远程 debug 连接到 6666 端口. 启用 suspend 是说是否阻塞直到被连接. 除非是 debug 应用启动过程的代码, 否则配置成 n. ","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:2:2","series":null,"tags":["blog","java"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#jvm-其他配置"},{"categories":["blog"],"content":" 推荐使用 -XX:+UseContainerSupport -XX:InitialRAMPercentage=70.0 -XX:MaxRAMPercentage=70.0 -XX:-OmitStackTraceInFastThrow -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=6666 ","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:2:3","series":null,"tags":["blog","java"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#推荐使用"},{"categories":["blog"],"content":" 命令","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:3:0","series":null,"tags":["blog","java"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#命令"},{"categories":["blog"],"content":" Maven 构建 # clean install 清理以前的文件,解决很多问题 # -T 4 4个线程构建 # -T 1C 每个cpu核心1个线程 # 跳过了测试和,不生成javadoc文件 mvn -T 1C clean install -Dmaven.test.skip -Dmaven.javadoc.skip=true ","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:3:1","series":null,"tags":["blog","java"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#maven-构建"},{"categories":["blog"],"content":" 内存 dump jmap -dump:format=b,file=/tmp/20210107mem.hprof 30699pid ","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:3:2","series":null,"tags":["blog","java"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#内存-dump"},{"categories":["blog"],"content":" 反编译 jar 包下载 jar 包 Releases · java-decompiler/jd-gui,然后 java -jar jd-gui.1.6.6.jar ","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:3:3","series":null,"tags":["blog","java"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#反编译-jar-包"},{"categories":["blog"],"content":" 代码配置 如何为SpringBoot应用设置健康检查_Serverless 应用引擎-阿里云帮助中心 ","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:4:0","series":null,"tags":["blog","java"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#代码配置"},{"categories":["blog"],"content":"这里记录一下 supervisor 在 [[笔记/point/linux|linux]] 下的常用配置, 方便复用.","date":"2023-07-03","objectID":"/posts/%E7%AC%94%E8%AE%B0/supervisor%E9%85%8D%E7%BD%AE/","series":null,"tags":["blog","supervisor","监控","devops"],"title":"supervisor配置","uri":"/posts/%E7%AC%94%E8%AE%B0/supervisor%E9%85%8D%E7%BD%AE/"},{"categories":["blog"],"content":" 简介这里记录一下 supervisor 的常用配置, 方便复用. ","date":"2023-07-03","objectID":"/posts/%E7%AC%94%E8%AE%B0/supervisor%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","supervisor","监控","devops"],"title":"supervisor配置","uri":"/posts/%E7%AC%94%E8%AE%B0/supervisor%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 操作手册安装和基础配置 # 安装 apt install supervisor -y # 加入2个参数,minfds最大文件数,minprocs最大进程数 vim /etc/supervisor/conf.d/supervisord.conf [supervisord] minfds=81920 minprocs=81920 systemctl enable supervisor systemctl start supervisor 编辑配置文件 vim /etc/supervisor/conf.d/demo.conf [program:demo] environment=VAR1=\"value1\",VAR2=\"value2\" directory = /root/app_dir command = /xxx/java -jar app.jar # 启动进程数目默认为1 numprocs = 1 # 如果supervisord是root启动的 设置此用户可以管理该program user = root # 程序运行的优先级 默认999 priority = 996 # 随着supervisord 自启动 autostart = true # 子进程挂掉后无条件自动重启 autorestart = true # 子进程启动多少秒之后 状态为running 表示运行成功 startsecs = 20 # 进程启动失败 最大尝试次数 超过将把状态置为FAIL startretries = 3 # 标准输出的文件路径 stdout_logfile = /tmp/demo-supervisor.log # 日志文件最大大小 stdout_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stdout_logfile_backups = 3 # 错误输出的文件路径 stderr_logfile = /tmp/demo-supervisor.log # 日志文件最大大小 stderr_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stderr_logfile_backups = 3 ","date":"2023-07-03","objectID":"/posts/%E7%AC%94%E8%AE%B0/supervisor%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","supervisor","监控","devops"],"title":"supervisor配置","uri":"/posts/%E7%AC%94%E8%AE%B0/supervisor%E9%85%8D%E7%BD%AE/#操作手册"},{"categories":["journal"],"content":"2023-07-01 日记","date":"2023-07-01","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-01/","series":null,"tags":["journal"],"title":"2023-07-01","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-01/"},{"categories":["journal"],"content":" Linux 初始化笔记? 引入 linux 相关文章 #todo/笔记 容器后 websocket 长连接中断问题.原因：部分原因 localhost，前端和后端之间的连接采用的是长连接。而在容器销毁和扩容的过程中就会断开连接，造成无法保持长连接的问题。解决: 后端每次容器销毁前，让 Header 部分返回 Connection:close,通知客户端处理完当前的请求后关闭连接，新的请求需要重新建立 TCP 连接。腾讯云容器团队的参考链接 #todo/笔记 ansible #todo/笔记 不要憎恨你的敌人, 这会影响你的判断力. #有意思的句子 ","date":"2023-07-01","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-01/:0:0","series":null,"tags":["journal"],"title":"2023-07-01","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-01/#"},{"categories":["point"],"content":"ansible 是一个远程管理工具. 要点: 开源, 用户量大 基于 ssh, 所以不需要在被控端安装 agent. ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/ansible/:0:0","series":null,"tags":["point","ansible"],"title":"ansible","uri":"/posts/%E7%AC%94%E8%AE%B0/point/ansible/#"},{"categories":["blog"],"content":"[[笔记/point/ansible|ansible]] 的使用记录, 用到的时候能快速重新捡起来..","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/","series":null,"tags":["blog","ansible"],"title":"ansible入门教程","uri":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介ansible 的使用记录, 用到的时候能快速重新捡起来.. ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","ansible"],"title":"ansible入门教程","uri":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 安装配置 安装 apt install ansible sshpass -y 配置主机 vim /etc/ansible/hosts # test组有一台机器,并配置了ssh连接信息 [test] sh-ecs01 ansible_ssh_host=test.kentxxq.com ansible_ssh_user=\"root\" ansible_ssh_pass=\"123456\" ansible_ssh_port=22 vim /etc/ansible/ansible.cfg [defaults] host_key_checking = False #不检测host key ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","ansible"],"title":"ansible入门教程","uri":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/#安装配置"},{"categories":["blog"],"content":" 日常操作简单执行命令 ansible test -m shell -a \"ls\" 使用 ansible-playbook playbook.yml 执行脚本, 下面是脚本文件 --- - name: Install remote facts hosts: test vars: test_dir: /tmp/test_dir test_file: /tmp/test.txt # 禁用收集信息，可以加快脚本执行 # gather_facts: false tasks: - name: 先ping一下 ping: - name: echo输出 command: echo 1 - name: 准备工作-创建测试目录 \"{{ test_dir }}\" file: path: \"{{ test_dir }}\" state: directory owner: \"root\" group: \"root\" mode: 0755 # 输出ansible默认采集到的信息 #- name: debug输出ansible默认收集的变量 # debug: # var: ansible_facts - name: 计算剩余内存百分比 debug: msg: \"{{ ansible_facts.memory_mb.nocache.free / ansible_facts.memtotal_mb * 100 }}\" register: memory_usage_percent - name: 拿到register变量 debug: msg: \"{{ memory_usage_percent.msg }}\" - name: 再register一个远程输出 shell: hostname register: hostname_info - name: 拿到hostname_info变量 debug: msg: \"{{ hostname_info.stdout }}\" - name: 创建本地文件 copy: content: \"123\" dest: \"{{ test_file }}\" delegate_to: localhost - name: 传送文件 copy: src: \"{{ test_file }}\" dest: \"{{ test_file }}\" - name: 本地执行命令 local_action: command tar -zcvf /tmp/tmp.tgz /tmp/test.txt # 压缩和解压 - name: \"拷贝代码去到对应目录\" unarchive: src: \"/tmp/tmp.tgz\" dest: \"{{ test_dir }}\" owner: \"root\" group: \"root\" extra_opts: - --strip-components= 1 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["blog","ansible"],"title":"ansible入门教程","uri":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/#日常操作"},{"categories":["blog"],"content":" Role 方案","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["blog","ansible"],"title":"ansible入门教程","uri":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/#role-方案"},{"categories":["blog"],"content":" 目录结构 root@poc:~/ansible-role# tree . ├── \\ ├── deploy_java_role.yml # 入口文件 ├── inventory │ └── test-hosts # 主机文件 └── roles └── deploy_java_role ├── tasks │ ├── depoly-task.yml # 部署任务 │ ├── init-app-task.yml # 初始化app环境 │ ├── init-system-task.yml # 初始化系统环境 │ ├── main.yml # 主入口 │ └── vars-task.yml # 获取环境变量 ├── templates │ └── supervisor_conf_template.j2 # 模板文件 └── vars └── main.yml # 静态环境变量 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["blog","ansible"],"title":"ansible入门教程","uri":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/#目录结构"},{"categories":["blog"],"content":" 调用方法 # 部署到了 deploy-task 阶段会报错,因为并没有 java 包,也没有 jenkins. 但是思路是一致的. 从本地 copy 构建物到目标机器. # 指定role文件,-i指定hosts文件,然后外部传入参数 ansible-playbook deploy_java_role.yml \\ -i inventory/test-hosts \\ --extra-vars \"ip_list=demo_test1\" \\ --extra-vars \"java_params='-Xms256m -Xmx256m'\" \\ --extra-vars \"module_name=name\" \\ --extra-vars \"init=1\" ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["blog","ansible"],"title":"ansible入门教程","uri":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/#调用方法"},{"categories":["blog"],"content":" 文件内容 # role入口文件 # deploy_java_role.yml --- - hosts: \"{{ ip_list }}\" remote_user: root roles: - role: deploy_java_role serial: 1 max_fail_percentage: 0 # 主机文件 # inventory/test-hosts [demo_test1] sh-ecs01 ansible_ssh_host=1.1.1.1 ansible_ssh_user=\"root\" ansible_ssh_pass=\"123456\" ansible_ssh_port=22 # 主入口 # roles/deploy_java_role/tasks/main.yml --- - name: 构建环境变量 import_tasks: vars-task.yml - name: 初始化环境 import_tasks: init-system-task.yml when: init == \"1\" - name: 应用所需环境 import_tasks: init-app-task.yml when: init == \"1\" - name: 部署脚本 import_tasks: depoly-task.yml # 获取环境变量 # roles/deploy_java_role/tasks/vars-task.yml - name: 获取workspace变量 debug: msg: \"{{ lookup('env', 'WORKSPACE')}}\" register: JenkinsWorkspace #failed_when: JenkinsWorkspace.msg == '' # 初始化系统环境 # roles/deploy_java_role/tasks/init-system-task.yml - name: 安装Supervisor启动管理程序 package: name: supervisor state: present - name: 开机自启supervisor service: name: supervisor enabled: yes - name: 创建程序运行目录 \"{{ program_dir }}\" file: path: \"{{program_dir}}\" state: directory owner: \"{{ appuser }}\" group: \"{{ appuser }}\" mode: 0755 - name: 创建程序备份目录 \"{{ program_dir_backup }}\" file: path: \"{{ program_dir_backup }}\" state: directory owner: \"{{ appuser }}\" group: \"{{ appuser }}\" mode: 0755 - name: 创建程序运行日志目录 \"{{ program_dir_logs }}\" file: path: \"{{ program_dir_logs }}\" state: directory owner: \"{{ appuser }}\" group: \"{{ appuser }}\" mode: 0755 - name: 创建程序运行临时目录 \"{{ program_dir_tmp }}\" file: path: \"{{ program_dir_tmp }}\" state: directory owner: \"{{ appuser }}\" group: \"{{ appuser }}\" mode: 0755 - name: 启动supervisor service: name: supervisor state: started # 初始化app环境 # roles/deploy_java_role/tasks/init-app-task.yml - name: 判断启动文件 \"{{ module_name }}\".ini是否存在 stat: path: /etc/supervisor/conf.d/{{ module_name }}.conf register: init_file - name: 如果启动文件不存在就拷贝一份启动模板文件 \"{{ module_name }}\".ini 到目标主机 template: src: supervisor_conf_template.j2 dest: /etc/supervisor/conf.d/{{ module_name }}.conf when: init_file.stat.exists == false - name: 更新supervisor shell: supervisorctl update when: init_file.stat.exists == false # 部署任务 # roles/deploy_java_role/tasks/depoly-task.yml - name: \"获取当前时间\" shell: date +%F_%H%M%S register: date_result - name: \"获取{{ module_name }}构建物的名称\" find: paths: - \"{{ JenkinsWorkspace.msg }}/deploy/target\" file_type: file use_regex: yes patterns: \".*{{ module_name }}((?!sources).)*.jar$\" recurse: no register: artcraft delegate_to: localhost - name: \"判断构建物是否存在，不存在则退出\" fail: msg: \"{{ module_name }}.jar is not find\" when: artcraft.matched == 0 - name: \"复制Jenkins构建物{{ module_name }}到对应服务器的指定目录\" copy: src: \"{{ item.path }}\" dest: \"{{ program_dir_tmp }}/{{ module_name }}.jar\" owner: \"{{ appuser }}\" group: \"{{ appuser }}\" mode: \"0644\" force: yes #backup: yes with_items: \"{{ artcraft.files }}\" - name: 注册.部署前.程序运行状况并注册状态 shell: ps -ef | grep {{ module_name }} | grep {{ appuser }} | awk '{print $2}' ignore_errors: True register: artcraft_status - name: 回显并注册当前进程PID信息 debug: var: artcraft_status.stdout_lines[0] verbosity: 0 when: artcraft_status.stdout_lines[1] is defined - name: 提示当前进程没有运行 debug: msg: \"当前用户服务进程没有运行...部署继续...\" when: artcraft_status.stdout_lines[1] is undefined - name: 停止{{ module_name }}对应的服务 command: supervisorctl stop {{ module_name }} when: artcraft_status.stdout_lines[1] is defined register: artcraft_stop_status - name: 回显当前程序状态是否停止成功 debug: var: artcraft_stop_status verbosity: 0 when: artcraft_status.stdout_lines[1] is defined - name: 注册.部署前.最新软件包的地址 shell: ls -lt {{ program_dir_tmp }} | grep {{ module_name }} | head -n 1 |awk '{print $9}' ignore_errors: True register: artcraft_file - name: 回显当前程序artcraft_file信息 debug: var: artcraft_file verbosity: 0 - name: 备份并复制{{ module_name }}的构建物到指定目录 copy: src: \"{{ program_dir_tmp }}/{{ artcraft_file.stdout }}\" dest: \"{{ program_dir }}/{{ appuser }}/{{ module_name }}.jar\" owner: \"{{ appuser }}\" group: \"{{ appuser }}\" mode: \"0644\" backup: yes remote_src: yes - name: 启动{{ module_name }}服务 command: supervisorctl start {{ module_name }} regis","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:4:3","series":null,"tags":["blog","ansible"],"title":"ansible入门教程","uri":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/#文件内容"},{"categories":["blog"],"content":"经常要去网上查, 对比一些 dns 的信息. 记录一下, 以后直接用就行了.","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/dns%E5%88%97%E8%A1%A8/","series":null,"tags":["blog","dns"],"title":"dns列表","uri":"/posts/%E7%AC%94%E8%AE%B0/dns%E5%88%97%E8%A1%A8/"},{"categories":["blog"],"content":" 简介经常要去网上查, 对比一些 dns 的信息. 记录一下, 以后直接用就行了. ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/dns%E5%88%97%E8%A1%A8/:1:0","series":null,"tags":["blog","dns"],"title":"dns列表","uri":"/posts/%E7%AC%94%E8%AE%B0/dns%E5%88%97%E8%A1%A8/#简介"},{"categories":["blog"],"content":" dns 的配置收集 ## 阿里云 https://www.alidns.com/ 223.5.5.5、223.6.6.6、2400:3200::1、2400:3200:baba::1 开手动模板 https://dns.alidns.com/dns-query DoH/DoT地址: dns.alidns.com ## 谷歌 https://developers.google.com/speed/public-dns/docs/doh 8.8.8.8 / 8.8.4.4 2001:4860:4860::8888 2001:4860:4860::8844 2001:4860:4860:0:0:0:0:8888 2001:4860:4860:0:0:0:0:8844 开自动模板 https://dns.google/dns-query ## 腾讯 https://www.dnspod.cn/Products/publicdns 很全 119.29.29.29 开手动模板 https://doh.pub/dns-query 支持dot，地址是dot.pub ## cloudflare 1.1.1.1 1.0.0.1 2606:4700:4700::1111 2606:4700:4700::1001 https://cloudflare-dns.com/dns-query ## 欧盟的dns 193.110.81.0 185.253.5.0 严格过滤 193.110.81.9 185.253.5.9 儿童版 193.110.81.1 185.253.5.1 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/dns%E5%88%97%E8%A1%A8/:2:0","series":null,"tags":["blog","dns"],"title":"dns列表","uri":"/posts/%E7%AC%94%E8%AE%B0/dns%E5%88%97%E8%A1%A8/#dns-的配置收集"},{"categories":["blog"],"content":"这里记录我调整过的 [[linux]] 内核参数.","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4/","series":null,"tags":["blog","linux"],"title":"linux内核参数调整","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4/"},{"categories":["blog"],"content":" 简介这里记录我调整过的 linux 内核参数. ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4/:1:0","series":null,"tags":["blog","linux"],"title":"linux内核参数调整","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4/#简介"},{"categories":["blog"],"content":" 内核参数调整内核参数的相关配置: /etc/sysctl.conf : 需要调整的配置文件 sysctl -p: 改了配置后立即生效 sysctl -a: 查看内核参数 复制使用 # 系统所有的进程能打开的最大文件数 (文件描述符) # fs.file-max = 9223372036854775807 # 单个进程可以打开的最大文件数 # fs.nr_open = 1048576 # 禁用内存交换 vm.swappiness = 0 # 无法操作的情况下, 进行重启/刷新磁盘 kernel.sysrq = 1 # 一定时间内没收到 arp 广播, 就删除 mac 和 ip 的匹配信息 net.ipv4.neigh.default.gc_stale_time = 120 # 阿里云负载均衡用到 https://help.aliyun.com/knowledge_detail/39428.html # 关闭源地址验证,防止ip欺骗 net.ipv4.conf.all.rp_filter = 0 net.ipv4.conf.eth0.rp_filter = 0 net.ipv4.conf.default.rp_filter = 0 # 发送arp请求的时候,使用目标ip作为源ip net.ipv4.conf.default.arp_announce = 2 net.ipv4.conf.lo.arp_announce = 2 net.ipv4.conf.all.arp_announce = 2 # see details in https://help.aliyun.com/knowledge_detail/41334.html # 服务端主动关闭连接后,会处于TIME_WAIT状态,设置可以保留5000等待.默认太大了,会占资源.太小影响复用. net.ipv4.tcp_max_tw_buckets = 5000 # 安全,导致恶意攻击者无法响应或误判 net.ipv4.tcp_syncookies = 1 # 3次握手等待最后一次响应的时候,这个等待队列的大小 net.ipv4.tcp_max_syn_backlog = 1024 # SYN_RECV状态时重传SYN+ACK包的次数 net.ipv4.tcp_synack_retries = 2 # TCP空闲一段时间后,会较小窗口发送数据,然后再放大窗口. 0代表立即最大窗口发送数据 net.ipv4.tcp_slow_start_after_idle = 0 # 复用TIME-WAIT状态的TCP连接 net.ipv4.tcp_tw_reuse = 1 # 关闭连接以后,内核60秒后释放相关资源 net.ipv4.tcp_fin_timeout = 60 # nat环境下多个机器同一个出口ip,可能会导致tcp连接被丢弃.这里表示响应所有的tcp请求. net.ipv4.tcp_timestamps = 0 # 3次握手时,会将信息保存到服务器队列里.每个端口的队列有60000个位置 net.core.somaxconn=60000 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4/:2:0","series":null,"tags":["blog","linux"],"title":"linux内核参数调整","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4/#内核参数调整"},{"categories":["blog"],"content":"用 iPhone 拍出来的照片，传到 [[macos|mac]] 上显示结尾是 HEIC 的图片文件。在 markdown 中不支持，同样在 [[hugo]] 的 web 页面里也不支持。所以找了一下方法，发现 automator 这个功能可以一劳永逸的实现。之前一直没有用过。所以记录一下","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/mac-heic%E8%BD%ACjpg%E6%88%96png/","series":null,"tags":["blog","macos"],"title":"mac-HEIC转JPG或PNG","uri":"/posts/%E7%AC%94%E8%AE%B0/mac-heic%E8%BD%ACjpg%E6%88%96png/"},{"categories":["blog"],"content":" 简介用 iPhone 拍出来的照片，传到 macos 上显示结尾是 HEIC 的图片文件。在 markdown 中不支持，同样在 hugo 的 web 页面里也不支持。所以找了一下方法，发现 automator 这个功能可以一劳永逸的实现。之前一直没有用过。所以记录一下 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/mac-heic%E8%BD%ACjpg%E6%88%96png/:1:0","series":null,"tags":["blog","macos"],"title":"mac-HEIC转JPG或PNG","uri":"/posts/%E7%AC%94%E8%AE%B0/mac-heic%E8%BD%ACjpg%E6%88%96png/#简介"},{"categories":["blog"],"content":" 操作手册 Command+Space(空格)，输入 automator,进入后点击新建文稿。 选择快速操作 把左边的步骤拖动到右边，调整后的页面如下 左上角文件 -\u003e存储 -\u003e保存名字 HEIC 转 JPEG 即可 在访达中使用即可 快去看看你的桌面上出现了什么！ ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/mac-heic%E8%BD%ACjpg%E6%88%96png/:2:0","series":null,"tags":["blog","macos"],"title":"mac-HEIC转JPG或PNG","uri":"/posts/%E7%AC%94%E8%AE%B0/mac-heic%E8%BD%ACjpg%E6%88%96png/#操作手册"},{"categories":["point"],"content":"macos 是苹果公司的电脑搭载的操作系统. 因为是苹果 mac 的专属系统, 日常 mac 也代表了 macos. 要点: 苹果专属系统 可以开发 ios 应用 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/macos/:0:0","series":null,"tags":["point","macos"],"title":"macos","uri":"/posts/%E7%AC%94%E8%AE%B0/point/macos/#"},{"categories":["blog"],"content":"这里记录在使用 [[笔记/point/macos|macos]] 过程中遇到的问题.","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"},{"categories":["blog"],"content":" 简介这里记录在使用 macos 过程中遇到的问题. ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:1:0","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#简介"},{"categories":["blog"],"content":" 问题列表","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:2:0","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#问题列表"},{"categories":["blog"],"content":" 显示隐藏文件 # 显示 defaults write com.apple.finder AppleShowAllFiles -bool true # 隐藏 defaults write com.apple.finder AppleShowAllFiles -bool false ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:2:1","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#显示隐藏文件"},{"categories":["blog"],"content":" 启用 ftp mac 下一般用 smb 服务来进行远程文件访问，但要用 FTP 的话，高版本的 mac os 默认关掉了，可以用如下命令打开: # 开启 sudo -s launchctl load -w /System/Library/LaunchDaemons/ftp.plist # 关闭 sudo -s launchctl unload -w /System/Library/LaunchDaemons/ftp.plist ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:2:2","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#启用-ftp"},{"categories":["blog"],"content":" Chrome 无法自动更新 # 这里是删除用户文件夹下面的google还有根目录下面的文件google文件夹，应该是会重新下载新的部分模块。同时也可以正常启用为所有用户更新chrome sudo rm -rf /Library/Google \u0026\u0026 sudo rm -rf ~/Library/Google ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:2:3","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#chrome-无法自动更新"},{"categories":["blog"],"content":" 修改主机名 sudo -scutil --set HostName 'kentxxq’s MacBook Pro' ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:2:4","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#修改主机名"},{"categories":["blog"],"content":" 启用 root # 启用root用户并且创建密码 sudo -i ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:2:5","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#启用-root"},{"categories":["blog"],"content":" 调试安卓或者 iphone 上的网页 开发的时候，电脑上 chrome 没问题，但是手机上访问有问题，那么就需要在手机上调试。 iphone 上调试 safari 开启 safari 上的 web 检查器 连接 mac，然后打开开发者选项 mac 上选中自己 iphone 即可开始调试 android 上调试 chrome brew cask install android-file-transfer 可以帮助你检测到手机 打开手机上的开发者选项，开启 usb 调试 chrome://inspect/#devices 就可以查看到设备，然后点开 手机上访问页面，就可以通过 devtools 调试了 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:2:6","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#调试安卓或者-iphone-上的网页"},{"categories":["blog"],"content":" 调试安卓或者 iphone 上的网页 开发的时候，电脑上 chrome 没问题，但是手机上访问有问题，那么就需要在手机上调试。 iphone 上调试 safari 开启 safari 上的 web 检查器 连接 mac，然后打开开发者选项 mac 上选中自己 iphone 即可开始调试 android 上调试 chrome brew cask install android-file-transfer 可以帮助你检测到手机 打开手机上的开发者选项，开启 usb 调试 chrome://inspect/#devices 就可以查看到设备，然后点开 手机上访问页面，就可以通过 devtools 调试了 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:2:6","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#iphone-上调试-safari"},{"categories":["blog"],"content":" 调试安卓或者 iphone 上的网页 开发的时候，电脑上 chrome 没问题，但是手机上访问有问题，那么就需要在手机上调试。 iphone 上调试 safari 开启 safari 上的 web 检查器 连接 mac，然后打开开发者选项 mac 上选中自己 iphone 即可开始调试 android 上调试 chrome brew cask install android-file-transfer 可以帮助你检测到手机 打开手机上的开发者选项，开启 usb 调试 chrome://inspect/#devices 就可以查看到设备，然后点开 手机上访问页面，就可以通过 devtools 调试了 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:2:6","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#android-上调试-chrome"},{"categories":["point"],"content":"python 是一门非常流行的编程语言. 要点: 生态强大, 特别在 ai 方便 解释执行, 强类型 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/python/:0:0","series":null,"tags":["point","python"],"title":"python","uri":"/posts/%E7%AC%94%E8%AE%B0/point/python/#"},{"categories":["blog"],"content":"推荐使用正版, 但用来学技术也是不错的.","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/","series":null,"tags":["blog","windows"],"title":"windows系统激活","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/"},{"categories":["blog"],"content":" 简介推荐使用正版, 但用来学技术也是不错的. windows 的系统激活方式有以下几种: MSDN 密钥。属于内部的使用，封不封看微软态度。 Retail 零售版密钥。就是你找微软买的，缺点就是要钱呗。 OEM 密钥。电脑厂家出厂预装的系统，然后绑定了你的硬件信息，无法跨机器使用。 VOL 密钥。一般是企业或者学校购买了批量授权。应该分 mak 和 kms 两种，前者永久，后者 180 天需激活一次。 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/:1:0","series":null,"tags":["blog","windows"],"title":"windows系统激活","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/#简介"},{"categories":["blog"],"content":" 操作步骤 如果是新安装的系统，没有 cd-key 输入过，可以直接跳过前面 2 步 #执行,弹出(已成功卸载了产品密钥) slmgr.vbs /upk #执行,弹出(成功的安装了产品密钥) slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX #执行,弹出(密钥管理服务计算机名成功的设置(kms.luody.info) slmgr /skms kms.luody.info #执行,弹出(成功的激活了产品) slmgr /ato ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/:2:0","series":null,"tags":["blog","windows"],"title":"windows系统激活","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/#操作步骤"},{"categories":["blog"],"content":" 自己搭建 docker run -d -p 1688:1688 --name kms --restart=always teddysun/kms # 验证 # 查看服务的版本信息 vlmcs.exe -v kms.luody.info # 查看支持的服务类型 vlmcs.exe -x kms.luody.info 附件/vlmcs.exe Dockerfile 在这里: across/docker/kms/Dockerfile at master · teddysun/across · GitHub 实现在这里: GitHub - Wind4/vlmcsd: KMS Emulator in C (currently runs on Linux including Android, FreeBSD, Solaris, Minix, Mac OS, iOS, Windows with or without Cygwin) ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/:3:0","series":null,"tags":["blog","windows"],"title":"windows系统激活","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/#自己搭建"},{"categories":["blog"],"content":" 可能遇到的问题","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/:4:0","series":null,"tags":["blog","windows"],"title":"windows系统激活","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/#可能遇到的问题"},{"categories":["blog"],"content":" 弹出内部版本 xx 过期我用的是 win10 预览版，一直没有激活。激活了以后，一直弹出内部版本过期。 进入系统更新，升级到最新的版本，之后重启解决 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/:4:1","series":null,"tags":["blog","windows"],"title":"windows系统激活","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/#弹出内部版本-xx-过期"},{"categories":["point"],"content":"CommonMark 是一种 markdown 的语法规范.因为有很多人的认同, 事实上已经是 markdown 的标准化组织. CommonMark 要点: 各大编程语言都有支持 各种公司的 markdown 拓展都以此为基础 ","date":"2023-06-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/commonmark/:0:0","series":null,"tags":["point","CommonMark"],"title":"CommonMark","uri":"/posts/%E7%AC%94%E8%AE%B0/point/commonmark/#"},{"categories":["point"],"content":"linux 是一个开源的系统. 有很多的发行版, 例如 centos, ubuntu. 要点: 免费 服务器默认系统 社区庞大 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/linux/:0:0","series":null,"tags":["point","linux"],"title":"linux","uri":"/posts/%E7%AC%94%E8%AE%B0/point/linux/#"},{"categories":["blog"],"content":"这里记录 [[笔记/point/linux|linux]] 的命令与配置, 通常都是某种情况下的处理方法.","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/"},{"categories":["blog"],"content":" 简介这里记录 linux 的命令与配置, 通常都是某种情况下的处理方法. ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 常用配置","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#常用配置"},{"categories":["blog"],"content":" 免密 sudo vim /etc/sudoers # 找到下面这部分内容 # Allow members of group sudo to execute any command %sudo ALL=(ALL:ALL) ALL kentxxq ALL=(ALL) NOPASSWD: ALL # 加入此行 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#免密-sudo"},{"categories":["blog"],"content":" 安装 chrome wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb apt install ./google-chrome-stable_current_amd64.deb google-chrome -v ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:2","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#安装-chrome"},{"categories":["blog"],"content":" alias 补全 # 通常已经安装了 # apt install bash-completion -y # 下载文件 curl https://raw.githubusercontent.com/cykerway/complete-alias/master/complete_alias -o ~/.complete_alias # 编辑配置文件 vim /root/.bash_completion . /root/.complete_alias # 设置alias vim ~/.bashrc alias sc='systemctl' # 尾部添加 vim /root/.complete_alias complete -F _complete_alias sc # 如果.bashrc文件没有启用.必须退出,重新登录后生效! # 默认是注释的 # enable programmable completion features (you don't need to enable # this, if it's already enabled in /etc/bash.bashrc and /etc/profile # sources /etc/bash.bashrc). #if [ -f /etc/bash_completion ] \u0026\u0026 ! shopt -oq posix; then # . /etc/bash_completion #fi 常用配置 # 查看日志 alias tailf='tail -f' # 查看出口ip alias myip = 'curl -L test.kentxxq.com/ip' # 全部代理配置 alias vpn='export all_proxy=http://1.1.1.1:7890;' # 清空 alias novpn='unset all_proxy;' # 当前会话代理 alias vpn='export http_proxy=http://1.1.1.1:7890; export https_proxy=http://1.1.1.1:7890;' # 带密码代理 alias vpn='export http_proxy=http://user1:pass1@1.1.1.1:7890; export https_proxy=http://user1:pass1@1.1.1.1:7890;' # 清空 alias novpn='unset http_proxy; unset https_proxy;' ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:3","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#alias"},{"categories":["blog"],"content":" alias 补全 # 通常已经安装了 # apt install bash-completion -y # 下载文件 curl https://raw.githubusercontent.com/cykerway/complete-alias/master/complete_alias -o ~/.complete_alias # 编辑配置文件 vim /root/.bash_completion . /root/.complete_alias # 设置alias vim ~/.bashrc alias sc='systemctl' # 尾部添加 vim /root/.complete_alias complete -F _complete_alias sc # 如果.bashrc文件没有启用.必须退出,重新登录后生效! # 默认是注释的 # enable programmable completion features (you don't need to enable # this, if it's already enabled in /etc/bash.bashrc and /etc/profile # sources /etc/bash.bashrc). #if [ -f /etc/bash_completion ] \u0026\u0026 ! shopt -oq posix; then # . /etc/bash_completion #fi 常用配置 # 查看日志 alias tailf='tail -f' # 查看出口ip alias myip = 'curl -L test.kentxxq.com/ip' # 全部代理配置 alias vpn='export all_proxy=http://1.1.1.1:7890;' # 清空 alias novpn='unset all_proxy;' # 当前会话代理 alias vpn='export http_proxy=http://1.1.1.1:7890; export https_proxy=http://1.1.1.1:7890;' # 带密码代理 alias vpn='export http_proxy=http://user1:pass1@1.1.1.1:7890; export https_proxy=http://user1:pass1@1.1.1.1:7890;' # 清空 alias novpn='unset http_proxy; unset https_proxy;' ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:3","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#补全"},{"categories":["blog"],"content":" alias 补全 # 通常已经安装了 # apt install bash-completion -y # 下载文件 curl https://raw.githubusercontent.com/cykerway/complete-alias/master/complete_alias -o ~/.complete_alias # 编辑配置文件 vim /root/.bash_completion . /root/.complete_alias # 设置alias vim ~/.bashrc alias sc='systemctl' # 尾部添加 vim /root/.complete_alias complete -F _complete_alias sc # 如果.bashrc文件没有启用.必须退出,重新登录后生效! # 默认是注释的 # enable programmable completion features (you don't need to enable # this, if it's already enabled in /etc/bash.bashrc and /etc/profile # sources /etc/bash.bashrc). #if [ -f /etc/bash_completion ] \u0026\u0026 ! shopt -oq posix; then # . /etc/bash_completion #fi 常用配置 # 查看日志 alias tailf='tail -f' # 查看出口ip alias myip = 'curl -L test.kentxxq.com/ip' # 全部代理配置 alias vpn='export all_proxy=http://1.1.1.1:7890;' # 清空 alias novpn='unset all_proxy;' # 当前会话代理 alias vpn='export http_proxy=http://1.1.1.1:7890; export https_proxy=http://1.1.1.1:7890;' # 带密码代理 alias vpn='export http_proxy=http://user1:pass1@1.1.1.1:7890; export https_proxy=http://user1:pass1@1.1.1.1:7890;' # 清空 alias novpn='unset http_proxy; unset https_proxy;' ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:3","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#常用配置-1"},{"categories":["blog"],"content":" 免密 ssh # 生成公钥和秘钥 ssh-keygen -t rsa # 拷贝公钥到远程机器,需要输入密码 ssh-copy-id root@1.1.1.1 # 测试效果 ssh root@1.1.1.1 # 如果目标ip重装过,需要清理本地的拷贝记录 ssh-keygen -R 1.1.1.1 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:4","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#免密-ssh"},{"categories":["blog"],"content":" 允许 root 远程登录 vim /etc/ssh/sshd_config # 把参数值改成yes PermitRootLogin yes # 设置密码 passwd root # 重启ssh服务 systemctl restart ssh ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:5","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#允许-root-远程登录"},{"categories":["blog"],"content":" 安装字体一般来说合同都要使用宋体, simsun # 创建字体文件夹，放入字体文件 mkdir -p /usr/share/fonts/simsun cd /usr/share/fonts/simsun rz sumsun.ttc # 安装字体工具 apt install xfonts-utils fontconfig -y # 字体操作 mkfontscale mkfontdir # 刷新缓存 fc-cache –fv # 字体查询 fc-list :lang=zh ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:6","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#安装字体"},{"categories":["blog"],"content":" 配置 limit # 先确保/etc/security/limits.d没有覆盖的配置 vim /etc/security/limits.conf # hard硬限制 不会超过 # soft软限制 告警 # nofile 每个进程可以打开的文件数 root soft nofile 65535 root hard nofile 65535 * soft nofile 65535 * hard nofile 65535 # nproc 操作系统级别对每个用户创建的进程数 root soft nproc 65535 root hard nproc 65535 * soft nproc 65535 * hard nproc 65535 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:7","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#配置-limit"},{"categories":["blog"],"content":" 温度传感器 apt install lm-sensors # 观察模式 watch sensors # 如果不是ubuntu系统 cat /sys/class/thermal/thermal_zone0/temp # 摄氏度 echo $[$(cat /sys/class/thermal/thermal_zone0/temp)/1000]° ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:8","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#温度传感器"},{"categories":["blog"],"content":" 安装 snap-store sudo snap install snap-store ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:9","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#安装-snap-store"},{"categories":["blog"],"content":" wifi 工具 sudo apt install wireless-tools # 查看wifi设备信息 iwconfig ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:10","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#wifi-工具"},{"categories":["blog"],"content":" 关闭防火墙 ufw disable ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:11","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#关闭防火墙"},{"categories":["blog"],"content":" 安装桌面 # 安装一个小工具 sudo apt install tasksel # 看可以装哪些版本 tasksel --list-tasks # 安装桌面套件 sudo tasksel install ubuntu-desktop # 重启生效 reboot ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:12","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#安装桌面"},{"categories":["blog"],"content":" 关闭 selinux # 当前生效 setenforce 0 # 永久生效 vim /etc/selinux/config SELINUX=disabled ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:13","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#关闭-selinux"},{"categories":["blog"],"content":" 定时任务 crontab vim /etc/cron.d/myjob # Example of job definition: # .---------------- minute (0 - 59) # | .------------- hour (0 - 23) # | | .---------- day of month (1 - 31) # | | | .------- month (1 - 12) OR jan,feb,mar,apr ... # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat # | | | | | # * * * * * user-name command to be executed # 凌晨5点和6点清理docker镜像 0 5,6 * * * root /usr/bin/docker rmi $(docker images -q) -f # 每10分钟执行 */10 * * * * * /bin/bash /root/backup.sh ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:14","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#定时任务-crontab"},{"categories":["blog"],"content":" 时间同步 apt install ntp ntpdate -y # 同步时间 ntpdate ntp.aliyun.com 0 * * * * /usr/sbin/ntpdate ntp.aliyun.com # 写入系统 hwclock -w # 查看当前时间和配置 timedatectl # 查询可用的时区 timedatectl list-timezones | grep -i shang # 设置时区 timedatectl set-timezone Asia/Shanghai ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:15","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#时间同步"},{"categories":["blog"],"content":" 配置 locale 中文 # 查看当前shell环境locale locale # 查看系统locale localectl # 查看系统有的字符集 localectl list-locales # 如果有中文字体 localectl set-locale LANG=zh_CN.UTF-8 # 默认英文 localectl set-locale LANG=en_US.UTF-8 # 没有效果? vim /etc/locale.conf LANG=zh_CN.UTF-8 # 搜索所有语言包 apt search language-pack* # 搜索中文包 apt search language-pack-zh* # 建议选用 apt install language-pack-zh-hans -y ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:16","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#配置-locale-中文"},{"categories":["blog"],"content":" 开启 bbrbbr 是一种浪费网络资源，提升网络速度和稳定性的通讯手段。 echo \"net.core.default_qdisc=fq\" \u003e\u003e /etc/sysctl.conf echo \"net.ipv4.tcp_congestion_control=bbr\" \u003e\u003e /etc/sysctl.conf # 生效 sysctl -p # 验证 lsmod | grep bbr ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:17","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#开启-bbr"},{"categories":["blog"],"content":" 登录后的提示信息 vim /etc/motd Welcome to Alibaba Cloud Elastic Compute Service ! ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:18","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#登录后的提示信息"},{"categories":["blog"],"content":" 常见操作","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#常见操作"},{"categories":["blog"],"content":" curl # -X 指定请求方式 大写 # -H 设置请求头，可以多个-H # -d 指定payload的数据 curl -X POST -H \"Accept: application/json\" -H \"Content-type: application/json\" -d '{\"post_data\":\"i_love_immvp.com\"}' localhost:8096/api/answer/checkAnswer # 忽略证书 curl -k https://127.0.0.1:5001/ # 下载 -C 断点续传 -O 指定名称 curl -C - https://dl.min.io/server/minio/release/linux-amd64/archive/minio_20230711212934.0.0_amd64.deb -O minio.deb # 模拟跨域 curl -vvv 'https://kentxxq.com/Count' -H 'Origin: http://localhost:3000' # 请求es curl -H \"Content-Type: application/json\" -XPUT --user elastic:password es-cn-oew1whnk60023e4s9.elasticsearch.aliyuncs.com:9200/flow_user_index/_settings -d '{\"index.mapping.total_fields.limit\":0}' 结果 {\"acknowledged\":true} ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:1","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#curl"},{"categories":["blog"],"content":" 代理 apt # 临时 -o Acquire::http::proxy=\"https://user1:pass1@a.kentxxq.com:17890\" -o Acquire::https::proxy=\"https://user1:pass1@a.kentxxq.com:17890\" # 永久,文件不存在就创建 vim /etc/apt/apt.conf.d/95proxy.conf Acquire::http::proxy \"https://user1:pass1@a.kentxxq.com:17890\"; Acquire::https::proxy \"https://user1:pass1@a.kentxxq.com:17890\"; ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:2","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#代理-apt"},{"categories":["blog"],"content":" 清除历史记录 # 清除指定id history -d 123 # 清除所有历史记录 history -c ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:3","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#清除历史记录"},{"categories":["blog"],"content":" 压缩/解压 tar # z是使用gzip # v是查看细节 # f是指定文件 # --strip-components=1 去掉一层解压目录 # 打包 tar -czvf dist.tgz dist/ # 解压 tar -xzvf dist.tgz # 解压到指定文件夹 tar Cxzvf /dist dist.tgz # 打包隐藏文件 # 通过 . 可以打包到隐藏文件 tar -czvf dist.tgz /dad/path/. # 通过上级目录来打包 tar -czvf dist.tgz /data/path # 如果是在当前目录，可以手动指定 tar -czvf dist.tgz tar -zcvf dist.tgz .[!.]* * ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:4","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#压缩解压-tar"},{"categories":["blog"],"content":" 大版本升级 apt install update-manager-core -y do-release-upgrade -d ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:5","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#大版本升级"},{"categories":["blog"],"content":" 跑分 wget http://soft.vpser.net/test/unixbench/unixbench-5.1.2.tar.gz tar zxvf unixbench-5.1.2.tar.gz cd unixbench-5.1.2/ vim Makefile # GRAPHIC_TESTS = defined make ./Run ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:6","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#跑分"},{"categories":["blog"],"content":" 软链接 ln # ln -s 现有文件/目标文件 链接文件 # 创建/usr/local/nginx/sbin/nginx的快捷方式到/usr/local/bin/nginx # 软连接的目标文件可以被替换,替换后会链接到新文件 ln -s /usr/local/nginx/sbin/nginx /usr/local/bin/nginx ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:7","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#软链接-ln"},{"categories":["blog"],"content":" 配置主机名 hostnamectl set-hostname master1 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:8","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#配置主机名"},{"categories":["blog"],"content":" shell 退出码 # 正常退出 ls EXCODE=$? echo $EXCODE # 0 # 异常错误 ls --- EXCODE=$? echo $EXCODE # 2 # shell脚本 EXCODE=$? if [ \"$EXCODE\" != \"0\" ]; then echo \"有问题！\" exit 1; fi ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:9","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#shell-退出码"},{"categories":["blog"],"content":" 用户, 组, 加入组, 权限 # 创建组dba,组号6001 groupadd -g 6001 dba # 创建用户sam,同时指定主目录 useradd –d /home/sam -m sam # 设置密码 passwd sam #把sam加入dba组 usermod -a -G dba sam # 修改目录拥有者:组 chown -R sam:dba file/folder # 放开权限给所有用户 chmod 777 file/folder ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:10","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#用户-组-加入组-权限"},{"categories":["blog"],"content":" 安装/卸载软件 # 安装deb包 dpkg -i minio.deb # 查看已安装的包 dpkg --list # 查看正则匹配的包 # 查看以dotnet-开头的包 dpkg --list 'dotnet-*' # 卸载匹配的包 sudo apt-get --purge remove \u003cprogramname\u003e # 按照正则卸载匹配的包 # 卸载以dotnet-开头的包 sudo apt-get --purge remove 'dotnet-*' # 如果不想自己手动输入Y确认的话则使用 echo \"Y\" |sudo apt-get --purge remove 'dotnet-*' ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:11","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#安装卸载软件"},{"categories":["blog"],"content":" 查看文件 # less 只读超大文件 # 输入F可以滚动输出,刷新当前屏幕,不刷屏.也可以手动输入G,移到底部 # q输出 /搜索 less file.txt # head 文件尾部 head -n 10 file.txt # tail 文件尾部 # tail -f 滚动输出 # 配合 |grep 过滤 tail -f file.txt # 末尾10行 tail -n 10 file.txt ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:12","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#查看文件"},{"categories":["blog"],"content":" 删除 x 天前的文件 find /data/weblog/ -name '*.log.*' -type f -mtime +7 -exec rm -f {} \\; ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:13","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#删除-x-天前的文件"},{"categories":["blog"],"content":" 查看进程启动时间 ps -eo pid,lstart,etime | grep 1310 1310 Sat Aug 10 10:21:25 2019 242-07:26:58 # 前面是启动时间，后面是启动了242天又7小时 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:14","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#查看进程启动时间"},{"categories":["blog"],"content":" 拷贝文件 scp简单高效, 日常使用. # 本地到远程 scp /path/thing root@10.10.10.10:/path/thing # 远程到本地 # -r遍历 # -C压缩 sshpass -p 密码 -o StrictHostKeyChecking=no scp -Cr root@10.10.10.10:/path/folder /path/folder # 使用sshpass免密一条命令 # scp支持所有ssh的参数 # StrictHostKeyChecking 第一次连接会需要输入yes,禁用掉它. # UserKnownHostsFile 这次的配置丢弃掉,表示临时使用.避免安全问题. /usr/bin/sshpass -p 密码 /usr/bin/scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@1.1.1.1:/tmp/t1/1 /tmp/t1/1 rsync通常用于增量传输. # 把1这个文件/文件夹 拷贝到远程的/tmp/t1/下面 # at保持文件信息不变 # VP先是进度 # -z 可以开启压缩 rsync -atvP /tmp/t1/1 root@1.1.1.1:/tmp/t1/ # 也支持sshpass /usr/bin/sshpass -p 密码 rsync -atvP -e \"ssh -o StrictHostKeyChecking=no\" /tmp/t1/1 root@1.1.1.1:/tmp/t1/ ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:15","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#拷贝文件"},{"categories":["blog"],"content":" 拷贝文件 scp简单高效, 日常使用. # 本地到远程 scp /path/thing root@10.10.10.10:/path/thing # 远程到本地 # -r遍历 # -C压缩 sshpass -p 密码 -o StrictHostKeyChecking=no scp -Cr root@10.10.10.10:/path/folder /path/folder # 使用sshpass免密一条命令 # scp支持所有ssh的参数 # StrictHostKeyChecking 第一次连接会需要输入yes,禁用掉它. # UserKnownHostsFile 这次的配置丢弃掉,表示临时使用.避免安全问题. /usr/bin/sshpass -p 密码 /usr/bin/scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@1.1.1.1:/tmp/t1/1 /tmp/t1/1 rsync通常用于增量传输. # 把1这个文件/文件夹 拷贝到远程的/tmp/t1/下面 # at保持文件信息不变 # VP先是进度 # -z 可以开启压缩 rsync -atvP /tmp/t1/1 root@1.1.1.1:/tmp/t1/ # 也支持sshpass /usr/bin/sshpass -p 密码 rsync -atvP -e \"ssh -o StrictHostKeyChecking=no\" /tmp/t1/1 root@1.1.1.1:/tmp/t1/ ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:15","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#scp"},{"categories":["blog"],"content":" 拷贝文件 scp简单高效, 日常使用. # 本地到远程 scp /path/thing root@10.10.10.10:/path/thing # 远程到本地 # -r遍历 # -C压缩 sshpass -p 密码 -o StrictHostKeyChecking=no scp -Cr root@10.10.10.10:/path/folder /path/folder # 使用sshpass免密一条命令 # scp支持所有ssh的参数 # StrictHostKeyChecking 第一次连接会需要输入yes,禁用掉它. # UserKnownHostsFile 这次的配置丢弃掉,表示临时使用.避免安全问题. /usr/bin/sshpass -p 密码 /usr/bin/scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@1.1.1.1:/tmp/t1/1 /tmp/t1/1 rsync通常用于增量传输. # 把1这个文件/文件夹 拷贝到远程的/tmp/t1/下面 # at保持文件信息不变 # VP先是进度 # -z 可以开启压缩 rsync -atvP /tmp/t1/1 root@1.1.1.1:/tmp/t1/ # 也支持sshpass /usr/bin/sshpass -p 密码 rsync -atvP -e \"ssh -o StrictHostKeyChecking=no\" /tmp/t1/1 root@1.1.1.1:/tmp/t1/ ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:15","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#rsync"},{"categories":["blog"],"content":" 清空文件 # 快速清空 \u003efile.txt # 截断任意文件 truncate -s 0 file.txt # 寻找log文件并清空 vim /opt/truncate-log.sh #!/bin/bash files=`find / -name *.log` for file in `ls $files` do truncate -s 0 $file done # 凌晨3点定时执行 chmod +x /opt/truncate-log.sh vim /etc/crontab 0 3 * * * root /opt/truncate-log.sh ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:16","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#清空文件"},{"categories":["blog"],"content":" 筛选替换 # -r遍历 当前目录,筛选所有带有kentxxq的文件 # 替换old-a成new-b sed -i 's/old-a/new-b/g' `grep kentxxq -rl ./` ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:17","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#筛选替换"},{"categories":["blog"],"content":" 系统监控","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:0","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#系统监控"},{"categories":["blog"],"content":" 信息查询 # 系统信息 lsb_release -a LSB Version: :core-4.1-amd64:core-4.1-noarch Distributor ID: CentOS Description: CentOS Linux release 8.0.1905 (Core) Release: 8.0.1905 Codename: Core # cpu信息 cat /proc/cpuinfo # 内存信息,2个16g代表32gb内存,双通道 # 或 cat /proc/meminfo # 或 dmidecode -t memory dmidecode | grep -A16 \"Memory Device\" | grep \"Size\" |sed 's/^[ \\t]*//' # 磁盘信息 fdisk -l # 系统os错误代码查询 perror 24 OS error code 24: Too many open files # 服务器型号 dmidecode | grep 'Product Name' # 主板序列号 dmidecode | grep 'Serial Number' # 系统序列号 dmidecode -s system-serial-number # oem信息 dmidecode -t 11 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:1","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#信息查询"},{"categories":["blog"],"content":" 状态监控 整体概况 top htop 内存 # 查看内存使用状态 free -m # 查看内存变化 vmstat 间隔 监控次数 vmstat 2 2 硬盘 # 磁盘分区等情况 fdisk -l # 硬盘监控 iotop 网络 # 用来进行查看各个网卡的总流量 nload # 用来监控各个进程的流量使用情况 nethogs # 图形化的工具，可以查看具体的端口情况 iptraf-ng # 外部ip连接最多的20条记录 netstat -ant | awk '/^tcp/ {split($5, a, \":\"); count[a[1]]++} END {for (ip in count) print ip \"\\t\" count[ip]}' | sort -nrk2 | head -n 20 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:2","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#状态监控"},{"categories":["blog"],"content":" 状态监控 整体概况 top htop 内存 # 查看内存使用状态 free -m # 查看内存变化 vmstat 间隔 监控次数 vmstat 2 2 硬盘 # 磁盘分区等情况 fdisk -l # 硬盘监控 iotop 网络 # 用来进行查看各个网卡的总流量 nload # 用来监控各个进程的流量使用情况 nethogs # 图形化的工具，可以查看具体的端口情况 iptraf-ng # 外部ip连接最多的20条记录 netstat -ant | awk '/^tcp/ {split($5, a, \":\"); count[a[1]]++} END {for (ip in count) print ip \"\\t\" count[ip]}' | sort -nrk2 | head -n 20 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:2","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#整体概况"},{"categories":["blog"],"content":" 状态监控 整体概况 top htop 内存 # 查看内存使用状态 free -m # 查看内存变化 vmstat 间隔 监控次数 vmstat 2 2 硬盘 # 磁盘分区等情况 fdisk -l # 硬盘监控 iotop 网络 # 用来进行查看各个网卡的总流量 nload # 用来监控各个进程的流量使用情况 nethogs # 图形化的工具，可以查看具体的端口情况 iptraf-ng # 外部ip连接最多的20条记录 netstat -ant | awk '/^tcp/ {split($5, a, \":\"); count[a[1]]++} END {for (ip in count) print ip \"\\t\" count[ip]}' | sort -nrk2 | head -n 20 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:2","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#内存"},{"categories":["blog"],"content":" 状态监控 整体概况 top htop 内存 # 查看内存使用状态 free -m # 查看内存变化 vmstat 间隔 监控次数 vmstat 2 2 硬盘 # 磁盘分区等情况 fdisk -l # 硬盘监控 iotop 网络 # 用来进行查看各个网卡的总流量 nload # 用来监控各个进程的流量使用情况 nethogs # 图形化的工具，可以查看具体的端口情况 iptraf-ng # 外部ip连接最多的20条记录 netstat -ant | awk '/^tcp/ {split($5, a, \":\"); count[a[1]]++} END {for (ip in count) print ip \"\\t\" count[ip]}' | sort -nrk2 | head -n 20 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:2","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#硬盘"},{"categories":["blog"],"content":" 状态监控 整体概况 top htop 内存 # 查看内存使用状态 free -m # 查看内存变化 vmstat 间隔 监控次数 vmstat 2 2 硬盘 # 磁盘分区等情况 fdisk -l # 硬盘监控 iotop 网络 # 用来进行查看各个网卡的总流量 nload # 用来监控各个进程的流量使用情况 nethogs # 图形化的工具，可以查看具体的端口情况 iptraf-ng # 外部ip连接最多的20条记录 netstat -ant | awk '/^tcp/ {split($5, a, \":\"); count[a[1]]++} END {for (ip in count) print ip \"\\t\" count[ip]}' | sort -nrk2 | head -n 20 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:2","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#网络"},{"categories":["point"],"content":"vscode 是微软开源的一个文本编辑器, 强大到匹敌 IDE. 要点: 开源免费 插件丰富 社区庞大 跨平台 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/vscode/:0:0","series":null,"tags":["point","vscode"],"title":"vscode","uri":"/posts/%E7%AC%94%E8%AE%B0/point/vscode/#"},{"categories":["point"],"content":"windows 是微软公司开发的操作系统. 要点: 兼容性好 功能最全面 用户最多 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/windows/:0:0","series":null,"tags":["point","windows"],"title":"windows","uri":"/posts/%E7%AC%94%E8%AE%B0/point/windows/#"},{"categories":["blog"],"content":"[[笔记/point/windows|windows]] 现在是我主要使用的桌面平台. 因为我挑选并使用了大量的软件工具, 而且经常会跨多设备工作. 所以这里我记录下来, 也给大家做一个参考.","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/","series":null,"tags":["blog","windows"],"title":"windows的初始化配置","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/"},{"categories":["blog"],"content":" 简介windows 现在是我主要使用的桌面平台. 因为我挑选并使用了大量的软件工具, 而且经常会跨多设备工作. 所以这里我记录下来, 也给大家做一个参考. 与 linux的初始化配置 目的类似. ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","windows"],"title":"windows的初始化配置","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 配置内容 对象 选择 说明 参考 字体 Caskaydia Cove Nerd Font 首先 Cascadia Code 是一个等宽字体, 而 Nerd Font 为其加入了大量图标. GitHub - ryanoasis/nerd-fonts: Iconic font aggregator, collection, \u0026 patcher. 3,600+ icons, 50+ patched fonts: Hack, Source Code Pro, more. Glyph collections: Font Awesome, Material Design Icons, Octicons, \u0026 more ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","windows"],"title":"windows的初始化配置","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/#配置内容"},{"categories":["blog"],"content":" 相关内容 windows系统激活 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["blog","windows"],"title":"windows的初始化配置","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/#相关内容"},{"categories":["point"],"content":"wsl 是 windows 下面的 linux 子系统. 方便开发人员在 windows 上使用 linux. 要点: 打通了文件系统 网络互通 支持 linux 图形界面 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/wsl/:0:0","series":null,"tags":["point","wsl"],"title":"wsl","uri":"/posts/%E7%AC%94%E8%AE%B0/point/wsl/#"},{"categories":["point"],"content":"docker 是一个用 golang 编写的容器化工具. 要点: 用户量大, 生态好 常用于软件打包 ","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/docker/:0:0","series":null,"tags":["point","docker"],"title":"docker","uri":"/posts/%E7%AC%94%E8%AE%B0/point/docker/#"},{"categories":["blog"],"content":"这里记录 [[笔记/point/docker|docker]] 的所有操作","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/","series":null,"tags":["blog","docker"],"title":"docker教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介这里记录 docker 的所有操作 ","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","docker"],"title":"docker教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 配置参数/etc/docker/daemon.json { \"registry-mirrors\": [\"https://bwx6yb0u.mirror.aliyuncs.com\"], \"proxies\": { \"default\": { \"httpProxy\": \"http://proxy.example.com:3128\", \"httpsProxy\": \"https://proxy.example.com:3129\", \"noProxy\": \"NO_PROXY: localhost,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,*.test.example.com\" } } } ","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","docker"],"title":"docker教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/#配置参数"},{"categories":["blog"],"content":" 上传 docker 镜像起因是国内经常因为网络问题, 无法正常拉取镜像. 需要手动把常用的镜像备份过来 (即使配置了代理源, 因为会请求 dockerhub 的接口, 这里也会导致失败). 这里记录一下 docker 的镜像上传. 在网络通常的情况下先拉取镜像 docker pull maven:3.6.1-jdk-8 给镜像打 tag docker tag maven:3.6.1-jdk-8 你的镜像仓库地址/命名空间/maven:3.6.1-jdk-8 # 这里拿阿里云的镜像仓库举例 # 镜像仓库命名为msb-images,下面是镜像仓库地址 # msb-images-registry-vpc.cn-zhangjiakou.cr.aliyuncs.com 私网 # msb-images-registry.cn-zhangjiakou.cr.aliyuncs.com 公网 # public 为命名空间 docker tag maven:3.6.1-jdk-8 msb-images-registry-vpc.cn-zhangjiakou.cr.aliyuncs.com/public/maven:3.6.1-jdk-8 登录,推送镜像 # 登录 docker login --username=用户名 -p 密码 msb-images-registry.cn-zhangjiakou.cr.aliyuncs.com # 推送 docker push msb-images-registry-vpc.cn-zhangjiakou.cr.aliyuncs.com/public/maven:3.6.1-jdk-8 ","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["blog","docker"],"title":"docker教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/#上传-docker-镜像"},{"categories":["blog"],"content":" 文件拷贝","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["blog","docker"],"title":"docker教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/#文件拷贝"},{"categories":["blog"],"content":" 从镜像拷贝文件到本地 id = $(docker create 镜像名) docker cp $id:path - \u003e 本地文件名 docker rm -v $id powershell 版本: $id = docker create 镜像名 docker cp \"${id}:镜像内源文件路径\" - | Set-Content 目标文件名 docker rm -v $id ","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["blog","docker"],"title":"docker教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/#从镜像拷贝文件到本地"},{"categories":["blog"],"content":" 操作 docker-compose虽然在生产环境 docker-compose 很少用到, 但是在开发, 测试, poc 的时候经常会用到. docker-compose 现在集成到了 docker 里, 所以 docker-compose 和 docker compose 等效 # 只拉取镜像 docker-compose pull # -d表示后台启动 --build表示构建镜像 docker-compose up -d --build # 停止 docker-compose down ","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["blog","docker"],"title":"docker教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/#操作-docker-compose"},{"categories":["point"],"content":"golang 是一个编程语言. 要点如下: 跨平台编译/部署 性能好,内存占用小 静态语言 ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/golang/:0:0","series":null,"tags":["point","golang"],"title":"golang","uri":"/posts/%E7%AC%94%E8%AE%B0/point/golang/#"},{"categories":["blog"],"content":"[[笔记/point/golang|golang]] 用的很少, 记录一下相关的安装, 配置, 构建.","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/","series":null,"tags":["blog","golang"],"title":"golang的使用","uri":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["blog"],"content":" 简介golang 用的很少, 记录一下相关的安装, 配置, 构建. ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/:1:0","series":null,"tags":["blog","golang"],"title":"golang的使用","uri":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/#简介"},{"categories":["blog"],"content":" 操作手册","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/:2:0","series":null,"tags":["blog","golang"],"title":"golang的使用","uri":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/#操作手册"},{"categories":["blog"],"content":" 安装 golang # 去这里下载最新的jar包 # https://go.dev/dl/ # 拿 go1.20.6.linux-amd64.tar.gz 举例 # 解压到/usr/local/ tar -C /usr/local/ -xzf go1.20.6.linux-amd64.tar.gz # 文件内容 root@poc:/usr/local/go# ls -l /usr/local/go total 68 drwxr-xr-x 2 root root 4096 Jun 2 01:02 api drwxr-xr-x 2 root root 4096 Jun 2 01:04 bin -rw-r--r-- 1 root root 52 Jun 2 01:01 codereview.cfg -rw-r--r-- 1 root root 1339 Jun 2 01:01 CONTRIBUTING.md drwxr-xr-x 2 root root 4096 Jun 2 01:02 doc drwxr-xr-x 3 root root 4096 Jun 2 01:02 lib -rw-r--r-- 1 root root 1479 Jun 2 01:01 LICENSE drwxr-xr-x 11 root root 4096 Jun 2 01:02 misc -rw-r--r-- 1 root root 1303 Jun 2 01:01 PATENTS drwxr-xr-x 4 root root 4096 Jun 2 01:04 pkg -rw-r--r-- 1 root root 1455 Jun 2 01:01 README.md -rw-r--r-- 1 root root 419 Jun 2 01:01 SECURITY.md drwxr-xr-x 49 root root 4096 Jun 2 01:02 src drwxr-xr-x 26 root root 12288 Jun 2 01:02 test -rw-r--r-- 1 root root 8 Jun 2 01:01 VERSION # 加入 ~/.bashrc,每次生效 export PATH=$PATH:/usr/local/go/bin:/root/go/bin/ # 此次终端生效 source ~/.bashrc # 验证效果 go version go version go1.20.6 windows/amd64 ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/:2:1","series":null,"tags":["blog","golang"],"title":"golang的使用","uri":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/#安装-golang"},{"categories":["blog"],"content":" 配置环境变量 # 查看变量 go env # 配置代理 go env -w GOPROXY=https://goproxy.cn,direct # 常用构建配置 # 完整版参考 https://go.dev/doc/install/source#environment $GOOS $GOARCH windows amd64 linux amd64 linux arm64 darwin amd64 darwin amd64 ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/:2:2","series":null,"tags":["blog","golang"],"title":"golang的使用","uri":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/#配置环境变量"},{"categories":["point"],"content":"hugo 是一个静态网站生成工具, 使用 golang 编写. GitHub - gohugoio/hugo: The world’s fastest framework for building websites. 运行启动 hugo serve --disableFastRender 要点: 速度快 迭代迅速且功能多 ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/hugo/:0:0","series":null,"tags":["point","hugo"],"title":"hugo","uri":"/posts/%E7%AC%94%E8%AE%B0/point/hugo/#"},{"categories":["point"],"content":"MinGW-w64 是一个基于 gcc 的 windows 开发工具集. 让你可以在 windows 上轻松使用 make, gcc 等命令. ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/mingw-w64/:0:0","series":null,"tags":["point","MinGW-w64"],"title":"MinGW-w64","uri":"/posts/%E7%AC%94%E8%AE%B0/point/mingw-w64/#"},{"categories":["point"],"content":"powershell 是一种 shell. 让你使用命令行操作系统. 要点: 跨平台 Windows 上的御用命令行 ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/powershell/:0:0","series":null,"tags":["point","powershell"],"title":"powershell","uri":"/posts/%E7%AC%94%E8%AE%B0/point/powershell/#"},{"categories":["blog"],"content":"这里记录 [[笔记/point/powershell|powershell]] 的常用命令.","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/"},{"categories":["blog"],"content":" 简介这里记录 powershell 的常用命令. ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 操作手册","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#操作手册"},{"categories":["blog"],"content":" 日常操作 操作变量 # 示例是配置golang,启用cgo编译 # 本地变量 set CGO_ENABLED \"1\" echo $CGO_ENABLED rv CGO_ENABLED # $env 用于访问用户变量和系统变量 echo $env:CGO_ENABLED ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#日常操作"},{"categories":["blog"],"content":" 日常操作 操作变量 # 示例是配置golang,启用cgo编译 # 本地变量 set CGO_ENABLED \"1\" echo $CGO_ENABLED rv CGO_ENABLED # $env 用于访问用户变量和系统变量 echo $env:CGO_ENABLED ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#操作变量"},{"categories":["blog"],"content":" 命令查询 # 查询所有命令 Get-Command # 查询名字包含Process的命令 Get-Command -Name *Process # 查看alias Get-Alias Alias set -\u003e Set-Variable Alias echo -\u003e Write-Output Alias rv -\u003e Remove-Variable Alias ls -\u003e Get-ChildItem Alias cat -\u003e Get-Content Alias cd -\u003e Set-Location Alias clear -\u003e Clear-Host Alias copy -\u003e Copy-Item Alias cp -\u003e Copy-Item Alias mv -\u003e Move-Item ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:2","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#命令查询"},{"categories":["blog"],"content":" 常用配置 $profile 配置 # 查看配置文件 code $profile # vscode打开 notepad $profile # 记事本打开 # 配置文件的内容 ## 安装oh-my-posh winget install JanDeDobbeleer.OhMyPosh -s winget # 主题配置,主题列表 https://ohmyposh.dev/docs/themes oh-my-posh init pwsh --config \"D:\\OneDrive\\kentxxq\\config\\oh-my-posh\\theme.json\" | Invoke-Expression # vpn命令 function vpn { $Env:http_proxy = \"http://127.0.0.1:7890\"; $Env:https_proxy = \"http://127.0.0.1:7890\"; } function novpn { $Env:http_proxy = \"\"; $Env:https_proxy = \"\"; } # 配合ssh-agent使用 $env:GIT_SSH=\"C:\\Windows\\System32\\OpenSSH\\ssh.exe\" 主题文件 { \"$schema\": \"https://raw.githubusercontent.com/JanDeDobbeleer/oh-my-posh/main/themes/schema.json\", \"blocks\": [ { \"alignment\": \"left\", \"newline\": true, \"segments\": [ { \"background\": \"#d75f00\", \"foreground\": \"#f2f3f8\", \"properties\": { \"alpine\": \"\\uf300\", \"arch\": \"\\uf303\", \"centos\": \"\\uf304\", \"debian\": \"\\uf306\", \"elementary\": \"\\uf309\", \"fedora\": \"\\uf30a\", \"gentoo\": \"\\uf30d\", \"linux\": \"\\ue712\", \"macos\": \"\\ue711\", \"manjaro\": \"\\uf312\", \"mint\": \"\\uf30f\", \"opensuse\": \"\\uf314\", \"raspbian\": \"\\uf315\", \"ubuntu\": \"\\uf31c\", \"windows\": \"\\ue70f\" }, \"style\": \"diamond\", \"leading_diamond\": \"\\u256d\\u2500\\ue0b2\", \"template\": \" {{ .Icon }} \", \"type\": \"os\" }, { \"background\": \"#e4e4e4\", \"foreground\": \"#4e4e4e\", \"style\": \"powerline\", \"powerline_symbol\": \"\\ue0b0\", \"template\": \" {{ .UserName }}@{{ .HostName }} \", \"type\": \"session\" }, { \"background\": \"#0087af\", \"foreground\": \"#f2f3f8\", \"properties\": { \"style\": \"full\", \"max_depth\": 3, \"folder_icon\": \"\\u2026\" // \"folder_separator_icon\": \" \u003ctransparent\u003e\\ue0b1\u003c/\u003e \" }, \"style\": \"powerline\", \"powerline_symbol\": \"\\ue0b0\", \"template\": \" \\ue5ff {{ .Path }} \", \"type\": \"path\" }, { \"background\": \"#378504\", \"foreground\": \"#f2f3f8\", \"background_templates\": [ \"{{ if or (.Working.Changed) (.Staging.Changed) }}#a97400{{ end }}\", \"{{ if and (gt .Ahead 0) (gt .Behind 0) }}#54433a{{ end }}\", \"{{ if gt .Ahead 0 }}#744d89{{ end }}\", \"{{ if gt .Behind 0 }}#744d89{{ end }}\" ], \"properties\": { \"branch_max_length\": 25, \"fetch_stash_count\": true, \"fetch_status\": true, \"branch_icon\": \"\\uf418 \", \"branch_identical_icon\": \"\\uf444\", \"branch_gone_icon\": \"\\uf655\" }, \"style\": \"diamond\", \"leading_diamond\": \"\u003ctransparent,background\u003e\\ue0b0\u003c/\u003e\", \"template\": \" {{ .HEAD }}{{if .BranchStatus }} {{ .BranchStatus }}{{ end }}{{ if .Working.Changed }} \u003ctransparent\u003e\\ue0b1\u003c/\u003e \u003c#121318\u003e\\uf044 {{ .Working.String }}\u003c/\u003e{{ end }}{{ if .Staging.Changed }} \u003ctransparent\u003e\\ue0b1\u003c/\u003e \u003c#121318\u003e\\uf046 {{ .Staging.String }}\u003c/\u003e{{ end }}{{ if gt .StashCount 0 }} \u003ctransparent\u003e\\ue0b1\u003c/\u003e \u003c#121318\u003e\\uf692 {{ .StashCount }}\u003c/\u003e{{ end }} \", \"trailing_diamond\": \"\\ue0b0\", \"type\": \"git\" } // , // { // \"type\": \"dotnet\", // \"style\": \"powerline\", // \"powerline_symbol\": \"\\uE0B0\", // \"foreground\": \"#000000\", // \"background\": \"#00ffff\", // \"template\": \" \\uE77F {{ .Full }} \" // } ], \"type\": \"prompt\" }, { \"alignment\": \"right\", \"segments\": [ { \"background\": \"#e4e4e4\", \"foreground\": \"#585858\", \"properties\": { \"style\": \"austin\", \"always_enabled\": true }, \"invert_powerline\": true, \"style\": \"powerline\", \"powerline_symbol\": \"\\ue0b2\", \"template\": \" \\uf608 {{ .FormattedMs }} \", \"type\": \"executiontime\" }, { \"background\": \"#d75f00\", \"foreground\": \"#f2f3f8\", \"properties\": { \"time_format\": \"15:04:05\" }, \"invert_powerline\": true, \"style\": \"diamond\", \"template\": \" \\uf5ef {{ .CurrentDate | date .Format }} \", // \"trailing_diamond\": \"\\ue0b0\", \"type\": \"time\" }, { \"type\": \"exit\", \"style\": \"diamond\", \"foreground\": \"#ffffff\", \"background\": \"#00897b\", // \"invert_powerline\": true, \"powerline_symbol\": \"\\ue0b2\", \"background_templates\": [ \" {{ if gt .Code 0 }} #e91e63 {{ end }} \" ], \"trailing_diamond\": \"\\ue0b0\", // \"template\": \"\\uE0B0 \\uE23A \", \"template\": \"\u003c#d75f00\u003e\\uE0B0\u003c/\u003e \\uE23A \", // \"template\": \" \u003c#193549\u003e\\uE0B0\u003c/\u003e \\uE23A \", \"properties\": { \"always_enabled\": true } } ], \"type\": \"prompt\" }, { \"alignment\": \"left\", \"newline\": true, \"segments\": [ { \"foreground\": \"#d75f00\", \"style\": \"plain\", \"template\": \"\\u2570\\u2500 {{ if .Root }}#{{else}}${{end}}\", \"type\": \"text\" } ], \"typ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:3","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#常用配置"},{"categories":["blog"],"content":" 常用配置 $profile 配置 # 查看配置文件 code $profile # vscode打开 notepad $profile # 记事本打开 # 配置文件的内容 ## 安装oh-my-posh winget install JanDeDobbeleer.OhMyPosh -s winget # 主题配置,主题列表 https://ohmyposh.dev/docs/themes oh-my-posh init pwsh --config \"D:\\OneDrive\\kentxxq\\config\\oh-my-posh\\theme.json\" | Invoke-Expression # vpn命令 function vpn { $Env:http_proxy = \"http://127.0.0.1:7890\"; $Env:https_proxy = \"http://127.0.0.1:7890\"; } function novpn { $Env:http_proxy = \"\"; $Env:https_proxy = \"\"; } # 配合ssh-agent使用 $env:GIT_SSH=\"C:\\Windows\\System32\\OpenSSH\\ssh.exe\" 主题文件 { \"$schema\": \"https://raw.githubusercontent.com/JanDeDobbeleer/oh-my-posh/main/themes/schema.json\", \"blocks\": [ { \"alignment\": \"left\", \"newline\": true, \"segments\": [ { \"background\": \"#d75f00\", \"foreground\": \"#f2f3f8\", \"properties\": { \"alpine\": \"\\uf300\", \"arch\": \"\\uf303\", \"centos\": \"\\uf304\", \"debian\": \"\\uf306\", \"elementary\": \"\\uf309\", \"fedora\": \"\\uf30a\", \"gentoo\": \"\\uf30d\", \"linux\": \"\\ue712\", \"macos\": \"\\ue711\", \"manjaro\": \"\\uf312\", \"mint\": \"\\uf30f\", \"opensuse\": \"\\uf314\", \"raspbian\": \"\\uf315\", \"ubuntu\": \"\\uf31c\", \"windows\": \"\\ue70f\" }, \"style\": \"diamond\", \"leading_diamond\": \"\\u256d\\u2500\\ue0b2\", \"template\": \" {{ .Icon }} \", \"type\": \"os\" }, { \"background\": \"#e4e4e4\", \"foreground\": \"#4e4e4e\", \"style\": \"powerline\", \"powerline_symbol\": \"\\ue0b0\", \"template\": \" {{ .UserName }}@{{ .HostName }} \", \"type\": \"session\" }, { \"background\": \"#0087af\", \"foreground\": \"#f2f3f8\", \"properties\": { \"style\": \"full\", \"max_depth\": 3, \"folder_icon\": \"\\u2026\" // \"folder_separator_icon\": \" \\ue0b1\u003c/\u003e \" }, \"style\": \"powerline\", \"powerline_symbol\": \"\\ue0b0\", \"template\": \" \\ue5ff {{ .Path }} \", \"type\": \"path\" }, { \"background\": \"#378504\", \"foreground\": \"#f2f3f8\", \"background_templates\": [ \"{{ if or (.Working.Changed) (.Staging.Changed) }}#a97400{{ end }}\", \"{{ if and (gt .Ahead 0) (gt .Behind 0) }}#54433a{{ end }}\", \"{{ if gt .Ahead 0 }}#744d89{{ end }}\", \"{{ if gt .Behind 0 }}#744d89{{ end }}\" ], \"properties\": { \"branch_max_length\": 25, \"fetch_stash_count\": true, \"fetch_status\": true, \"branch_icon\": \"\\uf418 \", \"branch_identical_icon\": \"\\uf444\", \"branch_gone_icon\": \"\\uf655\" }, \"style\": \"diamond\", \"leading_diamond\": \"\\ue0b0\u003c/\u003e\", \"template\": \" {{ .HEAD }}{{if .BranchStatus }} {{ .BranchStatus }}{{ end }}{{ if .Working.Changed }} \\ue0b1\u003c/\u003e \u003c#121318\u003e\\uf044 {{ .Working.String }}\u003c/\u003e{{ end }}{{ if .Staging.Changed }} \\ue0b1\u003c/\u003e \u003c#121318\u003e\\uf046 {{ .Staging.String }}\u003c/\u003e{{ end }}{{ if gt .StashCount 0 }} \\ue0b1\u003c/\u003e \u003c#121318\u003e\\uf692 {{ .StashCount }}\u003c/\u003e{{ end }} \", \"trailing_diamond\": \"\\ue0b0\", \"type\": \"git\" } // , // { // \"type\": \"dotnet\", // \"style\": \"powerline\", // \"powerline_symbol\": \"\\uE0B0\", // \"foreground\": \"#000000\", // \"background\": \"#00ffff\", // \"template\": \" \\uE77F {{ .Full }} \" // } ], \"type\": \"prompt\" }, { \"alignment\": \"right\", \"segments\": [ { \"background\": \"#e4e4e4\", \"foreground\": \"#585858\", \"properties\": { \"style\": \"austin\", \"always_enabled\": true }, \"invert_powerline\": true, \"style\": \"powerline\", \"powerline_symbol\": \"\\ue0b2\", \"template\": \" \\uf608 {{ .FormattedMs }} \", \"type\": \"executiontime\" }, { \"background\": \"#d75f00\", \"foreground\": \"#f2f3f8\", \"properties\": { \"time_format\": \"15:04:05\" }, \"invert_powerline\": true, \"style\": \"diamond\", \"template\": \" \\uf5ef {{ .CurrentDate | date .Format }} \", // \"trailing_diamond\": \"\\ue0b0\", \"type\": \"time\" }, { \"type\": \"exit\", \"style\": \"diamond\", \"foreground\": \"#ffffff\", \"background\": \"#00897b\", // \"invert_powerline\": true, \"powerline_symbol\": \"\\ue0b2\", \"background_templates\": [ \" {{ if gt .Code 0 }} #e91e63 {{ end }} \" ], \"trailing_diamond\": \"\\ue0b0\", // \"template\": \"\\uE0B0 \\uE23A \", \"template\": \"\u003c#d75f00\u003e\\uE0B0\u003c/\u003e \\uE23A \", // \"template\": \" \u003c#193549\u003e\\uE0B0\u003c/\u003e \\uE23A \", \"properties\": { \"always_enabled\": true } } ], \"type\": \"prompt\" }, { \"alignment\": \"left\", \"newline\": true, \"segments\": [ { \"foreground\": \"#d75f00\", \"style\": \"plain\", \"template\": \"\\u2570\\u2500 {{ if .Root }}#{{else}}${{end}}\", \"type\": \"text\" } ], \"typ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:3","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#profile-配置"},{"categories":["blog"],"content":" 常用配置 $profile 配置 # 查看配置文件 code $profile # vscode打开 notepad $profile # 记事本打开 # 配置文件的内容 ## 安装oh-my-posh winget install JanDeDobbeleer.OhMyPosh -s winget # 主题配置,主题列表 https://ohmyposh.dev/docs/themes oh-my-posh init pwsh --config \"D:\\OneDrive\\kentxxq\\config\\oh-my-posh\\theme.json\" | Invoke-Expression # vpn命令 function vpn { $Env:http_proxy = \"http://127.0.0.1:7890\"; $Env:https_proxy = \"http://127.0.0.1:7890\"; } function novpn { $Env:http_proxy = \"\"; $Env:https_proxy = \"\"; } # 配合ssh-agent使用 $env:GIT_SSH=\"C:\\Windows\\System32\\OpenSSH\\ssh.exe\" 主题文件 { \"$schema\": \"https://raw.githubusercontent.com/JanDeDobbeleer/oh-my-posh/main/themes/schema.json\", \"blocks\": [ { \"alignment\": \"left\", \"newline\": true, \"segments\": [ { \"background\": \"#d75f00\", \"foreground\": \"#f2f3f8\", \"properties\": { \"alpine\": \"\\uf300\", \"arch\": \"\\uf303\", \"centos\": \"\\uf304\", \"debian\": \"\\uf306\", \"elementary\": \"\\uf309\", \"fedora\": \"\\uf30a\", \"gentoo\": \"\\uf30d\", \"linux\": \"\\ue712\", \"macos\": \"\\ue711\", \"manjaro\": \"\\uf312\", \"mint\": \"\\uf30f\", \"opensuse\": \"\\uf314\", \"raspbian\": \"\\uf315\", \"ubuntu\": \"\\uf31c\", \"windows\": \"\\ue70f\" }, \"style\": \"diamond\", \"leading_diamond\": \"\\u256d\\u2500\\ue0b2\", \"template\": \" {{ .Icon }} \", \"type\": \"os\" }, { \"background\": \"#e4e4e4\", \"foreground\": \"#4e4e4e\", \"style\": \"powerline\", \"powerline_symbol\": \"\\ue0b0\", \"template\": \" {{ .UserName }}@{{ .HostName }} \", \"type\": \"session\" }, { \"background\": \"#0087af\", \"foreground\": \"#f2f3f8\", \"properties\": { \"style\": \"full\", \"max_depth\": 3, \"folder_icon\": \"\\u2026\" // \"folder_separator_icon\": \" \\ue0b1\u003c/\u003e \" }, \"style\": \"powerline\", \"powerline_symbol\": \"\\ue0b0\", \"template\": \" \\ue5ff {{ .Path }} \", \"type\": \"path\" }, { \"background\": \"#378504\", \"foreground\": \"#f2f3f8\", \"background_templates\": [ \"{{ if or (.Working.Changed) (.Staging.Changed) }}#a97400{{ end }}\", \"{{ if and (gt .Ahead 0) (gt .Behind 0) }}#54433a{{ end }}\", \"{{ if gt .Ahead 0 }}#744d89{{ end }}\", \"{{ if gt .Behind 0 }}#744d89{{ end }}\" ], \"properties\": { \"branch_max_length\": 25, \"fetch_stash_count\": true, \"fetch_status\": true, \"branch_icon\": \"\\uf418 \", \"branch_identical_icon\": \"\\uf444\", \"branch_gone_icon\": \"\\uf655\" }, \"style\": \"diamond\", \"leading_diamond\": \"\\ue0b0\u003c/\u003e\", \"template\": \" {{ .HEAD }}{{if .BranchStatus }} {{ .BranchStatus }}{{ end }}{{ if .Working.Changed }} \\ue0b1\u003c/\u003e \u003c#121318\u003e\\uf044 {{ .Working.String }}\u003c/\u003e{{ end }}{{ if .Staging.Changed }} \\ue0b1\u003c/\u003e \u003c#121318\u003e\\uf046 {{ .Staging.String }}\u003c/\u003e{{ end }}{{ if gt .StashCount 0 }} \\ue0b1\u003c/\u003e \u003c#121318\u003e\\uf692 {{ .StashCount }}\u003c/\u003e{{ end }} \", \"trailing_diamond\": \"\\ue0b0\", \"type\": \"git\" } // , // { // \"type\": \"dotnet\", // \"style\": \"powerline\", // \"powerline_symbol\": \"\\uE0B0\", // \"foreground\": \"#000000\", // \"background\": \"#00ffff\", // \"template\": \" \\uE77F {{ .Full }} \" // } ], \"type\": \"prompt\" }, { \"alignment\": \"right\", \"segments\": [ { \"background\": \"#e4e4e4\", \"foreground\": \"#585858\", \"properties\": { \"style\": \"austin\", \"always_enabled\": true }, \"invert_powerline\": true, \"style\": \"powerline\", \"powerline_symbol\": \"\\ue0b2\", \"template\": \" \\uf608 {{ .FormattedMs }} \", \"type\": \"executiontime\" }, { \"background\": \"#d75f00\", \"foreground\": \"#f2f3f8\", \"properties\": { \"time_format\": \"15:04:05\" }, \"invert_powerline\": true, \"style\": \"diamond\", \"template\": \" \\uf5ef {{ .CurrentDate | date .Format }} \", // \"trailing_diamond\": \"\\ue0b0\", \"type\": \"time\" }, { \"type\": \"exit\", \"style\": \"diamond\", \"foreground\": \"#ffffff\", \"background\": \"#00897b\", // \"invert_powerline\": true, \"powerline_symbol\": \"\\ue0b2\", \"background_templates\": [ \" {{ if gt .Code 0 }} #e91e63 {{ end }} \" ], \"trailing_diamond\": \"\\ue0b0\", // \"template\": \"\\uE0B0 \\uE23A \", \"template\": \"\u003c#d75f00\u003e\\uE0B0\u003c/\u003e \\uE23A \", // \"template\": \" \u003c#193549\u003e\\uE0B0\u003c/\u003e \\uE23A \", \"properties\": { \"always_enabled\": true } } ], \"type\": \"prompt\" }, { \"alignment\": \"left\", \"newline\": true, \"segments\": [ { \"foreground\": \"#d75f00\", \"style\": \"plain\", \"template\": \"\\u2570\\u2500 {{ if .Root }}#{{else}}${{end}}\", \"type\": \"text\" } ], \"typ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:3","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#主题文件"},{"categories":["blog"],"content":" 问题处理 wsl 的网络修复 # 需要管理员权限 netsh winsock reset 接触 powershell 的下载限制 Set-ExecutionPolicy RemoteSigned -Scope CurrentUser ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#问题处理"},{"categories":["blog"],"content":" 相关资源 官方参考文档 ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:0","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#相关资源"},{"categories":["blog"],"content":"快速安装 [[笔记/point/MinGW-w64|MinGW-w64]] 的方法.","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85mingw-w64/","series":null,"tags":["blog","MinGW-w64"],"title":"安装MinGW-w64","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85mingw-w64/"},{"categories":["blog"],"content":" 简介快速安装 MinGW-w64 的方法. ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85mingw-w64/:1:0","series":null,"tags":["blog","MinGW-w64"],"title":"安装MinGW-w64","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85mingw-w64/#简介"},{"categories":["blog"],"content":" 操作手册 访问 WinLibs - GCC+MinGW-w64 compiler for Windows 下载 MSVCRT runtime 解压后添加到 系统环境变量 中 测试验证 \u003e gcc --version gcc.exe (MinGW-W64 x86_64-msvcrt-posix-seh, built by Brecht Sanders) 13.1.0 Copyright (C) 2023 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. \u003e make --version GNU Make 3.81 Copyright (C) 2006 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. This program built for i386-pc-mingw32 ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85mingw-w64/:2:0","series":null,"tags":["blog","MinGW-w64"],"title":"安装MinGW-w64","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85mingw-w64/#操作手册"},{"categories":["blog"],"content":"在我决定使用 [[笔记/point/obsidian|obsidian]] 来记录笔记后, 就发现有 `wikilink` 这个东西, 它不是 [CommonMark](https://commonmark.org/) 的一部分, 所以会导致很多的工具链的不兼容. 例如 [[笔记/point/vscode|vscode]] 默认无法读取.而我选择用 [hugo](point/hugo.md) 进行站点的构建发布. 所以这篇博客就如题目所说的, 我要打通 [[笔记/point/hugo|hugo]] 和 [[笔记/point/obsidian|obsidian]] ,所以就有了这一篇文章.我搭建了一个 demo 站点, 你可以看看 [效果](https://doit-demo.kentxxq.com/).","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/","series":null,"tags":["blog","hugo"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/"},{"categories":["blog"],"content":" 前情提要在我决定使用 obsidian 来记录笔记后, 就发现有 wikilink 这个东西, 它不是 CommonMark 的一部分, 所以会导致很多的工具链的不兼容. 例如 vscode 默认无法读取. 而我选择用 hugo 进行站点的构建发布. 所以这篇博客就如题目所说的, 我要打通 hugo 和 obsidian ,所以就有了这一篇文章.我搭建了一个 demo 站点, 你可以看看 效果. ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/:1:0","series":null,"tags":["blog","hugo"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/#前情提要"},{"categories":["blog"],"content":" 我做了什么","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/:2:0","series":null,"tags":["blog","hugo"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/#我做了什么"},{"categories":["blog"],"content":" 原理 hugo 默认使用 goldmark 进行 markdown 的渲染. goldmark 可以通过插件支持 wikilink. abhinav 的 goldmark-wikilink 这个插件与我的主题, 笔记路径, url 配置不兼容, 需要进行调整. 改 hugo 代码, 加入配置, 编译构建. 编写 github actions 发布工具. ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/:2:1","series":null,"tags":["blog","hugo"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/#原理"},{"categories":["blog"],"content":" 准备 goldmark-wikilink首先 fork 一份 goldmark-wikilink 代码到 我的仓库. 改动 go.mod module github.com/kentxxq/goldmark-wikilink 改动 resolver.go, 添加解析代码. 下面是伪代码, 讲一下我做了什么: // 默认解析,看起来不错 // [[Foo]] // =\u003e \"Foo.html\" // [[Foo bar]] // =\u003e \"Foo bar.html\" // [[foo/Bar]] // =\u003e \"foo/Bar.html\" // [[foo.pdf]] // =\u003e \"foo.pdf\" // [[foo.png]] // =\u003e \"foo.png\" var DefaultResolver Resolver = defaultResolver{} // hugo默认路径是/Foo/,所以我加了一个PrettyResolver解决这个问题 // 关于url的路径切换可以参考文档 https://gohugo.io/content-management/urls/#appearance // [[Foo]] // =\u003e \"Foo/\" var PrettyResolver Resolver = prettyResolver{} // 当我的obsidian笔记wikilink使用`相对于当前文件的路径`时 // /root/Foo.md url: /root/Foo/ // /root/a.md include [[Foo]] . url: /root/a/ wikilink: /root/a/Foo/ not found! // 所以我加上了RelResolver // [[Foo]] // =\u003e \"../Foo/\" worked! var RelResolver Resolver = relResolver{} // 但其实obsidian中使用这样的格式并不好看.我改成了`相对于项目根路径`后 // when i use pretty url with [[absolute path]] // /Foo.md url: /posts/Foo/ // /a.md include [[root/Foo]] . url: /posts/a/ wikilink: /posts/a/posts/Foo/ not found! // so... // [[Foo]] // =\u003e \"/root/Foo/\" worked! var RootResolver = func(b string) Resolver { return \u0026rootResolver{ base: b, } } var pretty_html = []byte(\"/\") // 相对路径就是在最前面加上../,变成请求上一级目录 var rel_head = []byte(\"../\") type relResolver struct{} func (relResolver) ResolveWikilink(n *Node) ([]byte, error) { dest := make([]byte, len(rel_head)+len(n.Target)+len(pretty_html)+len(_hash)+len(n.Fragment)) var i int if len(n.Target) \u003e 0 { i += copy(dest, rel_head) i += copy(dest[i:], n.Target) if filepath.Ext(string(n.Target)) == \"\" { i += copy(dest[i:], pretty_html) } } if len(n.Fragment) \u003e 0 { i += copy(dest[i:], _hash) i += copy(dest[i:], n.Fragment) } return dest[:i], nil } // 绝对路径就是传入前缀,然后直接加上wikilink的内容即可 type rootResolver struct { base string } func (r rootResolver) ResolveWikilink(n *Node) ([]byte, error) { dest := make([]byte, len(r.base)+len(n.Target)+len(pretty_html)+len(_hash)+len(n.Fragment)) var i int if len(n.Target) \u003e 0 { i += copy(dest, []byte(r.base)) i += copy(dest[i:], n.Target) if filepath.Ext(string(n.Target)) == \"\" { i += copy(dest[i:], pretty_html) } } if len(n.Fragment) \u003e 0 { i += copy(dest[i:], _hash) i += copy(dest[i:], n.Fragment) } return dest[:i], nil } ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/:2:2","series":null,"tags":["blog","hugo"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/#准备-goldmark-wikilink"},{"categories":["blog"],"content":" 改动 hugo同样 fork 一份 hugo 代码到 我的仓库. 安装依赖 go get github.com/kentxxq/goldmark-wikilink. 改动 markup/goldmark/goldmark_config/config.go,加入配置参数 type Extensions struct { Typographer Typographer Footnote bool DefinitionList bool // GitHub flavored markdown Table bool Strikethrough bool Linkify bool LinkifyProtocol string TaskList bool // 下面是我们新加的参数 // 采用那种方法解析链接? WikilinkReslover string // ROOT模式下,传入路径前缀 WikilinkRootPath string // 是否启用wikilink EnableWikilink bool } 改动 markup/goldmark/convert.go,让我们的配置和 wikilink 解析器生效. import ( \"bytes\" \"github.com/gohugoio/hugo/identity\" \"github.com/gohugoio/hugo/markup/goldmark/codeblocks\" \"github.com/gohugoio/hugo/markup/goldmark/goldmark_config\" \"github.com/gohugoio/hugo/markup/goldmark/images\" \"github.com/gohugoio/hugo/markup/goldmark/internal/extensions/attributes\" \"github.com/gohugoio/hugo/markup/goldmark/internal/render\" \"github.com/gohugoio/hugo/markup/converter\" \"github.com/gohugoio/hugo/markup/tableofcontents\" wikilink \"github.com/kentxxq/goldmark-wikilink\" //引入解析 \"github.com/yuin/goldmark\" \"github.com/yuin/goldmark/ast\" \"github.com/yuin/goldmark/extension\" \"github.com/yuin/goldmark/parser\" \"github.com/yuin/goldmark/renderer\" \"github.com/yuin/goldmark/renderer/html\" \"github.com/yuin/goldmark/text\" ) extensions = append(extensions, images.New(cfg.Parser.WrapStandAloneImageWithinParagraph)) // 加入 if mcfg.Goldmark.Extensions.EnableWikilink { switch mcfg.Goldmark.Extensions.WikilinkReslover { case \"DefaultResolver\": extensions = append(extensions, \u0026wikilink.Extender{ Resolver: wikilink.DefaultResolver, }) case \"PrettyResolver\": extensions = append(extensions, \u0026wikilink.Extender{ Resolver: wikilink.PrettyResolver, }) case \"RelResolver\": extensions = append(extensions, \u0026wikilink.Extender{ Resolver: wikilink.RelResolver, }) case \"RootResolver\": extensions = append(extensions, \u0026wikilink.Extender{ Resolver: wikilink.RootResolver(mcfg.Goldmark.Extensions.WikilinkRootPath), }) } } ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/:2:3","series":null,"tags":["blog","hugo"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/#改动-hugo"},{"categories":["blog"],"content":" 配置 dart-sass下载 Releases · sass/dart-sass 的对应系统版本, 我用的 dart-sass-1.63.6-windows-x64.zip.解压后配置到环境变量里. 打开终端验证效果 sass --version 1.63.6 ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/:2:4","series":null,"tags":["blog","hugo"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/#配置-dart-sass"},{"categories":["blog"],"content":" 开始构建代码 $GOOS=windows $GOARCH=amd64 $CGO_ENABLED=1 $CC=\"gcc\" $CXX=\"g++\" # 构建命令 # -v 详细信息 # -x 打印出执行的命令，以及相关的详细信息 # extended是加入sass,release则是hugo自定义 # `-s` 表示禁用符号表，`-w` 表示禁用 DWARF 调试信息，`-extldflags '-static'` 表示使用静态链接方式进行链接。 go build -v -x -tags extended,release -ldflags \"-s -w -extldflags '-static'\" # 文件夹多出一个hugo.exe ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/:2:5","series":null,"tags":["blog","hugo"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/#开始构建代码"},{"categories":["blog"],"content":" hugo 预览 # 克隆我的示例代码 git clone https://github.com/kentxxq/doit-demo.git # 注意hugo.toml文件加入了如下配置 EnableWikilink = true WikilinkRootPath = \"/posts/\" WikilinkReslover = \"RootResolver\" # 启动3333端口 cd doit-demo hugo server --disableFastRender -p 3333 访问 http://localhost:3333 看看效果吧. ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/:2:6","series":null,"tags":["blog","hugo"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/#hugo-预览"},{"categories":["blog"],"content":" 相关资料 除非 CommonMark 添加对 wikilink 的支持, hugo 可能永远都不会有 wikilink 了. Support wiki-style internal page links · Issue #3606 · gohugoio/hugo · GitHub 除了让 hugo 在渲染阶段支持 wikilink, 还可以再主题内进行 url 的处理,例如 obsidian发布hugo-quartz.但是这样的主题很少… ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/:3:0","series":null,"tags":["blog","hugo"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/#相关资料"},{"categories":["journal"],"content":"2023-06-25 日记","date":"2023-06-25","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-06-25/","series":null,"tags":["journal"],"title":"2023-06-25","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-06-25/"},{"categories":["journal"],"content":" GitHub - mii-key/obsidian-links: manipulate \u0026 manage obisidian links #todo/ob优化 ","date":"2023-06-25","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-06-25/:0:0","series":null,"tags":["journal"],"title":"2023-06-25","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-06-25/#"},{"categories":["point"],"content":"logseq 是一款大纲型的笔记软件. 要点如下: 本地存储 支持 markdown 开源, 且开源 spa-publish ","date":"2023-06-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/logseq/:0:0","series":null,"tags":["point","logseq"],"title":"logseq","uri":"/posts/%E7%AC%94%E8%AE%B0/point/logseq/#"},{"categories":["point"],"content":"openssh 是 ssh 协议的开源实现.而 ssh 可以用来 建立远程连接, 文件传输. 表达时 openssh 和 ssh 通常是等价的. ","date":"2023-06-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/openssh/:0:0","series":null,"tags":["point","openssh"],"title":"openssh","uri":"/posts/%E7%AC%94%E8%AE%B0/point/openssh/#"},{"categories":["point"],"content":"ssh-agent 是 ssh 的一个代理软件. 用来保存秘钥, 方便你日常使用. 要点: Windows 通常自带了此服务 ","date":"2023-06-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/ssh-agent/:0:0","series":null,"tags":["point","ssh-agent"],"title":"ssh-agent","uri":"/posts/%E7%AC%94%E8%AE%B0/point/ssh-agent/#"},{"categories":["point"],"content":"git 是一个代码管理工具. 要点: 非常流行, 社区庞大 方便多人的协作办公 人人本地一份代码 ","date":"2023-06-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/git/:0:0","series":null,"tags":["point","git"],"title":"git","uri":"/posts/%E7%AC%94%E8%AE%B0/point/git/#"},{"categories":["point"],"content":"obsidian 是一个笔记软件. 要点: 本地离线, 安全保证 除同步,发布都免费 性能良好 插件丰富 社区活跃 使用 Prism 进行代码块渲染 ","date":"2023-06-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/obsidian/:0:0","series":null,"tags":["point","obsidian"],"title":"obsidian","uri":"/posts/%E7%AC%94%E8%AE%B0/point/obsidian/#"},{"categories":["journal"],"content":" tag-wragler 创建标签页，配合 add-summary。也可以配合 dataview/text-expander/query 语句. 配合模板一起工作 #todo/dashboard tag summary 的 add-summary 块 Obsidian中的标签，到底该如何使用？（第一集 两种不同的标签与标签汇总）Johnny学Obsidian_哔哩哔哩_bilibili #todo/dashboard kanban 做任务管理 #todo/dashboard ","date":"2023-06-23","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-06-23/:0:0","series":null,"tags":["journal"],"title":"2023-06-23","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-06-23/#"},{"categories":["journal"],"content":" Slides 做 ppt，搞成工作区 #todo/ppt 加入一个 query 语句，每天查询的我的 todo 任务。每周未完成，重要未完成？加入到日记模板中。每天提醒我？ #todo/dashboard GitHub - pyrochlore/obsidian-tracker: A plugin tracks occurrences and numbers in your notes 做出一些很好看的图追踪目标 #todo/dashboard Excalidraw的动态演示效果来了，伟大的匈牙利大叔又放狠招了，你的Obsidian更好用了_哔哩哔哩_bilibili 这个比 slide 幻灯片牛逼多了. #todo/ppt Open gate 添加站点到左边快捷栏 #todo/ob优化 text-expend 是分？还是合？Obsidian中的笔记到底分不分？_哔哩哔哩_bilibili #todo/dashboard 导出图片 export image plugin 没有工作 #todo/ob优化 ","date":"2023-06-22","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-06-22/:0:0","series":null,"tags":["journal"],"title":"2023-06-22","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-06-22/#"},{"categories":["blog"],"content":"我的使用 [[笔记/point/git|git]] 操作代码. 而 git 的通信会用到 [[笔记/point/openssh|openssh]].openssh 为了保证安全. 提供了私钥和公钥. 其中私钥可以密码加密, 保证安全性. 所以我就加密了.导致了什么问题呢?每次我用到 git 的时候, 都提示我输入密码. 所以我今天就来配置 [[笔记/point/ssh-agent|ssh-agent]].","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git-openssh%E7%9A%84%E5%85%8D%E5%AF%86/","series":null,"tags":["openssh","git","ssh-agent","blog"],"title":"git-openssh的免密","uri":"/posts/%E7%AC%94%E8%AE%B0/git-openssh%E7%9A%84%E5%85%8D%E5%AF%86/"},{"categories":["blog"],"content":" 简介我的使用 git 操作代码. 而 git 的通信会用到 openssh. openssh 为了保证安全. 提供了私钥和公钥. 其中私钥可以密码加密, 保证安全性. 所以我就加密了.导致了什么问题呢? 每次我用到 git 的时候, 都提示我输入密码. 所以我今天就来配置 ssh-agent. 我暂时只用 windows, 所以下面主要是 windows 的配置. ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git-openssh%E7%9A%84%E5%85%8D%E5%AF%86/:1:0","series":null,"tags":["openssh","git","ssh-agent","blog"],"title":"git-openssh的免密","uri":"/posts/%E7%AC%94%E8%AE%B0/git-openssh%E7%9A%84%E5%85%8D%E5%AF%86/#简介"},{"categories":["blog"],"content":" 操作流程 启动 windows 的 服务 =\u003e启动 ssh 服务 添加秘钥 ssh-add C:\\Users\\你的用户名\\.ssh\\id_rsa # 输入密码后回车 Enter passphrase for C:\\Users\\你的用户名\\.ssh\\id_rsa: Identity added: C:\\Users\\你的用户名\\.ssh\\id_rsa (kentxxq) # 验证效果 ssh-add -l 3072 SHA256:xxxxxxxxxxxxxxxxxxxxxxxoooooo kentxxq (RSA) 进入终端,编辑 notepad $profile 配置文件 # 加入下面这一行 $env:GIT_SSH=\"C:\\Windows\\System32\\OpenSSH\\ssh.exe\" 终端有效果, 但 vscode 等等软件没有生效? 按照这个老哥的做法, 改全局变量吧 Git: Support git with private key password · Issue #13680 · microsoft/vscode · GitHub 重新打开终端, 这里有一些 git教程 可以给你测试验证 ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git-openssh%E7%9A%84%E5%85%8D%E5%AF%86/:2:0","series":null,"tags":["openssh","git","ssh-agent","blog"],"title":"git-openssh的免密","uri":"/posts/%E7%AC%94%E8%AE%B0/git-openssh%E7%9A%84%E5%85%8D%E5%AF%86/#操作流程"},{"categories":["blog"],"content":"这里用来记录一些我可能用到的 [[笔记/point/git|git]] 命令. 每次去网上搜集都很麻烦, 还需要验证. 而这里的命令都经过了我的验证..","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/","series":null,"tags":["git","blog"],"title":"git教程","uri":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介这里用来记录一些我可能用到的 git 命令. 每次去网上搜集都很麻烦, 还需要验证. 而这里的命令都经过了我的验证.. ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["git","blog"],"title":"git教程","uri":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 具体操作","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["git","blog"],"title":"git教程","uri":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/#具体操作"},{"categories":["blog"],"content":" 规范 commit feat: 新功能 (feature) update: 在 feat 内的修改 fix: 修补 bug docs: 文档 (documentation) style: 格式（不影响代码运行的变动) refactor: 重构 (即不是新增功能，也不是修改 bug 的代码变动) perf: 性能优化 (performance) test: 增加测试 thore: 构建过程或辅助工具的变动 ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["git","blog"],"title":"git教程","uri":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/#规范-commit"},{"categories":["blog"],"content":" 克隆与加速 # clone 特定tag或release git clone -b v111 xxx.git # 深度为1的clone git clone --depth 1 xxx.git # 代理克隆 git clone https://ghproxy.com/https://github.com/kentxxq/hugo.git # 私有仓库配合token使用. git clone https://user:your_token@ghproxy.com/https://ghproxy.com/https://github.com/kentxxq/hugo.git # 修改origin地址 git remote set-url origin https://github.com/kentxxq/hugo.git # 验证效果 git remote -v ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["git","blog"],"title":"git教程","uri":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/#克隆与加速"},{"categories":["blog"],"content":" 推送 # 所有 git push git tag 1.0.0 # 指定tag git push origin \u003ctag_name\u003e # 所有tag,不推荐 git push --tags ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["git","blog"],"title":"git教程","uri":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/#推送"},{"categories":["blog"],"content":" 清空记录 # 新分支 git checkout --orphan new_branch # 添加到暂存区 git add -A # 提交 git commit -am \"文章更新\" # 删除原有的master git branch -D master # 重命名分支 git branch -m master # 强制推送 git push -f origin master ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":["git","blog"],"title":"git教程","uri":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/#清空记录"},{"categories":["point"],"content":" kentxxq 这是我的个人网名. ken 日常可以叫 “can”, 不是 \" 坑 “! 名字的由来? 我以前给自己起网名, 然后发现 超人 的名字叫 kent. 而日常叫起来的话, 一般都会叫 ken. 但是我买不到这个域名. 一般来说品牌合作都类似 卧龙\u0026凤雏 或者 卧龙X凤雏. 我名字的缩写是 xq,于是就 “kentXxq”=“kentxxq”. 联系方式我:admin@kentxxq.com ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/kentxxq/:0:0","series":null,"tags":["point","kentxxq"],"title":"kentxxq","uri":"/posts/%E7%AC%94%E8%AE%B0/point/kentxxq/#"},{"categories":["blog"],"content":"这里是我在确定使用 [[笔记/point/obsidian|obsidian]] 记录笔记以后. 对比选择我的博客发布方案.之前我的博客和笔记内容是割裂的. 一直使用 vscode 编写博客, 然后 [[笔记/point/hugo|hugo]] 发布. 而现在我想重新组合我的工作流.","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/","series":null,"tags":["obsidian","hugo","blog"],"title":"obsidian的发布方案","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/"},{"categories":["blog"],"content":" 简介这里是我在确定使用 obsidian 记录笔记以后. 对比选择我的博客发布方案. 之前我的博客和笔记内容是割裂的. 一直使用 vscode 编写博客, 然后 hugo 发布. 而现在我想重新组合我的工作流. ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/:1:0","series":null,"tags":["obsidian","hugo","blog"],"title":"obsidian的发布方案","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/#简介"},{"categories":["blog"],"content":" 发布方案","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/:2:0","series":null,"tags":["obsidian","hugo","blog"],"title":"obsidian的发布方案","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/#发布方案"},{"categories":["blog"],"content":" 现状先说结果,我选的 HEIGE-PCloud/DoIt: A clean, elegant and advanced blog theme for Hugo..没有哪种方案是十全十美的, 于是我先确定了优先级. seo: 既然是发布系统. 那么发布出去最重要的就是 seo 优化了. 评论: 交流, 反馈都会直接帮助到内容, 重要性排名第二. ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/:2:1","series":null,"tags":["obsidian","hugo","blog"],"title":"obsidian的发布方案","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/#现状"},{"categories":["blog"],"content":" 方案对比 对比项 hugo-quartz hugo-doit 官方 publish #todo标签 无法过滤解析 🚫 无法过滤解析 🚫 支持 ✅ 支持预览页面 支持 wikilink 和普通 link, 但效果一般 ⚠️ 不支持 🚫 支持 ✅ 需要做的改动 obsidian 发布到 quartz ℹ️ 移动 static 文件夹并配置 staticDirc ℹ️ 不需要 ✅ markdown 正常 link 到 head 只能定位到 page⚠️ 通过 goldmark-wiki 支持 ⚠️ 支持 ✅ seo 6 分 10 分 10 分 评论 🚫 ✅ 🚫 在确定了使用 doit 后,其中最让我纠结的就是语法问题. 禁用 wikilink 语法 - 相对于根目录. 需要在主题内修改 md 链接的渲染. 检测到 md 结尾就绕过原有逻辑,去除 md 结尾, 加上 /posts/ 前缀. 禁用 wikilink 语法 - 相对于当前文件, 需要开启 uglyURLs, 同时将 md 改成 html 采用 wikilink 语法, 在我编写笔记的时候好用. 但是发布需要渲染成 uglyURLs. 且要改源码编译 hugo 加入 goldmark-wikilink. 同时改动 wikilink 的渲染逻辑 分析: 2 比 1 要好, 不是绕过原有逻辑, 而是在原有逻辑后加入判断. 同时有兼容性好. 任意 markdown 编辑器都通用 3 比较麻烦, 同时如果 #todo/笔记 ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/:2:2","series":null,"tags":["obsidian","hugo","blog"],"title":"obsidian的发布方案","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/#方案对比"},{"categories":["blog"],"content":" 发布脚本 # 设置源文件夹和目标文件夹的路径 $sourceRootFolder = \"obsidian文档路径\" $targetRootFolder = \"博客路径\" # 切换到目标文件夹 Set-Location -Path $targetRootFolder git pull Write-Host \"github拉取完成\" Get-ChildItem -Path $targetRootFolder | Remove-Item -Force -Recurse Write-Host \"已删除存在的内容\" # 需要拷贝的文件夹 $folders = @(\"笔记\", \"附件\", \"日记\") foreach ($folder in $folders) { Copy-Item -Path \"$sourceRootFolder\\$folder\" -Destination \"$targetRootFolder\\$folder\" -Recurse -Force } Write-Host \"文件拷贝完成\" Write-Host \"查看效果\" Get-ChildItem -Path $targetRootFolder git add -A git commit -am \"文章更新\" git push Write-Host \"推送完成\" ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/:2:3","series":null,"tags":["obsidian","hugo","blog"],"title":"obsidian的发布方案","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/#发布脚本"},{"categories":["blog"],"content":"这里介绍我如何使用 [[笔记/point/obsidian|obsidian]] 来记录, 多总结, 总思考. 让 obsidian 真正成为最后一个笔记软件. (除非有其他革命性的创造, ar? 植入芯片?)","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/","series":null,"tags":["obsidian","blog"],"title":"obsidian的方法论","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/"},{"categories":["blog"],"content":" 简介这里介绍我如何使用 obsidian 来记录, 多总结, 总思考. 让 obsidian 真正成为最后一个笔记软件. (除非有其他革命性的创造, ar? 植入芯片?) ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/:1:0","series":null,"tags":["obsidian","blog"],"title":"obsidian的方法论","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/#简介"},{"categories":["blog"],"content":" 目标这部分是因为我刷到的一个 b 站视频, 我很认同他的观点. 于是想要来实践. 内容 问题点 说明 目标层 目标不明, 迟早要停 运用我的知识, 创造价值. 系统层 体系太乱, 事倍功半 于是我用 obsidian 来进行知识的管理与更新,并且发布出去. 管理和发布都会是价值 行为层 习惯不好, 大旗必倒 定期的整理, 添加新的理解, 关联知识体系. 流程层 流程不畅, 必走不长 使用日记来快速记录, 减少负担. 其他效果留给行为层 基础层 基础不牢, 地动山摇 生活, 工作都会有知识点. 不断探索, 进取是根本. ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/:2:0","series":null,"tags":["obsidian","blog"],"title":"obsidian的方法论","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/#目标"},{"categories":["blog"],"content":" 如何开始","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/:3:0","series":null,"tags":["obsidian","blog"],"title":"obsidian的方法论","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/#如何开始"},{"categories":["blog"],"content":" 开始日记用日记开始每天的笔记. 为什么我的记录越来越少? 因为我发现我要些一篇文章的时候, 需要了解非常透彻, 花费很多的时间. 所以我通过类似 logseq 的日记来开始每一天的协作. 每天都是一个新的开始. 不强制把写的内容记到日记中做双链. 减少无效, 无作用的日记, 减少负担. 或者说换一种形式, 一句话日记比流水账双链更有意义. 日记整理成笔记或 point, 无用的日记应该删除. 例如除了已完成的 todo 没有其他内容. 记录内容: Todo 任务, 不单独记录到一个文件中, 可以减少历史负担产生的干扰 一句话日记. 通过 tag 的方式收集记录 有意思的句子. 通过 tag 的方式收集记录 ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/:3:1","series":null,"tags":["obsidian","blog"],"title":"obsidian的方法论","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/#开始日记"},{"categories":["blog"],"content":" 日记的格式 --- tags: - journal - 标题名称 categories: - journal description: \"\u003c% tp.date.now(\"YYYY-MM-DD\") %\u003e 日记\" --- 输出 --- title: \"2023-06-25\" tags: - journal - date: 2023-06-25 lastmod: 2023-06-25 categories: - journal description: \"2023-06-25 日记\" --- 自己的内容... ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/:3:2","series":null,"tags":["obsidian","blog"],"title":"obsidian的方法论","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/#日记的格式"},{"categories":["blog"],"content":" 笔记的重要组成 - 点 (point)point 是我笔记中的最小原子. 名词就是一个点的最佳诠释, 例如: kentxxq 是我的网名. 这种别人不了解的东西, 就非常适合引用. 多种表达形式? Alias 的头就是用来链接, 别名链接。例如 point 名字叫 ios, 也可以别名 iOS. ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/:3:3","series":null,"tags":["obsidian","blog"],"title":"obsidian的方法论","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/#笔记的重要组成---点-point"},{"categories":["blog"],"content":" 点 (point) 的格式 --- tags: - point - \u003c% tp.file.title %\u003e categories: - point --- 输出 --- title: logseq tags: - point - logseq date: 2023-06-25 lastmod: 2023-06-26 categories: - point --- `logseq` 是一款大纲型的笔记软件. 通常只是很少的简介信息, 没有必要再进行 description. ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/:3:4","series":null,"tags":["obsidian","blog"],"title":"obsidian的方法论","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/#点-point-的格式"},{"categories":["blog"],"content":" 博客的格式 --- tags: - blog categories: - blog description: \"\" --- ## 简介 ## 内容 输出 --- title: git常用命令 tags: - git - 清空历史记录 - 克隆速度 date: 2023-06-21 lastmod: 2023-06-25 --- ## 简介 这里用来记录一些我可能用到的 [git](point/git.md) 命令. 每次去网上搜集都很麻烦, 还需要验证. 而这里的命令都经过了我的验证.. ## 内容 xxx 这里想要特别说明一下: 简介通常用于链接. 一篇文章中, 如果我高频使用了 git 这个词, 我并不希望所有的 git 都变成链接. 更新日志被我去掉了, 因为我觉得更新时间就已经代替了文章的时效性. 而日记又会关联到博客, 这样就有了单链. 而日志和博客之间, 没有必要变成双联. 也就减少了我的写作负担. ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/:3:5","series":null,"tags":["obsidian","blog"],"title":"obsidian的方法论","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/#博客的格式"},{"categories":["journal"],"content":" obsidian同步方案对比 #todo/笔记 ","date":"2023-06-20","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-06-20/:0:0","series":null,"tags":["journal"],"title":"2023-06-20","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-06-20/#"},{"categories":["blog"],"content":"这里是用 [[笔记/point/obsidian|obsidian]] 发布到 [[point/hugo|hugo]] 的 quartz 主题详细操作步骤.","date":"2023-06-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/","series":null,"tags":["blog","hugo","obsidian"],"title":"obsidian发布hugo-quartz","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/"},{"categories":["blog"],"content":" 简介这里是用 obsidian 发布到 hugo 的 quartz 主题详细操作步骤. quartz 主题优点如下: 支持双链语法 有双链图 ","date":"2023-06-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/:1:0","series":null,"tags":["blog","hugo","obsidian"],"title":"obsidian发布hugo-quartz","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/#简介"},{"categories":["blog"],"content":" 操作步骤","date":"2023-06-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/:2:0","series":null,"tags":["blog","hugo","obsidian"],"title":"obsidian发布hugo-quartz","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/#操作步骤"},{"categories":["blog"],"content":" fork 代码库 访问 hugo 模板仓库 jackyzha0/quartz: 🌱 host your own second brain and digital garden for free (github.com) fork 仓库 git 克隆到本地 git clone https://github.com/YOUR-USERNAME/quartz ","date":"2023-06-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/:2:1","series":null,"tags":["blog","hugo","obsidian"],"title":"obsidian发布hugo-quartz","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/#fork-代码库"},{"categories":["blog"],"content":" 初始化动作 移除 content 内的所有内容 编辑 data/config.yaml 目录下 name: kentxxq enableRecentNotes: true GitHubLink: https://github.com/kentxxq/quartz description: \"kentxxq's digital garden\" page_title: \"🪴 kentxxq's digital garden\" links: - link_name: Blog link: https://www.kentxxq.com - link_name: GitHub link: https://github.com/kentxxq 编辑 config.toml baseURL = \"https://blog.kentxxq.com/\" ignoreFiles = [ \"/content/templates/*\", \"/content/private/*\", \"/content/附件/*.md\", ] 注释掉 .github/workflows/docker-publish.yaml 文件 .gitignore 过滤 private 文件夹 content/private 修改 layouts/partials/date-fmt.html 里的日志格式 {{if .Date}} {{.Date.Format \"2006-01-02\"}} {{else if .Lastmod}} {{.Lastmod.Format \"2006-01-02\"}} {{else}} Unknown {{end}} 修改 .github/workflows/deploy.yaml 文件 name: Deploy to GitHub Pages on: push: branches: - hugo jobs: deploy: runs-on: ubuntu-20.04 steps: - uses: actions/checkout@v2 with: fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Build Link Index uses: jackyzha0/hugo-obsidian@v2.20 with: index: true input: content output: assets/indices root: . - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \"0.96.0\" extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public publish_branch: master # deploying branch cname: blog.kentxxq.com # 先用blog来做测试 ","date":"2023-06-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/:2:2","series":null,"tags":["blog","hugo","obsidian"],"title":"obsidian发布hugo-quartz","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/#初始化动作"},{"categories":["blog"],"content":" 配置 githubPage 到你的 quartz 仓库调整配置 进入 Settings \u003e Action \u003e General \u003e Workflow Permissions 并选中 Read and Write Permissions ","date":"2023-06-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/:2:3","series":null,"tags":["blog","hugo","obsidian"],"title":"obsidian发布hugo-quartz","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/#配置-githubpage"},{"categories":["blog"],"content":" 使用说明 vault 应该创建在 content 下面 _index.md 是 quartz 的首页 设置 - 编辑器 - 显示 - 显示 frontmatter, 方便我们迅速查看调整 tag, 标题之类的内容 做一个模板,方便你以后用 --- title: \"{{title}}\" tags: - blog --- ","date":"2023-06-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/:2:4","series":null,"tags":["blog","hugo","obsidian"],"title":"obsidian发布hugo-quartz","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/#使用说明"},{"categories":["blog"],"content":" 推送代码后 配置自定义域名解析,例如 blog.kentxxq.com 使用 cname 解析到 kentxxq.github.io 进入 Settings \u003e Pages \u003e Custom domain \u003e blog.kentxxq.com 开启 https 证书 Enforce HTTPS ","date":"2023-06-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/:2:5","series":null,"tags":["blog","hugo","obsidian"],"title":"obsidian发布hugo-quartz","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/#推送代码后"},{"categories":["journal"],"content":" 车险 #todo/生活 ","date":"2023-06-19","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-06-19/:0:0","series":null,"tags":["journal"],"title":"2023-06-19","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-06-19/#"},{"categories":["blog"],"content":"这篇文章主要记录我使用 [[笔记/point/obsidian|obsidian]] 的配置和插件.方便自己记录, 也可以让你了解我做了什么让 [[笔记/point/obsidian|obsidian]] 变得更好用.","date":"2023-06-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/","series":null,"tags":["blog","obsidian"],"title":"obsidian插件与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/"},{"categories":["blog"],"content":" 简介这篇文章主要记录我使用 obsidian 的配置和插件. 方便自己记录, 也可以让你了解我做了什么让 obsidian 变得更好用. ","date":"2023-06-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","obsidian"],"title":"obsidian插件与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 主要配置","date":"2023-06-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","obsidian"],"title":"obsidian插件与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/#主要配置"},{"categories":["blog"],"content":" 编辑器 ","date":"2023-06-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog","obsidian"],"title":"obsidian插件与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/#编辑器"},{"categories":["blog"],"content":" 文件与链接 ","date":"2023-06-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:2","series":null,"tags":["blog","obsidian"],"title":"obsidian插件与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/#文件与链接"},{"categories":["blog"],"content":" 插件","date":"2023-06-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["blog","obsidian"],"title":"obsidian插件与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/#插件"},{"categories":["blog"],"content":" 使用中的插件 插件名称 插件作用 总结说明 Advanced Tables 快速写 markdown 的 table 非常好用 excalidraw 画图的 可以自动生成 svg，并且同步画图改动，兼容性很高 Find orphaned files and broken links 清理文件 整理出无效链接和孤儿文件 tag warpper 加强处理 tag 批量重命名 Linter 格式化笔记 选项很多，需要折腾 Webpage HTML Export 导出 html 兼容性非常好 auto-link-title 自动填写网页标题 挺好的，可以统一 easy-typing 输入时格式化 帮我在英文标点后加上空格 image-toolkit 点击放大图片 蛮好的 emoji-toolbar 插入 emoji 蛮好的 Templater 模板 方便创建日期和文件名模板 ","date":"2023-06-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:1","series":null,"tags":["blog","obsidian"],"title":"obsidian插件与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/#使用中的插件"},{"categories":["blog"],"content":" 放弃了的插件 插件名称 插件作用 总结说明 Diagrams 画图 在 ob 没 excalidraw 好用，没导出 svg 这样的定制化功能 Digital Garden 发布站点 tag 效果不好、和 frontmatter 似乎冲突比较多、代码不是很活跃 Remotely Save 同步备份 全程使用 alist 的 webdav+ 阿里云盘。偶尔无法同步删除，无法删除 .obsidian 里的文件 livesync 同步 同步 需要搭建服务器端、其实没有备份功能 ","date":"2023-06-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:2","series":null,"tags":["blog","obsidian"],"title":"obsidian插件与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/#放弃了的插件"},{"categories":["blog"],"content":" 可能尝试的插件 插件名称 插件作用 总结说明 sliding panes 横向卷动 打开多个标签页，然后配合触摸板横向浏览 ","date":"2023-06-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:3","series":null,"tags":["blog","obsidian"],"title":"obsidian插件与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/#可能尝试的插件"},{"categories":["blog"],"content":"总结一下在 [[笔记/point/csharp|c#]] 中几种 Task 的用法.","date":"2023-06-02","objectID":"/posts/%E7%AC%94%E8%AE%B0/task%E7%9A%84%E4%BD%BF%E7%94%A8/","series":null,"tags":["blog","csharp"],"title":"Task的使用","uri":"/posts/%E7%AC%94%E8%AE%B0/task%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["blog"],"content":" 简介总结一下在 c# 中几种 Task 的用法. ","date":"2023-06-02","objectID":"/posts/%E7%AC%94%E8%AE%B0/task%E7%9A%84%E4%BD%BF%E7%94%A8/:1:0","series":null,"tags":["blog","csharp"],"title":"Task的使用","uri":"/posts/%E7%AC%94%E8%AE%B0/task%E7%9A%84%E4%BD%BF%E7%94%A8/#简介"},{"categories":["blog"],"content":" 对比 方法 适用场景 Task.Run 通用，适用异步 Task.Factory.StartNew(TaskCreationOptions.LongRunning) 钻牛角尖 下面全都是你想用 Task.Factory.StartNew 的必备条件 你想要新启一个线程来运行，因为会堵塞太久。 是同步方法。因为异步并不会在新启动的线程运行（参考链接），甚至因为开线程，切换线程影响性能。 会并发。如果最多同时 1 个，那没必要。 你很了解现在的线程池情况，你对线程池扩容的逻辑你不满意，你必须现在就申请一个新线程。否则会自动扩容的。 不想用 backgroundService后台执行 和 mq消息队列替代 ","date":"2023-06-02","objectID":"/posts/%E7%AC%94%E8%AE%B0/task%E7%9A%84%E4%BD%BF%E7%94%A8/:2:0","series":null,"tags":["blog","csharp"],"title":"Task的使用","uri":"/posts/%E7%AC%94%E8%AE%B0/task%E7%9A%84%E4%BD%BF%E7%94%A8/#对比"},{"categories":["blog"],"content":" 参考链接 LongRunning 的错误用法 devblog 官方 线程池 问题解答 ","date":"2023-06-02","objectID":"/posts/%E7%AC%94%E8%AE%B0/task%E7%9A%84%E4%BD%BF%E7%94%A8/:2:1","series":null,"tags":["blog","csharp"],"title":"Task的使用","uri":"/posts/%E7%AC%94%E8%AE%B0/task%E7%9A%84%E4%BD%BF%E7%94%A8/#参考链接"},{"categories":["blog"],"content":"elastalert2是一个日志告警服务，原理其实很简单，就是查询es数据，并触发告警信息。刚好最近在自建k8s和efk相关的内容，顺便更新到博客吧","date":"2022-05-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/","series":null,"tags":["blog","devops","告警"],"title":"elastalert2钉钉告警","uri":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/"},{"categories":["blog"],"content":" elastalert2 是一个日志告警服务，原理其实很简单，就是查询 es 数据，并触发告警信息。刚好最近在自建 k8s 和 efk 相关的内容，顺便更新到博客吧。 ","date":"2022-05-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/:0:0","series":null,"tags":["blog","devops","告警"],"title":"elastalert2钉钉告警","uri":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/#"},{"categories":["blog"],"content":" 背景介绍我们的日志通过 efk 套件采集、查询。 日志数据是存储在 es 内部的，所以我们的告警可以通过查询 es 数据来实现 ","date":"2022-05-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/:1:0","series":null,"tags":["blog","devops","告警"],"title":"elastalert2钉钉告警","uri":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/#背景介绍"},{"categories":["blog"],"content":" elastalert 的使用因为我们采用 docker 部署，因此我们优先写好配置文件，然后放到容器中 ","date":"2022-05-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/:2:0","series":null,"tags":["blog","devops","告警"],"title":"elastalert2钉钉告警","uri":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/#elastalert-的使用"},{"categories":["blog"],"content":" 配置 参考链接 目录结构 elastalert.yaml # 主配置文件 rules/ # 存在告警规则 demo1.yaml # 单个告警规则的配置文件 elastalert.yaml 文件内容 rules_folder: /opt/elastalert/rules run_every: seconds: 10 buffer_time: minutes: 15 es_host: es的主机ip es_port: 9200 writeback_index: elastalert_status alert_time_limit: days: 2 demo1.yaml 文件内容 name: \"demo1\" type: \"frequency\" index: \"xxx-index*\" # 查询日志所在的索引 is_enabled: true num_events: 1 # 出现几次就告警 timeframe: minutes: 1 # 1分钟 出现了 num_events次 匹配记录，就告警 realert: minutes: 1 # 1分钟内忽略重复告警 timestamp_field: \"@timestamp\" timestamp_type: \"iso\" use_strftime_index: false # 下面是在邮件中可能用到的字段 #alert_subject: \"Test 测试alter_subject \\n {} \" #alert_subject_args: # - \"message\" # - \"@log_name\" alert_text_type: alert_text_only # 下面是告警模板 alert_text: | \u003e 正式环境 告警信息 \u003e 时间: {0} \u003e 主机名: {1} \u003e 触发次数: {2} \u003e 匹配次数: {3} \u003e 日志信息: {4} alert_text_args: # 告警模板中用到的参数 - log_time - host.name - num_hits - num_matches - message filter: - query: query_string: query: \"LEVEL: ERROR\" # 告警查询语句 alert: - \"dingtalk\" # 告警类型 dingtalk_access_token: \"asidoijdosajdsao\" # 钉钉机器人访问地址 dingtalk_msgtype: \"text\" # 消息类型 ","date":"2022-05-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/:2:1","series":null,"tags":["blog","devops","告警"],"title":"elastalert2钉钉告警","uri":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/#配置-参考链接httpselastalert2readthedocsioenlatestruletypeshtml"},{"categories":["blog"],"content":" 配置 参考链接 目录结构 elastalert.yaml # 主配置文件 rules/ # 存在告警规则 demo1.yaml # 单个告警规则的配置文件 elastalert.yaml 文件内容 rules_folder: /opt/elastalert/rules run_every: seconds: 10 buffer_time: minutes: 15 es_host: es的主机ip es_port: 9200 writeback_index: elastalert_status alert_time_limit: days: 2 demo1.yaml 文件内容 name: \"demo1\" type: \"frequency\" index: \"xxx-index*\" # 查询日志所在的索引 is_enabled: true num_events: 1 # 出现几次就告警 timeframe: minutes: 1 # 1分钟 出现了 num_events次 匹配记录，就告警 realert: minutes: 1 # 1分钟内忽略重复告警 timestamp_field: \"@timestamp\" timestamp_type: \"iso\" use_strftime_index: false # 下面是在邮件中可能用到的字段 #alert_subject: \"Test 测试alter_subject \\n {} \" #alert_subject_args: # - \"message\" # - \"@log_name\" alert_text_type: alert_text_only # 下面是告警模板 alert_text: | \u003e 正式环境 告警信息 \u003e 时间: {0} \u003e 主机名: {1} \u003e 触发次数: {2} \u003e 匹配次数: {3} \u003e 日志信息: {4} alert_text_args: # 告警模板中用到的参数 - log_time - host.name - num_hits - num_matches - message filter: - query: query_string: query: \"LEVEL: ERROR\" # 告警查询语句 alert: - \"dingtalk\" # 告警类型 dingtalk_access_token: \"asidoijdosajdsao\" # 钉钉机器人访问地址 dingtalk_msgtype: \"text\" # 消息类型 ","date":"2022-05-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/:2:1","series":null,"tags":["blog","devops","告警"],"title":"elastalert2钉钉告警","uri":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/#目录结构"},{"categories":["blog"],"content":" 配置 参考链接 目录结构 elastalert.yaml # 主配置文件 rules/ # 存在告警规则 demo1.yaml # 单个告警规则的配置文件 elastalert.yaml 文件内容 rules_folder: /opt/elastalert/rules run_every: seconds: 10 buffer_time: minutes: 15 es_host: es的主机ip es_port: 9200 writeback_index: elastalert_status alert_time_limit: days: 2 demo1.yaml 文件内容 name: \"demo1\" type: \"frequency\" index: \"xxx-index*\" # 查询日志所在的索引 is_enabled: true num_events: 1 # 出现几次就告警 timeframe: minutes: 1 # 1分钟 出现了 num_events次 匹配记录，就告警 realert: minutes: 1 # 1分钟内忽略重复告警 timestamp_field: \"@timestamp\" timestamp_type: \"iso\" use_strftime_index: false # 下面是在邮件中可能用到的字段 #alert_subject: \"Test 测试alter_subject \\n {} \" #alert_subject_args: # - \"message\" # - \"@log_name\" alert_text_type: alert_text_only # 下面是告警模板 alert_text: | \u003e 正式环境 告警信息 \u003e 时间: {0} \u003e 主机名: {1} \u003e 触发次数: {2} \u003e 匹配次数: {3} \u003e 日志信息: {4} alert_text_args: # 告警模板中用到的参数 - log_time - host.name - num_hits - num_matches - message filter: - query: query_string: query: \"LEVEL: ERROR\" # 告警查询语句 alert: - \"dingtalk\" # 告警类型 dingtalk_access_token: \"asidoijdosajdsao\" # 钉钉机器人访问地址 dingtalk_msgtype: \"text\" # 消息类型 ","date":"2022-05-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/:2:1","series":null,"tags":["blog","devops","告警"],"title":"elastalert2钉钉告警","uri":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/#elastalertyaml-文件内容"},{"categories":["blog"],"content":" 配置 参考链接 目录结构 elastalert.yaml # 主配置文件 rules/ # 存在告警规则 demo1.yaml # 单个告警规则的配置文件 elastalert.yaml 文件内容 rules_folder: /opt/elastalert/rules run_every: seconds: 10 buffer_time: minutes: 15 es_host: es的主机ip es_port: 9200 writeback_index: elastalert_status alert_time_limit: days: 2 demo1.yaml 文件内容 name: \"demo1\" type: \"frequency\" index: \"xxx-index*\" # 查询日志所在的索引 is_enabled: true num_events: 1 # 出现几次就告警 timeframe: minutes: 1 # 1分钟 出现了 num_events次 匹配记录，就告警 realert: minutes: 1 # 1分钟内忽略重复告警 timestamp_field: \"@timestamp\" timestamp_type: \"iso\" use_strftime_index: false # 下面是在邮件中可能用到的字段 #alert_subject: \"Test 测试alter_subject \\n {} \" #alert_subject_args: # - \"message\" # - \"@log_name\" alert_text_type: alert_text_only # 下面是告警模板 alert_text: | \u003e 正式环境 告警信息 \u003e 时间: {0} \u003e 主机名: {1} \u003e 触发次数: {2} \u003e 匹配次数: {3} \u003e 日志信息: {4} alert_text_args: # 告警模板中用到的参数 - log_time - host.name - num_hits - num_matches - message filter: - query: query_string: query: \"LEVEL: ERROR\" # 告警查询语句 alert: - \"dingtalk\" # 告警类型 dingtalk_access_token: \"asidoijdosajdsao\" # 钉钉机器人访问地址 dingtalk_msgtype: \"text\" # 消息类型 ","date":"2022-05-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/:2:1","series":null,"tags":["blog","devops","告警"],"title":"elastalert2钉钉告警","uri":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/#demo1yaml-文件内容"},{"categories":["blog"],"content":" 部署使用 # docker命令 docker run -d --name elastalert --restart=always \\ -v $(pwd)/elastalert.yaml:/opt/elastalert/config.yaml \\ -v $(pwd)/rules:/opt/elastalert/rules \\ jertel/elastalert2 --verbose # 查看日志 docker logs -f elastalert ","date":"2022-05-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/:2:2","series":null,"tags":["blog","devops","告警"],"title":"elastalert2钉钉告警","uri":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/#部署使用"},{"categories":["blog"],"content":" 效果大概如下 \u003e 正式环境 告警信息 \u003e 时间: \u003cMISSING VALUE\u003e \u003e 主机名: mall-trade-service-7b5459d68b-fmqm2 \u003e 触发次数: 1 \u003e 匹配次数: 1 \u003e 日志信息: |dubbo-client-idleCheck-thread-1|TID:N/A|ERROR|o.a.d.r.e.s.header.ReconnectTimerTask:51|doTask| [DUBBO] Fail to connect to HeaderExchangeClient ","date":"2022-05-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/:3:0","series":null,"tags":["blog","devops","告警"],"title":"elastalert2钉钉告警","uri":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/#效果大概如下"},{"categories":["blog"],"content":"在日常的使用场景中，总是不得不接触各种各样的命令行工具。而在使用的过程中，多多少少有一些不好用的地方。马上就要发布到NET6，终于做到了在mac和windows系统上进行单个文件的发布。同时单个文件的大小又几乎缩小了一倍。所以就有了想法自己写一个","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/"},{"categories":["blog"],"content":"在日常的使用场景中，总是不得不接触各种各样的命令行工具。而在使用的过程中，多多少少有一些不好用的地方。马上就要发布到 NET6，终于做到了在 mac 和 windows 系统上进行单个文件的发布。同时单个文件的大小又几乎缩小了一倍。所以就有了想法自己写一个。 ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:0:0","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#"},{"categories":["blog"],"content":" 简介在日常的使用场景中，总是不得不接触各种各样的命令行工具。而在使用的过程中，多多少少有一些不好用的地方。马上就要发布到 NET6，终于做到了在 mac 和 windows 系统上进行单个文件的发布。同时单个文件的大小又几乎缩小了一倍。所以就有了想法自己写一个。 因为我希望命令尽量简短, 所以使用我的名字 ken 来命名. 代码都是开源 的，采用 csharp 编写。使用了微软自己的 System.Commandline。 现支持的所有系统版本 ken-linux-arm ken-linux-arm64 ken-linux-musl-x64 ken-linux-x64 ken-osx-arm64 ken-osx-x64 ken-win-arm.exe ken-win-arm64.exe ken-win-x64.exe ken-win-x86.exe # 下载举例：linux-x64 下载到程序路径 curl -L -o /usr/local/bin/ken https://github.com/kentxxq/kentxxq.Cli/releases/download/1.2.7/ken-linux-x64 # 如果是国内网络不行的话，可以使用代理下载 curl -L -o /usr/local/bin/ken https://github.abskoop.workers.dev/https://github.com/kentxxq/kentxxq.Cli/releases/download/1.2.7/ken-linux-x64 # 或 curl -L -o /usr/local/bin/ken https://ghproxy.com/https://github.com/kentxxq/kentxxq.Cli/releases/download/1.2.7/ken-linux-x64 # 赋权 chmod +x /usr/local/bin/ken ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:1:0","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#简介"},{"categories":["blog"],"content":" 如何使用说明: 如果命令返回状态非 0，则代表异常退出 ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:2:0","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#如何使用"},{"categories":["blog"],"content":" 端口检测 spsp 代表 socketping，之前一直都是用的 telnet。但是只能一次性请求，而 sp 可以设置连接超时时间、重试次数、连接成功后退出。 Usage: ken [options] sp \u003curl\u003e Arguments: \u003curl\u003e url: kentxxq.com:443 Options: -n, --retryTimes \u003cretryTimes\u003e default:0,retry forever [default: 0] -t, --timeout \u003ctimeout\u003e default:2 seconds [default: 2] -q, --quit Quit after connection succeeded [default: False] -?, -h, --help Show help and usage information # 请求2次 ken sp kentxxq.com:443 -n 2 request successed. waited 137 ms request successed. waited 1117 ms # 请求2次，一旦成功就退出 ken sp kentxxq.com:443 -n 2 -q request successed. waited 96 ms # 请求失败的情况，同时设置超时时间 ken sp kentxxq.com:444 -t 3 -n 2 -q request failed. waited 3016 ms request failed. waited 3013 ms # 解析失败的情况 ken sp kentxxq:443 -t 3 -n 2 -q parse error:不知道这样的主机。 ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:2:1","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#端口检测-sp"},{"categories":["blog"],"content":" 长连接 wsws 代表连接 websocket。之前一直用 wscat，但是wscat 依赖 nodejs。每次使用的时候都觉得有点小题大做了。 Usage: ken [options] ws \u003cwsUrl\u003e Arguments: \u003cwsUrl\u003e wsUrl: wss://ws.kentxxq.com/ws # 连接websocket ken ws wss://ws.kentxxq.com/ws \u003e\u003e ls \u003c\u003c ls \u003e\u003e pwd \u003c\u003c pwd \u003e\u003e 你好 \u003c\u003c 你好 ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:2:2","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#长连接-ws"},{"categories":["blog"],"content":" 查看端口监听 ssss 代表 socket status。主要原因是每次在 windows 上都容易忘记命令。后面会找时间去拓展成有用的功能。 ❯ .\\ken.exe ss 0.0.0.0:135 0.0.0.0:445 0.0.0.0:2179 0.0.0.0:5040 0.0.0.0:7680 0.0.0.0:7890 0.0.0.0:28653 0.0.0.0:49664 0.0.0.0:49665 0.0.0.0:49666 0.0.0.0:49667 0.0.0.0:49668 0.0.0.0:49669 0.0.0.0:49678 127.0.0.1:4012 127.0.0.1:4013 127.0.0.1:9100 127.0.0.1:9180 127.0.0.1:53087 127.0.0.1:53088 127.0.0.1:53117 127.0.0.1:53121 127.0.0.1:53430 127.0.0.1:57956 127.0.0.1:57961 127.0.0.1:61078 127.0.0.1:62078 169.254.171.114:139 172.18.87.230:139 172.18.87.230:5822 172.19.144.1:139 :::135 :::445 :::2179 :::7680 :::7890 :::49664 :::49665 :::49666 :::49667 :::49668 :::49669 :::49678 ::1:49672 ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:2:3","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#查看端口监听-ss"},{"categories":["blog"],"content":" 路由追踪 trtr 代表 traceroute。是通过 dotnet 的 ping 实现。结果发现在 linux 有问题，所以后续再去拓展吧。 ❯ ken.exe tr kentxxq.com try connecting to kentxxq.com ...success 1 request timeout 2 118.250.180.1 take 0ms 中国-湖南-长沙-电信 3 61.187.29.245 take 3ms 中国-湖南-长沙-电信 4 61.137.3.129 take 0ms 中国-湖南-长沙-电信 5 request timeout 6 202.97.94.122 take 19ms 中国-北京-北京-电信 7 202.97.94.94 take 58ms 中国-北京-北京-电信 8 202.97.60.214 take 0ms 日本-XX-XX-电信 9 129.250.3.23 take 79ms 美国-XX-XX-XX 10 129.250.6.127 take 0ms 美国-XX-XX-XX 11 61.200.82.50 take 102ms 日本-XX-XX-XX 12 185.199.110.153 美国-华盛顿-西雅图-XX ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:2:4","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#路由追踪-tr"},{"categories":["blog"],"content":" 操作 redisredis 因为经常删除特定的 key，而 redis-cli 没有没有很好的支持这点，所以就自己写了一个最常用的。。 # 错误命令就会输出usage # usage: # a*: search all keys start with a in db # del a2*: delete all keys start with a2 in db # select 1: checkout db 1 # exit(): just exit \u003e ken redis bwd.kentxxq.com -p 123456 connect success,take 27.4024 ms db0 keys:2 \u003e\u003ea keys count:1 \u003e\u003eb keys count:1 \u003e\u003ea* keys count:1 \u003e\u003edel a deleted 1 key(s) \u003e\u003eselect 1 using db1 keys count:1 \u003e\u003ec keys count:1 \u003e\u003eexit() ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:2:5","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#操作-redis"},{"categories":["blog"],"content":" k8s 状态查询k8s 命令的存在，主要是因为我日常需要查看 k8s 集群的信息，所以做到了命令里。 Description: get k8s resource info Usage: ken k8s [command] [options] Options: -c, --kubeconfig \u003ckubeconfig\u003e kubeconfig file path -n, --namespace \u003cnamespace\u003e specified namespace -?, -h, --help Show help and usage information Commands: 1 list restarted pod 2 list deployment resource usage 查看 k8s 内重启过的容器 ken k8s 1 ┌───────────┬──────────────────┬───────────────┐ │ Namespace │ Pod Name │ Restart Times │ ├───────────┼──────────────────┼───────────────┤ │ default │ A-service │ 187 │ │ default │ B-service │ 1 │ │ default │ C-service │ 3 │ └───────────┴──────────────────┴───────────────┘ 查看 deployment 的资源使用情况ken k8s 2 大致输出如下 Namespace Deployment Memory Usage Cpu Usage Request Memory Limit Memory Request Cpu Limit Cpu default kube-state-metrics 3.57% 0.25% 32Mi 1Gi 10m 200m ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:2:6","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#k8s-状态查询"},{"categories":["blog"],"content":" k8s 状态查询k8s 命令的存在，主要是因为我日常需要查看 k8s 集群的信息，所以做到了命令里。 Description: get k8s resource info Usage: ken k8s [command] [options] Options: -c, --kubeconfig kubeconfig file path -n, --namespace specified namespace -?, -h, --help Show help and usage information Commands: 1 list restarted pod 2 list deployment resource usage 查看 k8s 内重启过的容器 ken k8s 1 ┌───────────┬──────────────────┬───────────────┐ │ Namespace │ Pod Name │ Restart Times │ ├───────────┼──────────────────┼───────────────┤ │ default │ A-service │ 187 │ │ default │ B-service │ 1 │ │ default │ C-service │ 3 │ └───────────┴──────────────────┴───────────────┘ 查看 deployment 的资源使用情况ken k8s 2 大致输出如下 Namespace Deployment Memory Usage Cpu Usage Request Memory Limit Memory Request Cpu Limit Cpu default kube-state-metrics 3.57% 0.25% 32Mi 1Gi 10m 200m ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:2:6","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#查看-k8s-内重启过的容器"},{"categories":["blog"],"content":" k8s 状态查询k8s 命令的存在，主要是因为我日常需要查看 k8s 集群的信息，所以做到了命令里。 Description: get k8s resource info Usage: ken k8s [command] [options] Options: -c, --kubeconfig kubeconfig file path -n, --namespace specified namespace -?, -h, --help Show help and usage information Commands: 1 list restarted pod 2 list deployment resource usage 查看 k8s 内重启过的容器 ken k8s 1 ┌───────────┬──────────────────┬───────────────┐ │ Namespace │ Pod Name │ Restart Times │ ├───────────┼──────────────────┼───────────────┤ │ default │ A-service │ 187 │ │ default │ B-service │ 1 │ │ default │ C-service │ 3 │ └───────────┴──────────────────┴───────────────┘ 查看 deployment 的资源使用情况ken k8s 2 大致输出如下 Namespace Deployment Memory Usage Cpu Usage Request Memory Limit Memory Request Cpu Limit Cpu default kube-state-metrics 3.57% 0.25% 32Mi 1Gi 10m 200m ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:2:6","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#查看-deployment-的资源使用情况"},{"categories":["blog"],"content":" 更新 update这个命令主要是为了更新 ken 程序自己。避免冗长的 bash 命令。 ken update -h Description: update ken command Usage: ken update [options] Options: -f, --force force update current version [default: False] -kv, --ken-version \u003cken-version\u003e force upgrade to specific current version -p, --proxy use proxy url -t, --token \u003ctoken\u003e github token for query github-api [] -?, -h, --help Show help and usage information -p 使用 https://github.abskoop.workers.dev 代理下载，方便国内用户 -t 是因为 github 的 api 存在次数限制。带上 token 可以大幅提升 api 的请求次数 -kv 可以指定特定的版本，例如 -kv 1.3.2 则更新到 1.3.2 版本。因为我不想留着一些无用的版本号，所以 1.3.1 可能不见了。。。建议不使用此命令，直接 update 到最新版本 ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:2:7","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#更新-update"},{"categories":["blog"],"content":" 静态文件代理 webweb 直接将当前目录暴露成 http，并提供访问。方便调试、静态文件下载等等需求 Description: static file http server Usage: ken web [options] Options: -w, --webroot \u003cwebroot\u003e file path [default: .] -p, --port \u003cport\u003e http port [default: 5000] -?, -h, --help Show help and usage information # 使用示例 ken web listening http://0.0.0.0:5000 HTTP/1.1 GET / 200 text/html; charset=utf-8 5367 HTTP/1.1 GET /favicon.ico 404 默认当前目录，也可以只用 -w 指定目录 默认使用 5000 端口，也可以使用 -p 指定端口 ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:2:8","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#静态文件代理-web"},{"categories":["blog"],"content":" 网站连通性测试 wpwp 是 web ping 的缩写. 顾名思义类似 sp 命令不断发送 http 请求, 帮助判断是否存活. Description: web ping Usage: ken wp \u003curl\u003e [options] Arguments: \u003curl\u003e url: https://www.kentxxq.com Options: -i, --interval \u003cinterval\u003e web ping interval seconds [default: 1] -t, --timeout \u003ctimeout\u003e default:2 seconds [default: 2] -d, --disableKeepAlive default: true [default: False] -f, --curlFile \u003ccurlFile\u003e if curlFile is not null ,Argument url will be ignore. default: '' [] --debug enable verbose output [default: False] # 每秒一次请求 ken wp https://baidu.com 09:51:24,https://baidu.com/: Redirect 245ms 09:51:25,https://baidu.com/: Redirect 37ms 09:51:26,https://baidu.com/: Redirect 40ms # 支持导入curl.如果导入了curl文件,https://a.com 将不会生效 ken wp https://a.com -f D:\\tmp\\curl.txt ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:2:9","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#网站连通性测试-wp"},{"categories":["blog"],"content":" 压测 bmbm 是 benchmark 的缩写. 用来进行压测 http 压测的. Description: http benchmark Usage: ken bm \u003curl\u003e [options] Arguments: \u003curl\u003e url: https://test.kentxxq.com/Counter/Count Options: -d, --duration \u003cduration\u003e duration: benchmark duration [default: 10] -c, --concurrent \u003cconcurrent\u003e concurrent: concurrent request [default: 50] -f, --curlFile \u003ccurlFile\u003e if curlFile is not null ,Argument url will be ignore. default: '' [] # 默认50并发,10秒钟.请求了3328次 ken bm https://test.kentxxq.com/counter/count 完成次数3328 ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:2:10","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#压测-bm"},{"categories":["blog"],"content":" 简介程序性能总是一个永恒的话题。各个系统、编程语言、算法、io 逻辑，总是不停的对比。今天在 csharp 闲逛的时候，看到了官方做的一个性能评测库，但是指标我却看不懂。于是就看了一会儿相关知识，准备记录一下。 ","date":"2021-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/benchmark%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/:1:0","series":null,"tags":["blog","csharp"],"title":"benchmark的数学知识","uri":"/posts/%E7%AC%94%E8%AE%B0/benchmark%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/#简介"},{"categories":["blog"],"content":" 程序说明抄了一个官方的 demo。很简单，就是在对比 md5 和 sha256 两者的性能。 using System; using System.Security.Cryptography; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; namespace Cli { public class Md5VsSha256 { private const int N = 10000; private readonly byte[] data; private readonly SHA256 sha256 = SHA256.Create(); private readonly MD5 md5 = MD5.Create(); public Md5VsSha256() { data = new byte[N]; new Random(42).NextBytes(data); } [Benchmark] public byte[] Sha256() =\u003e sha256.ComputeHash(data); [Benchmark] public byte[] Md5() =\u003e md5.ComputeHash(data); } class Program { static void Main(string[] args) { var summary = BenchmarkRunner.Run\u003cMd5VsSha256\u003e(); } } } ","date":"2021-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/benchmark%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/:2:0","series":null,"tags":["blog","csharp"],"title":"benchmark的数学知识","uri":"/posts/%E7%AC%94%E8%AE%B0/benchmark%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/#程序说明"},{"categories":["blog"],"content":" 输出分析首先需要将代码 release。因为这样会对代码进行优化。让我们的性能观测更加准确。 接下来就是查看我们的输出结果。 BenchmarkDotNet=v0.13.1, OS=Windows 10.0.22000 Intel Core i5-10210U CPU 1.60GHz, 1 CPU, 8 logical and 4 physical cores .NET SDK=5.0.400 [Host] : .NET 5.0.9 (5.0.921.35908), X64 RyuJIT DefaultJob : .NET 5.0.9 (5.0.921.35908), X64 RyuJIT | Method | Mean | Error | StdDev | |------- |---------:|---------:|---------:| | Sha256 | 48.94 us | 0.947 us | 1.197 us | | Md5 | 19.58 us | 0.356 us | 0.315 us | Mean : Arithmetic mean of all measurements Error : Half of 99.9% confidence interval StdDev : Standard deviation of all measurements 1 us : 1 Microsecond (0.000001 sec) Mean代表平均值。举例我们有 100 次样本，这时候 Mean=所有样本时间/100。也就是说可以看做是平均时间。 Error代表标准误差。标准误越小，样本均值和总体均值差距越小，那么样本数据就越能代表总体数据。标准误是多次抽样统计，量化了多组测量值均值的变化程度。因此用于推论统计，越小对 Mean 的结果推论越准确。 StdDev代表标准偏差。标准差越小，样本值之前的差别越小。标准差是一次抽样，量化了一组测量值的变化程度，用于描述统计。而我们的测试中用到了所有的样本 (all measurements)，所以这里我们可以知道 Mean 和实际请求时间相差多少 us。 ","date":"2021-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/benchmark%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/:3:0","series":null,"tags":["blog","csharp"],"title":"benchmark的数学知识","uri":"/posts/%E7%AC%94%E8%AE%B0/benchmark%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/#输出分析"},{"categories":["blog"],"content":" 总结我们通过结果和概念，可以得到以下信息 Mean 是此次性能测试的平均值。得到信息是：md5 是比 sha256 要快的。 Error 表明如果我们做更多的测试。sha256 所花费的时间，预计是 Mean 加减 0.947us。而 md5 预计是 Mean 加减 0.356us。得到的信息是：准确性还是不错的。 StdDev 表明在此次测试中，sha256 偏差是加减 1.197us。md5 偏差是加减 0.315us。得到的信息是：此次测试中每次花费的时间差别不大。 ","date":"2021-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/benchmark%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/:4:0","series":null,"tags":["blog","csharp"],"title":"benchmark的数学知识","uri":"/posts/%E7%AC%94%E8%AE%B0/benchmark%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/#总结"},{"categories":["blog"],"content":"recalbox 是一个游戏模拟器的合集 +kodi 媒体中心！是的，都集成到了一起是我选用它的主要原因。下面的内容都是在 [[笔记/point/树莓派|树莓派]] 上操作的.","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/"},{"categories":["blog"],"content":" 简介recalbox 是一个游戏模拟器的合集 +kodi 媒体中心！是的，都集成到了一起是我选用它的主要原因。下面的内容都是在 树莓派 上操作的. ","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 配置内容","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#配置内容"},{"categories":["blog"],"content":" 基础设置 中文显示:主菜单=\u003e系统设置=\u003e语言=\u003e确认选中语言 ip 地址查看:主菜单=\u003e网络设置=\u003eip地址 ssh 连接: ssh root@ip地址,密码 recalboxroot。但是有一点需要注意，recalbox 可以看作是一个独立的 linux 发行版。这意味着你无法使用 yum 或者 apt，也无法安装 npm 和 deb 包！ ","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#基础设置"},{"categories":["blog"],"content":" Web 配置系统管理界面: 用浏览器访问ip，默认就是访问 80 端口。 其中的控制器模拟界面，对于测试了解手柄非常有用。 ","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:2:2","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#web-配置"},{"categories":["blog"],"content":" recalbox 游戏这里我就讲一下大致的步骤吧，下载游戏的网站我也随便 贴一个，试过了没问题 下载一个游戏 rom 包，例如 马里奥.nes。这个文件名最后会变成 recalbox 里面的游戏名！！ 在 web界面 上传这个文件，重启 es 服务! nes 是 nintendo entertainment system 的简写，找到这个模拟器，就可以看到游戏了 ! ! ","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:2:3","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#recalbox-游戏"},{"categories":["blog"],"content":" 开机自启 vim /etc/init.d/S99ddns-go #/bin/bash /etc/init.d/kentxxq/ddns-go # 授予执行权限 chmod +x /etc/init.d/S99ddns-go ","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:2:4","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#开机自启"},{"categories":["blog"],"content":" kodi 配置主菜单=\u003ekodi媒体中心,系统会重启。kodi 和 recalbox 的键盘映射不一定相同！ kodi 中文设置 设置齿轮=\u003einterface=\u003eSkin=\u003eFont=\u003eArial based 同界面下，Regional=\u003eLanguage=\u003e简体中文 kodi 启用插件启用插件: 插件=\u003e我的插件=\u003ePVR客户端=\u003ePVR IPTV Simple Client=\u003e启用 使用直播源 去 github 上面 下载 需要的电视直播源文件。 默认 recalbox 通过 SMB协议共享 出来了我们需要的文件夹，我们可以直接访问进去。在 share/kodi 下面新建 m3u8 文件夹，然后把下载好的直播源文件放进去。 在插件 iptv 界面进入设置，选择本地文件 m3u。 点击 kodi 开关，退出。然后重新进入 kodi 进入电视就可以看是选台看电视了！ ","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:2:5","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#kodi-配置"},{"categories":["blog"],"content":" kodi 配置主菜单=\u003ekodi媒体中心,系统会重启。kodi 和 recalbox 的键盘映射不一定相同！ kodi 中文设置 设置齿轮=\u003einterface=\u003eSkin=\u003eFont=\u003eArial based 同界面下，Regional=\u003eLanguage=\u003e简体中文 kodi 启用插件启用插件: 插件=\u003e我的插件=\u003ePVR客户端=\u003ePVR IPTV Simple Client=\u003e启用 使用直播源 去 github 上面 下载 需要的电视直播源文件。 默认 recalbox 通过 SMB协议共享 出来了我们需要的文件夹，我们可以直接访问进去。在 share/kodi 下面新建 m3u8 文件夹，然后把下载好的直播源文件放进去。 在插件 iptv 界面进入设置，选择本地文件 m3u。 点击 kodi 开关，退出。然后重新进入 kodi 进入电视就可以看是选台看电视了！ ","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:2:5","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#kodi-中文设置"},{"categories":["blog"],"content":" kodi 配置主菜单=\u003ekodi媒体中心,系统会重启。kodi 和 recalbox 的键盘映射不一定相同！ kodi 中文设置 设置齿轮=\u003einterface=\u003eSkin=\u003eFont=\u003eArial based 同界面下，Regional=\u003eLanguage=\u003e简体中文 kodi 启用插件启用插件: 插件=\u003e我的插件=\u003ePVR客户端=\u003ePVR IPTV Simple Client=\u003e启用 使用直播源 去 github 上面 下载 需要的电视直播源文件。 默认 recalbox 通过 SMB协议共享 出来了我们需要的文件夹，我们可以直接访问进去。在 share/kodi 下面新建 m3u8 文件夹，然后把下载好的直播源文件放进去。 在插件 iptv 界面进入设置，选择本地文件 m3u。 点击 kodi 开关，退出。然后重新进入 kodi 进入电视就可以看是选台看电视了！ ","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:2:5","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#kodi-启用插件"},{"categories":["blog"],"content":" kodi 配置主菜单=\u003ekodi媒体中心,系统会重启。kodi 和 recalbox 的键盘映射不一定相同！ kodi 中文设置 设置齿轮=\u003einterface=\u003eSkin=\u003eFont=\u003eArial based 同界面下，Regional=\u003eLanguage=\u003e简体中文 kodi 启用插件启用插件: 插件=\u003e我的插件=\u003ePVR客户端=\u003ePVR IPTV Simple Client=\u003e启用 使用直播源 去 github 上面 下载 需要的电视直播源文件。 默认 recalbox 通过 SMB协议共享 出来了我们需要的文件夹，我们可以直接访问进去。在 share/kodi 下面新建 m3u8 文件夹，然后把下载好的直播源文件放进去。 在插件 iptv 界面进入设置，选择本地文件 m3u。 点击 kodi 开关，退出。然后重新进入 kodi 进入电视就可以看是选台看电视了！ ","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:2:5","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#使用直播源"},{"categories":["blog"],"content":" 疑难杂症","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#疑难杂症"},{"categories":["blog"],"content":" 操作系统架构recalbox7.1.1 是 armv7l 架构。 arm64 是 64 位，默认的话就是 arm32。所以 recalbox7.1.1 是 32 位. armv7 应该是可以运行 armv6 程序的，同理 armv8。 arm 默认都是小端存储。armv7l 就是后面的 l 就是小端的意思。 ","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:3:1","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#操作系统架构"},{"categories":["blog"],"content":" 无法 chmod 执行权限 # 重新挂载即可 mount -o remount rw / # 然后拷贝到/下面 cp x /x chmod +x x ./x ","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:3:2","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#无法-chmod-执行权限"},{"categories":["blog"],"content":" 图像显示溢出 # 当前我的版本是recalbox8: 去除黑边不一定有效，但是对图像溢出是有用的。 # 我在调整了很多次黑边距离，没有效果。虽然黑边不大，不太影响。 # 重新挂载/boot分区 mount -o remount,rw /boot # 编辑配置文件 su root /boot/config.txt disable_overscan=0 overscan_left=24 overscan_right=24 overscan_top=24 overscan_bottom=24 overscan_scale=1 # 重启生效 reboot ","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:3:3","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#图像显示溢出"},{"categories":["blog"],"content":"家里一直有一个树莓派在跑网盘备份, ddns, 以及使用 wol. 记录一下初始化的过程.","date":"2021-03-13","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/","series":null,"tags":["blog","树莓派"],"title":"树莓派初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["blog"],"content":" 简介家里一直有一个 树莓派 在跑网盘备份, ddns, 以及使用 wol. 记录一下初始化的过程. ","date":"2021-03-13","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/:1:0","series":null,"tags":["blog","树莓派"],"title":"树莓派初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/#简介"},{"categories":["blog"],"content":" 操作手册","date":"2021-03-13","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/:2:0","series":null,"tags":["blog","树莓派"],"title":"树莓派初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/#操作手册"},{"categories":["blog"],"content":" 刷机直接去 官网下载 imager，然后安装后。就可以通过图形界面选择需要的系统了。但是因为网络太慢，所以我直接去 ubuntu官网下载 镜像文件，然后 use custom 写入 tf 卡。 ","date":"2021-03-13","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/:2:1","series":null,"tags":["blog","树莓派"],"title":"树莓派初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/#刷机"},{"categories":["blog"],"content":" ssh 通过路由器或者 ip 扫描工具拿到 ip，然后 ssh 上去会提示修改密码 默认密码是 ubuntu ","date":"2021-03-13","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/:2:2","series":null,"tags":["blog","树莓派"],"title":"树莓派初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/#ssh"},{"categories":["blog"],"content":" 替换国内源文件位置 /etc/apt/sources.list。 # 备份 sudo mv /etc/apt/sources.list /etc/apt/sources.list.bak # 创建文件 sudo vi /etc/apt/sources.list deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-security main restricted universe multiverse 更新: sudo apt update -y 升级: sudo apt upgrade -y ","date":"2021-03-13","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/:2:3","series":null,"tags":["blog","树莓派"],"title":"树莓派初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/#替换国内源"},{"categories":["blog"],"content":" wifi 配置进行配置 vim /etc/netplan/50-cloud-init.yaml。 但是 wifi 每次获取到的 ip 可能是不一样的，所以我们应该在路由里面把 ip 和 mac 地址进行绑定，保证 ip 地址不被会其他机器占用！！ network: ethernets: eth0: dhcp4: true optional: true version: 2 wifis: wlan0: optional: true access-points: \"TP-LINK_1D88\": password: \"123456781\" dhcp4: true ","date":"2021-03-13","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/:2:4","series":null,"tags":["blog","树莓派"],"title":"树莓派初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/#wifi-配置"},{"categories":["blog"],"content":"公司先阶段使用的是通过ansible来进行多服务器的部署。而微信小程序开发者工具官方只放出来了windows和mac版本。macOS老早就听说虚拟机需要超高的配置，而且也会很卡。自己也没有操作过，对mac的虚拟机没什么兴趣。估计以后也用不大上。否则也不会有那么多人去用黑苹果了。所以就开始了这次在windows机器上的踩坑之旅","date":"2020-02-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/","series":null,"tags":["blog","devops","部署"],"title":"微信小程序自动化部署","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"},{"categories":["blog"],"content":" 简介公司先阶段使用的是通过 ansible 来进行多服务器的部署。而微信小程序开发者工具官方只放出来了 windows 和 mac 版本。 MacOS 老早就听说虚拟机需要超高的配置，而且也会很卡。自己也没有操作过，对 mac 的虚拟机没什么兴趣。估计以后也用不大上。否则也不会有那么多人去用黑苹果了。 所以就开始了这次在 windows 机器上的踩坑之旅。 ","date":"2020-02-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/:1:0","series":null,"tags":["blog","devops","部署"],"title":"微信小程序自动化部署","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#简介"},{"categories":["blog"],"content":" 基本环境介绍本次操作是在 win 10 上进行的。 远程操作使用的 jenkins 是 Ubuntu 系统。 ","date":"2020-02-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/:2:0","series":null,"tags":["blog","devops","部署"],"title":"微信小程序自动化部署","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#基本环境介绍"},{"categories":["blog"],"content":" 远程操控端 Ubuntu 环境搭建默认 linux 都是有 python 环境的。但是不一定有 pip。这是 python 的一个包管理工具。很多需要用到的工具包，都需要用 pip 来进行安装。 操作步骤 在 Ubuntu 中，可以使用 apt install python-pip 命令安装。 输入 pip 命令，确认安装完成。 Pip install pywinrm ","date":"2020-02-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/:2:1","series":null,"tags":["blog","devops","部署"],"title":"微信小程序自动化部署","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#远程操控端-ubuntu-环境搭建"},{"categories":["blog"],"content":" Win 10 被控端环境搭建由于 windows 和 mac/linux 不一样，没有 ssh 远程连接。所以 ansible 是通过 pywinrm 模块，进行操作的。 系统要求 Net 要 3.0 以上。在 powershell 输入 $host 获取 net 版本。 Powershell 也要 3.0 以上。在 powershell 输入 $psversiontable 获得 ps 版本。 系统推荐使用 win 10。 操作步骤 Set-executionpolicy remotesigned (可以用 get-executionpolicy 验证) 下载并使用管理员 powershell 运行 此配置脚本 Winrm quickconfig 快速配置启用 Winrm set winrm/config/service ‘@{AllowUnencrypted=“true”}’ Winrm set winrm/config/service/auth ‘@{Basic=“true”}’ ","date":"2020-02-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/:2:2","series":null,"tags":["blog","devops","部署"],"title":"微信小程序自动化部署","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#win-10-被控端环境搭建"},{"categories":["blog"],"content":" 在 ansible 脚本内配置变量 [windows] 1.1.1.1 [windows:vars] ansible_ssh_user=username ansible_ssh_pass=password ansible_ssh_port=5985 ansible_winrm_transport=ntlm ansible_connection=winrm ansible_winrm_server_cert_validation=ignore ","date":"2020-02-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/:2:3","series":null,"tags":["blog","devops","部署"],"title":"微信小程序自动化部署","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#在-ansible-脚本内配置变量"},{"categories":["blog"],"content":" 具体流程由于很多东西不方便直接贴代码，所以这里列出大概的流程 Jenkins 拉下代码以后，开始执行 ansible 脚本。(在 jenkins 内部把用户名和密码等变量写好，通过 –extra-vars 方式传递) 通过 win_file 模块创建文件夹，win_copy 模块拷贝代码到 windows 机器上。 - name: 拷贝最新代码到win目录 win_copy: src: \"/local_workspace_path/\" dest: D:\\wechat_workspace\\{{ build_number }} 用 win_command 来安装依赖。构建代码同理。 - name: 在win上安装依赖 win_command: cmd.exe /c npm i args: chdir: D:\\wechat_workspace\\{{ build_number }} 开始部署 - name: 尝试开始部署 win_command: cmd.exe /c mini-deploy args: chdir: D:\\wechat_workspace\\{{ build_number }}\\dist 把预览图拷贝到本地 - name: 把生成的预览图片拷贝到本地 fetch: src: D:\\wechat_workspace\\{{ build_number }}\\dist\\preview.png dest: \"/local_workspace_path/preview.png\" flat: yes 通过 base 64 获取图片 encode 编码，md 5 sum 获取图片的 md 5 值。通过 curl 发送到企业机器人，群内就可以通过扫码进行代码代码测试了。 ","date":"2020-02-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/:3:0","series":null,"tags":["blog","devops","部署"],"title":"微信小程序自动化部署","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#具体流程"},{"categories":["blog"],"content":" 问题处理","date":"2020-02-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/:4:0","series":null,"tags":["blog","devops","部署"],"title":"微信小程序自动化部署","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#问题处理"},{"categories":["blog"],"content":" Npm i 的安装问题Npm 在 install 过程过，有需要调用 node 命令。因为存在微信 node 和本身环境的 node，会出现问题，需要通过如下指令进行配置！ npm config set scripts-prepend-node-path true ","date":"2020-02-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/:4:1","series":null,"tags":["blog","devops","部署"],"title":"微信小程序自动化部署","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#npm-i-的安装问题"},{"categories":["blog"],"content":" Mini-deploy 的问题Mini-deploy 代码中默认设置查找路径为 wxPaths = ['C:\\\\Program Files (x86)\\\\Tencent\\\\微信web开发者工具\\\\cli.bat', 'C:\\\\Program Files\\\\Tencent\\\\微信web开发者工具\\\\cli.bat'] 然后去注册表 REG QUERY \"HKLM\\\\SOFTWARE\\\\Wow6432Node\\\\Tencent\\\\微信web开发者工具 查询真正的安装位置，放在数组的第一位作为启动项。 由于微信开发工具默认安装到 c 盘，路径中包含有空格，在 ansible 的执行过程中，会出现报错。 于是改动到了 D 盘。于是路径出现了问题。 最终在 wxPaths 中新增了一个路径，顺利完成。 ","date":"2020-02-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/:4:2","series":null,"tags":["blog","devops","部署"],"title":"微信小程序自动化部署","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#mini-deploy-的问题"},{"categories":["blog"],"content":" 无法删除 dist，最终代码文件夹长期开启小程序工具，每一次的代码都存放到不同的文件夹。只能以后再去删除了。 ","date":"2020-02-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/:4:3","series":null,"tags":["blog","devops","部署"],"title":"微信小程序自动化部署","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#无法删除-dist最终代码文件夹"},{"categories":["blog"],"content":" 微信机器人 base 64 的问题由于 base 64 数据量大，发送的请求数据不可读。所以这个问题折腾了我差不多 3 个小时。 Base 64 命令默认会有一个 w 参数为 76，导致换行。上传后的 base 64 数据就会与 md 5 校验码不同。 需要添加参数，具体命令为 base -w 0 preview.png ","date":"2020-02-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/:4:4","series":null,"tags":["blog","devops","部署"],"title":"微信小程序自动化部署","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#微信机器人-base-64-的问题"},{"categories":["blog"],"content":" 补充说明 推荐先了解 scoop，类似于 centos 的 yum、Ubuntu 的 apt 命令。可以很方便的安装和卸载所需的工具。例如 wget、git、python、nodejs、java 等常用命令。 所有 win_command 需要使用 cmd.exe /c dir 这样的方法调用，可以避免很多问题。 Shell 代码内，一对双引号，里面包一对单引号。在单引号内就可以通过 $ 符号使用变量。 Ansible 的 fetch 可以用来同步回本地单个文件。无论是 linux 或 windows ","date":"2020-02-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/:5:0","series":null,"tags":["blog","devops","部署"],"title":"微信小程序自动化部署","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#补充说明"},{"categories":["blog"],"content":"虽然现在的互联网公司都流行mysql这样的免费数据库。但是在各行各业oracle还是非常主流的选择。无论是否有授权，很多的数据迁移都是在oracle之间进行的。所以这篇文章用来迁移一下自己的笔记，并进行梳理","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/","series":null,"tags":["blog","oracle"],"title":"oracle数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"},{"categories":["blog"],"content":" 简介虽然现在的互联网公司都流行 mysql 这样的免费数据库。但是在各行各业 oracle 还是非常主流的选择。无论是否有授权，很多的数据迁移都是在 oracle 之间进行的。 所以这篇文章用来迁移一下自己的笔记，并进行梳理。 ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:1:0","series":null,"tags":["blog","oracle"],"title":"oracle数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#简介"},{"categories":["blog"],"content":" 开篇说明我喜欢东西精简而不出错。所以尽量不给自己找麻烦。 所以很多的命令参数，但是我都没有用上。主要是因为在我的使用过程中，没有解决多余的问题，或者说没有提升体验。 ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:2:0","series":null,"tags":["blog","oracle"],"title":"oracle数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#开篇说明"},{"categories":["blog"],"content":" plsql_developplsql 是一个收费软件。但是国内你懂的，非常多的破解和绿色版。在我遇到的公司中，都是统一使用的工具。 ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:3:0","series":null,"tags":["blog","oracle"],"title":"oracle数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#plsql_develop"},{"categories":["blog"],"content":" 特点 适用于数据量不大的操作。非常简便。如果只是几千条数据，甚至我经常复制粘贴来处理日常工作。 有自己的 pde 格式。可以导出导入 tables 数据。 同时支持文本导入器。例如打开一个 csv 文件。然后通过字段映射，导入 oracle。 ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:3:1","series":null,"tags":["blog","oracle"],"title":"oracle数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#特点"},{"categories":["blog"],"content":" exp 和 imp一个历史悠长的工具。但是操作简单，oracle 自带。 在我交接数据的过程中，生成 dmp 结尾文件几乎是统一标准。 ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:4:0","series":null,"tags":["blog","oracle"],"title":"oracle数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#exp-和-imp"},{"categories":["blog"],"content":" 特点 适合统一的 oracle 的环境操作。 你需要关注字符集问题 (源数据库字符集、导出端字符集、导入端字符集、目标数据库字符集)。 高版本兼容低版本，但是反之则不然！ ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:4:1","series":null,"tags":["blog","oracle"],"title":"oracle数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#特点-1"},{"categories":["blog"],"content":" exp 表模式 # 导出数据。不导出索引。指定导出表名 exp user/pawd rows=y indexes=n file=path/exp.dmp log=exp.log tables=tab1,tab2,tab3 ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:4:2","series":null,"tags":["blog","oracle"],"title":"oracle数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#exp-表模式"},{"categories":["blog"],"content":" exp 用户模式 # 指定导出用户 exp user/pawd owner=user rows=y indexes=n file=exp.dmp log=exp.log ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:4:3","series":null,"tags":["blog","oracle"],"title":"oracle数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#exp-用户模式"},{"categories":["blog"],"content":" exp 完全模式 # 需要用高权限用户，然后导出全库。用到的极少。 exp user/pawd rows=y indexes=n full=y file=exp.dmp log=exp.log ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:4:4","series":null,"tags":["blog","oracle"],"title":"oracle数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#exp-完全模式"},{"categories":["blog"],"content":" imp 导入方法 # 指定以前的用户名，导入到现在的用户名。不导入索引 # 可以指定导入的表名 # ignore=n 可以忽略创建错误，直接追加数据 # commit=y 可以定量提交。否则会占用大量的回滚空间后一次性提交 # 不加表名默认导入所有。适合用户模式。如果再加上full=y，那么就是全库导入了 imp user/pawd fromuser=user touser=pawd rows=y indexes=n commit=y file=exp.dmp log=imp.log tables=t1,t2,t3 ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:4:5","series":null,"tags":["blog","oracle"],"title":"oracle数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#imp-导入方法"},{"categories":["blog"],"content":" expdp 和 impdp这是一个比较新的 oracle 自带工具。更加强大易用。 但是运维方面你懂的，很多都是老油条了。所以主要用来自己处理工作中的问题。 ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:5:0","series":null,"tags":["blog","oracle"],"title":"oracle数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#expdp-和-impdp"},{"categories":["blog"],"content":" 特点 性能好，速度快 可以远程通过网络导入导出！ 提供参数跨 oracle 版本导入导出 ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:5:1","series":null,"tags":["blog","oracle"],"title":"oracle数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#特点-2"},{"categories":["blog"],"content":" 前提条件expdp 和 impdp 都需要在数据库中指定目录。oracle 自带也有目录给你用，但是我推荐自己放一个容易找的地方。 create directory dump_path_name as '/path/backup'; 如果你不是在 oracle 服务器上操作，则需要在本地 oracle 建立 dblink。然后通过参数 network_link 参数进行操作。 ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:5:2","series":null,"tags":["blog","oracle"],"title":"oracle数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#前提条件"},{"categories":["blog"],"content":" expdp 使用方法 expdp system/123456 # 指定用户接收数据 schemas=xiangxi directory=EXPDP_DIR # 不需要统计信息，源数据库的统计信息可能会让目标数据库的查询策略改变，可能影响性能。 # 还可以加上indexes等等，加快导出速度。 exclude=STATISTICS # 并行导出，速度翻倍！ parallel=4 # %U可以让文件自动从01,02...来命名，主要用来配合上面的并行参数。 dumpfile=xiangxi20160726_%U.dmp logfile=xiangxi20160726.log # 可以过滤指定目标表的数据 query='xiangxi.T_SYS_LOGS:\"WHERE 1=2\"' # 指定按照什么版本的dmp格式导出 version=11.2.0.1.0 # 用来处理用户名不一致 remap_schema=old_schema:new_schema # 用来处理表空间不一致 remap_tablespace=old_tablespace:new_tablespace # 表如果存在，就跳过。还可以truncate清空表。APPEND追加。REPLACE替换。 TABLE_EXISTS_ACTION=SKIP # network_link=dblink_name用来远程导出。 ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:5:3","series":null,"tags":["blog","oracle"],"title":"oracle数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#expdp-使用方法"},{"categories":["blog"],"content":" impdp 使用方法 # 可以看到几乎相同。都是根据对应的expdp导出方法来进行参数设定 impdp xiangxi2/123456 directory=EXPDP_DIR dumpfile=xiangxi20160726_01.dmp,xiangxi20160726_02.dmp,xiangxi20160726_03.dmp,xiangxi20160726_04.dmp remap_schema=old_schema:new_schema version=11.2.0.1.0 parallel=4 ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:5:4","series":null,"tags":["blog","oracle"],"title":"oracle数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#impdp-使用方法"},{"categories":["blog"],"content":" 如何中止 expdp查看任务状态 select job_name,state from dba_datapump_jobs; 连接进去，看以查看状态 expdp \\\"sys/oracle as sysdba\\\" attach=SYS_EXPORT_SCHEMA_02 停止任务 stop_job=immediate 干掉人物 kill_job ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:5:5","series":null,"tags":["blog","oracle"],"title":"oracle数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#如何中止-expdp"},{"categories":["blog"],"content":" 总结其实只是一次笔记的搬迁整理。不过也正好巩固了一下知识。 后续可能还会追加信息，不过数据的交接已经足够使用了。 ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:6:0","series":null,"tags":["blog","oracle"],"title":"oracle数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#总结"},{"categories":["blog"],"content":"我对电子产品或者说科技产品真的是有极大的热忱，所以打算写下来看法以及推荐","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/"},{"categories":["blog"],"content":" 简介lines 我对电子产品或者说科技产品真的是有极大的热忱，所以打算写下来看法以及推荐。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:1:0","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#简介"},{"categories":["blog"],"content":" 快乐时光 小霸王 我的第一件个人电子产品，应该是小霸王学习机吧。就是成龙打过广告的那个。 我说是可以用来打字，提升自己的打字速度。于是我的外公买给了我。要不是写这篇博客，我可能都不会记得这件事情。当时是在衡东老汽车站的十字路口，那个店子卖磁带，光盘，以及各种电子产品，我觉得特别新奇。 当时我几乎没怎么摸过键盘。买回来以后，发现这些打字游戏真的是太难了，开始了和院子里的小伙伴们玩耍之路。。我觉得那是那个年代里最有性价比的东西了。。 因为街机厅里的游戏我只会打飞机游戏 - 雷电，还要买币。。 杂牌手机 在我读书的时候。用过好几款手机。都是因为在读书时候开始贪玩，不爱学习。喜欢和女同学聊天。。然后用自己从爸妈那拿来的零花钱买了好几次手机 - 小灵通。 100-200 元，可以 wap 上网。当时很流行 qq 空间的抢车位和偷菜游戏，我玩得不亦乐乎。可以说这一点钱，让我的学生生活丰富了好多倍。我的手机随时可能收到的消息，立马会改变我的想法，或者接下来的几个小时。 oppo A113 读书的时候，用的最后一款手机。也是干坏事拿家里钱买的。当时的手机可以后台挂 qq，加上 oppo 主打音乐手机。外观也硬朗，于是就买了。当时也算是最拉风的手机之一了吧。 诺基亚6730c 我在一次短暂的打工旅途中。买过 2 台手机。这台设备的使用寿命是短暂的。。我是因为想和一个女同学买同样的手机，入手的。结果第二天就被偷了。很可惜。很怀念。 诺基亚5800XM 因为丢掉了 6730c，于是买了这个手机。这是我打工回家的最后一个月工资买的。到家的时候，只有 30 块了。 这也是我第一次用触屏手机。感觉非常棒。算是第一代真正意义上的智能机了。当时也还有更厉害的型号，但是我觉得很前卫。 mp3~mp4 我在一次听过我表哥的 mp3(U 盘形状，128MB) 以后。怼着我爸去买。然后到了柜台，发现了一个带 2.4 显示屏的 mp3。为什么不是 mp4 呢？因为他只支持 wmv 格式。而当时 mp4 和 rmvb 格式已经流行开来了。而我转换为 wmv 格式后还需要 90 度调整方向，否则不能全屏播放，因为屏幕太小了，根本啥都看不到。同时 256MB 的存储，限制了我只能看看 mv，电影就别想了。而我当时并不知道，只觉得别人的吊~ 本来是我妈带我去永意买，结果我爸爸怕我妈会惯着我，一定要他带我去。结果买回来一个贵的。我爸反而被骂了一顿。。哈哈哈。 我记得我在回来的路上，带上了耳机。在马路中央，我像是听到了天空远处的音乐，那感觉太神了。肯定是我的脑放加成，因为现在来看就是电子垃圾。也因为没看车，被我爸买了一通。 后面我在读书的时候，自己用零花钱买了一个橡皮擦大小的 mp3，但是有黑白显示屏和黄光灯。可以显示 3 排文字，我用它一边听歌，一边看完了饶雪漫和郭敬明的小说。结果当然是被发现了，老师没收后我就再也没见过它。 家人的手机 我在小学的时候，我爸外出去了福建打工。给我带了礼物 - 可充电电池。当时我非常爱玩具四驱车，强大的电量让我的车比别人跑的快多了。而他带回来了一部非常小巧神奇的手机 -诺基亚8210。 它可以更换前后盖、电池。我爸买了 3 个左右的外壳。一两个月就换一次。就像是换了新手机。同时手机非常小巧，简洁。质量也是无敌的存在。记得那时候，电视上好多人物都用这个手机呢。并且不像现在手机都给了赞助。当时大家是真的觉得诺基亚好。 后来慢慢有了彩屏手机。我爸也换了一个 诺基亚3230。 记得买来的第一个下午，我爸还没捂热。我就用手机 wap 上网花掉了我爸爸好几十的话费。我爸要去学车，我都不给他。我妈说我爸的不是，于是我爸便没带手机出了门。我当时也非常担心自己让爸爸窝火了。后来其实没事。父亲对年幼贪玩的我，是有很多忍让和爱的。 我爸其实是诺基亚的粉丝。但是随着诺基亚的没落，他开始不再用诺基亚。我写到这的时候，觉得我爸似乎也慢慢在退出历史舞台。话语权和选择权落到了我这样的年轻人。谁年轻的时候没有追求呢？我应该认识到这一点，让自己的人生精彩起来。也要让我的爸妈过上好生活。 很遗憾的是我不记得了我妈妈这段时间用的是什么。妈妈在我的生命中如此重要，可我不记得了好多好多的细节，很是遗憾。 老式磁带机 我刚有记忆的时候，我妈在房间抹粉同时催我起床。可我不起来。于是我妈便会打开超大的老式磁带机催促我起来。听了多了，我也会唱好多歌，一下子就会暴露年龄，哈哈哈。样子大概如下!(老式磁带机)[/images/lines/老式磁带机.png] 我用它听了超级多周杰伦的磁带。 客厅系列 我的家里是院子里一个拥有 21 寸彩电、双立式音响、vcd+ 功放的。还有卡拉 ok。 于是我小时候经常和爸妈在家里唱歌。我甚至是在好几年以后，才知道别人家没有！现在想起来，别人应该都很羡慕小时候的我。 在我家不远，就有一个店子租盗版碟。我爸经常租，而我只能在 8 点半去睡觉。。但我还是看了好多电影，多是成龙和李连杰的。我还记得看过一个蜘蛛侠的电影。结果是一个恐怖片，假的蜘蛛侠。。当时我就觉得蜘蛛侠垃圾，现在想想，那年代谁知道盗版还有不对版的电影呀！ ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:2:0","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#快乐时光"},{"categories":["blog"],"content":" 上班准备我带着这个手机去的深圳上班。当时的 iPhone 已经非常有名气，但是 4999 的价格真是贵的离谱。三星也贵。小米和魅族都进入了我的视野。 魅族的mx2 魅族的系统外观和小众精品路线，让我非常喜欢。并且一开始觉得小米品牌低端。我更加认品牌和外观设计。 不过之后同学就买了一个小米手机，对比了速度。比小米慢。。。但我还是说服自己，魅族的设计和外观真的好很多。 现在那台手机已经不能开机了。白色的后盖烫得泛黄。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:3:0","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#上班准备"},{"categories":["blog"],"content":" 上班以后我上班以后，开始觉得自己开始有钱了。便觉得好多东西忍一忍，都能买下来。给自己买了不少的品牌货。手机当然也是一样。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:4:0","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#上班以后"},{"categories":["blog"],"content":" iPhone5s当时我还记得都用起了微信，而微信 5.0 推出了一个新功能 打飞机。刷爆了朋友圈。我还是用的魅族 mx2，而安卓版本的打飞机要在几天后才能更新。一下子，像是拉开了安卓和 iOS 的待遇差距。于是我在第一个月工资到账后，买了一台 iPhone5s。当然了，我借了钱。 当时是一个土豪金颜色要过万。好多的奸商囤货，赚的盆满钵满。我没记错的话，黑色版本不好看。然后买了白色 5888 还是 6888 来着。去的华强北买的港版。因为我当时已经知道香港那边的价格会便宜一些。且我在查资料的时候，发现港版支持 4g 网络！这也是为什么 iPhone5s 我能用到前年 (2017) 年的原因。 评价如下: 从 mx2 换到 iPhone5s，只是屏幕变得修长了，显示面积并没有变大。但是显示效果好了不少。 应该不是第一款指纹识别的手机。但是苹果作为手机标杆。其他厂商后续的机型都立马跟进了。而我也算是第一批用上了指纹识别的人。 性能很强。感觉就是非常流畅。拍照效果非常好。生态也是非常的好。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:4:1","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#iphone5s"},{"categories":["blog"],"content":" 小米 6转眼就到了 2017 年，我的 iPhone5s 在平时的使用过程中，真的是有点卡卡的。且从我起床开始，就开启了省电模式。让我养成了少用手机的习惯。但真的是不好用了。 我开始物色手机。苹果太贵了，且连续了好几代没有外观更新。或者说对我来讲，没有实质性的更新。当时的想法是屏幕大一些罢了。 之前一直有一个根深蒂固的概念，安卓慢。用久了就会卡。但是用同时的三星 note 系列时候，却发现响应很快。让我有了改观。同时我也去了实体店体验。于是有了让我换安卓的想法。有担心用个 1-2 年就卡了，于是我的第一想法是要有性价比。 小米当时还是性价比路线。而红米也是一个低端机路线，目的是干掉功能机。于是我买了小米 6。价格是 2558。 评价如下: 性能很好。我喜欢傻快的感觉。在开发者选项里把动画等等特效调成了 0.5x 速率。 拍照不够好。甚至对比 iPhone5s 都觉得不如。不过我的拍照需求不高，只是每次用到的时候，都感叹拍照真烂。 价格确实不错。且 MIUI 系统好用。刷国际版用谷歌。挂着 ss 且续航也好。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:4:2","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#小米-6"},{"categories":["blog"],"content":" 小米 a1也就是在我换了安卓以后的几个月。我开始迷上了谷歌，或者说是谷歌生态。之后也愈发离不开谷歌生态。 MIUI 的国际版虽然很不错，但是和原生还是有差距。我这里的原生是说的 pixel 这样的亲儿子系统。 于是关注到在一个安卓的 Android One/Go 计划。在印度小米和谷歌联合开发了一款手机 a1。系统除了相机部分，都是谷歌来负责的。其实我更希望谷歌来做相机。毕竟谷歌在当时的算法，说独步天下也不为过。 于是我把小米 6 给了我爸。自己入了小米 a1，价格 1368。小米 6 一直到现在 (2019 年末) 都非常好用。甚至可以说完全超出了我爸的性能需求。 拿到手后，折腾了好久。评价如下: 第一点就必须指出缺点 - 续航严重不足。很大关系是我开着 ss 功耗极高。哪怕是 625 这样以续航闻名的 soc，都没有办法。 系统是真的好用。一直都现在，我都依托着谷歌生态。 拍照、性能什么的因为硬件原因，比小米 6 要差不少。但是系统好，所以流畅度可以接受。前几个月 (2019 年 8 月) 拿给了我妹用，非常够用。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:4:3","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#小米-a1"},{"categories":["blog"],"content":" iPhone X我在换成了小米 a1 以后，只体验到了完整的谷歌生态。却几乎把其他的特性都给丢了。于是一直耿耿于怀，不甘心。在一次喝醉以后，我和同事在晚上大约 10 点的时候去了解放西。说要是有手机店现在还开着，我就买了。于是就这样给了自己一个理由。 为什么选 iPhone X 呢？因为 iPhone 终于大更新了。并且定型了以后，可以确认的是很久时间都不会变。到现在 (2019 年 12 月) 也证明我是对的。只是价格还是那么高高在上。7200 入手的美版，我是真的傻。明明这个价格可以在网上买到国行版本了。 评价如下: 因为是美版的 iPhone X，所以是因特尔基带。型号是真的差！而国行是高通基带。这也是我说我 7000+ 买美版傻逼的地方。 性能没的说。拍照和摄像都是顶级的。又开始觉得 iOS 吊打安卓了。。而且也能继续使用谷歌全家桶。只是没有那么深度的集成。 面部识别确实比指纹要好用。只是当时速度还不够快。现在 iOS 13 已经非常快了。同时新款手机因为 SOC 的升级，也会快上加快。 苹果也算是一改之前越用越慢的特性。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:4:4","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#iphone-x"},{"categories":["blog"],"content":" HIFI 套装在我从深圳回湖南的时候，在家里带我妹妹 2 个月。入了 hifi 的坑。 在我塞上耳朵后，觉得以前的歌都白听了。每个歌都戴上了更多的感情。而且细节部分太强了。我也懂了什么叫声场、音色等等。 评价: 我买的机器智能读取 tf 卡内的信息。无法直接在网上下载歌曲。所以每个月我都会找歌，特别麻烦。 是否需要飞傲这个前端，对我来说区别并不是那么大。但是达音科的耳机确实不错。没有过多的染色。而且耳机好推。好的耳机重要过前端。 由于慢慢很多手机都没有了耳机孔。于是我卖给了同事。。换上了 AirPods。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:4:5","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#hifi-套装"},{"categories":["blog"],"content":" 20191210 现状","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:5:0","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#20191210-现状"},{"categories":["blog"],"content":" 红米 k20proiPhone X 其实是可以支撑我一直用到 5G 时代的。但是我换掉了。理由就是续航、信号是真的差，让我经常担忧。 而我要是换到 k20 pro 呢？以旧换新，新的手机还能赚回来钱。把 airpods 一起退掉。用买手机送的无线蓝牙耳机。可以赚 1500 回来了。。于是我就换了。 我的考量如下: 性能没毛病，拍照小米也更上了，全面屏，内存和存储够用，价格香，信号和续航蛮不错的。 小米给我的印象不错，MIUI 蛮好用的。 iOS 的应用开发太麻烦了。一段时间后开发者证书就会过期。而安卓不会这样。且开发方便。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:5:1","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#红米-k20pro"},{"categories":["blog"],"content":" macbook pro2016在我的学生时代，用的联想 g450 笔记本。是一款质量过硬的产品。一直到现在都还在家里服役。给我妹妹玩我的世界。 但就像我之前没有用过 iOS 系统一样。我没有用过 MacOS 系统。虽然对 linux 有使用经验，但不熟练。对类 Unix 系统的哲学思想也是非常喜欢。 我买的 2016 刚刚推出的带 touchbar 256gb 13.3 寸版本。 评价如下: 在我搭配苹果生态使用的时候，真的很强。而且 iOS 开发必须要用到 macOS 系统。 系统速度快。和 iOS 一样流畅。对开发非常友好，甚至可以说是真正的傻瓜式。 雷电口拓展性好，但是需要很多转接头。不过 TypeC 是趋势。 重量轻，好携带。触控条好用。 键盘容易卡碎屑。touchbar 容易卡死等等小毛病。 虽然让我成长了很多。但真是贵，让我花了大价钱。哪怕现在想退掉，也会觉得亏。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:5:2","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#macbook-pro2016"},{"categories":["blog"],"content":" 99 块的红米无线耳机现在的手机已经在慢慢去掉了耳机孔。而且无线耳机也做到了白菜价。而我的这个还是送的。 评价如下: 比起来 AirPods 还是要难用不少。但是便宜，能将就。 因为之前听 hifi 级别的音质，所以从 AirPods 开始我就打算听个响完事了。无所谓音质了。 续航还不错。我听得也没以前多了，但是够用。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:5:3","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#99-块的红米无线耳机"},{"categories":["blog"],"content":" 家里我爸用的是小米 6. 我妹用的小米 a1. 我妈用的红米 5 plus。当时开始流行全面屏概念。其实也就是 18:9 的屏幕。当时我买的时候，觉得蛮不错的。我妈现在也都一直在用。不过估计明年我会给她换手机。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:5:4","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#家里"},{"categories":["blog"],"content":" 20191210 展望现在我越来越觉得我不是在用单一的电子产品，而是在选择自己的生态。来决定自己的科技生活。 各家也开始在生态上发力。估计以后只专攻手机的厂商会慢慢陨落下去。现在就来说下我的考量和对现状的想法吧。不过我也只会说几个我关注的重点。因为其他的我都不看好。 苹果 是一个有着比较悠久历史的公司。特别是在终端产品方面。一直在通过自己的观点，贯彻自己的产品路线。同时通过非常强势的生态管控，第三方开发者也一直跟进变化。从而一直让苹果保持优质体验。 iPhone 一直有小问题，例如信号、续航、充电速度等等。但是总体而言素质非常高。 mac 有着非常好的流畅体验。优秀的外观设计与体验。对开发者相当的友好。 ipad 是平板里生态和功能最好的，没有之一。同时随航功能搭配 macOS，极大的拓展了使用场景。云计算作为未来的趋势，ipad 的能力会越来越强。 AirPods 优秀的使用体验。 这一系列的产品线，全部都联动了起来。打造了一个平均不低于 80 分的生态圈。 华为 自从开始在终端发力以来。现在也开始推出生态圈。虽然暂时不如苹果好用，但是发力快。 华为/荣耀手机都使用自研的 SOC，体验虽不如高通和苹果。但是现在除了游戏场景，性能过剩还是比较严重的。没什么问题。相机其实没有那么夸张的厉害，但是顶级水准。UI 方面其实不怎么样。但是多屏协同是真的好。 电脑方面高端产品个人感觉溢价严重。magicbook pro 等产品还是不错的。但是留了 2.5 英寸的硬盘位，我就觉得很傻。感觉我并不是华为的消费群体。 平板的电脑模式和平行世界非常不错。有效提高了平板的使用体验。同时也能多屏协同。要不是因为安卓和 windows 的联动不如苹果生态，我觉得是比苹果还要强的。 总的来说，产品的平均分也挺高的。但是生态比起来差不少，毕竟也才刚起步。且暂时看来，华为一家公司很难做成这个生态。而且在现在这个时间点，华为无法使用谷歌 service。是一个非常大的痛点。 小米 在最开始是性价比路线。IOT 生态方面算是国内做的最好的。上到空调、投影仪、电视等大型家电，下到魔方、水性笔、指甲刀。 手机的 MIUI 算是国内最好用的安卓 rom 了。同时很多好用的地方。硬件方面基本都是最好的。或者说同价位最好的。非常不错 电脑走性价比路线，挺不错的。外观很简洁。 而手表，平板等等电子产品。我都觉得可以归类到生态里。生态数量非常多，家居也特别强。但是联动性是属于非常多，而不是那种个个都极度精致。一旦别人抄起来，也会特别快。 小米的生态现在应该要开始深耕体验了。把内核做好，护城河才会高。同时性价比的标签，会让更多人把第一次选择留给它。 谷歌 是我在做了好久混子程序员以后才了解到的公司。但是自从接触以后，就再也离不开了。 但是由于谷歌在国内被墙。所以谷歌的硬件一直都不能再国内有好的体验。同时谷歌善于软件方面，但是在硬件方面是真的不怎么样。 哪天谷歌在国内完全正常了。我会很乐意使用他。但现在还不是时候。同时谷歌作为一个软件服务商，在各平台都有方案。也就没有那么着急了。 三星 在我还小的时候，就觉得是大公司作风。大了以后才知道三星是一个帝国。 三星有军工、日用产品、家电、芯片、船坞、代工等等业务。整个韩国就是三星帝国的天下。我也多多少少都会接触到三星的电子产品。 手机三星一直是机皇般的存在，但是在中国份额已经掉到了其他。即使配置一流，顶级屏幕。体验也优秀。但是价格太高，却拉不开多少差距。或者说没有 get 到国人的 G 点。 因为屏幕好，内存好，固态好。所以如果想要顶级的体验，我肯定会选择三星的设备。但是三星在市场颓废的同时，也开始为其他厂商提供元器件。所以三星会是我以后评判顶级元器件基准。 在个人看来，三星虽然有很多的自家生态产品。但是体验不佳。单打独斗还行，组合起来并没有 1+1\u003e2 的感觉。不看好。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:6:0","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#20191210-展望"},{"categories":["blog"],"content":" 20191210 红米发布会笔记本虽然便宜。但是内存太小。对我这样的大内存需求者不友好。 音响产品是越来越便宜了。如果是用小米生态，小爱同学会慢慢变成必备品。 路由器一直被网友们诟病。但是价格实在是便宜。后续我还是会考虑入手一个。 红米 k30 手机: 支持 5G 的 Soc，性能强过 835，甚至到达 845 水平。gpu 由于我很少玩游戏，所以不在乎。 120hz 刷新率。这一点真的对手机体验提升特别大。估计在之后将全面普及。之后的换机我也只会考虑 120hz 以上的手机了，否则我会觉得比不过红米 k30。不值得买。 4500 电池、红外、挖孔屏 (这个一般般)、最新的索尼摄像头。水桶机般的配置。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:7:0","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#20191210-红米发布会"},{"categories":["blog"],"content":" 20210822 小结笔记本电脑 用的是小新 Pro13。最大缺点是键盘键程太短了，买之前觉得 macbookpro 的那种蝴蝶键盘都能忍受了，怎么会有问题呢。结果是真的垃圾到不想用。同时也因为接口比较少，转换器也是少不了的。当然了比之前的 macbookpro 强了一些，但是对于计算机的从业人员来说还是不够用。。 是 2020 年终买的。macbookpro 转手卖了 5000 块，加了几百块。不想加太多钱。觉得便携，性能还不错。同时我在工位上也配置了键盘和鼠标。所以觉得还不错。 手机 现在用的是小米 10。他的摄像头有点喜忧参半。清晰的时候确实很清晰，可是在拍摄近物的时候会出现严重的虚化，这一点在日常使用中的体现就是扫码老是扫不上。。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:8:0","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#20210822-小结"},{"categories":["blog"],"content":" 20230714 现状买房以后开始用台式机了, 在显卡最贵的 2022 年. 2 个 4 k 显示器 网易严选升降桌 金豪人体椅子 G 102 有线鼠标 小米屏幕挂灯 i5-12600k, 32g内存, 1t存储, 迫击炮主板, 3060ti七彩虹 最错误的决定就是换掉了 小米10,反向升级到了小米 12, 是真的卡的不行. 然后买的车是思域 2022, 它在国内只有 carlife, 阉割掉了 carplay. 而小米的车载只支持 iccoa 协议, 而自带的本田车机导航不好用. 因此我计划换 iphone 15, 一直在等. 因为 15 是 usb-c 接口. ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:9:0","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#20230714-现状"},{"categories":["blog"],"content":"最近把手上的事情都忙完了。准备来好好巩固自己的python知识。为什么标题是技巧呢，因为这部分是它和其他语言最大的不同，或者说特点。要玩得6，不熟这一些知识点，肯定是不行","date":"2019-11-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/","series":null,"tags":["blog","python"],"title":"python技巧-类","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/"},{"categories":["blog"],"content":" 简介最近把手上的事情都忙完了。准备来好好巩固自己的 python 知识。为什么标题是技巧呢，因为这部分是它和其他语言最大的不同，或者说特点。要玩得 6，不熟这一些知识点，肯定是不行。 ","date":"2019-11-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/:1:0","series":null,"tags":["blog","python"],"title":"python技巧-类","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/#简介"},{"categories":["blog"],"content":" python 的类python 可以用函数式编程。也支持面向对象编程。 在使用函数式编程的时候，多数都是用来写脚本。同时这也是 python 最开始发光发亮的点。但是在处理结构性数据以及架构项目的时候，面向对象的优势就会凸显出来。同时也有很多的黑魔法让你快速完成原型的构造。 ","date":"2019-11-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/:2:0","series":null,"tags":["blog","python"],"title":"python技巧-类","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/#python-的类"},{"categories":["blog"],"content":" 先说 type 函数我们经常用 type 函数来查看对象的类型信息。但还有一个用法，就是用 type 来生成对象。当你在写 python class 代码的时候，解析器遇到 class 代码块，就会解析 class 结构，然后用 type 来构造对象。 # name代表类名，base代表父类或者说基类，attrs为字典形式，代表属性值。 type(name, base, attrs) ","date":"2019-11-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/:2:1","series":null,"tags":["blog","python"],"title":"python技巧-类","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/#先说-type-函数"},{"categories":["blog"],"content":" type 和元类 class TMetaClass(type): def __new__(cls, name, base, attrs): print('in TMetaClass new') return type.__new__(cls, name, base, attrs) def __init__(self, object_or_name, bases, dict): print('in TMetaClass init') super().__init__(object_or_name, bases, dict) class Person(metaclass=TMetaClass): def __new__(cls): print('in Person') return object.__new__(cls) def __init__(self): print(self.__class__.__name__) super().__init__() def test(self): print('Person test..') class Man(Person): def __new__(cls): print('in Man') return object.__new__(cls) def test(self): print('Man test..') print('-'*20) kentxxq1 = Person() kentxxq1.test() print('-'*20) kentxxq2 = Man() kentxxq2.test() # 结果 # in TMetaClass new # in TMetaClass init # in TMetaClass new # in TMetaClass init # -------------------- # in Person # Person # Person test.. # -------------------- # in Man # Man # Man test.. 总结几个要点: type 可以通常被继承来使用。用法是 type.__new__，如果 __new__ 方法返回的不是实例化时的类型，不会进入到 __init__ 方法。 Person 指定元类以后，在定义过程中会进入元类 __new__ 和 __init__ 方法。而 Man 继承 Person 以后，定义过程也是进入元类的方法。在 python 中类也是对象，这里说的定义过程，也就是构建一个类对象。 而在实例化的过程中。使用的都是各自的 __new__ 方法。这里的实例化是将类对象进行实例化。 你在正常的代码编写过程中，很容易想到剥离相同的代码。放到一个基类中。那你什么时候应该要想到用基类呢？当你想要控制子类的行为时。 可以参考 orm 的做法，那么是实际代码中的使用方法应该如下: 在元类中编写构建类时需要做的事情。例如把子类所有的数据存放到一个 mapping 字典中。 编写一个基类，把所有继承者通用特性综合到一起。 在继承者内部编写不同之处 (调用者)。调用者可以非常方便的去使用基类，编写简单明了的代码。 上面的例子，是判断字段是否为 Field 类型。如果是的，那么这个变量代表的就是数据库内的字段名。 再举个例子，别人在继承你的基类时，加上了一个名字为 kentxxq 的变量，但是你对这个名字深恶痛绝！你就可以在基类指定 metaclass，而 metaclass 里对 attrs 进行判断，然后去掉它。这样别人要是不理解元类，就只能改变量名了！同样的方法，你也可以修改 name 和 base。也就是说，你可以通过条件操作这个子类会变成什么样子。 还来一个例子，哈哈。你写了一个很牛逼很牛逼的通用工具模块。别人只需要继承你，就可以让代码性能提高 10000%！你想看看到底有多少人再用！那么你就可以在这里做个统计，不就明白啦！ 当然还有很多的地方可以用上，关键在于你的需求。 ","date":"2019-11-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/:2:2","series":null,"tags":["blog","python"],"title":"python技巧-类","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/#type-和元类"},{"categories":["blog"],"content":" 特殊的内部函数 方法 调用方式 解释 _new_(cls [,…]) instance = MyClass(arg1, arg2) new 在创建实例的时候被调用 _init_(self [,…]) instance = MyClass(arg1, arg2) init 在创建实例的时候被调用 _cmp_(self, other) self == other, self \u003e other, 等。 在比较的时候调用 _pos_(self) +self 一元加运算符 _neg_(self) -self 一元减运算符 _invert_(self) ~self 取反运算符 _index_(self) x[self] 对象被作为索引使用的时候 _nonzero_(self) bool(self) 对象的布尔值 _getattr_(self, name) self.name # name 不存在 访问一个不存在的属性时 _setattr_(self, name, val) self.name = val 对一个属性赋值时 _delattr_(self, name) del self.name 删除一个属性时 _getattribute_(self, name) self.name 访问任何属性时 _getitem_(self, key) self[key] 使用索引访问元素时 _setitem_(self, key, val) self[key] = val 对某个索引值赋值时 _delitem_(self, key) del self[key] 删除某个索引值时 _iter_(self) for x in self 迭代时 _contains_(self, value) value in self, value not in self 使用 in 操作测试关系时 _concat_(self, value) self + other 连接两个对象时 _call_(self [,…]) self(args) “调用”对象时 _enter_(self) with self as x: with 语句环境管理 _exit_(self, exc, val, trace) with self as x: with 语句环境管理 _getstate_(self) pickle.dump(pkl_file, self) 序列化 _setstate_(self) data = pickle.load(pkl_file) 序列化 内部完整文档可以参考 官方 ","date":"2019-11-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/:2:3","series":null,"tags":["blog","python"],"title":"python技巧-类","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/#特殊的内部函数"},{"categories":["blog"],"content":" 类方法和静态方法classmethod 通常用来创造此类的实例。例如你需要通过别人的参数，来创造一个实例。但是参数可以包括对象、json 等。 好处: 简单且逻辑直观。 不需要实例化就可以使用。 还可以在内部调用静态方法。完整复杂的操作。 staticmethod 是为了解决各种尴尬的问题。当你需要一个通用的 Tools 类时，内部都写成静态方法是不错的选择。 可能遇到的尴尬之处: 写做外部方法，但不够通用。 作为内部普通方法，却想不需要实例化就使用。 和类方法对比起来。却又不需要和类对象有任何关系。 ","date":"2019-11-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/:3:0","series":null,"tags":["blog","python"],"title":"python技巧-类","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/#类方法和静态方法"},{"categories":["blog"],"content":" 好的技巧资料","date":"2019-11-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/:4:0","series":null,"tags":["blog","python"],"title":"python技巧-类","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/#好的技巧资料"},{"categories":["blog"],"content":" Python Cookbook","date":"2019-11-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/:4:1","series":null,"tags":["blog","python"],"title":"python技巧-类","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/#python-cookbookhttpspython3-cookbookreadthedocsiozh_cnlatest"},{"categories":["blog"],"content":"之前在一些文章里面就有说过。程序员是绕不过JavaScript的，即使有时候会恶心到人。。而很多硬件的嵌入式开发，算法工程师，底层开发人员则真的可以做一辈子，而免疫JavaScript的侵扰。而JavaScript的每一个改动，都多多少少与c/c++有关。可以说大神们用c/c++构建了现在数字化的底层逻辑。比c更底层的，晦涩难懂且开发效率低下，甚至人写的代码经常不如c编译器优化后的代码。比c高级的，性能下降且概念繁多。和c同级别的，都没有c混得好。c是事实标准","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/"},{"categories":["blog"],"content":" 前言如果你从来没有了解过编程，而想学习 c。那么去搜新手教程慢慢上手。 如果你有其他编程的基础。这篇文章能用来让你快速了解 c 代码。可以在你不得不去看 c 代码的时候，看懂他的意图。 之前在一些文章里面就有说过。程序员是绕不过 js 的，即使有时候会恶心到人。。 而很多硬件的嵌入式开发，算法工程师，底层开发人员则真的可以做一辈子，而免疫 JavaScript 的侵扰。而 JavaScript 的每一个改动，都多多少少与 c/c++ 有关。 可以说大神们用 c/c++ 构建了现在数字化的底层逻辑。比 c 更底层的，晦涩难懂且开发效率低下，甚至人写的代码经常不如 c 编译器优化后的代码。比 c 高级的，性能下降概念繁多。和 c 同级别的，都没有 c 混得好。事实上 c 是事实标准。 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:1:0","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#前言"},{"categories":["blog"],"content":" 基本了解","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:2:0","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#基本了解"},{"categories":["blog"],"content":" 类型二进制的 c 表达，需要用代码实现 # python用0b开头 a = 0b101 八进制 // c用0开头 int a = 08 # python用0o开头 数字0和字母o a = 0o516 十六进制 // c用0x开头 int a = 0x2A # python用0x开头 a = 0x2A 其中 int 是 2 个字节。long int 是 4 个字节。 而 float 是 4 个字节。double 是 8 个字节。long double 是 16 个字节。注意在计算的时候，可能存在舍入误差。 char 一个字符一个字节。 字符串则会比 char 多出来一个尾部的 \\0 字节。 unsigned 则代表没有符号位。例如 int 类型前面都会有一个符号位。没有符号位则会扩大 int 的可存储范围 附带补充一点知识。 数组 int a[10]; // 10个长度，空位补0 int b[10]={1,2,3,4,5}; // 自动检测到长度 int b[]={1,2,3,4,5}; 而字符串就这样表示 // 长度会是4，因为后面还有一个\\0 char c[]=\"C a\"; 说几个常用的字符串函数吧 strcat 合并 strcpy 拷贝 strcmp 比较 strlen 拿到字符串长度 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:2:1","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#类型"},{"categories":["blog"],"content":" 函数部分 函数其实没什么好说的。记得除了库函数 (自带标准库),都要定义一下。才能用。 全局变量默认在静态存储区。 加了 static 的局部变量也在静态存储区。 register 的变量会放在寄存器，会提高性能。 外部变量用 extern 声明，则可以在代码中使用。 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:2:2","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#函数部分"},{"categories":["blog"],"content":" 预处理命令 #define PI 3.1415 用 PI 替代代码中的 3.1415。#undef PI 取消。 // 可以带参数。 #define SQ(y) (y)*(y) /* 但注意扩起来。否则可能结果有误 */ /* 例如sq=SQ(a+1)会变成sq=a+1*a+1 */ #include \"stdio.h\" 引入头文件。一般都用双引号先从当前目录查找。 #ifdef #else #endif 用来判断执行。#if 则非 0 则为 true。 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:2:3","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#预处理命令"},{"categories":["blog"],"content":" 指针示例代码 // 声明int变量a和int指针*p int a,*p; a=10; // 把a的地址给p p=\u0026a; // 现在用*p即可取到a的值 printf('%d',*p); 指针如果指向数组，则默认指向数组的第一个元素。可以通过 *(p+1) 取到第二个元素的值。字符串同理。 函数也是占用连续的内存段。则 int (*pf)(); 代表指向一个返回值是 int 的函数。当指针赋值后，通过 (*pmax)(a) 调用。 int *ap(int x,int y) 代表返回指针。 语法 说明 int i; 定义整型变量 i int *p; p 为指向整型数据的指针变量 int a[n]; 定义整型数组 a，它有 n 个元素 int *p[n]; 定义指针数组 p，它由 n 个指向整型数据的指针元素组成 int (*p)[n]; p 为指向含 n 个元素的一维数组的指针变量 int f(); f 为带回整型函数值的函数 int *p(); p 为带回一个指针的函数，该指针指向整型数据 int (*p)(); p 为指向函数的指针，该函数返回一个整型值 int **p; P 是一个指针变量，它指向一个指向整型数据的指针变量 优先级为：()\u003e[]\u003e*。然后从左往右看。 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:2:4","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#指针"},{"categories":["blog"],"content":" 结构体如果你理解了前面所说的指针，那么指针就会很好理解。其实就是一系列的基本类型放在一个连续的内存段中。 // 声明一个结构体 struct human { int num; char name[20]; char sex; }; // human结构的变量 struct human { int num; char *name; char sex; }boy; // 5个human结构组成的数组变量 struct human { int num; char *name; char sex; }boy[5]; // 带上初始化的值 struct human { int num; char *name; char sex; }boy[5]={ {101,\"Li ping\",'M'}, {102,\"Zhang ping\",'M'}, {103,\"He fang\",'F'}, {104,\"Cheng ling\",'F'}, {105,\"Wang ming\",'M'}, }; 取值赋值:boy.num 数组类似普通数组:boy[i].num 指针:struct human *ph 指针取值:ph-\u003enum 或 (*ph).num ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:2:5","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#结构体"},{"categories":["blog"],"content":" 动态分配很多时候不确定需要多大空间的时候，通过传参来实现。 // 分配一个100字节长度字符数组，pc为指向这个字符数组 pc=(char *)malloc(100); // 分配2个struct human结构体的长度。ps为指针且指向这个数组 ps=(struet human*)calloc(2,sizeof(struct human)); // 接收指针变量，释放它 free(pc); free(ps); ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:2:6","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#动态分配"},{"categories":["blog"],"content":" typedef用 typedef 加在 struct 前面，变量名写 HUMAN，就可以用 HUMAN h1,h2 来声明变量了！简洁明了。 typedef int INTEGER; INTEGER a,b; typedef char NAME[20]; // 在和预定义不同的是，这是在编译器进行的。 NAME a1,a2,s1,s2; // 等效 char a1[20],a2[20],s1[20],s2[20] ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:2:7","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#typedef"},{"categories":["blog"],"content":" 位运算位运算方面其实和其他语言的区别不大。看到应用最多的地方是权限方面的。自己对着文档看吧。我反正是觉得不好理解，不爱用。 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:2:8","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#位运算"},{"categories":["blog"],"content":" 文件操作其实到了文件操作部分，就开始用前面学到的知识来进行延伸了。 File *fp; 声明一个指针变量，文件类型。这并不是一个特殊的语法。我的 mac 上可以看到定义，是一个结构体。 typedef struct __sFILE { unsigned char *_p; /* current position in (some) buffer */ int _r; /* read space left for getc() */ int _w; /* write space left for putc() */ short _flags; /* flags, below; this FILE is free if 0 */ short _file; /* fileno, if Unix descriptor, else -1 */ struct __sbuf _bf; /* the buffer (at least 1 byte, if !NULL) */ int _lbfsize; /* 0 or -_bf._size, for inline putc */ /* operations */ void *_cookie; /* cookie passed to io functions */ int (* _Nullable _close)(void *); int (* _Nullable _read) (void *, char *, int); fpos_t (* _Nullable _seek) (void *, fpos_t, int); int (* _Nullable _write)(void *, const char *, int); /* separate buffer for long sequences of ungetc() */ struct __sbuf _ub; /* ungetc buffer */ struct __sFILEX *_extra; /* additions to FILE to not break ABI */ int _ur; /* saved _r when _r is counting ungetc data */ /* tricks to meet minimum requirements even when malloc() fails */ unsigned char _ubuf[3]; /* guarantee an ungetc() buffer */ unsigned char _nbuf[1]; /* guarantee a getc() buffer */ /* separate buffer for fgetln() when line crosses buffer boundary */ struct __sbuf _lb; /* buffer for fgetln() */ /* Unix stdio files get aligned to block boundaries on fseek() */ int _blksize; /* stat.st_blksize (may be != _bf._size) */ fpos_t _offset; /* current lseek offset (see WARNING) */ } FILE; fp=(\"/home/a.txt\",\"r\"); 只读方式打开制定文件，后面的参数类似 python。 ch=fgetc(fp); 取第一个字符赋值给 ch。 fputc('a',fp); 弄一个字符串到到指针位置。 fgets(str,n,fp); 从 fp 中取 n-1 个字符 (即字符串) 到 str 这个 char 数组中。为什么是 n-1(一般也是 str 长度 -1)，因为字符串后面要有一个 ‘\\0’ 啊！ 它读取到换行符或者文件结尾会停止。 str 这个数组我试过几个不同的大小。发现 4096(4k) 是一个门槛，小于它可能会影响性能。而我看到 python 默认使用的是系统 buffer 大小 8192(8k 即 2 个 block)。现在的文件系统多数都是 4k 为一个 block，而 io 一般最少存取一个 block。那么设置成 2 个 block，也有助于更快的对下一个 block 数据块进行操作，而更大的话就没有太大意义了，可能会浪费磁盘 io 导致占用过多的资源。 fputs(“abcd“,fp); 把字符串放到指针位置。这里传递的是字符串，其实传递的就是字符数组首地址。所以如果是 char *b=“abcd” 要进行传递，直接传递 fputs(b,fp) 即可！ fread(qq,sizeof(struct stu),2,fp);qq 是一个指针，表示数据的首地址 (在这里指向一个 stu 结构体)，qq+1 会移动到第二个 stu 结构体。第二个是数据块的大小,第三个是读取几个数据块，fp 是文件指针。 fwrite(qq,sizeof(struct stu),2,fp); 参数同上，只不过是写数据。 fscanf(fp,\"%d %s\",\u0026i,s); 和 fprintf(fp,\"%d %c\",j,ch); 用来通过第二个参数指定的方式，存放或者打印数据。主义第二个参数中的空格也是会生效的！ rewind 函数把文件指针重新指向头部。 fseek(fp,100L,0); 类似 python 的指针偏移。0 文件首地址，1 当前位置，2 文件末尾。常量表示偏移量必须带上 ‘L’。移动到离文件首 100 字节距离的位置。也可以直接填写数字。负号前移，正号后移。 最后说明EOF 是一个隐藏字符。在读取完了数据以后，才会遇到 EOF。 而 feof() 是通过返回错误来判断是否结束。所以需要先取值，后判断。遇到了 EOF(即 -1) 就会出错。停止下一个循环。 0 是 false，非 0 位 true。 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:2:9","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#文件操作"},{"categories":["blog"],"content":" 编译简单来说，编译就是使用 gcc,make,cmake 等工具来进行的。 如果使用 vs 或者 clion 这样的工具，需要了解的是工具的使用方法。而下面我要简单说明的是手工编译。 在项目目录下新建 build 文件夹。 进入 build 文件夹使用 cmake .. 生成 Makefile 运行 make 命令编译成功，找到输出文件即可。 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:3:0","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#编译"},{"categories":["blog"],"content":" linux我在 centos7 上运行 gcc,make,cmake 都可以正常使用。 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:3:1","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#linux"},{"categories":["blog"],"content":" mac用 brew 安装 cmake 后，也可以跑通。 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:3:2","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#mac"},{"categories":["blog"],"content":" windows我是用的 scoop 安装 cmake。 然后安装最新的 vs。下载 mingw-get，然后安装 mingw32-make。 cmake -G \"MinGW Makefiles\" . # .为当前目录, \"MinGW Makefiles\"为makefile类型，如果编译器为vs的话使用\"NMake Makefiles\" 看到了 Makefile 后 mingw32-make 即可。 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:3:3","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#windows"},{"categories":["blog"],"content":" 难点记录一下难以理解的地方。 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:4:0","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#难点"},{"categories":["blog"],"content":" 指针数组和数组指针在看书的时候，了解到 main 函数可以接受 2 个参数。而 main 函数不能被其他函数调用 (有一些编译器不管你这么多，也能编译通过。但是制定标准的委员会明确表明了不行)。 int argc 代表单数的个数。包括程序自己本身。 char *argv[] 代表一个指向字符串的指针数组。 先说一下我之前的错误想法吧。 一个指针数组。那么我拿到的就是一个数组。 那么我应该先用 argv[i] 拿到数组中的第 i 个指针。然后如何取值呢？用 *(argv[i]) 取第一个值。可是报错了。 那么我的理解错误在哪呢？下面用 ./helloworld a=1 来举例。 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:4:1","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#指针数组和数组指针"},{"categories":["blog"],"content":" 第一点，c 中没有字符串类型。字符串是由字符数组组成，以\\0 结尾。字符串又有 2 个声明的方式。 //可以修改指针的地址，但是无法修改原有的值。存储在内存只读段。只要程序在运行，那么就不会释放。 char *a=\"hehe\"; //可以修改。在函数内接收，用完就会释放掉。 char b[]=\"hehe\"; c 是如何读取字符串的呢？ 在 c 语言中，指向字符和指向字符串的区别只是在于取值，根本就没有指向字符串的指针。从字符串 (字符数组) 的首地址开始取值，一直到\\0 结束，那么这个字符串就读完了。 于是根据例子，系统传递给 main 函数的就是 2 个字符数组。也就变成了传递 1 个包含有 2 个 char* 类型指针的指针数组即可。取第 n 个值，就从数组中第 n 个指针所指向的地址取值到\\0 即可。 所以 printf(\"%s\",*a) 中。*a 取到的值 ‘h’。而 printf 中指明了要取一个字符串。所以它打印的结果会一直读到\\0 才会停止。 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:4:2","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#第一点c-中没有字符串类型字符串是由字符数组组成以0-结尾字符串又有-2-个声明的方式"},{"categories":["blog"],"content":" 第二点，要彻底了解的是数组作为参数的传递。 我的 main 会得到一个长度为 2 的数组。如果用户还输入了 b=2，c=3 呢？我的的程序是无法预测到用户参数的具体个数。所以 main 函数无法写死数组长度，所以还会有一个 int argc 参数告诉我才行。 数组在传递的时候，传递的只是首地址。用一小段代码来理解一下发生了什么。 void test3(int ac,char av[]){ printf(\"%p\\n\",av); for (int i = 0; i \u003c ac; ++i) { printf(\"%c\",av[i]); } } void test4(char a){ printf(\"%p\\n\",\u0026a); } void test5(char *qt[]){ printf(\"%p\\n\", qt); } int main(int argc, char *argv[]) { char p='p'; printf(\"%p\\n\",\u0026p); test4(p); char pch[] = \"pch\"; printf(\"%p\\n\", pch); test3(strlen(pch), pch); char *qq[]={\"q\",\"w\"}; char **qq2=qq; printf(\"%p\\n\", qq); test5(qq); return 0; } // 结果 // 0x7ffee0afc77f // 0x7ffee0afc75f // 0x7ffee0afc77b // 0x7ffee0afc77b // pch // 0x7ffee81d0770 // 0x7ffee81d0770 先看 test3 和 test4 的结果。 可以发现 2 个变量的数据存在不同的内存区域，char 类型传递的是 具体值，也就是给形参 a 赋值。也即是我在 test4 中修改 a 的值，不会影响到 p 的值。 test3 中 2 个变量的数据为同一内存区域，数组类型传递的是 值的地址，也就是让 av 也指向 pch 所指向的地方，于是相同的地址指向同一个值。当我使用 *av 修改值，对应的 pch 值也会变动。 而通过打印，我们会知道。地址指向字符串 (字符数组) 第一个 char。可以用 *av 直接取值。 C 语言规定，数组名代表数组的首地址，也就是第 0 号元素的地址。说明我们在声明了 pch 以后，就可以把数组名 pch 看成是一个指针。 那么我们在 test3 函数中，形参也可以写成 char *av(你可以验证看)。 再看 test5 的结果。发现地址也是一样的。 同理就可以推断出，传递的是地址，所以 qt 是指针类型。根据结果，指针数组传递的就是第一个指针所指向值的地址。直接 *qt 即可取值。 前面在传递数组的时候，数组名代表着一个指针。同样在传递指针数组的时候，数组名就是第一个元素的地址，而第一个元素是指针。所以数组名 qt 是指针的指针！ 那么我们在 test5 函数中，形参也可以写成 char **qt(char **qq2=qq 也侧面验证了 char**类型 接收数组变量名 qq)。这也是为什么 main 函数中 char *argv[] 也可以写的 char **argv 的原因了！ 得到结论：数组在传递的时候，形参 char* 和 char[] 等效。char**与 char *[] 等效。 同时也说明，数组 [i] 只不过是指针的一个语法糖，相当于 *(指针 +i)。 所以取值如下： char **qt 强调自己是指针。取值常用 **qt。 char *qt[] 强调自己是数组。取值常用 qt[0]。 虽然你的形参是 char **qt 也可以用 qt[0] 取值。但是不方便理解，且容易出错。 // 你的第一感觉应该是用**rrr取值。 char r='a'; char *rr=\u0026r; char **rrr=\u0026rr; // 下面报错 printf(\"%d\\n\",rrr[0]); // 说明要分情况的，char **qt不等同于char *qt[] ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:4:3","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#第二点要彻底了解的是数组作为参数的传递"},{"categories":["blog"],"content":" 第三点，再来说一下我自己理解错误。由于之前所接触到的语言，基本的逻辑都是面向对象且没有指针。都是值传递，而不是地址传递。 写过一篇 go 语言的文章，可我没有深入了解过它的指针。经过翻查，发现 go 在数组传递的时候也是值传递。在 go 中，指针是为了减少性能开销存在的。而很少见到有人做指针运算。 而 c 的指针贯穿了整个语言。在进行值传递的时候，形参可以拿到所有信息，因为要进行赋值操作。值传递会让变量名直接取到值。 而地址传递只有一个地址和类型，需要用到取值符 *。且在一个指针指向数组的时候 *p 和 p[0] 等价。 只有搞清楚传递的过程中是值还是地址，才能正确的分析问题。 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:4:4","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#第三点再来说一下我自己理解错误"},{"categories":["blog"],"content":" 文件读取","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:4:5","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#文件读取"},{"categories":["blog"],"content":" 代码示例 /*文本内容如下 123 哈哈 */ /* 下面这段代码会正确打印文本内容直到结束 */ int str3; while ((str3 = fgetc(f1)) != EOF) { printf(\"%c\", str3); } /* 下面这段代码会多打印一个奇怪的问号符 */ int str2; while (str2 != EOF) { str2 = fgetc(f1); printf(\"%c\", str2); } /* 下面这段代码会把最后的哈哈打印两次 */ char str[4096]; while (!feof(f1)) { fgets(str, 4096, f1); printf(\"%s\", str); } 下面来说说为什么。 先看第一个。首先把数据用 fgetc 取出，然后判断是否为 EOF，选择是否打印。没毛病。 第二个则是先判断是否为 EOF，当我们读取到 ’ 哈 ’ 的时候，先打印出来。然后再判断依旧!=EOF，就会导致把 EOF 读取出来后进行了打印。 feof 是通过返回错误 -1 来停止循环的。所以在使用的时候先进行读取。在循环了 2 次以后，feof 仍然没有收到错误信息。第三次循环的时候 fgets 其实没有读取到数据。但是下面的语句还是得要执行。 /* 改成这样，最后一次读取到了错误，但是下面没有代码了，什么都没发生。循环条件进行判断后跳出循环。 */ char str[4096]; int c = 0; fgets(str, 4096, f1); if (feof(f1)) { printf(\"空文件\\n\"); } else { while (!feof(f1)) { printf(\"%s\", str); fgets(str, 4096, f1); } } ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:4:6","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#代码示例"},{"categories":["blog"],"content":" EOF 和 feofEOF 和 foef 什么时候用呢？ EOF 主要用于文本文件进行判断结尾。不适合或者说不适用于读取二进制文件。 foef 则都可以使用。 那么我到底应该怎么读取文件呢？ 下面这个应该是通用版本。无论是二进制还是文本。 FILE *fp,*xx; int c; fp=fopen(\"/Users/kentxxq/test.txt\",\"rb\"); xx=fopen(\"/Users/kentxxq/xx.txt\",\"wb\"); if(fp==NULL) { printf(\"文件打开错误\"); }else{ c = fgetc(fp); if(ferror(fp)){ printf(\"文件读取失败！\"); }else{ if(feof(fp)){ printf(\"这是一个空文件\"); } else{ while (!feof(fp)){ printf(\"%c\",c); fputc(c, xx); c = fgetc(fp); } } } } ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:4:7","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#eof-和-feof"},{"categories":["blog"],"content":" 静态库和动态库其实我来学 c 相关的知识，最大的动力就是性能以及 c/c++ 有很多的轮子。而我爱用 Python，它与 c 结合非常紧密。 静态库 编译完成以后就不需要 lib 和头文件了，所以是打包到了一起。不方便增量更新、且编译速度会慢一些。 动态库 编译完成以后其实还是需要从指定的路径取引用库文件。二进制分发的你在通过包管理工具安装以后 (例如 sqlite) 会在系统的 include 和 lib 之类的文件夹存放。源码则可以你自己通过编译放在系统或者自己指定的文件夹内。只要能引用到就好了。 windows 下的静态库为 .lib 文件。如果需要使用它，就包含它的头文件。然后 #pragma comment(lib,\"xxx.lib\") 即可直接通过函数名调用。打包后的文件不再 lib 静态库。这是标准做法。 不过我在 vs2019 的实际操作中，略有不同。可参考 微软官方文档 类 *unix 静态库为 .a 文件。用法同上。 windows 下的动态库为 .dll 文件。 动态库有 2 种用法。第一种是隐式调用。第二种是显式调用。注: 隐式调用若主函数是 C++ 程序,需要 extern “C”{}包含被调用函数 (add.c) 的头文件。动态库的文档可以参考这个 微软官方文档 我现在常见的是通过 LoadLibrary 来直接加载 dll 文件，然后通过 typedef 来定义一个函数指针声明出被调用函数的返回类型和参数类型，最后通过 GetProcAddress 来指定内部函数名得到函数赋值给指针。可以看到我们需要有 dll 文件、函数名、函数指针声明函数。而 python 的 ctypes 通过把传入的参数一一转换成了 c 的对应类型，所以函数指针可以自己推断出来是什么样，而我们给 ctypes 提供了必要的 dll 地址和函数名。所以直接传参即可调用。如果传入的参数错误，就直接报错呗~ 通过包含头文件、使用 #pragma comment(lib,\"xxx.lib\") 包含 lib、以及 dll，同静态库也直接通过函数名调用。这里的 lib 文件内部存放的是函数位置和索引。让程序在编译期间使用的。具体的函数体还是存放在 dll 中。 所以动态库两种方法都说明，在打包完程序以后，依旧需要 dll 文件。 类 *unix 动态库为 .so 文件。则对应 dlopen 和 dlsym 来加载和指定函数名。其他原理相同。 我们也知道，windows 一脉相承，提供比较强的兼容性。所以在 windows 上编译后的库，可以兼容多个 windows 版本。 而类 *unix 则不然。多数的做法都是在各个平台上各自编译后分发。 所以也就解决了我对如何使用别人代码库的疑惑。 有源码就下载下来，编译以后你用静态库或者动态库的方式都取决于你。 别人通过二进制分发 (注意选择对应平台的包)，除了 dll 也都会提供.h 的头文件。如果只有一个 dll 呢？那你就对着文档写就一个头文件或者函数指针用。头文件其实和 typedef 函数指针的目的是一样的，让 c/c++ 的代码能获取到函数的相关信息，从而正确编译。因此调用 dll 不用包含头文件也是可以的。只是如果别人做好了库给你用，肯定也会提供给你这个库的调用方法，不提供 h 头文件是他懒！ ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:4:8","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#静态库和动态库"},{"categories":["blog"],"content":" 总结在写这篇文章之前。好久没有写博客了。。偶尔更新一些影片记录而已。 最近也弄了一个域名邮箱，把联系地址改成了邮箱地址。 我大概看了 1 个月的 c 相关的东西。。才写完这点点东西。过程感觉还是很痛苦的，c 语言很简单，但是经常会涉及到系统、编译、环境、调试方面的问题。但是写完以后觉得豁然开朗。对以后的编码也有了更加清晰的理解。 不得不说一句，微软的文档是真的强。。我正在准备彻底抛弃苹果，面向微软。。如果你看不懂这篇文章，取参考微软的文档。毕竟那是 windows 的标准文档啊，绝不会错！ ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:5:0","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#总结"},{"categories":["blog"],"content":"编程语言多种多样。但是常见在视野中的，就那么一些。其中js就是一个无法忽视的存在。自从有了nodejs，前端迅速得开始了自己的工程化道理。各种框架满天飞。号称一切能用js来写的东西，都可以用js写出来。我本人对js是无感的。论性能没有静态语言好，论快捷没有python好，论黑魔法没有ruby好。要说跨平台展示，也有很多的方案不比js差。但是你架不住它的确是web的标准。。再怎么不搭理它，你也要懂它","date":"2019-05-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/","series":null,"tags":["blog","js"],"title":"使用js来帮助加解密信息","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/"},{"categories":["blog"],"content":" 简介编程语言多种多样。但是常见在视野中的，就那么一些。其中 js 就是一个无法忽视的存在。 自从有了 nodejs，前端迅速得开始了自己的工程化道理。各种框架满天飞。号称一切能用 js 来写的东西，都可以用 js 写出来。 我本人对 js 是无感的。论性能没有静态语言好，论快捷没有 python 好，论黑魔法没有 ruby 好。要说跨平台展示，也有很多的方案不比 js 差。 但是你架不住它的确是 web 的标准。。再怎么不搭理它，你也要懂它。 ","date":"2019-05-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/:1:0","series":null,"tags":["blog","js"],"title":"使用js来帮助加解密信息","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/#简介"},{"categories":["blog"],"content":" 初衷最近是一直在看 flutter，同时在学着做一个 app。以后要是有需要，我起码也有个东西可以展示一下。 现在的网站大多数都进行了反爬虫，反盗链等等处理。算是对自身版权的一种保护措施。无可厚非。也让你在学习的道路上接触到了更多的知识面。 出于学习的目的，我也就要迎难而上了。 ","date":"2019-05-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/:2:0","series":null,"tags":["blog","js"],"title":"使用js来帮助加解密信息","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/#初衷"},{"categories":["blog"],"content":" html 代码被 js 加密","date":"2019-05-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/:3:0","series":null,"tags":["blog","js"],"title":"使用js来帮助加解密信息","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/#html-代码被-js-加密"},{"categories":["blog"],"content":" 分析页面在 91porn 的视频播放页。 在 chrome 浏览器中有 mp4 地址，但是我在抓取完页面以后，没有找到 video 标签的 mp4 信息。 原因就在下面这一段 document.write(strencode(\"Y31+QVcpMF49ISQcEQIVdn5TEn8xJyV6CBMJTiEHLgIYWSNwO1JWS3Q8BU88TV4sESYmFwQIOhYnFHhxIyYCRTcuflgPGAVXegUkFDkeNDQrWhJtXC8CERcaFAc8JS8vES41RQUKMwF7IDBTejdeSBgQEBM+DB4lGTIdYQBsMwsHVBtFFCUVMCtXVh19dlMc\",\"35073qz4grffroXO4azOUodLDj16nSIwU3vAw8128Vn8p4gXrbwmHrwnhP5DmO71Tj/wl+Tn+Rruh/rsr6uY9kXaFORTYNCBEyc1asim+tub4c50UDIkqHGKPzOTc+f2MgA5NbCFgegj\",\"Y31+QVcpMF49ISQcEQIVdn5TEn8xJyV6CBMJTiEHLgIYWSNwO1JWS3Q8BU88TV4sESYmFwQIOhYnFHhxIyYCRTcuflgPGAVXegUkFDkeNDQrWhJtXC8CERcaFAc8JS8vES41RQUKMwF7IDBTejdeSBgQEBM+DB4lGTIdYQBsMwsHVBtFFCUVMCtXVh19dlMc\")); 我对 js 的方法不是很熟，于是谷歌了一下，发现 strencode 是一个编码库，或者说是一个加密库。 于是我在页面请求的资源中，搜索 strencode，定位到了 md5.js 中。 ;var encode_version = 'sojson.v5', lbbpm = '__0x33ad7', __0x33ad7=['QMOTw6XDtVE=','w5XDgsORw5LCuQ==','wojDrWTChFU=','dkdJACw=','w6zDpXDDvsKVwqA=','ZifCsh85fsKaXsOOWg==','RcOvw47DghzDuA==','w7siYTLCnw=='];(function(_0x94dee0,_0x4a3b74){var _0x588ae7=function(_0x32b32e){while(--_0x32b32e){_0x94dee0['push'](_0x94dee0['shift']());}};_0x588ae7(++_0x4a3b74);}(__0x33ad7,0x8f));var _0x5b60=function(_0x4d4456,_0x5a24e3){_0x4d4456=_0x4d4456-0x0;var _0xa82079=__0x33ad7[_0x4d4456];if(_0x5b60['initialized']===undefined){(function(){var _0xef6e0=typeof window!=='undefined'?window:typeof process==='object'\u0026\u0026typeof require==='function'\u0026\u0026typeof global==='object'?global:this;var _0x221728='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';_0xef6e0['atob']||(_0xef6e0['atob']=function(_0x4bb81e){var _0x1c1b59=String(_0x4bb81e)['replace'](/=+$/,'');for(var _0x5e3437=0x0,_0x2da204,_0x1f23f4,_0x3f19c1=0x0,_0x3fb8a7='';_0x1f23f4=_0x1c1b59['charAt'](_0x3f19c1++);~_0x1f23f4\u0026\u0026(_0x2da204=_0x5e3437%0x4?_0x2da204*0x40+_0x1f23f4:_0x1f23f4,_0x5e3437++%0x4)?_0x3fb8a7+=String['fromCharCode'](0xff\u0026_0x2da204\u003e\u003e(-0x2*_0x5e3437\u00260x6)):0x0){_0x1f23f4=_0x221728['indexOf'](_0x1f23f4);}return _0x3fb8a7;});}());var _0x43712e=function(_0x2e9442,_0x305a3a){var _0x3702d8=[],_0x234ad1=0x0,_0xd45a92,_0x5a1bee='',_0x4a894e='';_0x2e9442=atob(_0x2e9442);for(var _0x67ab0e=0x0,_0x1753b1=_0x2e9442['length'];_0x67ab0e\u003c_0x1753b1;_0x67ab0e++){_0x4a894e+='%'+('00'+_0x2e9442['charCodeAt'](_0x67ab0e)['toString'](0x10))['slice'](-0x2);}_0x2e9442=decodeURIComponent(_0x4a894e);for(var _0x246dd5=0x0;_0x246dd5\u003c0x100;_0x246dd5++){_0x3702d8[_0x246dd5]=_0x246dd5;}for(_0x246dd5=0x0;_0x246dd5\u003c0x100;_0x246dd5++){_0x234ad1=(_0x234ad1+_0x3702d8[_0x246dd5]+_0x305a3a['charCodeAt'](_0x246dd5%_0x305a3a['length']))%0x100;_0xd45a92=_0x3702d8[_0x246dd5];_0x3702d8[_0x246dd5]=_0x3702d8[_0x234ad1];_0x3702d8[_0x234ad1]=_0xd45a92;}_0x246dd5=0x0;_0x234ad1=0x0;for(var _0x39e824=0x0;_0x39e824\u003c_0x2e9442['length'];_0x39e824++){_0x246dd5=(_0x246dd5+0x1)%0x100;_0x234ad1=(_0x234ad1+_0x3702d8[_0x246dd5])%0x100;_0xd45a92=_0x3702d8[_0x246dd5];_0x3702d8[_0x246dd5]=_0x3702d8[_0x234ad1];_0x3702d8[_0x234ad1]=_0xd45a92;_0x5a1bee+=String['fromCharCode'](_0x2e9442['charCodeAt'](_0x39e824)^_0x3702d8[(_0x3702d8[_0x246dd5]+_0x3702d8[_0x234ad1])%0x100]);}return _0x5a1bee;};_0x5b60['rc4']=_0x43712e;_0x5b60['data']={};_0x5b60['initialized']=!![];}var _0x4be5de=_0x5b60['data'][_0x4d4456];if(_0x4be5de===undefined){if(_0x5b60['once']===undefined){_0x5b60['once']=!![];}_0xa82079=_0x5b60['rc4'](_0xa82079,_0x5a24e3);_0x5b60['data'][_0x4d4456]=_0xa82079;}else{_0xa82079=_0x4be5de;}return _0xa82079;};if(typeof encode_version!=='undefined'\u0026\u0026encode_version==='sojson.v5'){function strencode(_0x50cb35,_0x1e821d){var _0x59f053={'MDWYS':'0|4|1|3|2','uyGXL':function _0x3726b1(_0x2b01e8,_0x53b357){return _0x2b01e8(_0x53b357);},'otDTt':function _0x4f6396(_0x33a2eb,_0x5aa7c9){return _0x33a2eb\u003c_0x5aa7c9;},'tPPtN':function _0x3a63ea(_0x1546a9,_0x3fa992){return _0x1546a9%_0x3fa992;}};var _0xd6483c=_0x59f053[_0x5b60('0x0','cEiQ')][_0x5b60('0x1','\u0026]Gi')]('|'),_0x1a3127=0x0;while(!![]){switch(_0xd6483c[_0x1a3127++]){case'0':_0x50cb35=_0x59f053[_0x5b60('0x2','ofbL')](atob,_0x50cb35);continue;case'1':code='';continu","date":"2019-05-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/:3:1","series":null,"tags":["blog","js"],"title":"使用js来帮助加解密信息","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/#分析页面"},{"categories":["blog"],"content":" 解决办法到这里，一般有 3 种方法来继续你的工作 把这一大段的 js 翻译成 dart。缺点是耗时耗力，如果加密算法修改，你可能要重新来过。之前我的 python 爬虫就是这样的，不过那个加密算法才几行而已。 如果语言有工具支持运行 js，那么就好办了。js 自己跑 js 代码肯定没问题。而 v8 就是用 c++ 写的，c++ 肯定有库可以调用。java1.8 版本也有 js 引擎。c#则有 jint。而 python 则是调用本机的 node 环境，速度不理想。而我写 flutter 没有找到这种方法。 用 headless 浏览器来解析页面，然后把拿到最终结果。把地址解析出来。在 flutter 中也就是使用 webview 插件。缺点很慢很重。 于是我想到了远程 api 来执行代码。 ","date":"2019-05-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/:3:2","series":null,"tags":["blog","js"],"title":"使用js来帮助加解密信息","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/#解决办法"},{"categories":["blog"],"content":" 搭建基于 nodejs 的 web 服务","date":"2019-05-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/:4:0","series":null,"tags":["blog","js"],"title":"使用js来帮助加解密信息","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/#搭建基于-nodejs-的-web-服务"},{"categories":["blog"],"content":" web 代码搜了一下，express 貌似在 nodejs 里是很火的 web 框架。 于是基于 helloWorld 改了一点点。代码如下 //web框架 var express = require('express'); //body的解析工具 var bodyParser = require('body-parser'); var app = express(); var f = require('./decode') //一些解析设置 app.use(bodyParser.json()); app.use(bodyParser.urlencoded({ extended: false })); app.get('/', function (req, res) { res.send('Hello World!'); }); app.post('/', function (req, res) { //验证是不是合法的请求 if (req.body.token === 'qwer') { data = f(req.body.param1, req.body.param2) res.send(data) } else { res.send('fuck you!'); } }); app.listen(3000, function () { console.log('Example app listening on port 3000!'); }); ","date":"2019-05-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/:4:1","series":null,"tags":["blog","js"],"title":"使用js来帮助加解密信息","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/#web-代码"},{"categories":["blog"],"content":" 解密代码这个是 decode.js 文件的代码,我包成了一个方法，补上了几个用到的的变量。 'use strict'; module.exports = function (data1, data2) { //补上的变量 var len; var code; var i; var k; /** @type {string} */ var encode_version = \"sojson.v5\"; /** @type {string} */ var lbbpm = \"__0x33ad7\"; /** @type {!Array} */ var __0x33ad7 = [\"QMOTw6XDtVE=\", \"w5XDgsORw5LCuQ==\", \"wojDrWTChFU=\", \"dkdJACw=\", \"w6zDpXDDvsKVwqA=\", \"ZifCsh85fsKaXsOOWg==\", \"RcOvw47DghzDuA==\", \"w7siYTLCnw==\"]; (function (data, i) { /** * @param {number} isLE * @return {undefined}strencode */ var write = function (isLE) { for (; --isLE;) { data[\"push\"](data[\"shift\"]()); } }; write(++i); })(__0x33ad7, 143); /** * @param {string} name * @param {string} ll * @return {?} */ var _0x5b60 = function (name, ll) { /** @type {number} */ name = name - 0; var result = __0x33ad7[name]; if (_0x5b60[\"initialized\"] === undefined) { (function () { var jid = typeof window !== \"undefined\" ? window : typeof process === \"object\" \u0026\u0026 typeof require === \"function\" \u0026\u0026 typeof global === \"object\" ? global : this; /** @type {string} */ var listeners = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"; if (!jid[\"atob\"]) { /** * @param {?} i * @return {?} */ jid[\"atob\"] = function (i) { var str = String(i)[\"replace\"](/=+$/, \"\"); /** @type {number} */ var bc = 0; var bs; var buffer; /** @type {number} */ var Y = 0; /** @type {string} */ var pix_color = \"\"; for (; buffer = str[\"charAt\"](Y++); ~buffer \u0026\u0026 (bs = bc % 4 ? bs * 64 + buffer : buffer, bc++ % 4) ? pix_color = pix_color + String[\"fromCharCode\"](255 \u0026 bs \u003e\u003e (-2 * bc \u0026 6)) : 0) { buffer = listeners[\"indexOf\"](buffer); } return pix_color; }; } })(); /** * @param {string} data * @param {!Object} fn * @return {?} */ var testcase = function (data, fn) { /** @type {!Array} */ var secretKey = []; /** @type {number} */ var y = 0; var temp; /** @type {string} */ var testResult = \"\"; /** @type {string} */ var tempData = \"\"; /** @type {string} */ data = atob(data); /** @type {number} */ var val = 0; var key = data[\"length\"]; for (; val \u003c key; val++) { /** @type {string} */ tempData = tempData + (\"%\" + (\"00\" + data[\"charCodeAt\"](val)[\"toString\"](16))[\"slice\"](-2)); } /** @type {string} */ data = decodeURIComponent(tempData); /** @type {number} */ var x = 0; for (; x \u003c 256; x++) { /** @type {number} */ secretKey[x] = x; } /** @type {number} */ x = 0; for (; x \u003c 256; x++) { /** @type {number} */ y = (y + secretKey[x] + fn[\"charCodeAt\"](x % fn[\"length\"])) % 256; temp = secretKey[x]; secretKey[x] = secretKey[y]; secretKey[y] = temp; } /** @type {number} */ x = 0; /** @type {number} */ y = 0; /** @type {number} */ var i = 0; for (; i \u003c data[\"length\"]; i++) { /** @type {number} */ x = (x + 1) % 256; /** @type {number} */ y = (y + secretKey[x]) % 256; temp = secretKey[x]; secretKey[x] = secretKey[y]; secretKey[y] = temp; testResult = testResult + String[\"fromCharCode\"](data[\"charCodeAt\"](i) ^ secretKey[(secretKey[x] + secretKey[y]) % 256]); } return testResult; }; /** @type {function(string, !Object): ?} */ _0x5b60[\"rc4\"] = testcase; _0x5b60[\"data\"] = {}; /** @type {boolean} */ _0x5b60[\"initialized\"] = !![]; } var functionEntry = _0x5b60[\"data\"][name]; if (functionEntry === undefined) { if (_0x5b60[\"once\"] === undefined) { /** @type {boolean} */ _0x5b60[\"once\"] = !![]; } result = _0x5b60[\"rc4\"](result, ll); _0x5b60[\"data\"][name] = result; } else { result = functionEntry; } return result; }; if (typeof encode_version !== \"undefined\" \u0026\u0026 encode_version === \"sojson.v5\") { /** * @param {?} key * @param {!Object} object * @return {?} */ var strencode = function (key, object) { var self = { \"MDWYS\": \"0|4|1|3|2\", \"uyGXL\": function _cancelTransitioning(cb, TextureClass) { return cb(TextureClass); }, \"otDTt\": function handleSlide(isSlidingUp, $cont) { return isSlidingUp \u003c $cont; }, \"tPPtN\": function handleSlide(isSlidingUp, $cont) { return isSlidingUp % $cont; } }; var callbackVals = self[_0x5b60(\"0x0\", \"cEiQ\")][_0x5b60(\"0x1\", \"\u0026]Gi\")](\"|\"); /** @type {number} */ var callbackCount = 0; for (; !!","date":"2019-05-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/:4:2","series":null,"tags":["blog","js"],"title":"使用js来帮助加解密信息","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/#解密代码"},{"categories":["blog"],"content":" 测试把代码跑起来。测试成果 ojbk！ ","date":"2019-05-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/:4:3","series":null,"tags":["blog","js"],"title":"使用js来帮助加解密信息","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/#测试"},{"categories":["blog"],"content":" 总结后续我就只要把页面的参数用正则表达式弄出来。然后发送给我自己的服务器，就能获得地址啦！ 为什么我这样做呢？因为我有一台自己的服务器。后续在一些其他的应用中，我也会有更多这样的需求。所以搭建一个这样的 web 服务是非常值得的。 不得不说哪怕你再怎么骂，js 都是程序员的必经之路。 ","date":"2019-05-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/:5:0","series":null,"tags":["blog","js"],"title":"使用js来帮助加解密信息","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/#总结"},{"categories":["blog"],"content":"我看过了太多太多的影片。有好的，有坏的。我不觉得这是小学生的作业，是观后感流水账。所以不会统统记录下来。单独写出文章的影片，都是我自己觉得感触良多。正如阿甘正传里的一句台词:你永远也不会知道下一口糖果会是什么味道。下面只是我的个人推荐列表。不希望大家都能觉得好看，但希望会有一部影片，能触动到你","date":"2019-04-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E5%BD%B1%E7%89%87%E8%AE%B0%E5%BD%95/","series":null,"tags":["blog","影片"],"title":"我的影片记录","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E5%BD%B1%E7%89%87%E8%AE%B0%E5%BD%95/"},{"categories":["blog"],"content":" 简介lines 我看过了太多太多的影片。有好的，有坏的。 我不觉得这是小学生的作业，最终全变成观后感流水账。所以不会统统记录下来。 单独写出文章的影片，都是我自己觉得感触良多。 正如阿甘正传里的一句台词: 生活就像是一盒巧克力，你永远不会知道下一盒会是什么味道。 所以我不会给出关于影片的介绍。因为那是一种个人观点，也是一种剧透吧。 我也同样不会给影片进行分类，因为一部好影片是多方面的。而不仅仅是拍摄后的故事。 下面只是我的个人推荐列表。 ","date":"2019-04-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E5%BD%B1%E7%89%87%E8%AE%B0%E5%BD%95/:1:0","series":null,"tags":["blog","影片"],"title":"我的影片记录","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E5%BD%B1%E7%89%87%E8%AE%B0%E5%BD%95/#简介"},{"categories":["blog"],"content":" 影片列表 燕尾蝶 未麻的部屋 大话西游 - 系列 革命之路 无敌破坏王 王家卫 - 所有执导影片，外加一部纪录片 (摄氏零度 - 春光再现) 爱乐之城 佐伊 geostorm 人工智能 风雨哈弗路 垫底辣妹 一个明星的诞生 天气之子 活埋 此房是我造 海角七号 成为简·奥斯汀 华尔街之狼 解除好友 - 系列 网络迷踪 life is beautiful 午夜巴塞罗那 hello,树先生 抱歉打扰 头文字 D 戏梦巴黎 千与千寻 奔腾年代 驴得水 初恋五十次 别告诉她 (The Farewell) 危楼愚夫 精武英雄 前目的地 他其实没那么喜欢你 初恋红豆冰 秒速五厘米 盲井 十二猴子 怦然心动 搏击俱乐部 半个喜剧 盗梦空间 百元之恋 心动 禁闭岛 肖申克的救赎 恋空 霸王别姬 这个杀手不太冷 我的野蛮女友 盗梦侦探/红辣椒 阿甘正传 言叶之庭 寻枪 泰坦尼克号 辛德勒的名单 骡子 忌日快乐 机器人总动员 放牛班的春天 海上钢琴师 勇敢的心 楚门的世界 教父 - 系列 无间道 - 系列 当幸福来敲门 西西里的美丽传说 少年派的奇幻漂流 天堂影片院 不要抬头 少年时代 三天两夜 - 日本 1997 年 指环王 - 系列 鬼子来了 十二怒汉 飞屋环游记 闻香识女人 沉睡魔咒 1 我在雨中等你 两杆大烟枪 飞越疯人院 寻梦环游记 死亡诗社 甲方乙方 v 字仇杀队 美丽心灵 情书 钢琴家 本杰明巴顿奇事 美国往事 分手说爱你 看不见的客人 扬名立万 哈利波特 - 系列 让子弹飞 大圣归来 七宗罪 无名 被嫌弃的松子的一生 低俗小说 天使爱美丽 邪不压正 沉默的羔羊 猫鼠游戏 穆赫兰道 蝴蝶效应 心灵捕手 爱尔兰人 阳光灿烂的日子 鸟人 不能说的秘密 狩猎 喜剧之王 变脸 (1995) 告白 活着 大象席地而坐 无主之作 全城热恋 芳华 成长教育 买凶拍人 我不是潘金莲 等一个人咖啡 风声 her 大鱼 消失的爱人 大佛普拉斯 少年收容所 蔡国强的艺术 罗曼蒂克消亡史 致命魔术 被光抓走的人 致命 id 心灵奇旅 荒蛮故事 一级恐惧 孩子 L’enfant The Machinist 阳光姐妹淘 爱在黎明破晓前 - 系列 恐怖直播 超脱 上帝之城 幸福终点站 神偷奶爸 阿凡达 1、2 电锯惊魂 - 系列 真爱至上 黑天鹅 星际穿越 记忆碎片 傲慢与偏见 心迷宫 鲸 雨人 卢旺达饭店 恋恋笔记本 解救吾先生 第十一回 阳光普照 被解救的姜戈 三块广告牌 她与她的猫 你的名字 拨鼠之日 朱丽叶与梁山伯 观音山 人在囧途 入侵华尔街 疯狂的赛车 邮差 风平浪静 追凶者也 爆裂鼓手 天下无双 环形使者 模仿游戏 猜火车 后来的我们 恐怖游轮 无人知晓 香水 波斯语课 七号房的礼物 (土耳其) 小妇人 初缠恋后的二人世界 登月第一人 大赢家 神秘河 立春 江湖告急 黑客帝国 - 系列 无名之辈 浪潮 朗读者 白日焰火 黑社会 1/2 彗星来的那一夜 源代码 撞车 我想吃掉你的胰脏 桃姐 the big short 梦之安魂曲 秦颂 一个陌生女人的来信 太空救援 神探 JOKER 无姓之人 血钻 传染病 麦克法兰 实习生 这个男人来自地球 特朗勃 紫日 哆啦 A 梦伴我同行 2 功夫 孟买酒店 小情人 - 泰国 出路 -《为什么贫穷》系列纪录片第八集 发条橙 地心引力 十二夜 非常嫌疑犯 毕业生 房间 只有芸知道 谁先爱上他的 信条 断裂 少年的你 寄生虫 全裸导演 何以为家 半支烟 国王的演讲 误杀瞒天记 好莱坞往事 完美的世界 婚姻故事 好景当前 哪吒之魔童降世 英剧 -the end of the fucking world(去他妈的世界) 第一、二季 英剧 - 黑镜第一季 英剧 - 无人生还 韩剧 - 王国 美剧 - 越狱系列 美剧 - 纸牌屋 美剧 - 绝命毒师 美剧 - 风骚律师 美剧 - 诺尔切贝利 美剧 - 制造杀人犯 美剧 - 权力的游戏 意剧 - 我的天才女友 国产剧 - 蜗居 国产剧 - 北京青年 国产剧 - 裸婚时代 国产剧 - 北京爱情故事 国产剧 - 奋斗 国产剧 - 倚天屠龙记 (苏有朋版) 国产剧 - 毛骗 国产剧 - 武林外传 国产剧 - 余罪 1、2 综艺 - 美好的时光第一季 ","date":"2019-04-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E5%BD%B1%E7%89%87%E8%AE%B0%E5%BD%95/:2:0","series":null,"tags":["blog","影片"],"title":"我的影片记录","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E5%BD%B1%E7%89%87%E8%AE%B0%E5%BD%95/#影片列表"},{"categories":["blog"],"content":" 更新日志20190602: 新增 人工智能 20190702: 新增 成长教育 20190706: 新增 何以为家 20190804: 新增 房间 20190821: 新增 寄生虫/全裸导演 20190827: 新增 黑社会1/2 20190908: 新增 骡子/忌日快乐 20190911: 新增 危楼愚夫 20191014: 新增电影且加入电视剧 -英剧-the end of the fucking world(去他妈的世界)第一季、美剧-越狱系列、美剧-纸牌屋、美剧-权力的游戏、国产剧-蜗居、国产剧-北京青年、国产剧-裸婚时代、国产剧-北京爱情故事、国产剧-奋斗、哪吒之魔童降世、国产剧-毛骗、国产剧-武林外传 20191015: 新增 国产剧-余罪1、2 20191026: 新增 断裂 20191112: 新增 JOKER 20191117: 新增 少年时代 20191127: 新增 成为简·奥斯汀 20191127: 新增 少年的你 20191129: 新增 韩剧-王国 20191201: 新增 三天两夜-日本电影 20191207: 新增 沉睡恶魔1、环形使者、好莱坞往事 20191215: 新增 误杀瞒天记 20191216: 新增 初缠恋后的二人世界，超级好看 20191217: 新增 小情人-泰国 20191222: 新增 谁先爱上他的 20191225: 新增 初恋红豆冰、半个喜剧 20191228: 新增 the big short，不能说的秘密 20200102: 新增 登月第一人 20200104: 新增 好景当前 20200110: 新增 别告诉她(The Farewell) 20200114: 新增 少年收容所、被光抓走的人 20200123: 新增 勇敢的心 20200131: 新增 只有芸知道、一个陌生女人的来信 20200203: 新增 无名之辈、十二猴子 20200227: 新增 传染病 20200302: 新增 土拨鼠之日 20200303: 新增 婚姻故事 20200311: 新增 我想吃掉你的胰脏 20200313: 新增 英剧-无人生还 20200315: 新增 麦克法兰 20200322: 新增 实习生 20200406: 新增 阳光普照 20200408: 新增 大佛普拉斯 20200411: 新增 无主之作 20200420: 新增 孟买酒店 20200501: 新增 特朗勃 20200504: 新增 神秘河 20200510: 新增 爱尔兰人 20200719: 新增 盗梦侦探/红辣椒 20200727: 新增 我在雨中等你 20200802: 新增 小妇人 20200809: 新增 天气之子、秒速五厘米、言叶之庭、她与她的猫 20200920: 新增 寻枪 20200923: 新增 无姓之人 20201020: 新增 荒蛮故事 20201122: 新增 大象席地而坐 20201122: 新增 变脸(1995) 20201206: 新增 信条 20200112: 新增 十二夜 20200117: 新增 半支烟 20210119: 新增 孩子 L'enfant 20210119: 新增 毕业生 20210126: 新增 秦颂 20210205: 新增 入侵华尔街 20210210: 新增 人在囧途 20210228: 新增 风平浪静 20210313: 新增 罗曼蒂克消亡史 20210314: 新增 买凶拍人 20210323: 新增 心灵奇旅 20210328: 新增 蔡国强的艺术 20210408: 新增 波斯语课 20210409: 新增 出路-《为什么贫穷》系列纪录片第八集 20210422: 新增 观音山 20210502: 新增 七号房的礼物(土耳其) 20210511: 新增 桃姐 20210518: 新增 朱丽叶与梁山伯 20210523: 新增 第十一回、天下无双 20210530: 新增 综艺-美好的时光第一季 20210613: 新增 美剧-绝命毒师、美剧-风骚律师、哆啦A梦伴我同行2 20210615: 新增 意剧-我的天才女友 20210620: 新增 太空救援 20210716: 新增 追凶者也 20210719: 新增 海角七号 20210723: 新增 风声 20210807: 新增 疯狂的赛车 20210809: 新增 甲方乙方 20211226: 新增 鸟人 20220221: 新增 英剧-黑镜第一季 20220306: 新增 紫日 20220314: 新增 金钱男孩 20220509: 新增 扬名立万 20220805: 新增 神探 20220828: 新增 立春 20221127: 新增 阿凡达1 20230326: 新增 大赢家 20230402: 新增 阿凡达2 20230408: 新增 不要抬头 20230423: 新增 无名 20230426: 新增 鲸 ","date":"2019-04-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E5%BD%B1%E7%89%87%E8%AE%B0%E5%BD%95/:3:0","series":null,"tags":["blog","影片"],"title":"我的影片记录","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E5%BD%B1%E7%89%87%E8%AE%B0%E5%BD%95/#更新日志"},{"categories":["blog"],"content":"又有好几天没有写博客了。我谷歌日历上的任务，也不知道多久没更新了。。明天开始把。。本来是打算9点开始看电影，看完就去睡觉的。结果。。。。。真的是一部非常好看的电影啊","date":"2019-04-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/","series":null,"tags":["blog","影片"],"title":"电影_燕尾蝶","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/"},{"categories":["blog"],"content":" 简介lines 又有好几天没有写博客了。我谷歌日历上的任务，也不知道多久没更新了。。明天开始把。。本来是打算 9 点开始看电影，看完就去睡觉的。结果。。。。。 真的是一部非常好看的电影啊。 ","date":"2019-04-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/:1:0","series":null,"tags":["blog","影片"],"title":"电影_燕尾蝶","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/#简介"},{"categories":["blog"],"content":" 再次点开电影在写这篇文章的时候，我又点开了电影。除了印象中的片头旁白，我忘记了很多细节。 正式进入剧情的时候。一帮人跑向一辆披着丹盗流浪字样的火车。 随后镜头回到草丛里。里面躺着一个人。这一幕意味着故事从一开始，并不是毫无关联的起点。而是一个故事中的节点。 ","date":"2019-04-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/:2:0","series":null,"tags":["blog","影片"],"title":"电影_燕尾蝶","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/#再次点开电影"},{"categories":["blog"],"content":" 主人公","date":"2019-04-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/:3:0","series":null,"tags":["blog","影片"],"title":"电影_燕尾蝶","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/#主人公"},{"categories":["blog"],"content":" 雅佳 (音译) 最开始的细节，死去的就是她的母亲。 她的母亲是一名妓女。死去以后她母亲的“朋友们”拿走了原属于雅佳的一切。经过她们的出卖，来到了固力果的身边。 固力果也是一名妓女。原本也打算卖掉雅佳。却留意到了店里的小女孩们和毒品。留下了雅佳。 固力果因为自己有蝴蝶纹身，称呼自己为蝴蝶。所以给雅佳画了一个蝴蝶幼虫。为她起名雅佳。 雅佳认识了固力果的朋友们，并且在废品厂留了下来，融入了大家庭。 一次嫖客发现了藏在隔间的雅佳，产生了歹意。最终结果是嫖客死掉了。而在嫖客体内发现的磁带，改变了大家。 新开了 live house。由于一系列的变故。让雅佳成为了剧情的承接点。同时人设也开始变得立体起来。 探望飞鸿，每次带着精心准备的食物。展现了爱心。 有了自己的想法，编故事欺骗了飞鸿。因为现实是固力果其实为了自己的发展，抛弃了大家庭。 同时也无知无畏，自己注射了毒品。 拆掉的 live house，让雅佳决定纹身。同时体现了对飞鸿的不理解，以及对固力果的不可割舍。 记起了自己的童年，让蝴蝶和自己关联得更加紧密。 保持纯真。想依靠自己的能力，用钱重聚到大家。 她认为飞鸿就是元都人。她对自己以及大家的认知都是元都人。在结尾，她过着自己的生活。 她与刘梁魁对白也交代了一个完整的故事结局。 ","date":"2019-04-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/:3:1","series":null,"tags":["blog","影片"],"title":"电影_燕尾蝶","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/#雅佳-音译"},{"categories":["blog"],"content":" 固力果 在一开始，便交代了她的背景。 和两个哥哥。过着偷盗的日子。 二哥意外的死亡，才让固力果纹上了蝴蝶。成为自己的身份。 或许是因为厌倦了那样的生活，固力果选择了做妓女，而她的大哥，也因此离开了她，且不相认。 在 live house 后，被唱片发现了。这时候我开始认为她是爱着飞鸿的。并且挺听取飞鸿的意见。 可是人会变的。她变了。为了自己的名利和名声，断开了与之前一起的联系。成为了上海宝贝。中间有一段和飞鸿啪啪啪的过程，心里想到的都是明星后的自己，却忽视了眼前人。 在最终被挖出过往以后。又找到了飞鸿。 飞鸿也因她而死。 随后回到了大家庭。做回了自己。 她有着悲惨的故事背景。出于生活的无奈，做上了妓女。而 live house 才让她成长。发生的种种事情，让她认识了自己，找回了自己。 ","date":"2019-04-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/:3:2","series":null,"tags":["blog","影片"],"title":"电影_燕尾蝶","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/#固力果"},{"categories":["blog"],"content":" 飞鸿 他始终爱着固力果。 一直在元都无忧无虑的生活着。 当有了不义之财，第一想法就是坚持开办 live house，为了让固力果开心，展示才华。 飞鸿看向固力果的眼神，那就叫爱情。 之后的唱片公司。毅然帮固力果做主，帮助固力果有更好的事业成长。 却被唱片公司陷害。好运回到了 live house，却发现伤人的不是唱片公司。而是固力果。 成全了固力果，自己做了罪人。当固力果有难，表现了无畏。为了固力果和大家，不惜丢掉了性命。 ","date":"2019-04-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/:3:3","series":null,"tags":["blog","影片"],"title":"电影_燕尾蝶","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/#飞鸿"},{"categories":["blog"],"content":" 刘梁魁 他失去了弟弟。有一个做妓女的妹妹。一个心狠手辣的黑社会老大。 但在黑社会如果有一个这样的妹妹，谁会来做小弟呢？除了这个原因，与固力果的不相认，有他自己对妹妹的无奈。 他有爱心，救活了雅佳。有情义，对自己的妹妹念念不忘。 片尾。他在车上和司机说，拿到了磁带赚一票，就回家。可转眼，变遇到了雅佳。拿到了磁带。忍不住问了雅佳她和妓女固力果的情况。没有选择追上去找回固力果。 说明了他的心里，不愿意承认固力果做妓女的事实。拿到了磁带，他真的会回去吗？ 关于他的故事，就像是侠客的儿女情长。 ","date":"2019-04-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/:3:4","series":null,"tags":["blog","影片"],"title":"电影_燕尾蝶","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/#刘梁魁"},{"categories":["blog"],"content":" 总结雅佳是一个有爱心，有自己想法，无知无畏，带有蝴蝶纹身，保持纯真，捆绑主题的人物。 固力果属于小市井人物，有自己的成长，爱情，事业，过往，抉择。 飞鸿有情有义。除了爱人，无欲无求。而为了自己心中爱的一切，甚至可以深受无限的苦痛。 刘梁魁为了目的心狠手辣，但又有着自己的痛处。 就是这些人，组成了这样一个故事。 ","date":"2019-04-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/:4:0","series":null,"tags":["blog","影片"],"title":"电影_燕尾蝶","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/#总结"},{"categories":["blog"],"content":"有一段时间用有道云笔记来做笔记。里面有一个非常喜欢的功能就是流程图。让阅读文章的时候，体验更加的友好。同时我在看自己的站点过程中，觉得不够美观。更多的使用图表类似的功能，会让表达更加直观。所以今天就来动手做一下","date":"2019-03-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/","series":null,"tags":["blog","hugo"],"title":"hugo流程图mermaid","uri":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/"},{"categories":["blog"],"content":" 简介有一段时间用有道云笔记来做笔记。里面有一个非常喜欢的功能就是流程图. 同时我在看自己的站点过程中，觉得不够美观。更多的使用图表类似的功能，会让表达更加直观。所以今天就在 hugo 里加上图表. ","date":"2019-03-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/:1:0","series":null,"tags":["blog","hugo"],"title":"hugo流程图mermaid","uri":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/#简介"},{"categories":["blog"],"content":" Hugo 的渲染","date":"2019-03-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/:2:0","series":null,"tags":["blog","hugo"],"title":"hugo流程图mermaid","uri":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/#hugo-的渲染"},{"categories":["blog"],"content":" 使用 markdown主要采用 markdown 文件进行文章的编写，它的方案如下: Md 文件的解析，是用的 blackfriday 除了已有的自带拓展，提供 shortcodes 来进行功能的拓展 ","date":"2019-03-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/:2:1","series":null,"tags":["blog","hugo"],"title":"hugo流程图mermaid","uri":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/#使用-markdown"},{"categories":["blog"],"content":" Shortcodes 的演示使用 {{\u003c youtube 8HnLRrQ3RS4 \u003e}} 的简短编写，即可完成如下 youtube 视频的展示。 想要自动播放的话，使用 {{\u003c youtube id=\"8HnLRrQ3RS4\" autoplay=\"true\" \u003e}}\" 即可。 ","date":"2019-03-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/:2:2","series":null,"tags":["blog","hugo"],"title":"hugo流程图mermaid","uri":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/#shortcodes-的演示"},{"categories":["blog"],"content":" 为 markdown 拓展流程图","date":"2019-03-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/:3:0","series":null,"tags":["blog","hugo"],"title":"hugo流程图mermaid","uri":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/#为-markdown-拓展流程图"},{"categories":["blog"],"content":" 关于 mermaidmermaid 是一个 js 库，用来渲染流程图用的。2 w 多的 star，看了一下文档，觉得博客是肯定够了的。 如果真的要求特别高，那不如用专业软件做出来，导出图片更好。 ","date":"2019-03-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/:3:1","series":null,"tags":["blog","hugo"],"title":"hugo流程图mermaid","uri":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/#关于-mermaid"},{"categories":["blog"],"content":" 拓展步骤 在你使用的主题中，找到 yoursite/themes/themes_name/layouts 文件夹，如果没有 shortcodes 文件夹，就自己新建一个 把 mermaid的script标签 贴到 yoursite/themes/themes_name/layouts/partials/footer.html 的 footer外部 \u003c!--head部分添加--\u003e \u003cscript src=\"https://cdn.bootcss.com/mermaid/8.0.0-rc.8/mermaid.min.js\"\u003e\u003c/script\u003e 在 shortcodes 目录下新建 mermaid.html 文件 \u003c!--mermaid.html--\u003e \u003cdiv class=\"mermaid\" align=\"{{ if .Get \"align\" }} {{ .Get \"align\" }} {{ else }} center {{ end }}\"\u003e {{ safeHTML .Inner }} \u003c/div\u003e ","date":"2019-03-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/:3:2","series":null,"tags":["blog","hugo"],"title":"hugo流程图mermaid","uri":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/#拓展步骤"},{"categories":["blog"],"content":" Ojbk，测试一下 {{\u003c mermaid \u003e}} sequenceDiagram participant Alice participant Bob Alice-\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! {{\u003c /mermaid \u003e}} SequenceDiagram Participant Alice Participant Bob Alice-\u003eJohn: Hello John, how are you? Loop Healthcheck John-\u003eJohn: Fight against hypochondria End Note right of John: Rational thoughts prevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! ","date":"2019-03-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/:3:3","series":null,"tags":["blog","hugo"],"title":"hugo流程图mermaid","uri":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/#ojbk测试一下"},{"categories":["blog"],"content":" 文档参考mermaid文档 hugo文档 ","date":"2019-03-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/:4:0","series":null,"tags":["blog","hugo"],"title":"hugo流程图mermaid","uri":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/#文档参考"},{"categories":["blog"],"content":"我几乎保持着每周至少2部电影的节奏。前几天在找电影的时候，翻到了小李子(莱昂纳多·迪卡普里奥-Leonardo DiCaprio)的wiki，就想来看看这部电影。个人的评分应该能给到8分以上。可能含有剧透哦","date":"2019-03-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/","series":null,"tags":["blog","影片"],"title":"电影_革命之路","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/"},{"categories":["blog"],"content":" 简介lines 我几乎保持着每周至少 2 部电影的节奏。前几天在找电影的时候，翻到了小李子 (莱昂纳多·迪卡普里奥 -Leonardo DiCaprio) 的 wiki，就想来看看这部电影。个人的评分应该能给到 8 分以上。可能含有剧透哦 ","date":"2019-03-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/:1:0","series":null,"tags":["blog","影片"],"title":"电影_革命之路","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/#简介"},{"categories":["blog"],"content":" 剧情概况分析","date":"2019-03-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/:2:0","series":null,"tags":["blog","影片"],"title":"电影_革命之路","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/#剧情概况分析"},{"categories":["blog"],"content":" 男主和女主吵架可能只是生活间的一件小事情，也有可能是生活中压抑了很久。 在一次矛盾中，双方爆发了矛盾。这其实很平常，恋人之间都会有。 看的时候我在想:或许我也会这样子耍脾气，或者受不了突然而然的耍性子。 幸运的是他们彼此都深爱着对方。找到了一个解决方案。 ","date":"2019-03-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/:2:1","series":null,"tags":["blog","影片"],"title":"电影_革命之路","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/#男主和女主吵架"},{"categories":["blog"],"content":" 准备去巴黎找到一个解决的办法 我的观念中: 男的在吵架以后是需要时间冷静下来，或者放空自己的。而女的不一样。当场就需要把问题解决。时间越长，问题就会变得越严重。我很少遇到说冷静了以后，再来和你认错的女生。至少她们表面上不会来主动联系你。我很佩服那些刚说完，在极短时间之内就能认识到问题。并且解决他的男人。 而电影中女主却主动来解决这件事情，非常了不起。 在一番对谈以后，男主接受了对方的想法，共同决定去巴黎。开始新的生活，解决生活中的矛盾。 并且和周围的亲朋好友都说了这件事情。周围的人都不看好，并且觉得是个奇怪而且不现实的想法。 而一个精神病院出来的人，却理解他们。很不可思议，但是却合情合理。 精神病人直面问题的根本，没有任何道德，社会，生活等方方面面的束缚。保持着初心。 如果是我，也会觉得不现实。我其实是思想上的巨人，行动上的矮子。晚上想好了一切，第二天却还是如初。更别说和电影中一样努力而积极的态度了。但是我要改。而且一直在努力修正。其实这个站点，以及我尽量让自己写日志，就是我想改变的一部分。希望自己能保持下去。 ","date":"2019-03-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/:2:2","series":null,"tags":["blog","影片"],"title":"电影_革命之路","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/#准备去巴黎"},{"categories":["blog"],"content":" 女主怀孕，男主晋升女主角检测出来了怀孕。男主在工作中意外的升职。 怀孕让去巴黎，成为了一个不那么正确的决定。 没有人会想在怀孕的时候离开熟悉的地方而去到未知的环境，除非是为了小孩移民。 而男主的升职，会让生活变得更加美好。 这两件事情都直接影响到了男主。而女主确实心意已决。哪怕是自己引流掉小孩，也要去。同时对于男主的动摇，心存愤怒。 男主也无法接受女主的言论和引流想法。 引发了更大的矛盾。 ","date":"2019-03-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/:2:3","series":null,"tags":["blog","影片"],"title":"电影_革命之路","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/#女主怀孕男主晋升"},{"categories":["blog"],"content":" 女主让步，矛盾激化 女主无能为力，重新忍受与之前的一样，毫无激情的生活。并且更加消极。 而男主却不是这么认为的。对女主的态度产生了不满，激化出来了更多的矛盾。 她说:我不再爱你了。 精神病人的到访，将所有隐藏的矛盾。一一解刨了出来。 看出来女主的一如既往，便开始责问男主。毕竟在他看来，一件正确的事情，没有任何力量可以阻挡。 男主变得愤怒，我想是因为一个外人站在了女主的角度提问。虽然不了解所有的情况。却也句句都很直白，一针见血。 当精神病人向女主表达歉意，而看到女主态度的时候，也理解了男主为什么会如此愤怒。 精神病人也知道了，矛盾是双方的问题。 精神病人说:我很高兴我不会是那个未出世的孩子。 女主觉得男主已经不知道什么是爱了。 男主觉得女主的态度让人抓狂。同时也让自己进入了极度的紧张状态。 男主其实并没有多大的错误，更加的理性。这个不是优柔寡断或者说善变。 女主为了爱情，为了生活，做出了很多的努力。当没有办法和相爱的人一起进退，她选择了不爱。 ","date":"2019-03-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/:2:4","series":null,"tags":["blog","影片"],"title":"电影_革命之路","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/#女主让步矛盾激化"},{"categories":["blog"],"content":" 女主引流死亡，男主悲痛 女主回到家里。为男主做了早餐。像是一切美好如初。 其实这算是女主的一个补偿，用来补偿自己已经想好的念头(引流掉小孩)。 或许她有一个人去欧洲的计划，或许她准备好聚好散，或许这是她对于之后生活计划。 男主带着小孩去到了城里。 没有人愿意见到这个的结局。两个相爱的人，生活中的矛盾引发了这样一出闹剧。 或许很多人接受不了女主这样的处理方式。而我的看法是，这是她自己的选择。如果她自己如此积极/努力的情况下，也都没法帮助到自己。我想不应该指责她。 我在很小的时候，知道了人最多也就 100 岁。而 100 岁以后就会死亡。我的想象中，会是睡着了一样没有任何感觉。永久永久下去。我很害怕。 我坐在小霸王游戏机面前，眼泪直流。我妈妈很担心我，和我说: 如果一个人能活到 500 岁，10000 岁又能怎么样？有很多人自杀，是为什么？是因为他们受不了一些痛苦/对生活产生了绝望。他们不愿意活那么久。所以你不要担心这件事情，你要把自己的生活变美好。 ","date":"2019-03-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/:2:5","series":null,"tags":["blog","影片"],"title":"电影_革命之路","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/#女主引流死亡男主悲痛"},{"categories":["blog"],"content":" 大众的评论 大家对这对夫妇褒贬不一。 有的人深思，有的人无所谓，有的人缅怀，有的人不愿意再提起。 世界就是这样的，你就是男主角。别人永远都是别人。 ","date":"2019-03-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/:2:6","series":null,"tags":["blog","影片"],"title":"电影_革命之路","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/#大众的评论"},{"categories":["blog"],"content":" 总结","date":"2019-03-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/:3:0","series":null,"tags":["blog","影片"],"title":"电影_革命之路","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/#总结"},{"categories":["blog"],"content":" 电影评价 电影中关于 精神病人 的片段一定要仔细观看，算是剧情的点睛之笔。完美解释了当时男女主角的内心。 演技都非常好，电影的拍摄也很好。 我给 8 分以上，希望还能有这样的好电影啊。 精神病人的父亲，就像是我这样的观众。心里有想法，却不再去辩驳。 ","date":"2019-03-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/:3:1","series":null,"tags":["blog","影片"],"title":"电影_革命之路","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/#电影评价"},{"categories":["blog"],"content":" 今天看到相关的话语 有人說：人這輩子壹共會死三次。第壹次是妳的心臟停止跳動，那麽從生物的角度來說，妳死了；第二次是在葬禮上，認識妳的人都來祭奠，那麽妳在社會上的地位就死了；第三次是在最後壹個記得妳的人死後，那妳就真的死了。 亨利·大卫·梭罗曾言：大部分人过着默默而绝望的生活，带着心中尚存的歌谣，走进坟墓。（Most men lead lives of quiet desperation and go to the grave with the song still in them.) 好好消化一下这个电影，让自己拥有更美好的生活吧。 ","date":"2019-03-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/:3:2","series":null,"tags":["blog","影片"],"title":"电影_革命之路","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/#今天看到相关的话语"},{"categories":["blog"],"content":"很喜欢王家卫的电影。有格调，而不是装。常常会拿来翻看。感受都是不一样的","date":"2019-01-13","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%8E%8B%E5%AE%B6%E5%8D%AB/","series":null,"tags":["blog","影片"],"title":"王家卫","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%8E%8B%E5%AE%B6%E5%8D%AB/"},{"categories":["blog"],"content":" 简介lines 很喜欢王家卫的电影。有格调，而不是装。常常会拿来翻看。感受都是不一样的。 ","date":"2019-01-13","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%8E%8B%E5%AE%B6%E5%8D%AB/:1:0","series":null,"tags":["blog","影片"],"title":"王家卫","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%8E%8B%E5%AE%B6%E5%8D%AB/#简介"},{"categories":["blog"],"content":" 蓝莓之夜当女主站在楼下，望着窗户，心里的旁白 该怎么和一个不想分别的道别呢？所以我会不说再见 ","date":"2019-01-13","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%8E%8B%E5%AE%B6%E5%8D%AB/:1:1","series":null,"tags":["blog","影片"],"title":"王家卫","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%8E%8B%E5%AE%B6%E5%8D%AB/#蓝莓之夜"},{"categories":["blog"],"content":" 摄氏零度 (春光乍泄纪录片)坐在拍片房间里，只剩下她自己一人的旁白 在记忆里的感觉是潮湿的，感觉都是软软的 有点，生命感很严重。好像有生命，可是有点生病 不晒太阳的那种感觉 当他们两最后一次分开时候 次次你说要来就来，要走就走。我都没有哼过一声 但我想过了，这是最后一次 为什么次次都是我做不开心的那个，你做走的那个 其实我也可以的阿，我不舍得罢了 这次我想调换一下位置,我走先 当知道自杀死掉了以后 我知道我和他不会再见，所以我留了一个纪念给他(他自己的护照，让他们永远不能分开) ","date":"2019-01-13","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%8E%8B%E5%AE%B6%E5%8D%AB/:1:2","series":null,"tags":["blog","影片"],"title":"王家卫","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%8E%8B%E5%AE%B6%E5%8D%AB/#摄氏零度-春光乍泄纪录片"},{"categories":null,"content":"About Me","date":"2019-01-02","objectID":"/about/","series":null,"tags":null,"title":"Offline","uri":"/about/"},{"categories":null,"content":"kentxxq,放着我的所有 wechat:kentxxq github:kentxxq email:admin@kentxxq.com ","date":"2019-01-02","objectID":"/about/:0:0","series":null,"tags":null,"title":"Offline","uri":"/about/#"},{"categories":["blog"],"content":"oracle普通表转分区表","date":"2018-12-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/","series":null,"tags":["blog","oracle"],"title":"oracle-普通表转分区表","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/"},{"categories":["blog"],"content":" 简介oracle 有很多的版本，现在的话，常用的有 11g，12cR1/R2。都有不同的方法 对于数据库，我是不推荐使用外键，存储过程，或者触发器的。除非对数据需要超高度的一致性要求，同时不规范的数据，是属于不允许的 数据库的拓展需要添加 新的集群存储，新的机器部署oracle服务，很难像应用服务器一样动态部署，相反拓展服务器更加简单。承担了这一部分的数据库压力 外键是也是有 性能消耗 的，同时内部加锁，更容易出现 死锁 问题 尽量少的数据库约束，越方便数据之间的 解耦合。否则你会发现所有的表都互相依赖。牵一发而动全身 应用应该知道自己的操作是在干嘛，而不是考虑不周，让写在数据库里的 潜规则 告诉你必须如何 方便 读写分离，更好的解决了数据库写方面的压力，而读数据的锁几乎没有压力 ","date":"2018-12-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/:1:0","series":null,"tags":["blog","oracle"],"title":"oracle-普通表转分区表","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/#简介"},{"categories":["blog"],"content":" 操作前提 主键 拥有自己的逻辑 id，而不是业务 id 主键。否则不方便以后的水平拓展 使用 oracle 提供的包来检测是否可行 ","date":"2018-12-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/:2:0","series":null,"tags":["blog","oracle"],"title":"oracle-普通表转分区表","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/#操作前提"},{"categories":["blog"],"content":" 12cR1 和 11g --检查可用性 EXEC DBMS_REDEFINITION.can_redef_table(UNAME =\u003e 'QX_HENGSHAN',TNAME =\u003e 'A20181220_2'); --开始重定义 DBMS_REDEFINITION.START_REDEF_TABLE( uname =\u003e 'STEVE', orig_table =\u003e 'salestable', int_table =\u003e 'int_salestable1, int_salestable2, int_salestable3', col_mapping =\u003e NULL, options_flag =\u003e DBMS_REDEFINITION.CONS_USE_ROWID, part_name =\u003e 'sal03q1,sal03q2,sal03q3', continue_after_errors =\u003e TRUE); --开始拷贝数据 DBMS_REDEFINITION.COPY_TABLE_DEPENDENTS( uname =\u003e 'AKAHALI', orig_table =\u003e 'ST1', int_table =\u003e 'T1', num_errors =\u003e lvn_errs ); --完成重定义 dbms_redefinition.finish_redef_table( uname =\u003e 'AKAHALI', orig_table =\u003e 'ST1', int_table =\u003e 'T1' ); ","date":"2018-12-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/:3:0","series":null,"tags":["blog","oracle"],"title":"oracle-普通表转分区表","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/#12cr1-和-11g"},{"categories":["blog"],"content":" 12cR2 ALTER TABLE table_name MODIFY table_partitioning_clauses [ filter_condition ] [ ONLINE ] [ UPDATE INDEXES [ ( index { local_partitioned_index | global_partitioned_index | GLOBAL } [, index { local_partitioned_index | global_partitioned_index | GLOBAL } ]... ) ] ] --实例 alter table emp modify partition by range (deptno) interval (10) ( partition p1 values less than (10), partition p2 values less than (20) ) online update indexes (idx_emp_no local); ","date":"2018-12-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/:4:0","series":null,"tags":["blog","oracle"],"title":"oracle-普通表转分区表","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/#12cr2"},{"categories":["blog"],"content":" 其他 中小型的系统或者 olap 类型适合分区表，后期超大存储，建议用分布式 --一般分区表推荐这样建立两层，了解业务，自己来进行分层 partition by list(center_no) subpartition by list(join_year) subpartition template ( subpartition SP_2014 VALUES ('2014'), subpartition SP_2015 values ('2015'), subpartition SP_2016 values ('2016') ) ( partition p_433127 values ('433127'), partition P_433122 values ('433122'), partition P_433101 values ('433101') ); ","date":"2018-12-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/:5:0","series":null,"tags":["blog","oracle"],"title":"oracle-普通表转分区表","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/#其他"},{"categories":["blog"],"content":"以前对于位运算, 二级制了解的比较少. 这里统一记录一下使用和理解.","date":"2018-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/","series":null,"tags":["blog","python"],"title":"二进制和位运算","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["blog"],"content":" 简介以前对于位运算, 二级制了解的比较少. 这里统一记录一下使用和理解. 主要使用 python 做示范. ","date":"2018-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/:1:0","series":null,"tags":["blog","python"],"title":"二进制和位运算","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/#简介"},{"categories":["blog"],"content":" 内容","date":"2018-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/:2:0","series":null,"tags":["blog","python"],"title":"二进制和位运算","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/#内容"},{"categories":["blog"],"content":" 进制2 进制：逢 2 进 1 8 进制：逢 8 进 1 16 进制：逢 16 进 1 在 C 程序中的表示 (python 中也一样)： 0b101 /*2进制 0b开头*/ 0115 /*8进制 0开头*/ 0xFFF /*16进制 0x开头*/ 转换十进制方法: 个位直接加，十位是进制数的 1 次方，百位是进制数的 2 次方，高位以此类推即可 0b101 = 1 + 0*2 + 1*2*2 0115 = 5 + 1*8 + 1*8*8 0xFAF = 15 + 10*15 + 15*15*15 ","date":"2018-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/:2:1","series":null,"tags":["blog","python"],"title":"二进制和位运算","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/#进制"},{"categories":["blog"],"content":" 位运算符我其实用的不是特别多，见的也不多。但是在很多的官方案例中出现过，比如 python 人脸识别中的跳出循环 if cv2.waitKey(1) \u0026 0xFF == ord('q'): break 先把所有的运算符列出来： \u003c\u003c #左移 \u003e\u003e #右移 | #位或 \u0026 #位与 ^ #位异或 ~ #非 \u003c\u003c #左移 将所有的0和1的位置进行左移，移位之后将空位补0 左移操作相当于乘以2**n，以5 \u003c\u003c 3 为例，相当于5(2*3),结果为40 0b101 变成了 0b101000 # 一个int是4个字节，一个字节是8位(bit)，它存储的大小就是32位 # 如果加了0，超出了32位边界，那么就是溢出了 \u003e\u003e #右移 将所有的0和1的位置进行右移(直接舍弃)，空位正数补0，负数补1 右移操作相当于除以2**n，8 \u003e\u003e 3 相当于8/(2**3)=1 | #位或 0b110 | 0b101 #输出7,即0b111 只要有一位有1就为1，可以用在综合条件 \u0026 #位与 0b110 \u0026 0b011 #输出2，即0b010 相同的位才为1，可以用在linux权限 ^ #位异或 0b1010 ^ 0b1111 #输出5，即0b0101 异或常用于将所有的位反转，相同的位置是0，否则其他的位置变1， ~ #非 ~0b101 #输出2，即0b010 这个是单独运算的，直接就把所有的反转了 ","date":"2018-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/:2:2","series":null,"tags":["blog","python"],"title":"二进制和位运算","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/#位运算符"},{"categories":["blog"],"content":" 理解 cv2.waitKey(1) \u0026 0xFF == ord('q') 查看 python 结果 $ python Python 3.6.3 (default, Oct 16 2017, 17:26:31) [GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.37)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. \u003e\u003e\u003e print(ord('q')) 113 查看键盘 q 对应的数字是多少 #include \u003cstdio.h\u003e int main() { char i; scanf(\"%c\", \u0026i); printf(\"i = %d \\n\", i); return 0; } Launching: '/Users/user/kent/c/a.out' Working directory: '/Users/user/kent/c' 1 arguments: argv[0] = '/Users/user/kent/c/a.out' q q = 113 Process exited with status 0 那么推算如下 cv2.waitKey(1) \u0026 0xFF == ord('q') cv2.waitKey(1) \u0026 0xFF == 113 0xFF代表了你键盘上的所有按键都能匹配到(包括一些系统自己拓展的特殊按键)。 当我们按了`q`键,cv2.waitKey(1)得到的就是113的二进制，和0xFF匹配出来的结果就是二进制的113，在任何系统上转换为十进制，都会和右边的十进制113相等。 避免了bug ","date":"2018-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/:2:3","series":null,"tags":["blog","python"],"title":"二进制和位运算","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/#理解-cv2waitkey1--0xff--ordq"},{"categories":["blog"],"content":"在自己的机器还有服务器上面，都应该搭建好pyenv。网络上的教程太多了，但是说的又很乱。所以自己稍微整理一下。这次的目的是写一个及其简单的过程，所以如果有具体问题，请看官方文档","date":"2017-10-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E7%9A%84%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/","series":null,"tags":["blog","python"],"title":"python的文件项目打包","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E7%9A%84%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/"},{"categories":["blog"],"content":" 简介打算自己做一个 python 项目, 然后推到 pypi 上去. 这次的目的记录写一个及其简单的过程，所以如果有具体问题，请看官方文档。 ","date":"2017-10-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E7%9A%84%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/:1:0","series":null,"tags":["blog","python"],"title":"python的文件项目打包","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E7%9A%84%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/#简介"},{"categories":["blog"],"content":" 先看目录结构 $ tree . ├── MANIFEST.in ├── README.md ├── myapp │ ├── 1.txt │ ├── __init__.py │ ├── __pycache__ │ │ ├── __init__.cpython-36.pyc │ │ └── test.cpython-36.pyc │ ├── test.py │ └── txt │ └── 1.txt ├── myapp2 │ └── test222.py └── setup.py 4 directories, 10 files MANIFEST.in 用来记录除了 py 文件外，需要打包的文件 # 包含文件 include README.md # 递归-包含 recursive-include myapp/txt * README.md 一个用来简单介绍的文档 myapp 和 myapp2 都是存放代码 setup.py 是用来安装和打包的主要文件 # -*- coding: utf-8 -*- from setuptools import setup, find_packages setup( name='kentxxq', # 项目名 version='1.0.2', # 版本号 zip_safe=False, # 因为部分工具不支持zip，推荐禁用 packages=find_packages(), # 当前目录下所有的包 include_package_data=True, # 启用清单文件MANIFEST.in install_requires=[ # 依赖列表 \"Scrapy\u003e=1.4.0\", ] # 上传到PyPI所需要的信息 author=\"kentxxq\", author_email=\"805429509@qq.com\", description=\"This is an Example Package\", license=\"PSF\", keywords=\"hello world example examples\", url=\"https://a805429509.github.io/\", ) ","date":"2017-10-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E7%9A%84%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/:1:1","series":null,"tags":["blog","python"],"title":"python的文件项目打包","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E7%9A%84%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/#先看目录结构"},{"categories":["blog"],"content":" 运行打包 python setup.py sdist # 构建物在这里 dist/kentxxq-1.0.2.tar.gz ","date":"2017-10-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E7%9A%84%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/:1:2","series":null,"tags":["blog","python"],"title":"python的文件项目打包","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E7%9A%84%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/#运行打包"},{"categories":["blog"],"content":" 开始安装直接拷贝 dist/kentxxq-1.0.2.tar.gz 到目标机器，进行解压。 python setup.py install ","date":"2017-10-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E7%9A%84%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/:1:3","series":null,"tags":["blog","python"],"title":"python的文件项目打包","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E7%9A%84%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/#开始安装"},{"categories":["blog"],"content":" 安装完成后，查看安装结果 $ tree kentxxq-1.0.2-py3.6.egg kentxxq-1.0.2-py3.6.egg ├── EGG-INFO │ ├── dependency_links.txt │ ├── not-zip-safe │ ├── PKG-INFO │ ├── requires.txt │ ├── SOURCES.txt │ └── top_level.txt └── myapp ├── __init__.py ├── __pycache__ │ ├── __init__.cpython-36.pyc │ └── test.cpython-36.pyc ├── test.py └── txt └── 1.txt 4 directories, 11 files 没有 __init__.py 的 myapp2 是没有打包的。 myapp 中 1.txt 没有进入包内，而 MANIFEST.in 中的记录的 recursive-include myapp/txt * 在包内。 ","date":"2017-10-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E7%9A%84%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/:1:4","series":null,"tags":["blog","python"],"title":"python的文件项目打包","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E7%9A%84%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/#安装完成后查看安装结果"},{"categories":["blog"],"content":"oracle的DML_Error_Logging特性","date":"2017-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-dml_error_logging%E7%89%B9%E6%80%A7/","series":null,"tags":["blog","oracle"],"title":"oracle-DML_Error_Logging特性","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-dml_error_logging%E7%89%B9%E6%80%A7/"},{"categories":["blog"],"content":" 简介在工作中，常常要进行 oracle 数据的临时备份，还有导入数据的需求。但是却因为在源数据中个别数据不合法，导致无法插入。 功能效果： 把合法的数据导入进入目标表 把不合法的数据插入一张指定的表，并且记录下原因 ","date":"2017-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-dml_error_logging%E7%89%B9%E6%80%A7/:1:0","series":null,"tags":["blog","oracle"],"title":"oracle-DML_Error_Logging特性","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-dml_error_logging%E7%89%B9%E6%80%A7/#简介"},{"categories":["blog"],"content":" 需要用到 dbms 包 (10gR2 后版本支持) SQL\u003e DESC dbms_errlog.create_error_log Parameter Type Mode Default? ------------------- -------- ---- -------- DML_TABLE_NAME VARCHAR2 IN ERR_LOG_TABLE_NAME VARCHAR2 IN Y ERR_LOG_TABLE_OWNER VARCHAR2 IN Y ERR_LOG_TABLE_SPACE VARCHAR2 IN Y SKIP_UNSUPPORTED BOOLEAN IN Y SQL\u003e --默认会创建ERR$_SOURCE表，在``第二个``参数可以自己输入表名 ","date":"2017-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-dml_error_logging%E7%89%B9%E6%80%A7/:1:1","series":null,"tags":["blog","oracle"],"title":"oracle-DML_Error_Logging特性","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-dml_error_logging%E7%89%B9%E6%80%A7/#需要用到-dbms-包-10gr2-后版本支持"},{"categories":["blog"],"content":" 创建源表 source 的目标表 dest BEGIN DBMS_ERRLOG.create_error_log (dml_table_name =\u003e 'SOURCE'); END; ","date":"2017-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-dml_error_logging%E7%89%B9%E6%80%A7/:1:2","series":null,"tags":["blog","oracle"],"title":"oracle-DML_Error_Logging特性","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-dml_error_logging%E7%89%B9%E6%80%A7/#创建源表-source-的目标表-dest"},{"categories":["blog"],"content":" 在 insert 语句后按照固定格式填写 INSERT INTO dest SELECT * FROM source LOG ERRORS INTO err$_source('INSERT') REJECT LIMIT UNLIMITED; ","date":"2017-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-dml_error_logging%E7%89%B9%E6%80%A7/:1:3","series":null,"tags":["blog","oracle"],"title":"oracle-DML_Error_Logging特性","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-dml_error_logging%E7%89%B9%E6%80%A7/#在-insert-语句后按照固定格式填写"},{"categories":["blog"],"content":"在linux中，内存一般是2kb-4kb每页，如果是大内存，那么pagetables将会非常大。cpu在查找使用内存的时候，会比较慢。使用hugepages，一个内存页可以设置为2MB-1GB。从而可以加快对内存的访问速度。2MB-4MB，是适用于100GB一下的内存。1GB则适用于TB级别的内存容量","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql_hugepages%E9%85%8D%E7%BD%AE/","series":null,"tags":["blog","mysql"],"title":"mysql_hugepages配置","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql_hugepages%E9%85%8D%E7%BD%AE/"},{"categories":["blog"],"content":" 简介在 linux 中，内存一般是 2kb-4kb 每页，如果是大内存，那么 pagetables 将会非常大。mysql 在查找使用内存的时候，会比较慢。使用 hugepages，一个内存页可以设置为 2MB-1GB。从而可以加快对内存的访问速度。2MB-4MB，是适用于 100GB 一下的内存。 1GB 则适用于 TB 级别的内存容量。 ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql_hugepages%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","mysql"],"title":"mysql_hugepages配置","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql_hugepages%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 开始配置 mysql 适用 hugepages [mysql@centos1 ~]$ cat /proc/meminfo MemTotal: 1016460 kB MemFree: 557140 kB MemAvailable: 551864 kB Buffers: 948 kB Cached: 121004 kB SwapCached: 0 kB Active: 313228 kB Inactive: 83928 kB Active(anon): 275372 kB Inactive(anon): 6524 kB Active(file): 37856 kB Inactive(file): 77404 kB Unevictable: 0 kB Mlocked: 0 kB SwapTotal: 839676 kB SwapFree: 839676 kB Dirty: 0 kB Writeback: 0 kB AnonPages: 275228 kB Mapped: 28304 kB Shmem: 6692 kB Slab: 35700 kB SReclaimable: 14504 kB SUnreclaim: 21196 kB KernelStack: 2208 kB PageTables: 4344 kB NFS_Unstable: 0 kB Bounce: 0 kB WritebackTmp: 0 kB CommitLimit: 1347904 kB Committed_AS: 1719888 kB VmallocTotal: 34359738367 kB VmallocUsed: 5468 kB VmallocChunk: 34359730176 kB HardwareCorrupted: 0 kB AnonHugePages: 4096 kB HugePages_Total: 0 HugePages_Free: 0 HugePages_Rsvd: 0 HugePages_Surp: 0 Hugepagesize: 2048 kB DirectMap4k: 32704 kB DirectMap2M: 1015808 kB 上面可以看出没有启用 hugepages，默认 hugepages 每页大小为2mb。 而当前的 pagetables 为4344kB ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql_hugepages%E9%85%8D%E7%BD%AE/:1:1","series":null,"tags":["blog","mysql"],"title":"mysql_hugepages配置","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql_hugepages%E9%85%8D%E7%BD%AE/#开始配置-mysql-适用-hugepages"},{"categories":["blog"],"content":" centos 系统设置禁用 thp，在各个数据库的官方文档中都明确指出了透明大页有可能出现各种问题。 设置 hugepages 的个数。加入 mysql 所在的组 (1000) 因为是虚拟机，mac 硬盘休眠，就会造成时间上面的不准确。所以加上了一个时间同步的命令 vi /etc/rc.d/rc.local # 尾部加入 if test -f /sys/kernel/mm/transparent_hugepage/enabled; then echo never \u003e /sys/kernel/mm/transparent_hugepage/enabled fi if test -f /sys/kernel/mm/transparent_hugepage/defrag; then echo never \u003e /sys/kernel/mm/transparent_hugepage/defrag fi # 设置2mb一个的hugepage，400个，就是800m。 # 在mysql的启动日志中，会有记录需要的内存数量：Initializing buffer pool, total size = 768M 略大即可 echo 410 \u003e /proc/sys/vm/nr_hugepages # mysql所在的用户组 echo 1000 \u003e /proc/sys/vm/hugetlb_shm_group /usr/sbin/ntpdate ntp.shu.edu.cn \u003e\u003e /var/log/rc.log /usr/sbin/hwclock -w \u003e\u003e /var/log/rc.log ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql_hugepages%E9%85%8D%E7%BD%AE/:1:2","series":null,"tags":["blog","mysql"],"title":"mysql_hugepages配置","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql_hugepages%E9%85%8D%E7%BD%AE/#centos-系统设置"},{"categories":["blog"],"content":" centos 开启 hugepages 后的内存pagetables 减小不明显，但是确实减小了。我在看的时候，发现系统用到了 swap 内存，可能我的内存还是设置过大了 在 mysql 日志中有初始化内存的大小显示。那就是要用到的 hugepage 大小 [root@centos1 ~]# cat /proc/meminfo MemTotal: 1016460 kB MemFree: 69104 kB MemAvailable: 11624 kB Buffers: 0 kB Cached: 16892 kB SwapCached: 14032 kB Active: 35168 kB Inactive: 38428 kB Active(anon): 28708 kB Inactive(anon): 28676 kB Active(file): 6460 kB Inactive(file): 9752 kB Unevictable: 0 kB Mlocked: 0 kB SwapTotal: 839676 kB SwapFree: 642936 kB Dirty: 0 kB Writeback: 0 kB AnonPages: 48832 kB Mapped: 6296 kB Shmem: 604 kB Slab: 32648 kB SReclaimable: 11772 kB SUnreclaim: 20876 kB KernelStack: 2160 kB PageTables: 3688 kB NFS_Unstable: 0 kB Bounce: 0 kB WritebackTmp: 0 kB CommitLimit: 938304 kB Committed_AS: 757564 kB VmallocTotal: 34359738367 kB VmallocUsed: 5468 kB VmallocChunk: 34359730176 kB HardwareCorrupted: 0 kB AnonHugePages: 0 kB HugePages_Total: 400 HugePages_Free: 385 HugePages_Rsvd: 385 HugePages_Surp: 0 Hugepagesize: 2048 kB DirectMap4k: 32704 kB DirectMap2M: 1015808 kB ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql_hugepages%E9%85%8D%E7%BD%AE/:1:3","series":null,"tags":["blog","mysql"],"title":"mysql_hugepages配置","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql_hugepages%E9%85%8D%E7%BD%AE/#centos-开启-hugepages-后的内存"},{"categories":["blog"],"content":" 验证是否成功如果报错，没有成功使用大页,错误日志中会有 warning 2017-07-12T14:47:00.662616Z 0 [Warning] InnoDB: Failed to allocate 138412032 bytes. errno 12 2017-07-12T14:47:00.697358Z 0 [Warning] InnoDB: Using conventional memory pool ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql_hugepages%E9%85%8D%E7%BD%AE/:1:4","series":null,"tags":["blog","mysql"],"title":"mysql_hugepages配置","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql_hugepages%E9%85%8D%E7%BD%AE/#验证是否成功"},{"categories":["blog"],"content":"mysql备份恢复","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/","series":null,"tags":["blog","mysql"],"title":"mysql备份恢复","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/"},{"categories":["blog"],"content":" 简介这里介绍 mysql 的几种备份恢复方法. into outfile，适合在工作中导出指定的报表数据等 mysqldump 轮流进行锁表 innobakcupex(暂时发现最好用的备份工具，且开源) ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/:1:0","series":null,"tags":["blog","mysql"],"title":"mysql备份恢复","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/#简介"},{"categories":["blog"],"content":" into outfile—load infile # 导入到指定的文件位置 select * into outfile 'secure_file_priv' fields terminated by ',' from test # 导入指定的文件到表 load data infile '/var/lib/mysql-files/20170628' into table test fields terminated by ','; # 注意 secure_file_priv路径位置，否则无法导出 # 注意 表必须存在，然后导入数据。 并不是删除表后可以重建表 ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/:2:0","series":null,"tags":["blog","mysql"],"title":"mysql备份恢复","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/#into-outfile---load-infile"},{"categories":["blog"],"content":" mysqldump 导出为 sql 脚本，可以直接运行进行恢复 # 指定表 mysqldump -u root -p databasename tablename \u003e /tmp/20170628_databasename_tablename.sql # 指定数据库 mysqldump -u root -p --databases databasename1 databasename2 \u003e /tmp/20170628_databasename.sql # 备份全部数据库 mysqldump -u root -p -all-databases \u003e /tmp/20170628_databasename.sql ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/:3:0","series":null,"tags":["blog","mysql"],"title":"mysql备份恢复","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/#mysqldump-导出为-sql-脚本可以直接运行进行恢复"},{"categories":["blog"],"content":" innobackupex 的使用 (这个是 xtrabackup 的封装，可以备份多种类的存储引擎文件) # 备份 innobackupex --user=root --password=password /tmp/backups # 把备份里面日志等进行检查提交操作，让备份可以正常使用 innobackupex --apply-log /extrabackup/2016-04-27_07-30-48/ # 这里需要把文件全部都清空，并且需要注意文件的所有者、读写权限。 # 进行恢复，然后重启即可正常使用 innobackupex --copy-back /tmp/backups/2017-07-02_00-51-21/ # 增量备份 innobackupex --user=root --password=password /tmp/backups --incremental --incremental-basedir=/tmp/backups/full_bak # 增量恢复 innobackupex --apply-log --redo-only /tmp/backups/full_bak --incremental-dir=/tmp/backups/incremental_bak # 在上面要注意--redo-only参数,在合并最后一个增量备份的时候，不需要加上这个参数！！ # 如果没有redo-log这个参数，会进行回滚操作。将无法添加增量事务。最后一个因为则没有了后续的增量事务。 关于 redo-only，我翻来覆去看了官网文档和各种 blog，想了 2 天……终于理解了。 在完全备份的时候，数据库可能正在进行一个 update 操作，数据量很大，时间很长，差不多需要 2 天时间。为了保证备份可用，进行了回滚操作。在日志中 update 语句没有能够正确保存结果到备份。 在第二天，你开始进行增量备份。这一个 update 已经完成了操作，日志只记录并且进行 commit 提交。由于之前的备份进行了回滚，导致这个 commit 是不成功的。这一个 update 操作回滚掉后，没有了数据需要提交。 这样下来，就造成了数据的丢失。 在官方文档中说，无法添加后续的增量事务。应该是说这个 update 操作后续 (完成备份后第二天 update 语句进行的操作) 的改动，都没有办法应用。 同理，无论第一步中式完全备份还是增量备份，都会导致这个问题。所以使用 redo-only 参数保证 update 操作在是最后一个可用备份之前，没有回滚掉。 如果在之后的备份中，日志记录了提交或者回滚，则正常提交或回滚了这个 update 操作的数据。 如果没有后续记录，则说明这个 update 操作还没有完成，为了保证备份可用，回滚掉。并将在之后的备份中进行 commit 或回滚,而不进行 redo-only 第六步中都保证了备份可用。 ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/:4:0","series":null,"tags":["blog","mysql"],"title":"mysql备份恢复","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/#innobackupex-的使用-这个是-xtrabackup-的封装可以备份多种类的存储引擎文件"},{"categories":["blog"],"content":" 冷备份 关掉 mysql 直接拷贝数据文件 到指定机器上面粘贴即可 注意：只有 myisam 存储引擎的表，才能这样备份！ ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/:5:0","series":null,"tags":["blog","mysql"],"title":"mysql备份恢复","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/#冷备份"},{"categories":["blog"],"content":"有时候会自建 mysql [[笔记/point/mysql|mysql]] 测试配置. 所以记录一下配置和操作.","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/","series":null,"tags":["blog","mysql","docker"],"title":"mysql配置和优化","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/"},{"categories":["blog"],"content":" 简介有时候会自建 mysql 测试配置. 所以记录一下配置和操作. ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/:1:0","series":null,"tags":["blog","mysql","docker"],"title":"mysql配置和优化","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/#简介"},{"categories":["blog"],"content":" 操作","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/:2:0","series":null,"tags":["blog","mysql","docker"],"title":"mysql配置和优化","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/#操作"},{"categories":["blog"],"content":" sql 命令 # 创建用户 CREATE USER 'ttt'@'%' IDENTIFIED BY '123456'; grant all privileges on *.* to 'ttt'@'%'; # 授权 GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER,INDEX,TRIGGER,CREATE VIEW,SHOW VIEW ON `db`.`table` TO 'ttt'@'%'; # 改密码 ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456'; FLUSH PRIVILEGES; ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/:2:1","series":null,"tags":["blog","mysql","docker"],"title":"mysql配置和优化","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/#sql-命令"},{"categories":["blog"],"content":" docker 启动 # 名称ken-mysql # 数据在本地/data/mysql-data # 密码123 docker run --name ken-mysql -v /data/mysql-data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123 -p3306:3306 -d mysql:latest ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/:2:2","series":null,"tags":["blog","mysql","docker"],"title":"mysql配置和优化","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/#docker-启动"},{"categories":["blog"],"content":" 配置","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/:3:0","series":null,"tags":["blog","mysql","docker"],"title":"mysql配置和优化","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/#配置"},{"categories":["blog"],"content":" 最大连接数 # 配置最大连接数 show variables like '%max_connection%'; set global max_connections=1000; # 配置文件 [mysqld] max_connections = 1000 ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/:3:1","series":null,"tags":["blog","mysql","docker"],"title":"mysql配置和优化","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/#最大连接数"},{"categories":["blog"],"content":" 慢 sql # 先配置保存的位置 # 如果是写入到file，那么就不会输出到表 show variables like \"%log_output%\"; set global log_output = file; set global log_output = \"TABLE\"; # 慢日志的地址 show variables like '%slow_query_log%' # 查看慢查询的定义 show global variables like 'long_query_time'; # 改成1秒就算慢查询 set global long_query_time=1 # 开启log show variables like \"general_log%\"; set global general_log = 'ON'; # 非常占用性能，测试完就关闭 SET GLOBAL general_log = 'OFF'; # 输出到表的话，就查这里 select * from mysql.slow_log; # 转换blob为text select CONVERT( `sql_text` USING utf8) from mysql.slow_log; # 配置文件 [mysqld] log_output = TABLE long_query_time = 1 general_log = ON ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/:3:2","series":null,"tags":["blog","mysql","docker"],"title":"mysql配置和优化","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/#慢-sql"},{"categories":["blog"],"content":"mysql启动参数优化","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96/","series":null,"tags":["blog","mysql"],"title":"mysql启动参数优化","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96/"},{"categories":["blog"],"content":" 简介这里是我总结的 mysql 配置文件配置项. ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96/:1:0","series":null,"tags":["blog","mysql"],"title":"mysql启动参数优化","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96/#简介"},{"categories":["blog"],"content":" 参数文件 [mysqld] ### # 基本相关配置 ### server-id=1 pid-file=/var/run/mysqld/mysqld.pid datadir=/var/lib/mysql socket=/var/lib/mysql/mysql.sock # 在linux中，文件可以进行ln，类似快捷方式。如果设置为1，则有可能会出现安全问题，默认配置中设置为0，进行关闭 symbolic-links=0 # 设置数据库字符集 character_set_server=utf8mb4 # 禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求 skip-name-resolve character_set_filesystem=utf8mb4 # 统一使用小写的表名 lower_case_table_names = 1 ### # 日志配置 ### log-error=/var/log/mysqld.log # 二进制日志路径 log-bin=/tmp/logbin # 超过30天的binlog删除 expire_logs_days = 30 # 慢查询时间 超过1秒则为慢查询 long_query_time = 1 slow_query_log_file = /tmp/mysql-slow.log ### # 性能提升参数 ### # mysql最大连接数 查看max_used_connections，在最大值的70%左右最好 max_connections = 1000 # 官方：8 + (max_connections / 100)，上限100. 缓存的线程池不应该过多。 # 暂时我的业务高峰期，估计是200+的并发一直保持。50个应该足够 # 一般来说，大于4G的内存，预先缓存50个线程没有问题 thread_cache_size=10 # 表缓存分为多个区。5.7开始16为默认值，非常好！ # table_open_cache_instances=16 # 查询缓存关闭 # 听起来很美好的参数而已：如果表有insert、update等操作，表的相关所有cache失效 # 保存的是一个sql的查询结果集，而不是执行计划之类的 query_cache_size=0 # INNODB # innodb非常好！所以默认使用它做存储引擎。 设置为总内存的80% innodb_buffer_pool_size=800m # 为提高性能，MySQL可以以循环方式将日志文件写到多个文件。推荐设置为3 innodb_log_files_in_group = 3 # SHOW GLOBAL STATUS like '%innodb_os_log_written%' 单位：字节 # 官方推荐innodb_log_files_in_group*innodb_log_file_size * 0.75 \u003e 209MB，可以设置更大一些，但1小时内最好内进行一次刷入磁盘 innodb_log_file_size=140m ## 这里我启用的搭配模式，满足性能要求，系统一般情况下不会断电就不会崩溃。 # 控制数据库的事务日志刷到磁盘上 # 0:最快，但是进程崩溃就会丢失数据 # 1:最慢，数据会回滚没有提交的操作，数据保证一致 # 2:性能不错，除非操作系统不可用，才会丢失数据 innodb_flush_log_at_trx_commit=2 # 控制数据库的binlog刷到磁盘上 # 0:最快 系统决定 # n:10000\u003en\u003e1 多少条日志记录后开刷 # 1:每次提交就开刷 sync_binlog=0 # O_DIRECT直接跨过os缓存，直接写入到文件。 直接在raid上操作数据会更快 # 默认为空：fsync 直接连接到san存储，会更快 # O_DSYNC很少使用，没有上两个设置的优点 innodb_flush_method=O_DIRECT # 不限制线程并发的数量，在大型系统中会进行集群，同时会分配好任务，所以不需要调整 # 如果是单个的数据库，最高并发数量达到了100，那么设置为80，将会很好的满足需求 innodb_thread_concurrency=0 # mysql5.7的默认值，会提高速度 innodb_checksum_algorithm=crc32 # 不会有很大的提升，但是如果你的磁盘非常快，可以提高到16-32之间 innodb_read_io_threads=8 innodb_write_io_threads=8 # 刷新脏数据时每秒写 IO请求数 默认200即可，除非用sysbench压力测试，tps一段时间内为0，是因为它的问题。而且磁盘速度非常快 # 数值过大，mysql认为磁盘能力很强，不会着急得把redo log刷到磁盘。而不大或者100这样比较小的值，则会认为磁盘能力一般，提早刷入磁盘 innodb_io_capacity=200 # 关闭的时候把缓冲了的数据记录id记录到文件，启动的时候加载进来，这样尽可能的让它在重启的时候，缓冲数据完全一致 innodb_buffer_pool_load_at_startup=on innodb_buffer_pool_dump_at_shutdown=on ### # 连接相关参数 ### # 设置同一主机，最大可连接报错数。设置成100万没有特别大的影响，但是极大减少了flush hosts的次数 max_connect_errors=1000000 # 连接到达数量之后，排队的请求格式。超过600就会拒绝 back_log = 600 # 会话超过多久自动断开，默认秒，8小时 wait_timeout = 28800 # mysql可以打开的文件数 open_files_limit = 65535 ### # 备份工具innobackupex的备份路径 ### [xtrabackup] target_dir = /tmp/backups ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96/:2:0","series":null,"tags":["blog","mysql"],"title":"mysql启动参数优化","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96/#参数文件"},{"categories":["blog"],"content":" 随记为了搞定这一系列的参数，真是花了好大力气，也加深了对 mysql 的了解 2015-06-17 17:28:53 26720 [Warning] Buffered warning: Changed limits: max_connections: 5000 (requested 65535) 2015-06-17 17:28:53 26720 [Warning] Buffered warning: Changed limits: table_open_cache: 1995 (requested 2000) 这个问题的 解决办法 # 修改系统的参数 vi /etc/security/limits.conf # 加入这两行，或者把*指定为mysql用户 * soft nofile 65535 * hard nofile 65535 # 这个是mysql服务的参数，也要加上 mkdir /etc/systemd/system/mysqld.service.d //if not exists vi limits.conf [root@centos1 system]# cat /etc/systemd/system/mysql.service.d/override.conf [Service] LimitNOFILE=65535 ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96/:3:0","series":null,"tags":["blog","mysql"],"title":"mysql启动参数优化","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96/#随记"},{"categories":null,"content":" 你没有连接至互联网, 只有缓存的页面可用. ","date":"0001-01-01","objectID":"/offline/:0:0","series":null,"tags":null,"title":"Offline","uri":"/offline/#"}]