[{"categories":["journal"],"content":"2023-07-08 日记","date":"2023-07-08","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-08/","series":null,"tags":["journal"],"title":"2023-07-08","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-08/"},{"categories":["journal"],"content":" #todo/笔记 vsftpd 搭建 om1 做参考 #todo/笔记 对比 hugo 自带的 mermaid 和我的笔记 #todo/笔记 Webhook events and payloads - GitHub Docs csharp 做一个 webhook 接收器? 处理任务? 推送博客信息可能用到? #todo/笔记 使用TianliGPT让你的博客自动生成文章的AI摘要子比主题-一只橙子 豆瓣观影 - 大大的小蜗牛 电影表 Ghost博客实现豆瓣观影清单 好物 - 大大的小蜗牛 博客带货? #todo/笔记 静态博客评论系统的选择 - 大大的小蜗牛 评论系统的筛选 #todo/笔记 #todo/笔记 本地需要一个类似 rsync 的工具? 博客变多, 拷贝速度越来越慢. ","date":"2023-07-08","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-08/:0:0","series":null,"tags":["journal"],"title":"2023-07-08","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-08/#"},{"categories":["blog"],"content":" 简介程序性能总是一个永恒的话题。各个系统、编程语言、算法、io 逻辑，总是不停的对比。今天在 dotnet 闲逛的时候，看到了官方做的一个性能评测库，但是指标我却看不懂。于是就看了一会儿相关知识，准备记录一下。 ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/benchmark%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/:1:0","series":null,"tags":["blog","csharp"],"title":"benchmark的数学知识","uri":"/posts/%E7%AC%94%E8%AE%B0/benchmark%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/#简介"},{"categories":["blog"],"content":" 程序说明抄了一个官方的 demo。很简单，就是在对比 md5 和 sha256 两者的性能。 using System; using System.Security.Cryptography; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; namespace Cli { public class Md5VsSha256 { private const int N = 10000; private readonly byte[] data; private readonly SHA256 sha256 = SHA256.Create(); private readonly MD5 md5 = MD5.Create(); public Md5VsSha256() { data = new byte[N]; new Random(42).NextBytes(data); } [Benchmark] public byte[] Sha256() =\u003e sha256.ComputeHash(data); [Benchmark] public byte[] Md5() =\u003e md5.ComputeHash(data); } class Program { static void Main(string[] args) { var summary = BenchmarkRunner.Run\u003cMd5VsSha256\u003e(); } } } ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/benchmark%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/:2:0","series":null,"tags":["blog","csharp"],"title":"benchmark的数学知识","uri":"/posts/%E7%AC%94%E8%AE%B0/benchmark%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/#程序说明"},{"categories":["blog"],"content":" 输出分析首先需要将代码 release。因为这样会对代码进行优化。让我们的性能观测更加准确。 接下来就是查看我们的输出结果。 BenchmarkDotNet=v0.13.1, OS=Windows 10.0.22000 Intel Core i5-10210U CPU 1.60GHz, 1 CPU, 8 logical and 4 physical cores .NET SDK=5.0.400 [Host] : .NET 5.0.9 (5.0.921.35908), X64 RyuJIT DefaultJob : .NET 5.0.9 (5.0.921.35908), X64 RyuJIT | Method | Mean | Error | StdDev | |------- |---------:|---------:|---------:| | Sha256 | 48.94 us | 0.947 us | 1.197 us | | Md5 | 19.58 us | 0.356 us | 0.315 us | Mean : Arithmetic mean of all measurements Error : Half of 99.9% confidence interval StdDev : Standard deviation of all measurements 1 us : 1 Microsecond (0.000001 sec) Mean代表平均值。举例我们有 100 次样本，这时候 Mean=所有样本时间/100。也就是说可以看做是平均时间。 Error代表标准误差。标准误越小，样本均值和总体均值差距越小，那么样本数据就越能代表总体数据。标准误是多次抽样统计，量化了多组测量值均值的变化程度。因此用于推论统计，越小对 Mean 的结果推论越准确。 StdDev代表标准偏差。标准差越小，样本值之前的差别越小。标准差是一次抽样，量化了一组测量值的变化程度，用于描述统计。而我们的测试中用到了所有的样本 (all measurements)，所以这里我们可以知道 Mean 和实际请求时间相差多少 us。 ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/benchmark%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/:3:0","series":null,"tags":["blog","csharp"],"title":"benchmark的数学知识","uri":"/posts/%E7%AC%94%E8%AE%B0/benchmark%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/#输出分析"},{"categories":["blog"],"content":" 总结我们通过结果和概念，可以得到以下信息 Mean 是此次性能测试的平均值。得到信息是：md5 是比 sha256 要快的。 Error 表明如果我们做更多的测试。sha256 所花费的时间，预计是 Mean 加减 0.947us。而 md5 预计是 Mean 加减 0.356us。得到的信息是：准确性还是不错的。 StdDev 表明在此次测试中，sha256 偏差是加减 1.197us。md5 偏差是加减 0.315us。得到的信息是：此次测试中每次花费的时间差别不大。 ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/benchmark%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/:4:0","series":null,"tags":["blog","csharp"],"title":"benchmark的数学知识","uri":"/posts/%E7%AC%94%E8%AE%B0/benchmark%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/#总结"},{"categories":["point"],"content":"csharp 是一门静态编程语言. 要点: 性能好 微软大厂支持 ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/csharp/:0:0","series":null,"tags":["point","csharp"],"title":"csharp","uri":"/posts/%E7%AC%94%E8%AE%B0/point/csharp/#"},{"categories":["point"],"content":"helm 是 k8s 用来将应用所需资源打包为一个整体的工具。可类比为 yum/centos ,apt/ubuntu. 基础概念: repo 是一个仓库，有一些别人写好的。你自己的代码打包以后也可以上传到私有仓库 charts 是一个应用所需资源的概括 release 是一个 charts 发布到 k8s 后的实例 基础操作: 说明 操作 添加 repo 仓库 helm repo add bitnami https://charts.bitnami.com/bitnami 更新仓库 helm repo update 搜索 charts 包 helm search repo redis 安装 charts 包 helm install name bitnami/mysql 查看当前部署 helm ls 查看应用详情 helm status name 卸载指定的 release helm uninstall name 编写 helm 脚本: 说明 操作 创建一个 helm 模板 helm create name 打包一个 helm 模板 helm package name ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/helm/:0:0","series":null,"tags":["point","helm"],"title":"helm","uri":"/posts/%E7%AC%94%E8%AE%B0/point/helm/#"},{"categories":["point"],"content":"k8s 是非常流行的容器编排工具. 要点: 免费 社区,生态强大 事实标准 ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/k8s/:0:0","series":null,"tags":["point","k8s"],"title":"k8s","uri":"/posts/%E7%AC%94%E8%AE%B0/point/k8s/#"},{"categories":["blog"],"content":" 简介经常会购买/重装 linux 服务器, 制作过很多次的镜像. 这里记录一下的初始化配置, 以后搞成一个 shell 脚本来用. ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog"],"title":"linux的初始化配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 操作手册 时间同步 防火墙关闭 Selinux 关闭 Supervisor 安装和默认配置 Alias Htop, nethogs, lrzsz, tree, nload, iotop, vmstat, iptraf-ng 等等命令 因为已经有了 linux 命令和其他工具的文档, 这里只要记录一下必要的点, 然后写成一个 shell 脚本就好了. #todo/笔记 ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog"],"title":"linux的初始化配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/#操作手册"},{"categories":["blog"],"content":"总结一下在 [[笔记/point/csharp|c#]] 中几种 Task 的用法.","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/task%E7%9A%84%E4%BD%BF%E7%94%A8/","series":null,"tags":["blog","csharp"],"title":"Task的使用","uri":"/posts/%E7%AC%94%E8%AE%B0/task%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["blog"],"content":" 简介总结一下在 c# 中几种 Task 的用法. ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/task%E7%9A%84%E4%BD%BF%E7%94%A8/:1:0","series":null,"tags":["blog","csharp"],"title":"Task的使用","uri":"/posts/%E7%AC%94%E8%AE%B0/task%E7%9A%84%E4%BD%BF%E7%94%A8/#简介"},{"categories":["blog"],"content":" 对比 方法 适用场景 Task.Run 通用，适用异步 Task.Factory.StartNew(TaskCreationOptions.LongRunning) 钻牛角尖 下面全都是你想用 Task.Factory.StartNew 的必备条件 你想要新启一个线程来运行，因为会堵塞太久。 是同步方法。因为异步并不会在新启动的线程运行（参考链接），甚至因为开线程，切换线程影响性能。 会并发。如果最多同时 1 个，那没必要。 你很了解现在的线程池情况，你对线程池扩容的逻辑你不满意，你必须现在就申请一个新线程。否则会自动扩容的。 不想用 backgroundService后台执行 和 mq消息队列替代 ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/task%E7%9A%84%E4%BD%BF%E7%94%A8/:2:0","series":null,"tags":["blog","csharp"],"title":"Task的使用","uri":"/posts/%E7%AC%94%E8%AE%B0/task%E7%9A%84%E4%BD%BF%E7%94%A8/#对比"},{"categories":["blog"],"content":" 参考链接 LongRunning 的错误用法 devblog 官方 线程池 问题解答 ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/task%E7%9A%84%E4%BD%BF%E7%94%A8/:2:1","series":null,"tags":["blog","csharp"],"title":"Task的使用","uri":"/posts/%E7%AC%94%E8%AE%B0/task%E7%9A%84%E4%BD%BF%E7%94%A8/#参考链接"},{"categories":["blog"],"content":"以前对于位运算, 二级制了解的比较少. 这里统一记录一下使用和理解.","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/","series":null,"tags":["blog","位运算"],"title":"二进制和位运算","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["blog"],"content":" 简介以前对于位运算, 二级制了解的比较少. 这里统一记录一下使用和理解. ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/:1:0","series":null,"tags":["blog","位运算"],"title":"二进制和位运算","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/:2:0","series":null,"tags":["blog","位运算"],"title":"二进制和位运算","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/#内容"},{"categories":["blog"],"content":" 进制2 进制：逢 2 进 1 8 进制：逢 8 进 1 16 进制：逢 16 进 1 在 C 程序中的表示 (python 中也一样)： 0b101 /*2进制 0b开头*/ 0115 /*8进制 0开头*/ 0xFFF /*16进制 0x开头*/ 转换十进制方法: 个位直接加，十位是进制数的 1 次方，百位是进制数的 2 次方，高位以此类推即可 0b101 = 1 + 0*2 + 1*2*2 0115 = 5 + 1*8 + 1*8*8 0xFAF = 15 + 10*15 + 15*15*15 ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/:2:1","series":null,"tags":["blog","位运算"],"title":"二进制和位运算","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/#进制"},{"categories":["blog"],"content":" 位运算符我其实用的不是特别多，见的也不多。但是在很多的官方案例中出现过，比如 python 人脸识别中的跳出循环 if cv2.waitKey(1) \u0026 0xFF == ord('q'): break 先把所有的运算符列出来： \u003c\u003c #左移 \u003e\u003e #右移 | #位或 \u0026 #位与 ^ #位异或 ~ #非 \u003c\u003c #左移 将所有的0和1的位置进行左移，移位之后将空位补0 左移操作相当于乘以2**n，以5 \u003c\u003c 3 为例，相当于5(2*3),结果为40 0b101 变成了 0b101000 # 一个int是4个字节，一个字节是8位(bit)，它存储的大小就是32位 # 如果加了0，超出了32位边界，那么就是溢出了 \u003e\u003e #右移 将所有的0和1的位置进行右移(直接舍弃)，空位正数补0，负数补1 右移操作相当于除以2**n，8 \u003e\u003e 3 相当于8/(2**3)=1 | #位或 0b110 | 0b101 #输出7,即0b111 只要有一位有1就为1，可以用在综合条件 \u0026 #位与 0b110 \u0026 0b011 #输出2，即0b010 相同的位才为1，可以用在linux权限 ^ #位异或 0b1010 ^ 0b1111 #输出5，即0b0101 异或常用于将所有的位反转，相同的位置是0，否则其他的位置变1， ~ #非 ~0b101 #输出2，即0b010 这个是单独运算的，直接就把所有的反转了 ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/:2:2","series":null,"tags":["blog","位运算"],"title":"二进制和位运算","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/#位运算符"},{"categories":["blog"],"content":" 理解 cv2.waitKey(1) \u0026 0xFF == ord('q') 查看 python 结果 $ python Python 3.6.3 (default, Oct 16 2017, 17:26:31) [GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.37)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. \u003e\u003e\u003e print(ord('q')) 113 查看键盘 q 对应的数字是多少 #include \u003cstdio.h\u003e int main() { char i; scanf(\"%c\", \u0026i); printf(\"i = %d \\n\", i); return 0; } Launching: '/Users/user/kent/c/a.out' Working directory: '/Users/user/kent/c' 1 arguments: argv[0] = '/Users/user/kent/c/a.out' q q = 113 Process exited with status 0 那么推算如下 cv2.waitKey(1) \u0026 0xFF == ord('q') cv2.waitKey(1) \u0026 0xFF == 113 0xFF代表了你键盘上的所有按键都能匹配到(包括一些系统自己拓展的特殊按键)。 当我们按了`q`键,cv2.waitKey(1)得到的就是113的二进制，和0xFF匹配出来的结果就是二进制的113，在任何系统上转换为十进制，都会和右边的十进制113相等。 避免了bug ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/:2:3","series":null,"tags":["blog","位运算"],"title":"二进制和位运算","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/#理解-cv2waitkey1--0xff--ordq"},{"categories":["blog"],"content":" 简介recalbox 是一个游戏模拟器的合集 +kodi 媒体中心！是的，都集成到了一起是我选用它的主要原因。 ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","树莓派","recalbox"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 配置内容","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","树莓派","recalbox"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#配置内容"},{"categories":["blog"],"content":" 基础设置 中文显示:主菜单=\u003e系统设置=\u003e语言=\u003e确认选中语言 ip 地址查看:主菜单=\u003e网络设置=\u003eip地址 ssh 连接: ssh root@ip地址,密码 recalboxroot。但是有一点需要注意，recalbox 可以看作是一个独立的 linux 发行版。这意味着你无法使用 yum 或者 apt，也无法安装 npm 和 deb 包！ ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog","树莓派","recalbox"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#基础设置"},{"categories":["blog"],"content":" Web 配置系统管理界面: 用浏览器访问ip，默认就是访问 80 端口。 其中的控制器模拟界面，对于测试了解手柄非常有用。 ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:2:2","series":null,"tags":["blog","树莓派","recalbox"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#web-配置"},{"categories":["blog"],"content":" recalbox 游戏这里我就讲一下大致的步骤吧，下载游戏的网站我也随便 贴一个，试过了没问题 下载一个游戏 rom 包，例如 马里奥.nes。这个文件名最后会变成 recalbox 里面的游戏名！！ 在 web界面 上传这个文件，重启 es 服务! nes 是 nintendo entertainment system 的简写，找到这个模拟器，就可以看到游戏了 ! ! ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:2:3","series":null,"tags":["blog","树莓派","recalbox"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#recalbox-游戏"},{"categories":["blog"],"content":" 开机自启 vim /etc/init.d/S99ddns-go #/bin/bash /etc/init.d/kentxxq/ddns-go # 授予执行权限 chmod +x /etc/init.d/S99ddns-go ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:2:4","series":null,"tags":["blog","树莓派","recalbox"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#开机自启"},{"categories":["blog"],"content":" kodi 配置主菜单=\u003ekodi媒体中心,系统会重启。kodi 和 recalbox 的键盘映射不一定相同！ kodi 中文设置 设置齿轮=\u003einterface=\u003eSkin=\u003eFont=\u003eArial based 同界面下，Regional=\u003eLanguage=\u003e简体中文 kodi 启用插件启用插件: 插件=\u003e我的插件=\u003ePVR客户端=\u003ePVR IPTV Simple Client=\u003e启用 使用直播源 去 github 上面 下载 需要的电视直播源文件。 默认 recalbox 通过 SMB协议共享 出来了我们需要的文件夹，我们可以直接访问进去。在 share/kodi 下面新建 m3u8 文件夹，然后把下载好的直播源文件放进去。 在插件 iptv 界面进入设置，选择本地文件 m3u。 点击 kodi 开关，退出。然后重新进入 kodi 进入电视就可以看是选台看电视了！ ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:2:5","series":null,"tags":["blog","树莓派","recalbox"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#kodi-配置"},{"categories":["blog"],"content":" kodi 配置主菜单=\u003ekodi媒体中心,系统会重启。kodi 和 recalbox 的键盘映射不一定相同！ kodi 中文设置 设置齿轮=\u003einterface=\u003eSkin=\u003eFont=\u003eArial based 同界面下，Regional=\u003eLanguage=\u003e简体中文 kodi 启用插件启用插件: 插件=\u003e我的插件=\u003ePVR客户端=\u003ePVR IPTV Simple Client=\u003e启用 使用直播源 去 github 上面 下载 需要的电视直播源文件。 默认 recalbox 通过 SMB协议共享 出来了我们需要的文件夹，我们可以直接访问进去。在 share/kodi 下面新建 m3u8 文件夹，然后把下载好的直播源文件放进去。 在插件 iptv 界面进入设置，选择本地文件 m3u。 点击 kodi 开关，退出。然后重新进入 kodi 进入电视就可以看是选台看电视了！ ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:2:5","series":null,"tags":["blog","树莓派","recalbox"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#kodi-中文设置"},{"categories":["blog"],"content":" kodi 配置主菜单=\u003ekodi媒体中心,系统会重启。kodi 和 recalbox 的键盘映射不一定相同！ kodi 中文设置 设置齿轮=\u003einterface=\u003eSkin=\u003eFont=\u003eArial based 同界面下，Regional=\u003eLanguage=\u003e简体中文 kodi 启用插件启用插件: 插件=\u003e我的插件=\u003ePVR客户端=\u003ePVR IPTV Simple Client=\u003e启用 使用直播源 去 github 上面 下载 需要的电视直播源文件。 默认 recalbox 通过 SMB协议共享 出来了我们需要的文件夹，我们可以直接访问进去。在 share/kodi 下面新建 m3u8 文件夹，然后把下载好的直播源文件放进去。 在插件 iptv 界面进入设置，选择本地文件 m3u。 点击 kodi 开关，退出。然后重新进入 kodi 进入电视就可以看是选台看电视了！ ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:2:5","series":null,"tags":["blog","树莓派","recalbox"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#kodi-启用插件"},{"categories":["blog"],"content":" kodi 配置主菜单=\u003ekodi媒体中心,系统会重启。kodi 和 recalbox 的键盘映射不一定相同！ kodi 中文设置 设置齿轮=\u003einterface=\u003eSkin=\u003eFont=\u003eArial based 同界面下，Regional=\u003eLanguage=\u003e简体中文 kodi 启用插件启用插件: 插件=\u003e我的插件=\u003ePVR客户端=\u003ePVR IPTV Simple Client=\u003e启用 使用直播源 去 github 上面 下载 需要的电视直播源文件。 默认 recalbox 通过 SMB协议共享 出来了我们需要的文件夹，我们可以直接访问进去。在 share/kodi 下面新建 m3u8 文件夹，然后把下载好的直播源文件放进去。 在插件 iptv 界面进入设置，选择本地文件 m3u。 点击 kodi 开关，退出。然后重新进入 kodi 进入电视就可以看是选台看电视了！ ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:2:5","series":null,"tags":["blog","树莓派","recalbox"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#使用直播源"},{"categories":["blog"],"content":" 疑难杂症","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["blog","树莓派","recalbox"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#疑难杂症"},{"categories":["blog"],"content":" 操作系统架构recalbox7.1.1 是 armv7l 架构。 arm64 是 64 位，默认的话就是 arm32。所以 recalbox7.1.1 是 32 位. armv7 应该是可以运行 armv6 程序的，同理 armv8。 arm 默认都是小端存储。armv7l 就是后面的 l 就是小端的意思。 ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:3:1","series":null,"tags":["blog","树莓派","recalbox"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#操作系统架构"},{"categories":["blog"],"content":" 无法 chmod 执行权限 # 重新挂载即可 mount -o remount rw / # 然后拷贝到/下面 cp x /x chmod +x x ./x ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:3:2","series":null,"tags":["blog","树莓派","recalbox"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#无法-chmod-执行权限"},{"categories":["blog"],"content":" 图像显示溢出 # 当前我的版本是recalbox8: 去除黑边不一定有效，但是对图像溢出是有用的。 # 我在调整了很多次黑边距离，没有效果。虽然黑边不大，不太影响。 # 重新挂载/boot分区 mount -o remount,rw /boot # 编辑配置文件 su root /boot/config.txt disable_overscan=0 overscan_left=24 overscan_right=24 overscan_top=24 overscan_bottom=24 overscan_scale=1 # 重启生效 reboot ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/:3:3","series":null,"tags":["blog","树莓派","recalbox"],"title":"树莓派recalbox配置","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BErecalbox%E9%85%8D%E7%BD%AE/#图像显示溢出"},{"categories":["blog"],"content":"家里一直有一个树莓派在跑网盘备份, ddns, 以及使用 wol. 记录一下初始化的过程.","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/","series":null,"tags":["blog"],"title":"树莓派初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["blog"],"content":" 简介家里一直有一个树莓派在跑网盘备份, ddns, 以及使用 wol. 记录一下初始化的过程. ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/:1:0","series":null,"tags":["blog"],"title":"树莓派初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/#简介"},{"categories":["blog"],"content":" 操作手册","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/:2:0","series":null,"tags":["blog"],"title":"树莓派初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/#操作手册"},{"categories":["blog"],"content":" 刷机直接去 官网下载 imager，然后安装后。就可以通过图形界面选择需要的系统了。但是因为网络太慢，所以我直接去 ubuntu官网下载 镜像文件，然后 use custom 写入 tf 卡。 ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/:2:1","series":null,"tags":["blog"],"title":"树莓派初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/#刷机"},{"categories":["blog"],"content":" ssh 通过路由器或者 ip 扫描工具拿到 ip，然后 ssh 上去会提示修改密码 默认密码是 ubuntu ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/:2:2","series":null,"tags":["blog"],"title":"树莓派初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/#ssh"},{"categories":["blog"],"content":" 替换国内源文件位置 /etc/apt/sources.list。 # 备份 sudo mv /etc/apt/sources.list /etc/apt/sources.list.bak # 创建文件 sudo vi /etc/apt/sources.list deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-security main restricted universe multiverse 更新: sudo apt update -y 升级: sudo apt upgrade -y ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/:2:3","series":null,"tags":["blog"],"title":"树莓派初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/#替换国内源"},{"categories":["blog"],"content":" wifi 配置进行配置 vim /etc/netplan/50-cloud-init.yaml。 但是 wifi 每次获取到的 ip 可能是不一样的，所以我们应该在路由里面把 ip 和 mac 地址进行绑定，保证 ip 地址不被会其他机器占用！！ network: ethernets: eth0: dhcp4: true optional: true version: 2 wifis: wlan0: optional: true access-points: \"TP-LINK_1D88\": password: \"123456781\" dhcp4: true ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/:2:4","series":null,"tags":["blog"],"title":"树莓派初始化","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96/#wifi-配置"},{"categories":["blog"],"content":"我看过了太多太多的影片。有好的，有坏的。我不觉得这是小学生的作业，是观后感流水账。所以不会统统记录下来。单独写出文章的影片，都是我自己觉得感触良多。正如阿甘正传里的一句台词:你永远也不会知道下一口糖果会是什么味道。下面只是我的个人推荐列表。不希望大家都能觉得好看，但希望会有一部影片，能触动到你","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E5%BD%B1%E7%89%87%E8%AE%B0%E5%BD%95/","series":null,"tags":["blog"],"title":"我的影片记录","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E5%BD%B1%E7%89%87%E8%AE%B0%E5%BD%95/"},{"categories":["blog"],"content":" 简介我看过了太多太多的影片。有好的，有坏的。 我不觉得这是小学生的作业，最终全变成观后感流水账。所以不会统统记录下来。 单独写出文章的影片，都是我自己觉得感触良多。 正如阿甘正传里的一句台词: 生活就像是一盒巧克力，你永远不会知道下一盒会是什么味道。 所以我不会给出关于影片的介绍。因为那是一种个人观点，也是一种剧透吧。 我也同样不会给影片进行分类，因为一部好影片是多方面的。而不仅仅是拍摄后的故事。 下面只是我的个人推荐列表。 ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E5%BD%B1%E7%89%87%E8%AE%B0%E5%BD%95/:1:0","series":null,"tags":["blog"],"title":"我的影片记录","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E5%BD%B1%E7%89%87%E8%AE%B0%E5%BD%95/#简介"},{"categories":["blog"],"content":" 影片列表 燕尾蝶 未麻的部屋 大话西游 - 系列 革命之路 无敌破坏王 王家卫 - 所有执导影片，外加一部纪录片 (摄氏零度 - 春光再现) 爱乐之城 佐伊 geostorm 人工智能 风雨哈弗路 垫底辣妹 一个明星的诞生 天气之子 活埋 此房是我造 海角七号 成为简·奥斯汀 华尔街之狼 解除好友 - 系列 网络迷踪 life is beautiful 午夜巴塞罗那 hello,树先生 抱歉打扰 头文字 D 戏梦巴黎 千与千寻 奔腾年代 驴得水 初恋五十次 别告诉她 (The Farewell) 危楼愚夫 精武英雄 前目的地 他其实没那么喜欢你 初恋红豆冰 秒速五厘米 盲井 十二猴子 怦然心动 搏击俱乐部 半个喜剧 盗梦空间 百元之恋 心动 禁闭岛 肖申克的救赎 恋空 霸王别姬 这个杀手不太冷 我的野蛮女友 盗梦侦探/红辣椒 阿甘正传 言叶之庭 寻枪 泰坦尼克号 辛德勒的名单 骡子 忌日快乐 机器人总动员 放牛班的春天 海上钢琴师 勇敢的心 楚门的世界 教父 - 系列 无间道 - 系列 当幸福来敲门 西西里的美丽传说 少年派的奇幻漂流 天堂影片院 不要抬头 少年时代 三天两夜 - 日本 1997 年 指环王 - 系列 鬼子来了 十二怒汉 飞屋环游记 闻香识女人 沉睡魔咒 1 我在雨中等你 两杆大烟枪 飞越疯人院 寻梦环游记 死亡诗社 甲方乙方 v 字仇杀队 美丽心灵 情书 钢琴家 本杰明巴顿奇事 美国往事 分手说爱你 看不见的客人 扬名立万 哈利波特 - 系列 让子弹飞 大圣归来 七宗罪 无名 被嫌弃的松子的一生 低俗小说 天使爱美丽 邪不压正 沉默的羔羊 猫鼠游戏 穆赫兰道 蝴蝶效应 心灵捕手 爱尔兰人 阳光灿烂的日子 鸟人 不能说的秘密 狩猎 喜剧之王 变脸 (1995) 告白 活着 大象席地而坐 无主之作 全城热恋 芳华 成长教育 买凶拍人 我不是潘金莲 等一个人咖啡 风声 her 大鱼 消失的爱人 大佛普拉斯 少年收容所 蔡国强的艺术 罗曼蒂克消亡史 致命魔术 被光抓走的人 致命 id 心灵奇旅 荒蛮故事 一级恐惧 孩子 L’enfant The Machinist 阳光姐妹淘 爱在黎明破晓前 - 系列 恐怖直播 超脱 上帝之城 幸福终点站 神偷奶爸 阿凡达 1、2 电锯惊魂 - 系列 真爱至上 黑天鹅 星际穿越 记忆碎片 傲慢与偏见 心迷宫 鲸 雨人 卢旺达饭店 恋恋笔记本 解救吾先生 第十一回 阳光普照 被解救的姜戈 三块广告牌 她与她的猫 你的名字 拨鼠之日 朱丽叶与梁山伯 观音山 人在囧途 入侵华尔街 疯狂的赛车 邮差 风平浪静 追凶者也 爆裂鼓手 天下无双 环形使者 模仿游戏 猜火车 后来的我们 恐怖游轮 无人知晓 香水 波斯语课 七号房的礼物 (土耳其) 小妇人 初缠恋后的二人世界 登月第一人 大赢家 神秘河 立春 江湖告急 黑客帝国 - 系列 无名之辈 浪潮 朗读者 白日焰火 黑社会 1/2 彗星来的那一夜 源代码 撞车 我想吃掉你的胰脏 桃姐 the big short 梦之安魂曲 秦颂 一个陌生女人的来信 太空救援 神探 JOKER 无姓之人 血钻 传染病 麦克法兰 实习生 这个男人来自地球 特朗勃 紫日 哆啦 A 梦伴我同行 2 功夫 孟买酒店 小情人 - 泰国 出路 -《为什么贫穷》系列纪录片第八集 发条橙 地心引力 十二夜 非常嫌疑犯 毕业生 房间 只有芸知道 谁先爱上他的 信条 断裂 少年的你 寄生虫 全裸导演 何以为家 半支烟 国王的演讲 误杀瞒天记 好莱坞往事 完美的世界 婚姻故事 好景当前 哪吒之魔童降世 英剧 -the end of the fucking world(去他妈的世界) 第一、二季 英剧 - 黑镜第一季 英剧 - 无人生还 韩剧 - 王国 美剧 - 越狱系列 美剧 - 纸牌屋 美剧 - 绝命毒师 美剧 - 风骚律师 美剧 - 诺尔切贝利 美剧 - 制造杀人犯 美剧 - 权力的游戏 意剧 - 我的天才女友 国产剧 - 蜗居 国产剧 - 北京青年 国产剧 - 裸婚时代 国产剧 - 北京爱情故事 国产剧 - 奋斗 国产剧 - 倚天屠龙记 (苏有朋版) 国产剧 - 毛骗 国产剧 - 武林外传 国产剧 - 余罪 1、2 综艺 - 美好的时光第一季 ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E5%BD%B1%E7%89%87%E8%AE%B0%E5%BD%95/:2:0","series":null,"tags":["blog"],"title":"我的影片记录","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E5%BD%B1%E7%89%87%E8%AE%B0%E5%BD%95/#影片列表"},{"categories":["blog"],"content":" 更新日志20190602: 新增 人工智能 20190702: 新增 成长教育 20190706: 新增 何以为家 20190804: 新增 房间 20190821: 新增 寄生虫/全裸导演 20190827: 新增 黑社会1/2 20190908: 新增 骡子/忌日快乐 20190911: 新增 危楼愚夫 20191014: 新增电影且加入电视剧 -英剧-the end of the fucking world(去他妈的世界)第一季、美剧-越狱系列、美剧-纸牌屋、美剧-权力的游戏、国产剧-蜗居、国产剧-北京青年、国产剧-裸婚时代、国产剧-北京爱情故事、国产剧-奋斗、哪吒之魔童降世、国产剧-毛骗、国产剧-武林外传 20191015: 新增 国产剧-余罪1、2 20191026: 新增 断裂 20191112: 新增 JOKER 20191117: 新增 少年时代 20191127: 新增 成为简·奥斯汀 20191127: 新增 少年的你 20191129: 新增 韩剧-王国 20191201: 新增 三天两夜-日本电影 20191207: 新增 沉睡恶魔1、环形使者、好莱坞往事 20191215: 新增 误杀瞒天记 20191216: 新增 初缠恋后的二人世界，超级好看 20191217: 新增 小情人-泰国 20191222: 新增 谁先爱上他的 20191225: 新增 初恋红豆冰、半个喜剧 20191228: 新增 the big short，不能说的秘密 20200102: 新增 登月第一人 20200104: 新增 好景当前 20200110: 新增 别告诉她(The Farewell) 20200114: 新增 少年收容所、被光抓走的人 20200123: 新增 勇敢的心 20200131: 新增 只有芸知道、一个陌生女人的来信 20200203: 新增 无名之辈、十二猴子 20200227: 新增 传染病 20200302: 新增 土拨鼠之日 20200303: 新增 婚姻故事 20200311: 新增 我想吃掉你的胰脏 20200313: 新增 英剧-无人生还 20200315: 新增 麦克法兰 20200322: 新增 实习生 20200406: 新增 阳光普照 20200408: 新增 大佛普拉斯 20200411: 新增 无主之作 20200420: 新增 孟买酒店 20200501: 新增 特朗勃 20200504: 新增 神秘河 20200510: 新增 爱尔兰人 20200719: 新增 盗梦侦探/红辣椒 20200727: 新增 我在雨中等你 20200802: 新增 小妇人 20200809: 新增 天气之子、秒速五厘米、言叶之庭、她与她的猫 20200920: 新增 寻枪 20200923: 新增 无姓之人 20201020: 新增 荒蛮故事 20201122: 新增 大象席地而坐 20201122: 新增 变脸(1995) 20201206: 新增 信条 20200112: 新增 十二夜 20200117: 新增 半支烟 20210119: 新增 孩子 L'enfant 20210119: 新增 毕业生 20210126: 新增 秦颂 20210205: 新增 入侵华尔街 20210210: 新增 人在囧途 20210228: 新增 风平浪静 20210313: 新增 罗曼蒂克消亡史 20210314: 新增 买凶拍人 20210323: 新增 心灵奇旅 20210328: 新增 蔡国强的艺术 20210408: 新增 波斯语课 20210409: 新增 出路-《为什么贫穷》系列纪录片第八集 20210422: 新增 观音山 20210502: 新增 七号房的礼物(土耳其) 20210511: 新增 桃姐 20210518: 新增 朱丽叶与梁山伯 20210523: 新增 第十一回、天下无双 20210530: 新增 综艺-美好的时光第一季 20210613: 新增 美剧-绝命毒师、美剧-风骚律师、哆啦A梦伴我同行2 20210615: 新增 意剧-我的天才女友 20210620: 新增 太空救援 20210716: 新增 追凶者也 20210719: 新增 海角七号 20210723: 新增 风声 20210807: 新增 疯狂的赛车 20210809: 新增 甲方乙方 20211226: 新增 鸟人 20220221: 新增 英剧-黑镜第一季 20220306: 新增 紫日 20220314: 新增 金钱男孩 20220509: 新增 扬名立万 20220805: 新增 神探 20220828: 新增 立春 20221127: 新增 阿凡达1 20230326: 新增 大赢家 20230402: 新增 阿凡达2 20230408: 新增 不要抬头 20230423: 新增 无名 20230426: 新增 鲸 ","date":"2023-07-08","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E5%BD%B1%E7%89%87%E8%AE%B0%E5%BD%95/:3:0","series":null,"tags":["blog"],"title":"我的影片记录","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E5%BD%B1%E7%89%87%E8%AE%B0%E5%BD%95/#更新日志"},{"categories":["blog"],"content":"记录和收集工具, 做到笔记里感觉比书签要好用.","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/","series":null,"tags":["blog","工具收集"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/"},{"categories":["blog"],"content":" 简介记录和收集工具, 做到笔记里感觉比书签要好用. ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:1:0","series":null,"tags":["blog","工具收集"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:2:0","series":null,"tags":["blog","工具收集"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#内容"},{"categories":["blog"],"content":" 图片压缩 Compress Image Online | compressImage.io: 离线, 调整压缩比例 ","date":"2023-07-07","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/:2:1","series":null,"tags":["blog","工具收集"],"title":"工具收集","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/#图片压缩"},{"categories":["journal"],"content":"2023-07-06 日记","date":"2023-07-06","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-06/","series":null,"tags":["journal"],"title":"2023-07-06","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-06/"},{"categories":["journal"],"content":" 写关于 shell 脚本, 变量, 循环等等 #todo/笔记 #!/bin/bash --login # 输入部署命令 supervisorctl stop haobo-live truncate -s 0 /haobo-live-supervisor.log truncate -s 0 /data/logs/console.log cd /root/haobo-live # tar -xzvf package.tgz apt install sshpass -y echo '安装完成' /usr/bin/sshpass -p 密码 /usr/bin/scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@10.30.1.81:/root/haobo-live/haobo-live.jar /root/haobo-live/haobo-live.jar echo '启动程序' supervisorctl start haobo-live 写 ken-cli 文档 #todo/笔记 Grafana 监控 #todo/笔记 # 内存使用率 (max(container_memory_working_set_bytes{namespace=\"default\"}) by (pod) / sum(kube_pod_container_resource_requests_memory_bytes{namespace=\"default\"}) by (pod)) * 100 ","date":"2023-07-06","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-06/:0:0","series":null,"tags":["journal"],"title":"2023-07-06","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-06/#"},{"categories":["point"],"content":"JavaScript 是一门动态编程语言. 要点: 异步 社区非常庞大 浏览器 web 上统一标准 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/javascript/:0:0","series":null,"tags":["point","JavaScript"],"title":"JavaScript","uri":"/posts/%E7%AC%94%E8%AE%B0/point/javascript/#"},{"categories":["point"],"content":"mongodb 是一个文本型数据库. 不同于 mysql 等关系型数据库. 要点: 免费 和 js 匹配度高 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/mongodb/:0:0","series":null,"tags":["point","mongodb"],"title":"mongodb","uri":"/posts/%E7%AC%94%E8%AE%B0/point/mongodb/#"},{"categories":["point"],"content":" 导入导出 # 导出库db_a mongodump -d db_a # 从db_a文件夹导入库 mongorestore -d db_a db_a/ ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/mongodb/:0:1","series":null,"tags":["point","mongodb"],"title":"mongodb","uri":"/posts/%E7%AC%94%E8%AE%B0/point/mongodb/#导入导出"},{"categories":["point"],"content":"nginx 是一个常见的负载均衡服务. 要点: 免费 用户量大, 教程多 性能强大 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/nginx/:0:0","series":null,"tags":["point","nginx"],"title":"nginx","uri":"/posts/%E7%AC%94%E8%AE%B0/point/nginx/#"},{"categories":["blog"],"content":"这里记录 [[笔记/point/nginx|nginx]] 的模块编译和升级操作.","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/","series":null,"tags":["blog","nginx"],"title":"nginx编译和升级","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/"},{"categories":["blog"],"content":" 简介这里记录 nginx 的模块编译和升级操作. ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/:1:0","series":null,"tags":["blog","nginx"],"title":"nginx编译和升级","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/#简介"},{"categories":["blog"],"content":" 操作手册","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/:2:0","series":null,"tags":["blog","nginx"],"title":"nginx编译和升级","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/#操作手册"},{"categories":["blog"],"content":" 编译 # 下载,解压 curl http://nginx.org/download/nginx-1.20.2.tar.gz -o nginx-1.20.2.tar.gz tar -zxvf nginx-1.20.2.tar.gz # 安装编译需要用的依赖 apt install libpcre3 libpcre3-dev openssl libssl-dev -y # ssl证书 --with-http_ssl_module # tcp代理 --with-stream # tcp代理的时候，把客户端ip传到PROXY协议的header头部 --with-stream_realip_module,虽然我一直用header传输 # 启用http2 --with-http_v2_module ./configure --user=nginx --group=nginx --prefix=/usr/local/nginx --with-http_ssl_module --with-stream --with-stream_realip_module --with-http_v2_module make make install # 软连接 ln -s /usr/local/nginx/sbin/nginx /usr/local/bin/nginx # 验证 nginx -t # 启动 nginx # 报错 [emerg] getpwnam(\"nginx\") failed useradd -s /bin/false nginx ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/:2:1","series":null,"tags":["blog","nginx"],"title":"nginx编译和升级","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/#编译"},{"categories":["blog"],"content":" 升级 # 下载,解压 curl http://nginx.org/download/nginx-1.22.1.tar.gz -o ~/nginx-1.22.1.tar.gz tar xf ~/nginx-1.22.1.tar.gz # nginx -V查看现有配置，然后到新版本nginx目录下执行同样配置 ./configure --user=nginx --group=nginx --prefix=/usr/local/nginx --with-http_ssl_module --with-stream --with-stream_realip_module --with-http_v2_module # 编译 make # 备份一下 cd /usr/local/nginx/sbin cp nginx nginx.bak # 停老版本nginx ./nginx -s stop # 替换文件 cp ~/nginx-1.22.1/objs/nginx nginx # 重建软连接 ln -s /usr/local/nginx/sbin/nginx /usr/local/bin/nginx # 测试是否正常 nginx -t # 启动新版本nginx nginx ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/:2:2","series":null,"tags":["blog","nginx"],"title":"nginx编译和升级","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E7%BC%96%E8%AF%91%E5%92%8C%E5%8D%87%E7%BA%A7/#升级"},{"categories":["blog"],"content":"[[笔记/point/nginx|nginx]] 的配置示例.","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/"},{"categories":["blog"],"content":" 简介nginx 的配置示例, 目录结构可以符合 nginx编译和升级 后的目录. ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 基础配置","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#基础配置"},{"categories":["blog"],"content":" nginx.conf 主配置#todo/笔记 理解 tcp 参数在每层产生的实际效果 #user nobody; worker_processes auto; worker_cpu_affinity auto; error_log /data/logs/nginx-error.log; #pid logs/nginx.pid; worker_rlimit_nofile 65535; events { use epoll; worker_connections 65535; } ## tcp代理参考 stream { upstream service-a { hash $remote_addr consistent; server 1.1.1.1:222; } server { listen 10022; proxy_connect_timeout 30s; proxy_timeout 300s; proxy_pass service-a; } } http { include mime.types; default_type application/octet-stream; # 普通日志格式 log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" \"$http_user_agent\" ' '$request_length $request_time $upstream_addr ' '$upstream_response_length $upstream_response_time $upstream_status'; # json日志格式 log_format k-json escape=json '{ \"@timestamp\":\"$time_iso8601\", ' '\"@fields\":{ ' '\"request_uri\":\"$request_uri\", ' '\"url\":\"$uri\", ' '\"upstream_addr\":\"$upstream_addr\", ' '\"remote_addr\":\"$remote_addr\", ' '\"remote_user\":\"$remote_user\", ' '\"body_bytes_sent\":\"$body_bytes_sent\", ' '\"host\":\"$host\", ' '\"server_addr\":\"$server_addr\", ' '\"request_time\":\"$request_time\", ' '\"status\":\"$status\", ' '\"request\":\"$request\", ' '\"request_method\":\"$request_method\", ' '\"upstream_response_time\":\"$upstream_response_time\", ' '\"http_referrer\":\"$http_referer\", ' '\"http_x_forwarded_for\":\"$http_x_forwarded_for\", ' '\"http_user_agent\":\"$http_user_agent\" } }'; # 访问日志 access_log /data/logs/nginx-access.log main; # 默认http 1.0, 改成1.1 proxy_http_version 1.1; # 内核完成文件发送,不需要read再write,没有上下文切换 sendfile on; # sendfile启用后才生效.累计一定大小后发送,减小额外开销,提高网络效率 tcp_nopush on; # 尽快发送数据,禁用Nagle算法(等凑满一个MSS-Maximum Segment Size最大报文长度或收到确认再发送) tcp_nodelay on; # 可以看到 TCP_NOPUSH 是要等数据包累积到一定大小才发送, TCP_NODELAY 是要尽快发送, 二者相互矛盾. 实际上, 它们确实可以一起用, 最终的效果是先填满包, 再尽快发送. 在传输过程中, 应用程序发送的数据会被 TCP 协议分割成多个段(segment), 每个段都会被封装为一个网络层的包(packet)进行传输. keepalive_timeout 360; types_hash_max_size 2048; server_tokens off; # 超时时间 proxy_connect_timeout 300; proxy_read_timeout 300; proxy_send_timeout 500; # 上传文件 client_max_body_size 2048M; # 大Header会导致502,解决 client_header_buffer_size 64k; proxy_buffer_size 256k; proxy_buffers 4 256k; proxy_busy_buffers_size 512k; # header允许下划线 underscores_in_headers on; # 打开gzip,10k内不压缩 gzip on; gzip_min_length 10k; gzip_http_version 1.1; gzip_comp_level 7; # 压缩类型，下面的配置压缩了接口。可配置项参考nginx目录下的mime.types gzip_types text/css text/xml application/javascript application/json; gzip_vary on; gzip_disable \"msie6\"; # 等价 gzip_disable \"MSIE[1-6]\\.\" 但性能更好,匹配更合适; # 包含目录 include /usr/local/nginx/conf/hosts/*.conf; # 默认配置,保留是为了不加自定义配置也能起nginx server { listen 80; server_name localhost; location / { root html; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#nginxconf-主配置"},{"categories":["blog"],"content":" 通用代理配置/usr/local/nginx/conf/options/normal.conf proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:2","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#通用代理配置"},{"categories":["blog"],"content":" 长连接 websocket 配置/usr/local/nginx/conf/options/### upgrade_to_websocket.conf proxy_http_version 1.1; proxy_set_header Host $host; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:3","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#长连接-websocket-配置"},{"categories":["blog"],"content":" 证书配置/usr/local/nginx/conf/options/ssl_kentxxq.conf ssl_certificate /usr/local/nginx/conf/ssl/kentxxq.cer; ssl_certificate_key /usr/local/nginx/conf/ssl/kentxxq.key; ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:4","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#证书配置"},{"categories":["blog"],"content":" map 配置/usr/local/nginx/conf/options/map.conf # 域名匹配,就把 map $http_origin $allow_origin { default \"\"; \"~http://www.kentxxq.com\" http://www.kentxxq.com; \"~https://www.kentxxq.com\" https://www.kentxxq.com; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:5","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#map-配置"},{"categories":["blog"],"content":" 跨域配置文件 全部跨域/usr/local/nginx/conf/options/allow_all_cross_origin.conf # add_header 'Access-Control-Allow-Origin' * always; add_header 'Access-Control-Allow-Origin' $http_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, HEAD, PUT, DELETE, TRACE, CONNECT'; # add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type'; add_header 'Access-Control-Allow-Headers' *; add_header 'Access-Control-Max-Age' 86400; 全部 options 跨域/usr/local/nginx/conf/options/allow_all_cross_origin.conf if ($request_method = 'OPTIONS') { # 前两条的配置为固定格式！兼容性最强。原因是客户端发送ajax请求，包含withCredentials的时候，origin不能为*，且Credentials必须为true。 # 参考链接 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials add_header 'Access-Control-Allow-Origin' $http_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET,POST,OPTIONS,HEAD,PUT,DELETE, TRACE, CONNECT'; add_header 'Access-Control-Allow-Headers' *; add_header 'Access-Control-Max-Age' 86400; add_header 'Content-Length' 0; return 204; } 特定匹配 options 跨域/usr/local/nginx/conf/options/allow_kentxxq_cross_origin.conf if ($request_method = 'OPTIONS') { add_header 'Access-Control-Allow-Origin' $allow_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, HEAD, PUT, DELETE, TRACE, CONNECT'; add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type,Accept,Origin,User-Agent,DNT,Cache-Control,X-Mx-ReqToken,X-Requested-With,token,terminalType'; add_header 'Access-Control-Max-Age' 86400; add_header 'Content-Length' 0; return 204; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:6","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#跨域配置文件"},{"categories":["blog"],"content":" 跨域配置文件 全部跨域/usr/local/nginx/conf/options/allow_all_cross_origin.conf # add_header 'Access-Control-Allow-Origin' * always; add_header 'Access-Control-Allow-Origin' $http_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, HEAD, PUT, DELETE, TRACE, CONNECT'; # add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type'; add_header 'Access-Control-Allow-Headers' *; add_header 'Access-Control-Max-Age' 86400; 全部 options 跨域/usr/local/nginx/conf/options/allow_all_cross_origin.conf if ($request_method = 'OPTIONS') { # 前两条的配置为固定格式！兼容性最强。原因是客户端发送ajax请求，包含withCredentials的时候，origin不能为*，且Credentials必须为true。 # 参考链接 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials add_header 'Access-Control-Allow-Origin' $http_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET,POST,OPTIONS,HEAD,PUT,DELETE, TRACE, CONNECT'; add_header 'Access-Control-Allow-Headers' *; add_header 'Access-Control-Max-Age' 86400; add_header 'Content-Length' 0; return 204; } 特定匹配 options 跨域/usr/local/nginx/conf/options/allow_kentxxq_cross_origin.conf if ($request_method = 'OPTIONS') { add_header 'Access-Control-Allow-Origin' $allow_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, HEAD, PUT, DELETE, TRACE, CONNECT'; add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type,Accept,Origin,User-Agent,DNT,Cache-Control,X-Mx-ReqToken,X-Requested-With,token,terminalType'; add_header 'Access-Control-Max-Age' 86400; add_header 'Content-Length' 0; return 204; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:6","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#全部跨域"},{"categories":["blog"],"content":" 跨域配置文件 全部跨域/usr/local/nginx/conf/options/allow_all_cross_origin.conf # add_header 'Access-Control-Allow-Origin' * always; add_header 'Access-Control-Allow-Origin' $http_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, HEAD, PUT, DELETE, TRACE, CONNECT'; # add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type'; add_header 'Access-Control-Allow-Headers' *; add_header 'Access-Control-Max-Age' 86400; 全部 options 跨域/usr/local/nginx/conf/options/allow_all_cross_origin.conf if ($request_method = 'OPTIONS') { # 前两条的配置为固定格式！兼容性最强。原因是客户端发送ajax请求，包含withCredentials的时候，origin不能为*，且Credentials必须为true。 # 参考链接 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials add_header 'Access-Control-Allow-Origin' $http_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET,POST,OPTIONS,HEAD,PUT,DELETE, TRACE, CONNECT'; add_header 'Access-Control-Allow-Headers' *; add_header 'Access-Control-Max-Age' 86400; add_header 'Content-Length' 0; return 204; } 特定匹配 options 跨域/usr/local/nginx/conf/options/allow_kentxxq_cross_origin.conf if ($request_method = 'OPTIONS') { add_header 'Access-Control-Allow-Origin' $allow_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, HEAD, PUT, DELETE, TRACE, CONNECT'; add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type,Accept,Origin,User-Agent,DNT,Cache-Control,X-Mx-ReqToken,X-Requested-With,token,terminalType'; add_header 'Access-Control-Max-Age' 86400; add_header 'Content-Length' 0; return 204; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:6","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#全部-options-跨域"},{"categories":["blog"],"content":" 跨域配置文件 全部跨域/usr/local/nginx/conf/options/allow_all_cross_origin.conf # add_header 'Access-Control-Allow-Origin' * always; add_header 'Access-Control-Allow-Origin' $http_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, HEAD, PUT, DELETE, TRACE, CONNECT'; # add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type'; add_header 'Access-Control-Allow-Headers' *; add_header 'Access-Control-Max-Age' 86400; 全部 options 跨域/usr/local/nginx/conf/options/allow_all_cross_origin.conf if ($request_method = 'OPTIONS') { # 前两条的配置为固定格式！兼容性最强。原因是客户端发送ajax请求，包含withCredentials的时候，origin不能为*，且Credentials必须为true。 # 参考链接 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials add_header 'Access-Control-Allow-Origin' $http_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET,POST,OPTIONS,HEAD,PUT,DELETE, TRACE, CONNECT'; add_header 'Access-Control-Allow-Headers' *; add_header 'Access-Control-Max-Age' 86400; add_header 'Content-Length' 0; return 204; } 特定匹配 options 跨域/usr/local/nginx/conf/options/allow_kentxxq_cross_origin.conf if ($request_method = 'OPTIONS') { add_header 'Access-Control-Allow-Origin' $allow_origin always; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, HEAD, PUT, DELETE, TRACE, CONNECT'; add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type,Accept,Origin,User-Agent,DNT,Cache-Control,X-Mx-ReqToken,X-Requested-With,token,terminalType'; add_header 'Access-Control-Max-Age' 86400; add_header 'Content-Length' 0; return 204; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:6","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#特定匹配-options-跨域"},{"categories":["blog"],"content":" 域名转发/usr/local/nginx/conf/hosts/www.kentxxq.com.conf server { listen 80; server_name www.kentxxq.com; return 301 https://$server_name$request_uri; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log k-json; } server { listen 443 ssl http2; server_name www.kentxxq.com; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log k-json; # 普通header头,ip之类的 include /usr/local/nginx/conf/options/normal.conf; # 跨域 include /usr/local/nginx/conf/options/allow_all_cross_origin.conf; # 证书相关 include /usr/local/nginx/conf/options/ssl_kentxxq.conf; location / { # 跨域 include /usr/local/nginx/conf/options/allow_all_options_cross_origin.conf; proxy_pass http://1.1.1.1:80; } } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:7","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#域名转发"},{"categories":["blog"],"content":" 静态页代理 简单版 location / { root /usr/share/nginx/html; index index.html; try_files $uri $uri/index.html /index.html; } 完整版本 server { listen 80; server_name www.kentxxq.com; return 301 https://$server_name$request_uri; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log; } server { listen 443 ssl http2; server_name www.kentxxq.com; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log; include /usr/local/nginx/conf/options/normal.conf; include /usr/local/nginx/conf/options/ssl_kentxxq.conf; location / { if ($request_filename ~* .*\\.(?:htm|html)$) { add_header Cache-Control \"no-store\"; } root /usr/share/nginx/html; try_files $uri @index ; } location @index { add_header Cache-Control \"no-store\" ; root /usr/share/nginx/html; index index.html index.htm; try_files $uri/index.html /index.html; } error_page 405 =200 $uri; } 容器版本 server { listen 80; listen [::]:80; server_name localhost default_server; client_max_body_size 200m; location / { if ($request_filename ~* .*\\.(?:htm|html)$) { add_header Cache-Control \"no-store\"; } root /usr/share/nginx/html; try_files $uri @index ; } location @index { add_header Cache-Control \"no-store\" ; root /usr/share/nginx/html; index index.html index.htm; try_files $uri/index.html /index.html; } error_page 405 =200 $uri; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:8","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#静态页代理"},{"categories":["blog"],"content":" 静态页代理 简单版 location / { root /usr/share/nginx/html; index index.html; try_files $uri $uri/index.html /index.html; } 完整版本 server { listen 80; server_name www.kentxxq.com; return 301 https://$server_name$request_uri; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log; } server { listen 443 ssl http2; server_name www.kentxxq.com; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log; include /usr/local/nginx/conf/options/normal.conf; include /usr/local/nginx/conf/options/ssl_kentxxq.conf; location / { if ($request_filename ~* .*\\.(?:htm|html)$) { add_header Cache-Control \"no-store\"; } root /usr/share/nginx/html; try_files $uri @index ; } location @index { add_header Cache-Control \"no-store\" ; root /usr/share/nginx/html; index index.html index.htm; try_files $uri/index.html /index.html; } error_page 405 =200 $uri; } 容器版本 server { listen 80; listen [::]:80; server_name localhost default_server; client_max_body_size 200m; location / { if ($request_filename ~* .*\\.(?:htm|html)$) { add_header Cache-Control \"no-store\"; } root /usr/share/nginx/html; try_files $uri @index ; } location @index { add_header Cache-Control \"no-store\" ; root /usr/share/nginx/html; index index.html index.htm; try_files $uri/index.html /index.html; } error_page 405 =200 $uri; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:8","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#简单版"},{"categories":["blog"],"content":" 静态页代理 简单版 location / { root /usr/share/nginx/html; index index.html; try_files $uri $uri/index.html /index.html; } 完整版本 server { listen 80; server_name www.kentxxq.com; return 301 https://$server_name$request_uri; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log; } server { listen 443 ssl http2; server_name www.kentxxq.com; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log; include /usr/local/nginx/conf/options/normal.conf; include /usr/local/nginx/conf/options/ssl_kentxxq.conf; location / { if ($request_filename ~* .*\\.(?:htm|html)$) { add_header Cache-Control \"no-store\"; } root /usr/share/nginx/html; try_files $uri @index ; } location @index { add_header Cache-Control \"no-store\" ; root /usr/share/nginx/html; index index.html index.htm; try_files $uri/index.html /index.html; } error_page 405 =200 $uri; } 容器版本 server { listen 80; listen [::]:80; server_name localhost default_server; client_max_body_size 200m; location / { if ($request_filename ~* .*\\.(?:htm|html)$) { add_header Cache-Control \"no-store\"; } root /usr/share/nginx/html; try_files $uri @index ; } location @index { add_header Cache-Control \"no-store\" ; root /usr/share/nginx/html; index index.html index.htm; try_files $uri/index.html /index.html; } error_page 405 =200 $uri; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:8","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#完整版本"},{"categories":["blog"],"content":" 静态页代理 简单版 location / { root /usr/share/nginx/html; index index.html; try_files $uri $uri/index.html /index.html; } 完整版本 server { listen 80; server_name www.kentxxq.com; return 301 https://$server_name$request_uri; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log; } server { listen 443 ssl http2; server_name www.kentxxq.com; access_log /usr/local/nginx/conf/hosts/logs/www.kentxxq.com.log; include /usr/local/nginx/conf/options/normal.conf; include /usr/local/nginx/conf/options/ssl_kentxxq.conf; location / { if ($request_filename ~* .*\\.(?:htm|html)$) { add_header Cache-Control \"no-store\"; } root /usr/share/nginx/html; try_files $uri @index ; } location @index { add_header Cache-Control \"no-store\" ; root /usr/share/nginx/html; index index.html index.htm; try_files $uri/index.html /index.html; } error_page 405 =200 $uri; } 容器版本 server { listen 80; listen [::]:80; server_name localhost default_server; client_max_body_size 200m; location / { if ($request_filename ~* .*\\.(?:htm|html)$) { add_header Cache-Control \"no-store\"; } root /usr/share/nginx/html; try_files $uri @index ; } location @index { add_header Cache-Control \"no-store\" ; root /usr/share/nginx/html; index index.html index.htm; try_files $uri/index.html /index.html; } error_page 405 =200 $uri; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:2:8","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#容器版本"},{"categories":["blog"],"content":" 功能配置","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#功能配置"},{"categories":["blog"],"content":" 用户名密码 # 安装 apt install apache2-utils -y # 密码在 /usr/local/nginx/conf/passwd.db ,让你输入密码 htpasswd -c /usr/local/nginx/conf/passwd.db user1 # 配置使用用户名密码 location / { auth_basic \"需要输入用户名: 密码:\"; auth_basic_user_file /usr/local/nginx/conf/passwd.db; proxy_pass http://1.1.1.1:80; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:3:1","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#用户名密码"},{"categories":["blog"],"content":" 移动端检测Detect Mobile Browsers - Open source mobile phone detection location /mobile-page { set $is_mobile 0; if ($http_user_agent ~* \"(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino\") { set $is_mobile 1; } if ($http_user_agent ~* \"^(1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-)\") { set $is_mobile 1; } # =0是pc端 =1是移动端 if ($is_mobile = 0) { return 302 https://www.kentxxq.com$request_uri; } proxy_set_header Host $host; proxy_pass http://1.1.1.1:80; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:3:2","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#移动端检测"},{"categories":["blog"],"content":" 返回 200 location /string { default_type text/html; return 200 \"维护中\"; } location /json { default_type application/json; return 200 '{\"status\":\"success\",\"result\":\"nginx json\"}'; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:3:3","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#返回-200"},{"categories":["blog"],"content":" 405 错误 -post 请求静态文件 # 这一行加在server的第一层，不能加在location位置 error_page 405 =200 $uri; ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:3:4","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#405-错误--post-请求静态文件"},{"categories":["blog"],"content":" 防止嵌入 iframe # frame-ancestors 谁能嵌入我 # frame-src 我可以嵌入哪些站点 # 参考 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors # 当前站点,a.com,b.com,以及子域名 # 空格间隔,不同参数分号隔开 add_header Content-Security-Policy \"frame-ancestors 'self' a.com b.com *.a.com *.b.com; frame-src 'self' a.com b.com *.a.com *.b.com\"; ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:3:5","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#防止嵌入-iframe"},{"categories":["blog"],"content":" Ingress-nginx 配置 # 双层nginx,第二层的ingress-nginx需要配置这个 use-forwarded-headers: 'true' # yml配置 kind: Ingress apiVersion: networking.k8s.io/v1 metadata: name: gateway.gateway.com namespace: default annotations: kubectl.kubernetes.io/last-applied-configuration: \u003e {\"apiVersion\":\"networking.k8s.io/v1\",\"kind\":\"Ingress\",\"metadata\":{\"annotations\":{\"kubernetes.io/ingress.class\":\"nginx\",\"nginx.ingress.kubernetes.io/cors-allow-headers\":\"uid,download,repeat,DNT,X-CustomHeader,X-LANG,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,X-Api-Key,X-Device-Id,Access-Control-Allow-Origin,authorization\",\"nginx.ingress.kubernetes.io/cors-allow-methods\":\"PUT, GET, POST, OPTIONS, DELETE\",\"nginx.ingress.kubernetes.io/cors-allow-origin\":\"*\",\"nginx.ingress.kubernetes.io/enable-cors\":\"true\"},\"name\":\"gateway.kentxxq.com\",\"namespace\":\"default\"},\"spec\":{\"ingressClassName\":\"nginx\",\"rules\":[{\"host\":\"gateway.kentxxq.com\",\"http\":{\"paths\":[{\"backend\":{\"service\":{\"name\":\"gateway\",\"port\":{\"number\":8090}}},\"path\":\"/\",\"pathType\":\"Prefix\"}]}}],\"tls\":[{\"hosts\":[\"gateway.kentxxq.com\"],\"secretName\":\"a.kentxxq.com-secret\"}]}} kubernetes.io/ingress.class: nginx nginx.ingress.kubernetes.io/cors-allow-headers: \u003e- uid,download,repeat,DNT,X-CustomHeader,X-LANG,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,X-Api-Key,X-Device-Id,Access-Control-Allow-Origin,authorization nginx.ingress.kubernetes.io/cors-allow-methods: 'PUT, GET, POST, OPTIONS, DELETE' nginx.ingress.kubernetes.io/cors-allow-origin: '*' nginx.ingress.kubernetes.io/enable-cors: 'true' # 下面是手动添加内容，用于压测或自定义 nginx.ingress.kubernetes.io/server-snippet: | location /200_ingress_nginx { default_type text/html; return 200 \"200_ingress_nginx\"; } spec: ingressClassName: nginx tls: - hosts: - gateway.kentxxq.com secretName: a.kentxxq.com-secret rules: - host: gateway.kentxxq.com http: paths: - path: / pathType: Prefix backend: service: name: gateway port: number: 8090 - path: /200_ingress_to_nginx pathType: Prefix backend: service: name: test-nginx port: number: 80 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:4:0","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#ingress-nginx-配置"},{"categories":["blog"],"content":" Openrestry 转发给 kafka","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:5:0","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#openrestry-转发给-kafka"},{"categories":["blog"],"content":" 依赖配置以前做过这个, 但是现在觉得没有必要. 因为我对 lua 语言不熟悉, 而且觉得 nginx 做负载就好了, 不应该嵌入一些业务需求. GitHub - doujiang24/lua-resty-kafka: Lua kafka client driver for the Openresty based on the cosocket API # nginx.conf http { lua_package_path \"/path/to/lua-resty-kafka/lib/?.lua;;\"; ... } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:5:1","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#依赖配置"},{"categories":["blog"],"content":" 转发配置 server { listen 443 ssl http2; server_name a.kentxxq.com; access_log /data/weblog/nginx/logs/a.kentxxq.com.access.log main; lua_need_request_body on; include /usr/local/openresty/nginx/conf/option/ssl_kentxxq.com.conf; location /lua { default_type 'text/html'; content_by_lua 'ngx.say(\"hello world！\")'; } location /api/livereportorgan/playbackRecord { proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; default_type 'application/json'; content_by_lua ' local cjson = require \"cjson\" local client = require \"resty.kafka.client\" local producer = require \"resty.kafka.producer\" local uuid = require \"resty.uuid\" local broker_list = { { host = \"ip1\", port = 9092 }, { host = \"ip2\", port = 9092 }, { host = \"ip3\", port = 9092 }, } local message = {} message[\"uri\"]=ngx.var.uri message[\"args\"]=ngx.var.args message[\"host\"]=ngx.var.host message[\"request_body\"]=ngx.var.request_body message[\"remote_addr\"] = ngx.var.http_x_forwarded_for message[\"remote_user\"] = ngx.var.remote_user message[\"time_local\"] = ngx.var.time_iso8601 message[\"status\"] = ngx.var.status message[\"body_bytes_sent\"] = ngx.var.body_bytes_sent message[\"http_referer\"] = ngx.var.http_referer message[\"http_user_agent\"] = ngx.var.http_user_agent message[\"http_x_forwarded_for\"] = ngx.var.http_x_forwarded_for message[\"upstream_response_time\"] = ngx.var.upstream_response_time message[\"request_time\"] = ngx.var.request_time message[\"http_token\"] = ngx.var.http_token message[\"terminalType\"] = ngx.var.http_terminalType message[\"header\"] = ngx.var.header message[\"uuid\"] = uuid.generate() -- 转换json为字符串 local message = cjson.encode(message); -- 定义kafka异步生产者 -- this is async producer_type and bp will be reused in the whole nginx worker local bp = producer:new(broker_list, { producer_type = \"sync\" }) local ok, err = bp:send(\"playback_duration_notice_org\", nil, message) if not ok then local response = {} response[\"code\"]=\"1\" response[\"message\"]=err response[\"data\"]=\"true\" local response = cjson.encode(response); ngx.say(response) return end local delayData = {delay = 60} local response = {code = \"0\", message = \"success\", data = delayData} local response = cjson.encode(response); ngx.say(response) '; } } server { listen 80; server_name a.kentxxq.com; return 301 https://$server_name$request_uri; } ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/:5:2","series":null,"tags":["blog","nginx"],"title":"nginx配置","uri":"/posts/%E7%AC%94%E8%AE%B0/nginx%E9%85%8D%E7%BD%AE/#转发配置"},{"categories":["point"],"content":"oracle 是一种关系型数据库, 类似 mssql, mysql. 要点: 收费 用户量大 国内互联网几乎不用 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/oracle/:0:0","series":null,"tags":["point","oracle"],"title":"oracle","uri":"/posts/%E7%AC%94%E8%AE%B0/point/oracle/#"},{"categories":["blog"],"content":"因为以前的公司是用 [[笔记/point/oracle|oracle]],所以也记录了不少的命令. 记录一下后续使用.","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E9%85%8D%E7%BD%AE%E5%92%8C%E5%91%BD%E4%BB%A4/","series":null,"tags":["blog","oracle"],"title":"oracle配置和命令","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E9%85%8D%E7%BD%AE%E5%92%8C%E5%91%BD%E4%BB%A4/"},{"categories":["blog"],"content":" 简介因为以前的公司是用 oracle,所以也记录了不少的命令. 记录一下后续使用. ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E9%85%8D%E7%BD%AE%E5%92%8C%E5%91%BD%E4%BB%A4/:1:0","series":null,"tags":["blog","oracle"],"title":"oracle配置和命令","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E9%85%8D%E7%BD%AE%E5%92%8C%E5%91%BD%E4%BB%A4/#简介"},{"categories":["blog"],"content":" 命令","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E9%85%8D%E7%BD%AE%E5%92%8C%E5%91%BD%E4%BB%A4/:2:0","series":null,"tags":["blog","oracle"],"title":"oracle配置和命令","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E9%85%8D%E7%BD%AE%E5%92%8C%E5%91%BD%E4%BB%A4/#命令"},{"categories":["blog"],"content":" 索引 # 快速创建索引 create index idx_table_a on table_a(字段a,字段b) nologging parallel 4; ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E9%85%8D%E7%BD%AE%E5%92%8C%E5%91%BD%E4%BB%A4/:2:1","series":null,"tags":["blog","oracle"],"title":"oracle配置和命令","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E9%85%8D%E7%BD%AE%E5%92%8C%E5%91%BD%E4%BB%A4/#索引"},{"categories":["blog"],"content":" 删除操作 # 加速插入 alter table x nologging; insert /*+append*/ into x (a,b,c) as select a,b,c from xxx; # 批量删除.根据时间排序,1000条commmit一次 declare cursor [del_cursor] is select a.*, a.rowid row_id from [table_name] a order by a.rowid; begin for v_cusor in [del_cursor] loop if v_cusor.[time_stamp] \u003c to_date('2014-01-01','yyyy-mm-dd') then delete from [table_name] where rowid = v_cusor.row_id; end if; if mod([del_cursor]%rowcount,1000)=0 then commit; end if; end loop; commit; end; # 两表数据同步 MERGE INTO t_canhe_family t1 USING(select a1.family_id,a1.account_money,a1.balance,a1.remaining_money from t_canhe_family_bak20161121 a1) tt ON (tt.family_id=t1.family_id) when matched then update set t1.account_money=tt.account_money, t1.balance=tt.balance, t1.remaining_money=tt.remaining_money ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E9%85%8D%E7%BD%AE%E5%92%8C%E5%91%BD%E4%BB%A4/:2:2","series":null,"tags":["blog","oracle"],"title":"oracle配置和命令","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E9%85%8D%E7%BD%AE%E5%92%8C%E5%91%BD%E4%BB%A4/#删除操作"},{"categories":["blog"],"content":" sql 优化 # 查看执行计划 select /*+ gather_plan_statistics */* from table(dbms_xplan.display_cursor(NVL('ajkqn4733r2qx',NULL),NULL,'ALL ALLSTATS LAST PEEKED_BINDS cost partition -projection -outline')); ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/oracle%E9%85%8D%E7%BD%AE%E5%92%8C%E5%91%BD%E4%BB%A4/:2:3","series":null,"tags":["blog","oracle"],"title":"oracle配置和命令","uri":"/posts/%E7%AC%94%E8%AE%B0/oracle%E9%85%8D%E7%BD%AE%E5%92%8C%E5%91%BD%E4%BB%A4/#sql-优化"},{"categories":["point"],"content":"redis 通常用来做缓存数据库. 要点: 免费 性能高 缓存常用 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/redis/:0:0","series":null,"tags":["point","redis"],"title":"redis","uri":"/posts/%E7%AC%94%E8%AE%B0/point/redis/#"},{"categories":["point"],"content":" 操作手册 # 删除 ip地址的8号库的a_* redis-cli -h ip地址 -a 密码 -n 8 keys 'a_*' | xargs redis-cli -h ip地址 -a 密码 -n 8 del # 把0库所有内容移动到1库 redis-cli -a 密码 -n 0 keys '*' | xargs -I '{}' redis-cli -a didi -n 0 move '{}' 1 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/redis/:0:1","series":null,"tags":["point","redis"],"title":"redis","uri":"/posts/%E7%AC%94%E8%AE%B0/point/redis/#操作手册"},{"categories":["blog"],"content":"这里记录一些 ip, 包, 传输协议, 段, 和7 层网络知识等等网络知识, 方便快速查阅. ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"},{"categories":["blog"],"content":" 简介这里记录一些 ip, 包, 传输协议, 段, 和 7 层网络知识等等网络知识, 方便快速查阅. ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:1:0","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:0","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#内容"},{"categories":["blog"],"content":" 7 层通信 路由器和 3层交换机 等价. 2层交换机 活动在数据链路层, 只是延长网络. 每一层都加上自己的 header头部数据. ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:1","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#7-层通信"},{"categories":["blog"],"content":" 7 层模型各自的作用 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:2","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#7-层模型各自的作用"},{"categories":["blog"],"content":" 7 层网络协议 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:3","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#7-层网络协议"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 例如以太网是 IEEE 802.3 标准, wifi 是 IEEE 802.11 标准. Wi-Fi 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段长度 MSS、窗口扩大、时间戳、选择确认…… TCP 建立连接 刚开始客户端处于 closed 状态，服务端处于 listen 状态 **第一次握手：**客户端发送连接请求报文段（SYN = 1，seq = x（随机）），无应用层数据。此时客户端处于 SYN_Send （同步发送）状态 **第二次握手：**服务端收到客户端的连接请求报文后，为该 TCP 连接分配缓存和变量，并向客户端返回确认报文（SYN = 1，ACK = 1，seq = y（随机），ack = x + 1），允许连接，无应用层数据。此时服务端处于 SYN_REVD（同步接收）状态 第三次握手：客户端收到连接请求报文后，会发送一个对确认的确认报文（ACK = 1，seq = x + 1，ack = y + 1），可以携带数据。此时客户端处于 established 状态 服务器收到确认报文后，也会处于 established 状态。此时，双方建立了连接. SYN 哄泛攻击: 攻击者发送握手第一个包 服务器响应后, 处于半连接. 发送消耗资源, 挂起消耗资源 服务器收不到响应, 重复发送, 持续消耗资源 短时间内服务器大量等待, 会崩掉 TCP 连接释放 刚开始双方都处于 established 状态，假如是客户端先发起关闭请求，则： 第一次挥手：客户端发送连接释放报文段（FIN = 1，seq = u（前面已传送数据的最后","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#数据包详解"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 例如以太网是 IEEE 802.3 标准, wifi 是 IEEE 802.11 标准. Wi-Fi 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段长度 MSS、窗口扩大、时间戳、选择确认…… TCP 建立连接 刚开始客户端处于 closed 状态，服务端处于 listen 状态 **第一次握手：**客户端发送连接请求报文段（SYN = 1，seq = x（随机）），无应用层数据。此时客户端处于 SYN_Send （同步发送）状态 **第二次握手：**服务端收到客户端的连接请求报文后，为该 TCP 连接分配缓存和变量，并向客户端返回确认报文（SYN = 1，ACK = 1，seq = y（随机），ack = x + 1），允许连接，无应用层数据。此时服务端处于 SYN_REVD（同步接收）状态 第三次握手：客户端收到连接请求报文后，会发送一个对确认的确认报文（ACK = 1，seq = x + 1，ack = y + 1），可以携带数据。此时客户端处于 established 状态 服务器收到确认报文后，也会处于 established 状态。此时，双方建立了连接. SYN 哄泛攻击: 攻击者发送握手第一个包 服务器响应后, 处于半连接. 发送消耗资源, 挂起消耗资源 服务器收不到响应, 重复发送, 持续消耗资源 短时间内服务器大量等待, 会崩掉 TCP 连接释放 刚开始双方都处于 established 状态，假如是客户端先发起关闭请求，则： 第一次挥手：客户端发送连接释放报文段（FIN = 1，seq = u（前面已传送数据的最后","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#数据包示意图"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 例如以太网是 IEEE 802.3 标准, wifi 是 IEEE 802.11 标准. Wi-Fi 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段长度 MSS、窗口扩大、时间戳、选择确认…… TCP 建立连接 刚开始客户端处于 closed 状态，服务端处于 listen 状态 **第一次握手：**客户端发送连接请求报文段（SYN = 1，seq = x（随机）），无应用层数据。此时客户端处于 SYN_Send （同步发送）状态 **第二次握手：**服务端收到客户端的连接请求报文后，为该 TCP 连接分配缓存和变量，并向客户端返回确认报文（SYN = 1，ACK = 1，seq = y（随机），ack = x + 1），允许连接，无应用层数据。此时服务端处于 SYN_REVD（同步接收）状态 第三次握手：客户端收到连接请求报文后，会发送一个对确认的确认报文（ACK = 1，seq = x + 1，ack = y + 1），可以携带数据。此时客户端处于 established 状态 服务器收到确认报文后，也会处于 established 状态。此时，双方建立了连接. SYN 哄泛攻击: 攻击者发送握手第一个包 服务器响应后, 处于半连接. 发送消耗资源, 挂起消耗资源 服务器收不到响应, 重复发送, 持续消耗资源 短时间内服务器大量等待, 会崩掉 TCP 连接释放 刚开始双方都处于 established 状态，假如是客户端先发起关闭请求，则： 第一次挥手：客户端发送连接释放报文段（FIN = 1，seq = u（前面已传送数据的最后","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#数据链路层"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 例如以太网是 IEEE 802.3 标准, wifi 是 IEEE 802.11 标准. Wi-Fi 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段长度 MSS、窗口扩大、时间戳、选择确认…… TCP 建立连接 刚开始客户端处于 closed 状态，服务端处于 listen 状态 **第一次握手：**客户端发送连接请求报文段（SYN = 1，seq = x（随机）），无应用层数据。此时客户端处于 SYN_Send （同步发送）状态 **第二次握手：**服务端收到客户端的连接请求报文后，为该 TCP 连接分配缓存和变量，并向客户端返回确认报文（SYN = 1，ACK = 1，seq = y（随机），ack = x + 1），允许连接，无应用层数据。此时服务端处于 SYN_REVD（同步接收）状态 第三次握手：客户端收到连接请求报文后，会发送一个对确认的确认报文（ACK = 1，seq = x + 1，ack = y + 1），可以携带数据。此时客户端处于 established 状态 服务器收到确认报文后，也会处于 established 状态。此时，双方建立了连接. SYN 哄泛攻击: 攻击者发送握手第一个包 服务器响应后, 处于半连接. 发送消耗资源, 挂起消耗资源 服务器收不到响应, 重复发送, 持续消耗资源 短时间内服务器大量等待, 会崩掉 TCP 连接释放 刚开始双方都处于 established 状态，假如是客户端先发起关闭请求，则： 第一次挥手：客户端发送连接释放报文段（FIN = 1，seq = u（前面已传送数据的最后","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#帧-frame"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 例如以太网是 IEEE 802.3 标准, wifi 是 IEEE 802.11 标准. Wi-Fi 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段长度 MSS、窗口扩大、时间戳、选择确认…… TCP 建立连接 刚开始客户端处于 closed 状态，服务端处于 listen 状态 **第一次握手：**客户端发送连接请求报文段（SYN = 1，seq = x（随机）），无应用层数据。此时客户端处于 SYN_Send （同步发送）状态 **第二次握手：**服务端收到客户端的连接请求报文后，为该 TCP 连接分配缓存和变量，并向客户端返回确认报文（SYN = 1，ACK = 1，seq = y（随机），ack = x + 1），允许连接，无应用层数据。此时服务端处于 SYN_REVD（同步接收）状态 第三次握手：客户端收到连接请求报文后，会发送一个对确认的确认报文（ACK = 1，seq = x + 1，ack = y + 1），可以携带数据。此时客户端处于 established 状态 服务器收到确认报文后，也会处于 established 状态。此时，双方建立了连接. SYN 哄泛攻击: 攻击者发送握手第一个包 服务器响应后, 处于半连接. 发送消耗资源, 挂起消耗资源 服务器收不到响应, 重复发送, 持续消耗资源 短时间内服务器大量等待, 会崩掉 TCP 连接释放 刚开始双方都处于 established 状态，假如是客户端先发起关闭请求，则： 第一次挥手：客户端发送连接释放报文段（FIN = 1，seq = u（前面已传送数据的最后","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#mtu"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 例如以太网是 IEEE 802.3 标准, wifi 是 IEEE 802.11 标准. Wi-Fi 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段长度 MSS、窗口扩大、时间戳、选择确认…… TCP 建立连接 刚开始客户端处于 closed 状态，服务端处于 listen 状态 **第一次握手：**客户端发送连接请求报文段（SYN = 1，seq = x（随机）），无应用层数据。此时客户端处于 SYN_Send （同步发送）状态 **第二次握手：**服务端收到客户端的连接请求报文后，为该 TCP 连接分配缓存和变量，并向客户端返回确认报文（SYN = 1，ACK = 1，seq = y（随机），ack = x + 1），允许连接，无应用层数据。此时服务端处于 SYN_REVD（同步接收）状态 第三次握手：客户端收到连接请求报文后，会发送一个对确认的确认报文（ACK = 1，seq = x + 1，ack = y + 1），可以携带数据。此时客户端处于 established 状态 服务器收到确认报文后，也会处于 established 状态。此时，双方建立了连接. SYN 哄泛攻击: 攻击者发送握手第一个包 服务器响应后, 处于半连接. 发送消耗资源, 挂起消耗资源 服务器收不到响应, 重复发送, 持续消耗资源 短时间内服务器大量等待, 会崩掉 TCP 连接释放 刚开始双方都处于 established 状态，假如是客户端先发起关闭请求，则： 第一次挥手：客户端发送连接释放报文段（FIN = 1，seq = u（前面已传送数据的最后","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#网络层"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 例如以太网是 IEEE 802.3 标准, wifi 是 IEEE 802.11 标准. Wi-Fi 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段长度 MSS、窗口扩大、时间戳、选择确认…… TCP 建立连接 刚开始客户端处于 closed 状态，服务端处于 listen 状态 **第一次握手：**客户端发送连接请求报文段（SYN = 1，seq = x（随机）），无应用层数据。此时客户端处于 SYN_Send （同步发送）状态 **第二次握手：**服务端收到客户端的连接请求报文后，为该 TCP 连接分配缓存和变量，并向客户端返回确认报文（SYN = 1，ACK = 1，seq = y（随机），ack = x + 1），允许连接，无应用层数据。此时服务端处于 SYN_REVD（同步接收）状态 第三次握手：客户端收到连接请求报文后，会发送一个对确认的确认报文（ACK = 1，seq = x + 1，ack = y + 1），可以携带数据。此时客户端处于 established 状态 服务器收到确认报文后，也会处于 established 状态。此时，双方建立了连接. SYN 哄泛攻击: 攻击者发送握手第一个包 服务器响应后, 处于半连接. 发送消耗资源, 挂起消耗资源 服务器收不到响应, 重复发送, 持续消耗资源 短时间内服务器大量等待, 会崩掉 TCP 连接释放 刚开始双方都处于 established 状态，假如是客户端先发起关闭请求，则： 第一次挥手：客户端发送连接释放报文段（FIN = 1，seq = u（前面已传送数据的最后","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#tcp-ip-协议栈"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 例如以太网是 IEEE 802.3 标准, wifi 是 IEEE 802.11 标准. Wi-Fi 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段长度 MSS、窗口扩大、时间戳、选择确认…… TCP 建立连接 刚开始客户端处于 closed 状态，服务端处于 listen 状态 **第一次握手：**客户端发送连接请求报文段（SYN = 1，seq = x（随机）），无应用层数据。此时客户端处于 SYN_Send （同步发送）状态 **第二次握手：**服务端收到客户端的连接请求报文后，为该 TCP 连接分配缓存和变量，并向客户端返回确认报文（SYN = 1，ACK = 1，seq = y（随机），ack = x + 1），允许连接，无应用层数据。此时服务端处于 SYN_REVD（同步接收）状态 第三次握手：客户端收到连接请求报文后，会发送一个对确认的确认报文（ACK = 1，seq = x + 1，ack = y + 1），可以携带数据。此时客户端处于 established 状态 服务器收到确认报文后，也会处于 established 状态。此时，双方建立了连接. SYN 哄泛攻击: 攻击者发送握手第一个包 服务器响应后, 处于半连接. 发送消耗资源, 挂起消耗资源 服务器收不到响应, 重复发送, 持续消耗资源 短时间内服务器大量等待, 会崩掉 TCP 连接释放 刚开始双方都处于 established 状态，假如是客户端先发起关闭请求，则： 第一次挥手：客户端发送连接释放报文段（FIN = 1，seq = u（前面已传送数据的最后","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#ip-数据报格式"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 例如以太网是 IEEE 802.3 标准, wifi 是 IEEE 802.11 标准. Wi-Fi 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段长度 MSS、窗口扩大、时间戳、选择确认…… TCP 建立连接 刚开始客户端处于 closed 状态，服务端处于 listen 状态 **第一次握手：**客户端发送连接请求报文段（SYN = 1，seq = x（随机）），无应用层数据。此时客户端处于 SYN_Send （同步发送）状态 **第二次握手：**服务端收到客户端的连接请求报文后，为该 TCP 连接分配缓存和变量，并向客户端返回确认报文（SYN = 1，ACK = 1，seq = y（随机），ack = x + 1），允许连接，无应用层数据。此时服务端处于 SYN_REVD（同步接收）状态 第三次握手：客户端收到连接请求报文后，会发送一个对确认的确认报文（ACK = 1，seq = x + 1，ack = y + 1），可以携带数据。此时客户端处于 established 状态 服务器收到确认报文后，也会处于 established 状态。此时，双方建立了连接. SYN 哄泛攻击: 攻击者发送握手第一个包 服务器响应后, 处于半连接. 发送消耗资源, 挂起消耗资源 服务器收不到响应, 重复发送, 持续消耗资源 短时间内服务器大量等待, 会崩掉 TCP 连接释放 刚开始双方都处于 established 状态，假如是客户端先发起关闭请求，则： 第一次挥手：客户端发送连接释放报文段（FIN = 1，seq = u（前面已传送数据的最后","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#ip-数据报分片"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 例如以太网是 IEEE 802.3 标准, wifi 是 IEEE 802.11 标准. Wi-Fi 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段长度 MSS、窗口扩大、时间戳、选择确认…… TCP 建立连接 刚开始客户端处于 closed 状态，服务端处于 listen 状态 **第一次握手：**客户端发送连接请求报文段（SYN = 1，seq = x（随机）），无应用层数据。此时客户端处于 SYN_Send （同步发送）状态 **第二次握手：**服务端收到客户端的连接请求报文后，为该 TCP 连接分配缓存和变量，并向客户端返回确认报文（SYN = 1，ACK = 1，seq = y（随机），ack = x + 1），允许连接，无应用层数据。此时服务端处于 SYN_REVD（同步接收）状态 第三次握手：客户端收到连接请求报文后，会发送一个对确认的确认报文（ACK = 1，seq = x + 1，ack = y + 1），可以携带数据。此时客户端处于 established 状态 服务器收到确认报文后，也会处于 established 状态。此时，双方建立了连接. SYN 哄泛攻击: 攻击者发送握手第一个包 服务器响应后, 处于半连接. 发送消耗资源, 挂起消耗资源 服务器收不到响应, 重复发送, 持续消耗资源 短时间内服务器大量等待, 会崩掉 TCP 连接释放 刚开始双方都处于 established 状态，假如是客户端先发起关闭请求，则： 第一次挥手：客户端发送连接释放报文段（FIN = 1，seq = u（前面已传送数据的最后","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#私有-ip-地址"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 例如以太网是 IEEE 802.3 标准, wifi 是 IEEE 802.11 标准. Wi-Fi 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段长度 MSS、窗口扩大、时间戳、选择确认…… TCP 建立连接 刚开始客户端处于 closed 状态，服务端处于 listen 状态 **第一次握手：**客户端发送连接请求报文段（SYN = 1，seq = x（随机）），无应用层数据。此时客户端处于 SYN_Send （同步发送）状态 **第二次握手：**服务端收到客户端的连接请求报文后，为该 TCP 连接分配缓存和变量，并向客户端返回确认报文（SYN = 1，ACK = 1，seq = y（随机），ack = x + 1），允许连接，无应用层数据。此时服务端处于 SYN_REVD（同步接收）状态 第三次握手：客户端收到连接请求报文后，会发送一个对确认的确认报文（ACK = 1，seq = x + 1，ack = y + 1），可以携带数据。此时客户端处于 established 状态 服务器收到确认报文后，也会处于 established 状态。此时，双方建立了连接. SYN 哄泛攻击: 攻击者发送握手第一个包 服务器响应后, 处于半连接. 发送消耗资源, 挂起消耗资源 服务器收不到响应, 重复发送, 持续消耗资源 短时间内服务器大量等待, 会崩掉 TCP 连接释放 刚开始双方都处于 established 状态，假如是客户端先发起关闭请求，则： 第一次挥手：客户端发送连接释放报文段（FIN = 1，seq = u（前面已传送数据的最后","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#arprarp-协议"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 例如以太网是 IEEE 802.3 标准, wifi 是 IEEE 802.11 标准. Wi-Fi 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段长度 MSS、窗口扩大、时间戳、选择确认…… TCP 建立连接 刚开始客户端处于 closed 状态，服务端处于 listen 状态 **第一次握手：**客户端发送连接请求报文段（SYN = 1，seq = x（随机）），无应用层数据。此时客户端处于 SYN_Send （同步发送）状态 **第二次握手：**服务端收到客户端的连接请求报文后，为该 TCP 连接分配缓存和变量，并向客户端返回确认报文（SYN = 1，ACK = 1，seq = y（随机），ack = x + 1），允许连接，无应用层数据。此时服务端处于 SYN_REVD（同步接收）状态 第三次握手：客户端收到连接请求报文后，会发送一个对确认的确认报文（ACK = 1，seq = x + 1，ack = y + 1），可以携带数据。此时客户端处于 established 状态 服务器收到确认报文后，也会处于 established 状态。此时，双方建立了连接. SYN 哄泛攻击: 攻击者发送握手第一个包 服务器响应后, 处于半连接. 发送消耗资源, 挂起消耗资源 服务器收不到响应, 重复发送, 持续消耗资源 短时间内服务器大量等待, 会崩掉 TCP 连接释放 刚开始双方都处于 established 状态，假如是客户端先发起关闭请求，则： 第一次挥手：客户端发送连接释放报文段（FIN = 1，seq = u（前面已传送数据的最后","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#dhcp-协议"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 例如以太网是 IEEE 802.3 标准, wifi 是 IEEE 802.11 标准. Wi-Fi 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段长度 MSS、窗口扩大、时间戳、选择确认…… TCP 建立连接 刚开始客户端处于 closed 状态，服务端处于 listen 状态 **第一次握手：**客户端发送连接请求报文段（SYN = 1，seq = x（随机）），无应用层数据。此时客户端处于 SYN_Send （同步发送）状态 **第二次握手：**服务端收到客户端的连接请求报文后，为该 TCP 连接分配缓存和变量，并向客户端返回确认报文（SYN = 1，ACK = 1，seq = y（随机），ack = x + 1），允许连接，无应用层数据。此时服务端处于 SYN_REVD（同步接收）状态 第三次握手：客户端收到连接请求报文后，会发送一个对确认的确认报文（ACK = 1，seq = x + 1，ack = y + 1），可以携带数据。此时客户端处于 established 状态 服务器收到确认报文后，也会处于 established 状态。此时，双方建立了连接. SYN 哄泛攻击: 攻击者发送握手第一个包 服务器响应后, 处于半连接. 发送消耗资源, 挂起消耗资源 服务器收不到响应, 重复发送, 持续消耗资源 短时间内服务器大量等待, 会崩掉 TCP 连接释放 刚开始双方都处于 established 状态，假如是客户端先发起关闭请求，则： 第一次挥手：客户端发送连接释放报文段（FIN = 1，seq = u（前面已传送数据的最后","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#icmp-协议"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 例如以太网是 IEEE 802.3 标准, wifi 是 IEEE 802.11 标准. Wi-Fi 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段长度 MSS、窗口扩大、时间戳、选择确认…… TCP 建立连接 刚开始客户端处于 closed 状态，服务端处于 listen 状态 **第一次握手：**客户端发送连接请求报文段（SYN = 1，seq = x（随机）），无应用层数据。此时客户端处于 SYN_Send （同步发送）状态 **第二次握手：**服务端收到客户端的连接请求报文后，为该 TCP 连接分配缓存和变量，并向客户端返回确认报文（SYN = 1，ACK = 1，seq = y（随机），ack = x + 1），允许连接，无应用层数据。此时服务端处于 SYN_REVD（同步接收）状态 第三次握手：客户端收到连接请求报文后，会发送一个对确认的确认报文（ACK = 1，seq = x + 1，ack = y + 1），可以携带数据。此时客户端处于 established 状态 服务器收到确认报文后，也会处于 established 状态。此时，双方建立了连接. SYN 哄泛攻击: 攻击者发送握手第一个包 服务器响应后, 处于半连接. 发送消耗资源, 挂起消耗资源 服务器收不到响应, 重复发送, 持续消耗资源 短时间内服务器大量等待, 会崩掉 TCP 连接释放 刚开始双方都处于 established 状态，假如是客户端先发起关闭请求，则： 第一次挥手：客户端发送连接释放报文段（FIN = 1，seq = u（前面已传送数据的最后","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#传输层"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 例如以太网是 IEEE 802.3 标准, wifi 是 IEEE 802.11 标准. Wi-Fi 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段长度 MSS、窗口扩大、时间戳、选择确认…… TCP 建立连接 刚开始客户端处于 closed 状态，服务端处于 listen 状态 **第一次握手：**客户端发送连接请求报文段（SYN = 1，seq = x（随机）），无应用层数据。此时客户端处于 SYN_Send （同步发送）状态 **第二次握手：**服务端收到客户端的连接请求报文后，为该 TCP 连接分配缓存和变量，并向客户端返回确认报文（SYN = 1，ACK = 1，seq = y（随机），ack = x + 1），允许连接，无应用层数据。此时服务端处于 SYN_REVD（同步接收）状态 第三次握手：客户端收到连接请求报文后，会发送一个对确认的确认报文（ACK = 1，seq = x + 1，ack = y + 1），可以携带数据。此时客户端处于 established 状态 服务器收到确认报文后，也会处于 established 状态。此时，双方建立了连接. SYN 哄泛攻击: 攻击者发送握手第一个包 服务器响应后, 处于半连接. 发送消耗资源, 挂起消耗资源 服务器收不到响应, 重复发送, 持续消耗资源 短时间内服务器大量等待, 会崩掉 TCP 连接释放 刚开始双方都处于 established 状态，假如是客户端先发起关闭请求，则： 第一次挥手：客户端发送连接释放报文段（FIN = 1，seq = u（前面已传送数据的最后","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#udp"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 例如以太网是 IEEE 802.3 标准, wifi 是 IEEE 802.11 标准. Wi-Fi 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段长度 MSS、窗口扩大、时间戳、选择确认…… TCP 建立连接 刚开始客户端处于 closed 状态，服务端处于 listen 状态 **第一次握手：**客户端发送连接请求报文段（SYN = 1，seq = x（随机）），无应用层数据。此时客户端处于 SYN_Send （同步发送）状态 **第二次握手：**服务端收到客户端的连接请求报文后，为该 TCP 连接分配缓存和变量，并向客户端返回确认报文（SYN = 1，ACK = 1，seq = y（随机），ack = x + 1），允许连接，无应用层数据。此时服务端处于 SYN_REVD（同步接收）状态 第三次握手：客户端收到连接请求报文后，会发送一个对确认的确认报文（ACK = 1，seq = x + 1，ack = y + 1），可以携带数据。此时客户端处于 established 状态 服务器收到确认报文后，也会处于 established 状态。此时，双方建立了连接. SYN 哄泛攻击: 攻击者发送握手第一个包 服务器响应后, 处于半连接. 发送消耗资源, 挂起消耗资源 服务器收不到响应, 重复发送, 持续消耗资源 短时间内服务器大量等待, 会崩掉 TCP 连接释放 刚开始双方都处于 established 状态，假如是客户端先发起关闭请求，则： 第一次挥手：客户端发送连接释放报文段（FIN = 1，seq = u（前面已传送数据的最后","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#tcp"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 例如以太网是 IEEE 802.3 标准, wifi 是 IEEE 802.11 标准. Wi-Fi 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段长度 MSS、窗口扩大、时间戳、选择确认…… TCP 建立连接 刚开始客户端处于 closed 状态，服务端处于 listen 状态 **第一次握手：**客户端发送连接请求报文段（SYN = 1，seq = x（随机）），无应用层数据。此时客户端处于 SYN_Send （同步发送）状态 **第二次握手：**服务端收到客户端的连接请求报文后，为该 TCP 连接分配缓存和变量，并向客户端返回确认报文（SYN = 1，ACK = 1，seq = y（随机），ack = x + 1），允许连接，无应用层数据。此时服务端处于 SYN_REVD（同步接收）状态 第三次握手：客户端收到连接请求报文后，会发送一个对确认的确认报文（ACK = 1，seq = x + 1，ack = y + 1），可以携带数据。此时客户端处于 established 状态 服务器收到确认报文后，也会处于 established 状态。此时，双方建立了连接. SYN 哄泛攻击: 攻击者发送握手第一个包 服务器响应后, 处于半连接. 发送消耗资源, 挂起消耗资源 服务器收不到响应, 重复发送, 持续消耗资源 短时间内服务器大量等待, 会崩掉 TCP 连接释放 刚开始双方都处于 established 状态，假如是客户端先发起关闭请求，则： 第一次挥手：客户端发送连接释放报文段（FIN = 1，seq = u（前面已传送数据的最后","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#tcp-的头部格式"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 例如以太网是 IEEE 802.3 标准, wifi 是 IEEE 802.11 标准. Wi-Fi 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段长度 MSS、窗口扩大、时间戳、选择确认…… TCP 建立连接 刚开始客户端处于 closed 状态，服务端处于 listen 状态 **第一次握手：**客户端发送连接请求报文段（SYN = 1，seq = x（随机）），无应用层数据。此时客户端处于 SYN_Send （同步发送）状态 **第二次握手：**服务端收到客户端的连接请求报文后，为该 TCP 连接分配缓存和变量，并向客户端返回确认报文（SYN = 1，ACK = 1，seq = y（随机），ack = x + 1），允许连接，无应用层数据。此时服务端处于 SYN_REVD（同步接收）状态 第三次握手：客户端收到连接请求报文后，会发送一个对确认的确认报文（ACK = 1，seq = x + 1，ack = y + 1），可以携带数据。此时客户端处于 established 状态 服务器收到确认报文后，也会处于 established 状态。此时，双方建立了连接. SYN 哄泛攻击: 攻击者发送握手第一个包 服务器响应后, 处于半连接. 发送消耗资源, 挂起消耗资源 服务器收不到响应, 重复发送, 持续消耗资源 短时间内服务器大量等待, 会崩掉 TCP 连接释放 刚开始双方都处于 established 状态，假如是客户端先发起关闭请求，则： 第一次挥手：客户端发送连接释放报文段（FIN = 1，seq = u（前面已传送数据的最后","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#tcp-建立连接"},{"categories":["blog"],"content":" 数据包详解 数据包示意图 数据链路层 帧 frame帧首部和尾部的大小并不一定. 例如以太网是 IEEE 802.3 标准, wifi 是 IEEE 802.11 标准. Wi-Fi 的帧结构在设计上考虑了无线信道特性、多跳传输、移动性以及安全性等因素，以适应无线局域网环境中的需求。 帧类型字段： Wi-Fi 帧中包含一个帧类型字段，用于指示该帧的类型。帧类型字段可以表示数据帧、控制帧或管理帧。这有助于 Wi-Fi 设备在接收到帧时正确处理和解释其目的和功能。 MAC 地址格式： 以太网使用 6 字节的 MAC 地址来唯一标识网络设备，而 Wi-Fi 引入了扩展的 MAC 地址格式。Wi-Fi 的帧首部包含 4 字节的接收者 MAC 地址和 4 字节的发送者 MAC 地址。这样的设计支持更复杂的无线网络拓扑，例如多跳传输和移动设备的漫游。 序列控制字段： Wi-Fi 帧中包含一个序列控制字段，用于维护帧的传输顺序和可靠性。序列控制字段包括分片编号、片段计数和帧序列号等信息，以确保帧在无线信道上传输和组装时的正确顺序。 帧校验序列（FCS）： 以太网帧使用循环冗余校验（CRC）字段来检测帧的传输错误，而 Wi-Fi 帧使用一个更复杂的 FCS 字段来实现错误检测。FCS 字段包含了更强大的校验算法，以提高对无线信道上的干扰和误码的容错能力。 MTUMTU 如果设置太大, 可能被路由器拒绝转发. 太小又会导致效率低. windows 查看 MTU netsh.exe interface ipv4 show subinterfaces linux 查看 MTU ip a 网络层 TCP-IP 协议栈 IP 数据报格式 版本：占 4 位，指 IP 协议的版本。（IPv4/IPv6） 首部长度：占 4 位，单位是 4B，最小为 5（因为首部固定部分 20B，5 * 4B = 20B），最大为 15（15 * 4B = 60B） 区分服务：占 8 位，用来获取更好的服务（如：优先级），但实际上一直没有用过 总长度：占 16 位，首部 + 数据部分的总长度，单位是 1B，因此数据报的总长度为 标识/标志/片偏移是分片专用. IP 数据报分片 生存时间（TTL）：占 8 位，IP 分组的保质期，经过一个路由器就 -1，变为 0 则丢弃 协议：占 8 位，数据部分的协议，即传输层使用的是什么协议 首部检验和：占 16 位，只检验数据报的首部，但不包含数据部分。每经过一个路由器，都会重新计算一下首部检验和。 源地址：占 32 位 目的地址：占 32 位 可选字段：占 0 ~ 40 位，用来支持排错、测量以及安全措施 填充：全 0，把首部长度补成 4B 的整数倍 协议名 ICMP IGMP TCP EGP IGP UDP IPv6 ESP OSPF 字段值 1 2 6 8 9 17 41 50 89 IP 数据报分片由于 MTU 最大 1500 的限制, 如果发送大于 1500-20 (ip 头部最小为 20 byte)=1480 的数据, 就需要分片. 标识：占 16 位，同一数据报的分片使用同一标识 标志：占 3 位，只有两位有意义 x _ _ 中间位 DF（Don’t Fragment） DF = 1，禁止分片 DF = 0，允许分片 最低位 MF（More Fragment） MF = 1，后面还有分片 MF = 0，代表最后一片 / 没分片 片偏移：指出较长分组分片后，某片在原分组中的相对位置。（以 8B 为单位） 除了最后一片，每个分片长度一定是 8B 的整数倍 假设我要发送 3800 byte 的数据,tcp 头 24 byte,组成的数据包 3824 byte. 最大数据量为 1500-24 = 1476 byte. 要被 8 整除. 所以最大数据量为 1472/8=184 . 3800 / 1472 = 2.58…. = 3 次. 数据 总长度 标识 MF DF 片偏移 原始数据包 3800+24=3824 12345 0 0 0 数据包 1 1472+24=1496 12345 1 0 0 数据包 2 1472+24=1496 12345 1 0 184 数据包 3 856+24=880 12345 0 0 368 私有 IP 地址 CIDR 标识 地址范围 IP 个数 10.0.0.0/8 10.0.0.0~10.255.255.255 16,777,216 172.16.0.0/12 172.16.0.0~172.31.255.255 1,048,576 192.168.0.0/16 192.168.0.0~192.168.255.255 65,536 ARP/RARP 协议 ARP: 通过 ip 获取物理 mac 地址. 发送 arp 广播, 目标机器响应结果. 此协议互信, 所以可以伪造 ARP 响应包, 目标一旦缓存了错误的数据, 目标就会将数据发送给伪造者. RARP: 通过 mac 地址获取 ip 地址. 广播 mac 地址, RARP 服务器检查后, 返回 IP 地址, 不存在则不响应. DHCP 协议DHCP 协议过程： 主机广播 DHCP 发现报文 “有没有 DHCP 服务器呀” 试图找到网络中的服务器，向服务器获得一个 IP 地址 DHCP 服务器广播 DHCP 提供报文 “有！有！有！” 服务器拟分配给主机一个 IP 地址及相关配置，先到先得 主机广播 DHCP 请求报文 “我用你给我的 IP 地址啦？” 主机向服务器请求提供 IP 地址 DHCP 服务器广播 DHCP 确认报文 “用吧！” 正式将 IP 地址分配给主机 ICMP 协议 Ping 测试连通性. 发送数据包, 通常远端会返回响应. 但防火墙之类的也可以不响应. Tracertoute 跟踪数据包流转的路径. 每次经过节点都会 ttl-1 .同时如果为 0, 当前节点就会返回响应. 所以可以不断尝试, 拿到路由路径. 传输层 UDP UDP 是无连接的，减少开销和发送数据之间的时延 UDP 使用最大努力交付，即不保证可靠交付 UDP 是面向报文的，适合一次性传输少量数据的网络应用. 对于应用层交付的报文，直接原封不动的封装到 UDP 数据报的数据部分，即一次发一个完整的报文 UDP 无拥塞控制，适合很多实时应用. 例如直播 UDP 首部开销很小，8 byte，TCP 需要 20 byte UDP 的头部格式 TCP TCP 的头部格式 **序号（seq）：**在一个 TCP 连接中传送的字节流中的每一个字节都按序编号，本字段表示本报文段所发送数据的第一个字节的序号 **确认号（ack）：**期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，则证明到序号 N - 1 为止的所有数据都已正确收到 **数据偏移（首部长度）：**TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位，即 1 个数值是 4B **紧急位 URG：**URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队，配合紧急指针字段使用 **确认位 ACK：**ACK = 1 时确认号有效，在连接建立之后所有传送的报文段都必须把 ACK 置为 1 **推送位 PSH：**PSH = 1 时，接收方尽快交付接受应用程序，不再等到缓存填满再向上交付（和紧急位是对应的，紧急位是发送发优先发送，推送位是接收方优先向上交付） 复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输连接 同步位 SYN：SYN = 1 时，表明是一个连接请求/连接接收报文 **终止位 FIN：**FIN = 1 时，表明此报文段发送方数据已发送完，要求释放连接 **窗口：**指发送本报文段的一方的接收窗口，即现在允许对方发送的数据量 **检验和：**检验首部 + 数据，检验时要加上 12B 伪首部，伪首部第四个字段是 6 **紧急指针：**URG = 1 时才有意义，指出本报文段中紧急数据的字节数 **选项：**最大报文段长度 MSS、窗口扩大、时间戳、选择确认…… TCP 建立连接 刚开始客户端处于 closed 状态，服务端处于 listen 状态 **第一次握手：**客户端发送连接请求报文段（SYN = 1，seq = x（随机）），无应用层数据。此时客户端处于 SYN_Send （同步发送）状态 **第二次握手：**服务端收到客户端的连接请求报文后，为该 TCP 连接分配缓存和变量，并向客户端返回确认报文（SYN = 1，ACK = 1，seq = y（随机），ack = x + 1），允许连接，无应用层数据。此时服务端处于 SYN_REVD（同步接收）状态 第三次握手：客户端收到连接请求报文后，会发送一个对确认的确认报文（ACK = 1，seq = x + 1，ack = y + 1），可以携带数据。此时客户端处于 established 状态 服务器收到确认报文后，也会处于 established 状态。此时，双方建立了连接. SYN 哄泛攻击: 攻击者发送握手第一个包 服务器响应后, 处于半连接. 发送消耗资源, 挂起消耗资源 服务器收不到响应, 重复发送, 持续消耗资源 短时间内服务器大量等待, 会崩掉 TCP 连接释放 刚开始双方都处于 established 状态，假如是客户端先发起关闭请求，则： 第一次挥手：客户端发送连接释放报文段（FIN = 1，seq = u（前面已传送数据的最后","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:2:4","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#tcp-连接释放"},{"categories":["blog"],"content":" FAQ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:3:0","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#faq"},{"categories":["blog"],"content":" TCP segment 段和 package 包在 TCP（传输控制协议）中，“Segment size”（段大小）和 “Packet”（包）是两个不同但相关的概念。 “Segment size” 指的是 TCP 协议中数据传输时每个 TCP 段（segment）的最大大小。TCP 使用分段（segmentation）将应用程序发送的数据划分为较小的片段进行传输。这些片段被称为 TCP 段，每个段都包含一个 TCP 头部和有效载荷（数据）。段的大小由操作系统或网络堆栈的配置参数确定，并且可以根据网络条件进行调整。通常情况下，段的大小在几百字节到几千字节之间。 而 “Packet”（包）是在网络层（如互联网协议 IP）上进行数据传输时使用的单位。包是由网络层负责封装和传递的，其中包括源地址、目标地址和有效载荷（即从传输层接收到的 TCP 段）。包的大小由网络层协议定义，例如在 IPv4 中，包的最大大小为 64KB。 区别： 概念层次不同：TCP 段是在传输层协议 TCP 中定义的，而包是在网络层协议（如 IP）中定义的。 功能不同：TCP 段负责将数据从应用程序发送到接收方的 TCP 协议栈，而包在网络中进行路由和传递，确保数据的正确交付。 大小限制不同：TCP 段的大小受到 TCP 协议栈的配置参数限制，而包的大小由网络层协议定义。 联系： 在传输过程中，应用程序发送的数据会被 TCP 协议分割成多个段（segment），每个段都会被封装为一个网络层的包（packet）进行传输。这两个概念都是为了实现可靠的数据传输和网络通信而存在的。 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:3:1","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#tcp-segment-段和-package-包"},{"categories":["blog"],"content":" 参考资料 计算机网络 - Computer Network ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/:4:0","series":null,"tags":["blog","网络知识"],"title":"网络知识","uri":"/posts/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/#参考资料"},{"categories":["blog"],"content":"这里记录一些文档的格式, 有时候写文档不知道还要写一些什么方面, 维度信息. 可以做一个参考.","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/","series":null,"tags":["blog","文档助手"],"title":"文档助手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/"},{"categories":["blog"],"content":" 简介这里记录一些文档的格式, 有时候写文档不知道还要写一些什么方面, 维度信息. 可以做一个参考. ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/:1:0","series":null,"tags":["blog","文档助手"],"title":"文档助手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/#简介"},{"categories":["blog"],"content":" 内容","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/:2:0","series":null,"tags":["blog","文档助手"],"title":"文档助手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/#内容"},{"categories":["blog"],"content":" 调研 - 主干 背景、问题 整理分析、目的 介绍、概览（图标）、对比（表格） 细节 概念统一、规范 示例（代码） 参考信息（链接） ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/:2:1","series":null,"tags":["blog","文档助手"],"title":"文档助手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/#调研---主干"},{"categories":["blog"],"content":" 计划任务 - 5w2h why- 为什么做 what- 做什么 when- 何时 where- 何地 who- 谁来做 how to- 如何做 how much- 做到什么程度 ","date":"2023-07-06","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/:2:2","series":null,"tags":["blog","文档助手"],"title":"文档助手","uri":"/posts/%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B/#计划任务---5w2h"},{"categories":["point"],"content":"mssql 是一个关系型数据库, 类似与 mysql, oracle. 要点: 收费 微软家的, 大厂支持 性能强 ","date":"2023-07-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/mssql/:0:0","series":null,"tags":["point","mssql"],"title":"mssql","uri":"/posts/%E7%AC%94%E8%AE%B0/point/mssql/#"},{"categories":["blog"],"content":"这里记录 [[笔记/point/mssql|mssql]] 的常用命令和配置.","date":"2023-07-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/","series":null,"tags":["blog","mssql","docker"],"title":"mssql的配置和使用","uri":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["blog"],"content":" 简介这里记录 mssql 的常用命令和配置. ","date":"2023-07-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/:1:0","series":null,"tags":["blog","mssql","docker"],"title":"mssql的配置和使用","uri":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/#简介"},{"categories":["blog"],"content":" 操作手册","date":"2023-07-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/:2:0","series":null,"tags":["blog","mssql","docker"],"title":"mssql的配置和使用","uri":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/#操作手册"},{"categories":["blog"],"content":" docker 启动 # ACCEPT_EULA=Y 接收用户协议 # SA_PASSWORD 密码 # MSSQL_PID 指定版本,默认 -e 'MSSQL_PID=Developer' # 版本参考 https://learn.microsoft.com/zh-cn/sql/sql-server/editions-and-components-of-sql-server-2019?view=sql-server-ver16 docker run -e 'ACCEPT_EULA=Y' -e 'MSSQL_SA_PASSWORD=123456' -p 1433:1433 -v /data/msdata:/var/opt/mssql/data -v /data/mslog:/var/opt/mssql/log -v /data/secrets:/var/opt/mssql/secrets -d --name mssql mcr.microsoft.com/mssql/server:latest ","date":"2023-07-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/:2:1","series":null,"tags":["blog","mssql","docker"],"title":"mssql的配置和使用","uri":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/#docker-启动"},{"categories":["blog"],"content":" sql 语法 # 日期转字符串 CONVERT(CHAR(8), CURRENT_TIMESTAMP, 112) ---20060222 CONVERT(CHAR(19), CURRENT_TIMESTAMP, 120) ---2006-02-22 16:26:08 CONVERT(CHAR(10), CURRENT_TIMESTAMP, 23) ---2006-02-22 # 字符串转日期 cast('2013-03-01' as datetime) cast('20130301' as datetime) ","date":"2023-07-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/:2:2","series":null,"tags":["blog","mssql","docker"],"title":"mssql的配置和使用","uri":"/posts/%E7%AC%94%E8%AE%B0/mssql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/#sql-语法"},{"categories":["point"],"content":"mysql 是一个关系型数据库, 类似与 mssql, oracle. 要点: 免费使用 用户量非常多 ","date":"2023-07-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/mysql/:0:0","series":null,"tags":["point","mysql"],"title":"mysql","uri":"/posts/%E7%AC%94%E8%AE%B0/point/mysql/#"},{"categories":["blog"],"content":"有时候会自建 mysql [[笔记/point/mysql|mysql]] 测试配置. 所以记录一下配置和操作.","date":"2023-07-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/","series":null,"tags":["blog","mysql","docker"],"title":"mysql配置和优化","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/"},{"categories":["blog"],"content":" 简介有时候会自建 mysql 测试配置. 所以记录一下配置和操作. ","date":"2023-07-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/:1:0","series":null,"tags":["blog","mysql","docker"],"title":"mysql配置和优化","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/#简介"},{"categories":["blog"],"content":" 操作","date":"2023-07-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/:2:0","series":null,"tags":["blog","mysql","docker"],"title":"mysql配置和优化","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/#操作"},{"categories":["blog"],"content":" sql 命令 # 创建用户 CREATE USER 'ttt'@'%' IDENTIFIED BY '123456'; grant all privileges on *.* to 'ttt'@'%'; # 授权 GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER,INDEX,TRIGGER,CREATE VIEW,SHOW VIEW ON `db`.`table` TO 'ttt'@'%'; # 改密码 ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456'; FLUSH PRIVILEGES; ","date":"2023-07-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/:2:1","series":null,"tags":["blog","mysql","docker"],"title":"mysql配置和优化","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/#sql-命令"},{"categories":["blog"],"content":" docker 启动 # 名称ken-mysql # 数据在本地/data/mysql-data # 密码123 docker run --name ken-mysql -v /data/mysql-data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123 -p3306:3306 -d mysql:latest ","date":"2023-07-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/:2:2","series":null,"tags":["blog","mysql","docker"],"title":"mysql配置和优化","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/#docker-启动"},{"categories":["blog"],"content":" 配置","date":"2023-07-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/:3:0","series":null,"tags":["blog","mysql","docker"],"title":"mysql配置和优化","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/#配置"},{"categories":["blog"],"content":" 最大连接数 # 配置最大连接数 show variables like '%max_connection%'; set global max_connections=1000; # 配置文件 [mysqld] max_connections = 1000 ","date":"2023-07-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/:3:1","series":null,"tags":["blog","mysql","docker"],"title":"mysql配置和优化","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/#最大连接数"},{"categories":["blog"],"content":" 慢 sql # 先配置保存的位置 # 如果是写入到file，那么就不会输出到表 show variables like \"%log_output%\"; set global log_output = file; set global log_output = \"TABLE\"; # 慢日志的地址 show variables like '%slow_query_log%' # 查看慢查询的定义 show global variables like 'long_query_time'; # 改成1秒就算慢查询 set global long_query_time=1 # 开启log show variables like \"general_log%\"; set global general_log = 'ON'; # 非常占用性能，测试完就关闭 SET GLOBAL general_log = 'OFF'; # 输出到表的话，就查这里 select * from mysql.slow_log; # 转换blob为text select CONVERT( `sql_text` USING utf8) from mysql.slow_log; # 配置文件 [mysqld] log_output = TABLE long_query_time = 1 general_log = ON ","date":"2023-07-05","objectID":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/:3:2","series":null,"tags":["blog","mysql","docker"],"title":"mysql配置和优化","uri":"/posts/%E7%AC%94%E8%AE%B0/mysql%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/#慢-sql"},{"categories":["point"],"content":"java 是一种非常流行的编程语言, 基于 JVM 虚拟机. 要点: 开源, 社区庞大 性能不错 吃资源 ","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/java/:0:0","series":null,"tags":["point","java"],"title":"java","uri":"/posts/%E7%AC%94%E8%AE%B0/point/java/#"},{"categories":["blog"],"content":"我不怎么写 [[笔记/point/java|java]] 代码, 但是国内一般都是 java 后台, 所以记录一些配置和操作, 方便复用.","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/","series":null,"tags":["blog","JVM"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/"},{"categories":["blog"],"content":" 简介我不怎么写 java 代码, 但是国内一般都是 java 后台, 所以记录一些配置和操作, 方便复用. ","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:1:0","series":null,"tags":["blog","JVM"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#简介"},{"categories":["blog"],"content":" JVM 启动参数","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:2:0","series":null,"tags":["blog","JVM"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#jvm-启动参数"},{"categories":["blog"],"content":" JVM 内存配置可以理解成 java运行内存 = 堆内存 + 元空间 + 非堆内存. 堆内存：通过参数设置 元空间：通过参数设置 非堆内存：线程数 *1m + non-heap 线程数：pstree pid 常用内存参数 -Xms2048m 初始堆大小 -Xmx2048m 最大堆大小 (建议一致，避免伸缩带来的性能影响) -Xmn500m 新生代，可以不设置 -Xss1024k 线程的栈大小，默认 1m。线程数 * 这个值是内存一部分 -XX:MaxMetaspaceSize=256m 最大元数据空间大小 -XX:+UseContainerSupport 使用容器内存,JDK 8u191+、JDK 10 及以上版本 -XX:InitialRAMPercentage=70.0 初始内存百分比 -XX:MaxRAMPercentage=70.0 最大内存百分比 ","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:2:1","series":null,"tags":["blog","JVM"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#jvm-内存配置"},{"categories":["blog"],"content":" JVM 其他配置 gc配置 不同的 jvm 版本用不同的 gc 回收. 例如 java8 用 ParallelGC 或者 CMS java8的gc优化, java 11 用 g1, java 17 用 zgc.所以参数也都不一样. 除非根据监控确定了问题, 明确了解决方案, 否则用默认的吧. -XX:-OmitStackTraceInFastThrow 一些 jvm 会优化异常抛出, 但缺少 message 和 stack trace, 所以关闭. -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=6666 远程 debug 连接到 6666 端口. 启用 suspend 是说是否阻塞直到被连接. 除非是 debug 应用启动过程的代码, 否则配置成 n. ","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:2:2","series":null,"tags":["blog","JVM"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#jvm-其他配置"},{"categories":["blog"],"content":" 推荐使用 -XX:+UseContainerSupport -XX:InitialRAMPercentage=70.0 -XX:MaxRAMPercentage=70.0 -XX:-OmitStackTraceInFastThrow -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=6666 ","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:2:3","series":null,"tags":["blog","JVM"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#推荐使用"},{"categories":["blog"],"content":" 命令","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:3:0","series":null,"tags":["blog","JVM"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#命令"},{"categories":["blog"],"content":" Maven 构建 # clean install 清理以前的文件,解决很多问题 # -T 4 4个线程构建 # -T 1C 每个cpu核心1个线程 # 跳过了测试和,不生成javadoc文件 mvn -T 1C clean install -Dmaven.test.skip -Dmaven.javadoc.skip=true ","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:3:1","series":null,"tags":["blog","JVM"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#maven-构建"},{"categories":["blog"],"content":" 内存 dump jmap -dump:format=b,file=/tmp/20210107mem.hprof 30699pid ","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:3:2","series":null,"tags":["blog","JVM"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#内存-dump"},{"categories":["blog"],"content":" 反编译 jar 包下载 jar 包 Releases · java-decompiler/jd-gui,然后 java -jar jd-gui.1.6.6.jar ","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:3:3","series":null,"tags":["blog","JVM"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#反编译-jar-包"},{"categories":["blog"],"content":" 代码配置 如何为SpringBoot应用设置健康检查_Serverless 应用引擎-阿里云帮助中心 ","date":"2023-07-04","objectID":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/:4:0","series":null,"tags":["blog","JVM"],"title":"java配置和操作","uri":"/posts/%E7%AC%94%E8%AE%B0/java%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#代码配置"},{"categories":["blog"],"content":" 简介这里记录一下 supervisor 的常用配置, 方便复用. ","date":"2023-07-03","objectID":"/posts/%E7%AC%94%E8%AE%B0/supervisor%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","supervisor"],"title":"supervisor配置","uri":"/posts/%E7%AC%94%E8%AE%B0/supervisor%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 操作手册安装和基础配置 # 安装 apt install supervisor -y # 加入2个参数,minfds最大文件数,minprocs最大进程数 vim /etc/supervisor/conf.d/supervisord.conf [supervisord] minfds=81920 minprocs=81920 systemctl enable supervisor systemctl start supervisor 编辑配置文件 vim /etc/supervisor/conf.d/demo.conf [program:demo] environment=VAR1=\"value1\",VAR2=\"value2\" directory = /root/app_dir command = /xxx/java -jar app.jar # 启动进程数目默认为1 numprocs = 1 # 如果supervisord是root启动的 设置此用户可以管理该program user = root # 程序运行的优先级 默认999 priority = 996 # 随着supervisord 自启动 autostart = true # 子进程挂掉后无条件自动重启 autorestart = true # 子进程启动多少秒之后 状态为running 表示运行成功 startsecs = 20 # 进程启动失败 最大尝试次数 超过将把状态置为FAIL startretries = 3 # 标准输出的文件路径 stdout_logfile = /tmp/demo-supervisor.log # 日志文件最大大小 stdout_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stdout_logfile_backups = 3 # 错误输出的文件路径 stderr_logfile = /tmp/demo-supervisor.log # 日志文件最大大小 stderr_logfile_maxbytes=20MB # 日志文件保持数量 默认为10 设置为0 表示不限制 stderr_logfile_backups = 3 ","date":"2023-07-03","objectID":"/posts/%E7%AC%94%E8%AE%B0/supervisor%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","supervisor"],"title":"supervisor配置","uri":"/posts/%E7%AC%94%E8%AE%B0/supervisor%E9%85%8D%E7%BD%AE/#操作手册"},{"categories":["journal"],"content":"2023-07-01 日记","date":"2023-07-01","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-01/","series":null,"tags":["journal"],"title":"2023-07-01","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-01/"},{"categories":["journal"],"content":" Linux 初始化笔记? 引入 linux 相关文章 #todo/笔记 容器后 websocket 长连接中断问题.原因：部分原因 localhost，前端和后端之间的连接采用的是长连接。而在容器销毁和扩容的过程中就会断开连接，造成无法保持长连接的问题。解决: 后端每次容器销毁前，让 Header 部分返回 Connection:close,通知客户端处理完当前的请求后关闭连接，新的请求需要重新建立 TCP 连接。腾讯云容器团队的参考链接 #todo/笔记 ansible #todo/笔记 不要憎恨你的敌人, 这会影响你的判断力. #有意思的句子 ","date":"2023-07-01","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-07-01/:0:0","series":null,"tags":["journal"],"title":"2023-07-01","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-07-01/#"},{"categories":["point"],"content":"ansible 是一个远程管理工具. 要点: 开源, 用户量大 基于 ssh, 所以不需要在被控端安装 agent. ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/ansible/:0:0","series":null,"tags":["point","ansible"],"title":"ansible","uri":"/posts/%E7%AC%94%E8%AE%B0/point/ansible/#"},{"categories":["blog"],"content":"[[笔记/point/ansible|ansible]] 的使用记录, 用到的时候能快速重新捡起来..","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/","series":null,"tags":["blog"],"title":"ansible入门教程","uri":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["blog"],"content":" 简介ansible 的使用记录, 用到的时候能快速重新捡起来.. ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["blog"],"title":"ansible入门教程","uri":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/#简介"},{"categories":["blog"],"content":" 安装配置 安装 apt install ansible sshpass -y 配置主机 vim /etc/ansible/hosts # test组有一台机器,并配置了ssh连接信息 [test] sh-ecs01 ansible_ssh_host=test.kentxxq.com ansible_ssh_user=\"root\" ansible_ssh_pass=\"123456\" ansible_ssh_port=22 vim /etc/ansible/ansible.cfg [defaults] host_key_checking = False #不检测host key ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["blog"],"title":"ansible入门教程","uri":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/#安装配置"},{"categories":["blog"],"content":" 日常操作简单执行命令 ansible test -m shell -a \"ls\" 使用 ansible-playbook playbook.yml 执行脚本, 下面是脚本文件 --- - name: Install remote facts hosts: test vars: test_dir: /tmp/test_dir test_file: /tmp/test.txt # 禁用收集信息，可以加快脚本执行 # gather_facts: false tasks: - name: 先ping一下 ping: - name: echo输出 command: echo 1 - name: 准备工作-创建测试目录 \"{{ test_dir }}\" file: path: \"{{ test_dir }}\" state: directory owner: \"root\" group: \"root\" mode: 0755 # 输出ansible默认采集到的信息 #- name: debug输出ansible默认收集的变量 # debug: # var: ansible_facts - name: 计算剩余内存百分比 debug: msg: \"{{ ansible_facts.memory_mb.nocache.free / ansible_facts.memtotal_mb * 100 }}\" register: memory_usage_percent - name: 拿到register变量 debug: msg: \"{{ memory_usage_percent.msg }}\" - name: 再register一个远程输出 shell: hostname register: hostname_info - name: 拿到hostname_info变量 debug: msg: \"{{ hostname_info.stdout }}\" - name: 创建本地文件 copy: content: \"123\" dest: \"{{ test_file }}\" delegate_to: localhost - name: 传送文件 copy: src: \"{{ test_file }}\" dest: \"{{ test_file }}\" - name: 本地执行命令 local_action: command tar -zcvf /tmp/tmp.tgz /tmp/test.txt # 压缩和解压 - name: \"拷贝代码去到对应目录\" unarchive: src: \"/tmp/tmp.tgz\" dest: \"{{ test_dir }}\" owner: \"root\" group: \"root\" extra_opts: - --strip-components= 1 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["blog"],"title":"ansible入门教程","uri":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/#日常操作"},{"categories":["blog"],"content":" Role 方案","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["blog"],"title":"ansible入门教程","uri":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/#role-方案"},{"categories":["blog"],"content":" 目录结构 root@poc:~/ansible-role# tree . ├── \\ ├── deploy_java_role.yml # 入口文件 ├── inventory │ └── test-hosts # 主机文件 └── roles └── deploy_java_role ├── tasks │ ├── depoly-task.yml # 部署任务 │ ├── init-app-task.yml # 初始化app环境 │ ├── init-system-task.yml # 初始化系统环境 │ ├── main.yml # 主入口 │ └── vars-task.yml # 获取环境变量 ├── templates │ └── supervisor_conf_template.j2 # 模板文件 └── vars └── main.yml # 静态环境变量 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["blog"],"title":"ansible入门教程","uri":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/#目录结构"},{"categories":["blog"],"content":" 调用方法 # 部署到了 deploy-task 阶段会报错,因为并没有 java 包,也没有 jenkins. 但是思路是一致的. 从本地 copy 构建物到目标机器. # 指定role文件,-i指定hosts文件,然后外部传入参数 ansible-playbook deploy_java_role.yml \\ -i inventory/test-hosts \\ --extra-vars \"ip_list=demo_test1\" \\ --extra-vars \"java_params='-Xms256m -Xmx256m'\" \\ --extra-vars \"module_name=name\" \\ --extra-vars \"init=1\" ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["blog"],"title":"ansible入门教程","uri":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/#调用方法"},{"categories":["blog"],"content":" 文件内容 # role入口文件 # deploy_java_role.yml --- - hosts: \"{{ ip_list }}\" remote_user: root roles: - role: deploy_java_role serial: 1 max_fail_percentage: 0 # 主机文件 # inventory/test-hosts [demo_test1] sh-ecs01 ansible_ssh_host=1.1.1.1 ansible_ssh_user=\"root\" ansible_ssh_pass=\"123456\" ansible_ssh_port=22 # 主入口 # roles/deploy_java_role/tasks/main.yml --- - name: 构建环境变量 import_tasks: vars-task.yml - name: 初始化环境 import_tasks: init-system-task.yml when: init == \"1\" - name: 应用所需环境 import_tasks: init-app-task.yml when: init == \"1\" - name: 部署脚本 import_tasks: depoly-task.yml # 获取环境变量 # roles/deploy_java_role/tasks/vars-task.yml - name: 获取workspace变量 debug: msg: \"{{ lookup('env', 'WORKSPACE')}}\" register: JenkinsWorkspace #failed_when: JenkinsWorkspace.msg == '' # 初始化系统环境 # roles/deploy_java_role/tasks/init-system-task.yml - name: 安装Supervisor启动管理程序 package: name: supervisor state: present - name: 开机自启supervisor service: name: supervisor enabled: yes - name: 创建程序运行目录 \"{{ program_dir }}\" file: path: \"{{program_dir}}\" state: directory owner: \"{{ appuser }}\" group: \"{{ appuser }}\" mode: 0755 - name: 创建程序备份目录 \"{{ program_dir_backup }}\" file: path: \"{{ program_dir_backup }}\" state: directory owner: \"{{ appuser }}\" group: \"{{ appuser }}\" mode: 0755 - name: 创建程序运行日志目录 \"{{ program_dir_logs }}\" file: path: \"{{ program_dir_logs }}\" state: directory owner: \"{{ appuser }}\" group: \"{{ appuser }}\" mode: 0755 - name: 创建程序运行临时目录 \"{{ program_dir_tmp }}\" file: path: \"{{ program_dir_tmp }}\" state: directory owner: \"{{ appuser }}\" group: \"{{ appuser }}\" mode: 0755 - name: 启动supervisor service: name: supervisor state: started # 初始化app环境 # roles/deploy_java_role/tasks/init-app-task.yml - name: 判断启动文件 \"{{ module_name }}\".ini是否存在 stat: path: /etc/supervisor/conf.d/{{ module_name }}.conf register: init_file - name: 如果启动文件不存在就拷贝一份启动模板文件 \"{{ module_name }}\".ini 到目标主机 template: src: supervisor_conf_template.j2 dest: /etc/supervisor/conf.d/{{ module_name }}.conf when: init_file.stat.exists == false - name: 更新supervisor shell: supervisorctl update when: init_file.stat.exists == false # 部署任务 # roles/deploy_java_role/tasks/depoly-task.yml - name: \"获取当前时间\" shell: date +%F_%H%M%S register: date_result - name: \"获取{{ module_name }}构建物的名称\" find: paths: - \"{{ JenkinsWorkspace.msg }}/deploy/target\" file_type: file use_regex: yes patterns: \".*{{ module_name }}((?!sources).)*.jar$\" recurse: no register: artcraft delegate_to: localhost - name: \"判断构建物是否存在，不存在则退出\" fail: msg: \"{{ module_name }}.jar is not find\" when: artcraft.matched == 0 - name: \"复制Jenkins构建物{{ module_name }}到对应服务器的指定目录\" copy: src: \"{{ item.path }}\" dest: \"{{ program_dir_tmp }}/{{ module_name }}.jar\" owner: \"{{ appuser }}\" group: \"{{ appuser }}\" mode: \"0644\" force: yes #backup: yes with_items: \"{{ artcraft.files }}\" - name: 注册.部署前.程序运行状况并注册状态 shell: ps -ef | grep {{ module_name }} | grep {{ appuser }} | awk '{print $2}' ignore_errors: True register: artcraft_status - name: 回显并注册当前进程PID信息 debug: var: artcraft_status.stdout_lines[0] verbosity: 0 when: artcraft_status.stdout_lines[1] is defined - name: 提示当前进程没有运行 debug: msg: \"当前用户服务进程没有运行...部署继续...\" when: artcraft_status.stdout_lines[1] is undefined - name: 停止{{ module_name }}对应的服务 command: supervisorctl stop {{ module_name }} when: artcraft_status.stdout_lines[1] is defined register: artcraft_stop_status - name: 回显当前程序状态是否停止成功 debug: var: artcraft_stop_status verbosity: 0 when: artcraft_status.stdout_lines[1] is defined - name: 注册.部署前.最新软件包的地址 shell: ls -lt {{ program_dir_tmp }} | grep {{ module_name }} | head -n 1 |awk '{print $9}' ignore_errors: True register: artcraft_file - name: 回显当前程序artcraft_file信息 debug: var: artcraft_file verbosity: 0 - name: 备份并复制{{ module_name }}的构建物到指定目录 copy: src: \"{{ program_dir_tmp }}/{{ artcraft_file.stdout }}\" dest: \"{{ program_dir }}/{{ appuser }}/{{ module_name }}.jar\" owner: \"{{ appuser }}\" group: \"{{ appuser }}\" mode: \"0644\" backup: yes remote_src: yes - name: 启动{{ module_name }}服务 command: supervisorctl start {{ module_name }} regis","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:4:3","series":null,"tags":["blog"],"title":"ansible入门教程","uri":"/posts/%E7%AC%94%E8%AE%B0/ansible%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/#文件内容"},{"categories":["blog"],"content":"经常要去网上查, 对比一些 dns 的信息. 记录一下, 以后直接用就行了.","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/dns%E5%88%97%E8%A1%A8/","series":null,"tags":["blog","dns"],"title":"dns列表","uri":"/posts/%E7%AC%94%E8%AE%B0/dns%E5%88%97%E8%A1%A8/"},{"categories":["blog"],"content":" 简介经常要去网上查, 对比一些 dns 的信息. 记录一下, 以后直接用就行了. ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/dns%E5%88%97%E8%A1%A8/:1:0","series":null,"tags":["blog","dns"],"title":"dns列表","uri":"/posts/%E7%AC%94%E8%AE%B0/dns%E5%88%97%E8%A1%A8/#简介"},{"categories":["blog"],"content":" dns 的配置收集 ## 阿里云 https://www.alidns.com/ 223.5.5.5、223.6.6.6、2400:3200::1、2400:3200:baba::1 开手动模板 https://dns.alidns.com/dns-query DoH/DoT地址: dns.alidns.com ## 谷歌 https://developers.google.com/speed/public-dns/docs/doh 8.8.8.8 / 8.8.4.4 2001:4860:4860::8888 2001:4860:4860::8844 2001:4860:4860:0:0:0:0:8888 2001:4860:4860:0:0:0:0:8844 开自动模板 https://dns.google/dns-query ## 腾讯 https://www.dnspod.cn/Products/publicdns 很全 119.29.29.29 开手动模板 https://doh.pub/dns-query 支持dot，地址是dot.pub ## cloudflare 1.1.1.1 1.0.0.1 2606:4700:4700::1111 2606:4700:4700::1001 https://cloudflare-dns.com/dns-query ## 欧盟的dns 193.110.81.0 185.253.5.0 严格过滤 193.110.81.9 185.253.5.9 儿童版 193.110.81.1 185.253.5.1 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/dns%E5%88%97%E8%A1%A8/:2:0","series":null,"tags":["blog","dns"],"title":"dns列表","uri":"/posts/%E7%AC%94%E8%AE%B0/dns%E5%88%97%E8%A1%A8/#dns-的配置收集"},{"categories":["blog"],"content":"这里记录我调整过的 [[linux]] 内核参数.","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4/","series":null,"tags":["blog"],"title":"linux内核参数调整","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4/"},{"categories":["blog"],"content":" 简介这里记录我调整过的 linux 内核参数. ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4/:1:0","series":null,"tags":["blog"],"title":"linux内核参数调整","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4/#简介"},{"categories":["blog"],"content":" 内核参数调整内核参数的相关配置: /etc/sysctl.conf : 需要调整的配置文件 sysctl -p: 改了配置后立即生效 sysctl -a: 查看内核参数 类型 参数名称 参数作用 参数说明 进程 fs.file-max 系统所有的进程能打开的最大文件数 (文件描述符) 默认 9223372036854775807 或者更大 进程 fs.nr_open 单个进程可以打开的最大文件数 默认 1048576 或者更大 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4/:2:0","series":null,"tags":["blog"],"title":"linux内核参数调整","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4/#内核参数调整"},{"categories":["blog"],"content":"用 iPhone 拍出来的照片，传到 [[macos|mac]] 上显示结尾是 HEIC 的图片文件。在 markdown 中不支持，同样在 [[hugo]] 的 web 页面里也不支持。所以找了一下方法，发现 automator 这个功能可以一劳永逸的实现。之前一直没有用过。所以记录一下","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/mac-heic%E8%BD%ACjpg%E6%88%96png/","series":null,"tags":["blog","macos"],"title":"mac-HEIC转JPG或PNG","uri":"/posts/%E7%AC%94%E8%AE%B0/mac-heic%E8%BD%ACjpg%E6%88%96png/"},{"categories":["blog"],"content":" 简介用 iPhone 拍出来的照片，传到 macos 上显示结尾是 HEIC 的图片文件。在 markdown 中不支持，同样在 hugo 的 web 页面里也不支持。所以找了一下方法，发现 automator 这个功能可以一劳永逸的实现。之前一直没有用过。所以记录一下 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/mac-heic%E8%BD%ACjpg%E6%88%96png/:1:0","series":null,"tags":["blog","macos"],"title":"mac-HEIC转JPG或PNG","uri":"/posts/%E7%AC%94%E8%AE%B0/mac-heic%E8%BD%ACjpg%E6%88%96png/#简介"},{"categories":["blog"],"content":" 操作手册 Command+Space(空格)，输入 automator,进入后点击新建文稿。 选择快速操作 把左边的步骤拖动到右边，调整后的页面如下 左上角文件 -\u003e存储 -\u003e保存名字 HEIC 转 JPEG 即可 在访达中使用即可 快去看看你的桌面上出现了什么！ ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/mac-heic%E8%BD%ACjpg%E6%88%96png/:2:0","series":null,"tags":["blog","macos"],"title":"mac-HEIC转JPG或PNG","uri":"/posts/%E7%AC%94%E8%AE%B0/mac-heic%E8%BD%ACjpg%E6%88%96png/#操作手册"},{"categories":["point"],"content":"macos 是苹果公司的电脑搭载的操作系统. 因为是苹果 mac 的专属系统, 日常 mac 也代表了 macos. 要点: 苹果专属系统 可以开发 ios 应用 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/macos/:0:0","series":null,"tags":["point","macos"],"title":"macos","uri":"/posts/%E7%AC%94%E8%AE%B0/point/macos/#"},{"categories":["blog"],"content":"这里记录在使用 [[笔记/point/macos|macos]] 过程中遇到的问题.","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"},{"categories":["blog"],"content":" 简介这里记录在使用 macos 过程中遇到的问题. ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:1:0","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#简介"},{"categories":["blog"],"content":" 问题列表","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:2:0","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#问题列表"},{"categories":["blog"],"content":" 显示隐藏文件 # 显示 defaults write com.apple.finder AppleShowAllFiles -bool true # 隐藏 defaults write com.apple.finder AppleShowAllFiles -bool false ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:2:1","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#显示隐藏文件"},{"categories":["blog"],"content":" 启用 ftp mac 下一般用 smb 服务来进行远程文件访问，但要用 FTP 的话，高版本的 mac os 默认关掉了，可以用如下命令打开: # 开启 sudo -s launchctl load -w /System/Library/LaunchDaemons/ftp.plist # 关闭 sudo -s launchctl unload -w /System/Library/LaunchDaemons/ftp.plist ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:2:2","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#启用-ftp"},{"categories":["blog"],"content":" Chrome 无法自动更新 # 这里是删除用户文件夹下面的google还有根目录下面的文件google文件夹，应该是会重新下载新的部分模块。同时也可以正常启用为所有用户更新chrome sudo rm -rf /Library/Google \u0026\u0026 sudo rm -rf ~/Library/Google ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:2:3","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#chrome-无法自动更新"},{"categories":["blog"],"content":" 修改主机名 sudo -scutil --set HostName 'kentxxq’s MacBook Pro' ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:2:4","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#修改主机名"},{"categories":["blog"],"content":" 启用 root # 启用root用户并且创建密码 sudo -i ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:2:5","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#启用-root"},{"categories":["blog"],"content":" 调试安卓或者 iphone 上的网页 开发的时候，电脑上 chrome 没问题，但是手机上访问有问题，那么就需要在手机上调试。 iphone 上调试 safari 开启 safari 上的 web 检查器 连接 mac，然后打开开发者选项 mac 上选中自己 iphone 即可开始调试 android 上调试 chrome brew cask install android-file-transfer 可以帮助你检测到手机 打开手机上的开发者选项，开启 usb 调试 chrome://inspect/#devices 就可以查看到设备，然后点开 手机上访问页面，就可以通过 devtools 调试了 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:2:6","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#调试安卓或者-iphone-上的网页"},{"categories":["blog"],"content":" 调试安卓或者 iphone 上的网页 开发的时候，电脑上 chrome 没问题，但是手机上访问有问题，那么就需要在手机上调试。 iphone 上调试 safari 开启 safari 上的 web 检查器 连接 mac，然后打开开发者选项 mac 上选中自己 iphone 即可开始调试 android 上调试 chrome brew cask install android-file-transfer 可以帮助你检测到手机 打开手机上的开发者选项，开启 usb 调试 chrome://inspect/#devices 就可以查看到设备，然后点开 手机上访问页面，就可以通过 devtools 调试了 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:2:6","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#iphone-上调试-safari"},{"categories":["blog"],"content":" 调试安卓或者 iphone 上的网页 开发的时候，电脑上 chrome 没问题，但是手机上访问有问题，那么就需要在手机上调试。 iphone 上调试 safari 开启 safari 上的 web 检查器 连接 mac，然后打开开发者选项 mac 上选中自己 iphone 即可开始调试 android 上调试 chrome brew cask install android-file-transfer 可以帮助你检测到手机 打开手机上的开发者选项，开启 usb 调试 chrome://inspect/#devices 就可以查看到设备，然后点开 手机上访问页面，就可以通过 devtools 调试了 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:2:6","series":null,"tags":["blog","macos"],"title":"macos问题处理","uri":"/posts/%E7%AC%94%E8%AE%B0/macos%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/#android-上调试-chrome"},{"categories":["point"],"content":"python 是一门非常流行的编程语言. 要点: 生态强大, 特别在 ai 方便 解释执行, 强类型 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/python/:0:0","series":null,"tags":["point","python"],"title":"python","uri":"/posts/%E7%AC%94%E8%AE%B0/point/python/#"},{"categories":["blog"],"content":"推荐使用正版, 但用来学技术也是不错的.","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/","series":null,"tags":["blog","windows"],"title":"windows系统激活","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/"},{"categories":["blog"],"content":" 简介推荐使用正版, 但用来学技术也是不错的. windows 的系统激活方式有以下几种: MSDN 密钥。属于内部的使用，封不封看微软态度。 Retail 零售版密钥。就是你找微软买的，缺点就是要钱呗。 OEM 密钥。电脑厂家出厂预装的系统，然后绑定了你的硬件信息，无法跨机器使用。 VOL 密钥。一般是企业或者学校购买了批量授权。应该分 mak 和 kms 两种，前者永久，后者 180 天需激活一次。 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/:1:0","series":null,"tags":["blog","windows"],"title":"windows系统激活","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/#简介"},{"categories":["blog"],"content":" 操作步骤 如果是新安装的系统，没有 cd-key 输入过，可以直接跳过前面 2 步 #执行,弹出(已成功卸载了产品密钥) slmgr.vbs /upk #执行,弹出(成功的安装了产品密钥) slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX #执行,弹出(密钥管理服务计算机名成功的设置(kms.luody.info) slmgr /skms kms.luody.info #执行,弹出(成功的激活了产品) slmgr /ato ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/:2:0","series":null,"tags":["blog","windows"],"title":"windows系统激活","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/#操作步骤"},{"categories":["blog"],"content":" 自己搭建 docker run -d -p 1688:1688 --name kms --restart=always teddysun/kms # 验证 # 查看服务的版本信息 vlmcs.exe -v kms.luody.info # 查看支持的服务类型 vlmcs.exe -x kms.luody.info 附件/vlmcs.exe Dockerfile 在这里: across/docker/kms/Dockerfile at master · teddysun/across · GitHub 实现在这里: GitHub - Wind4/vlmcsd: KMS Emulator in C (currently runs on Linux including Android, FreeBSD, Solaris, Minix, Mac OS, iOS, Windows with or without Cygwin) ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/:3:0","series":null,"tags":["blog","windows"],"title":"windows系统激活","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/#自己搭建"},{"categories":["blog"],"content":" 可能遇到的问题","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/:4:0","series":null,"tags":["blog","windows"],"title":"windows系统激活","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/#可能遇到的问题"},{"categories":["blog"],"content":" 弹出内部版本 xx 过期我用的是 win10 预览版，一直没有激活。激活了以后，一直弹出内部版本过期。 进入系统更新，升级到最新的版本，之后重启解决 ","date":"2023-07-01","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/:4:1","series":null,"tags":["blog","windows"],"title":"windows系统激活","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB/#弹出内部版本-xx-过期"},{"categories":["point"],"content":"CommonMark 是一种 markdown 的语法规范.因为有很多人的认同, 事实上已经是 markdown 的标准化组织. CommonMark 要点: 各大编程语言都有支持 各种公司的 markdown 拓展都以此为基础 ","date":"2023-06-30","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/commonmark/:0:0","series":null,"tags":["point","CommonMark"],"title":"CommonMark","uri":"/posts/%E7%AC%94%E8%AE%B0/point/commonmark/#"},{"categories":["point"],"content":"linux 是一个开源的系统. 有很多的发行版, 例如 centos, ubuntu. 要点: 免费 服务器默认系统 社区庞大 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/linux/:0:0","series":null,"tags":["point","linux"],"title":"linux","uri":"/posts/%E7%AC%94%E8%AE%B0/point/linux/#"},{"categories":["blog"],"content":"这里记录 [[笔记/point/linux|linux]] 的命令与配置, 通常都是某种情况下的处理方法.","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/"},{"categories":["blog"],"content":" 简介这里记录 linux 的命令与配置, 通常都是某种情况下的处理方法. ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 常用配置","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#常用配置"},{"categories":["blog"],"content":" 免密 sudo vim /etc/sudoers # 找到下面这部分内容 # Allow members of group sudo to execute any command %sudo ALL=(ALL:ALL) ALL kentxxq ALL=(ALL) NOPASSWD: ALL # 加入此行 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#免密-sudo"},{"categories":["blog"],"content":" alias alias vpn='export http_proxy=http://1.1.1.1:7890; export https_proxy=http://1.1.1.1:7890;' alias novpn='unset http_proxy; unset https_proxy;' ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:2","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#alias"},{"categories":["blog"],"content":" 免密 ssh # 生成公钥和秘钥 ssh-keygen -t rsa # 拷贝公钥到远程机器,需要输入密码 ssh-copy-id root@1.1.1.1 # 测试效果 ssh root@1.1.1.1 # 如果目标ip重装过,需要清理本地的拷贝记录 ssh-keygen -R 1.1.1.1 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:3","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#免密-ssh"},{"categories":["blog"],"content":" 允许 root 远程登录 vim /etc/ssh/sshd_config # 把参数值改成yes PermitRootLogin yes # 设置密码 passwd root # 重启ssh服务 systemctl restart ssh ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:4","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#允许-root-远程登录"},{"categories":["blog"],"content":" 安装字体一般来说合同都要使用宋体, simsun # 创建字体文件夹，放入字体文件 mkdir -p /usr/share/fonts/simsun cd /usr/share/fonts/simsun rz sumsun.ttc # 安装字体工具 apt install xfonts-utils fontconfig -y # 字体操作 mkfontscale mkfontdir # 刷新缓存 fc-cache –fv # 字体查询 fc-list :lang=zh ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:5","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#安装字体"},{"categories":["blog"],"content":" 配置 limit vim /etc/security/limits.conf # hard硬限制 不会超过 # soft软限制 告警 # nofile 每个进程可以打开的文件数 root soft nofile 65535 root hard nofile 65535 * soft nofile 65535 * hard nofile 65535 # nproc 操作系统级别对每个用户创建的进程数 root soft nofile 65535 root hard nofile 65535 * soft nofile 65535 * hard nofile 65535 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:6","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#配置-limit"},{"categories":["blog"],"content":" 温度传感器 apt install lm-sensors # 观察模式 watch sensors # 如果不是ubuntu系统 cat /sys/class/thermal/thermal_zone0/temp # 摄氏度 echo $[$(cat /sys/class/thermal/thermal_zone0/temp)/1000]° ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:7","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#温度传感器"},{"categories":["blog"],"content":" 安装 snap-store sudo snap install snap-store ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:8","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#安装-snap-store"},{"categories":["blog"],"content":" wifi 工具 sudo apt install wireless-tools # 查看wifi设备信息 iwconfig ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:9","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#wifi-工具"},{"categories":["blog"],"content":" 关闭防火墙 ufw disable ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:10","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#关闭防火墙"},{"categories":["blog"],"content":" 安装桌面 # 安装一个小工具 sudo apt install tasksel # 看可以装哪些版本 tasksel --list-tasks # 安装桌面套件 sudo tasksel install ubuntu-desktop # 重启生效 reboot ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:11","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#安装桌面"},{"categories":["blog"],"content":" 关闭 selinux # 当前生效 setenforce 0 # 永久生效 vim /etc/selinux/config SELINUX=disabled ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:12","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#关闭-selinux"},{"categories":["blog"],"content":" 定时任务 crontab vim /etc/cron.d/myjob # Example of job definition: # .---------------- minute (0 - 59) # | .------------- hour (0 - 23) # | | .---------- day of month (1 - 31) # | | | .------- month (1 - 12) OR jan,feb,mar,apr ... # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat # | | | | | # * * * * * user-name command to be executed # 凌晨5点和6点清理docker镜像 0 5,6 * * * root /usr/bin/docker rmi $(docker images -q) -f # 每10分钟执行 */10 * * * * * /bin/bash /root/backup.sh ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:13","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#定时任务-crontab"},{"categories":["blog"],"content":" 时间同步 apt install ntp ntpdate -y # 同步时间 ntpdate ntp.aliyun.com 0 * * * * /usr/sbin/ntpdate ntp.aliyun.com # 写入系统 hwclock -w # 查看当前时间和配置 timedatectl # 查询可用的时区 timedatectl list-timezones | grep -i shang # 设置时区 timedatectl set-timezone Asia/Shanghai ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:14","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#时间同步"},{"categories":["blog"],"content":" 配置 locale 中文 # 查看当前shell环境locale locale # 查看系统locale localectl # 查看系统有的字符集 localectl list-locales # 如果有中文字体 localectl set-locale LANG=zh_CN.UTF-8 # 默认英文 localectl set-locale LANG=en_US.UTF-8 # 没有效果? vim /etc/locale.conf LANG=zh_CN.UTF-8 # 搜索所有语言包 apt search language-pack* # 搜索中文包 apt search language-pack-zh* # 建议选用 apt install language-pack-zh-hans -y ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:15","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#配置-locale-中文"},{"categories":["blog"],"content":" 开启 bbrbbr 是一种浪费网络资源，提升网络速度和稳定性的通讯手段。 echo \"net.core.default_qdisc=fq\" \u003e\u003e /etc/sysctl.conf echo \"net.ipv4.tcp_congestion_control=bbr\" \u003e\u003e /etc/sysctl.conf # 生效 sysctl -p # 验证 lsmod | grep bbr ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:16","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#开启-bbr"},{"categories":["blog"],"content":" 登录后的提示信息 vim /etc/motd Welcome to Alibaba Cloud Elastic Compute Service ! ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:17","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#登录后的提示信息"},{"categories":["blog"],"content":" 常见操作","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#常见操作"},{"categories":["blog"],"content":" curl # -X 指定请求方式 大写 # -H 设置请求头，可以多个-H # -d 指定payload的数据 curl -X POST -H \"Accept: application/json\" -H \"Content-type: application/json\" -d '{\"post_data\":\"i_love_immvp.com\"}' localhost:8096/api/answer/checkAnswer # 模拟跨域 curl -vvv 'https://kentxxq.com/Count' -H 'Origin: http://localhost:3000' # 请求es curl -H \"Content-Type: application/json\" -XPUT --user elastic:password es-cn-oew1whnk60023e4s9.elasticsearch.aliyuncs.com:9200/flow_user_index/_settings -d '{\"index.mapping.total_fields.limit\":0}' 结果 {\"acknowledged\":true} ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:1","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#curl"},{"categories":["blog"],"content":" 清除历史记录 # 清除指定id history -d 123 # 清除所有历史记录 history -c ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:2","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#清除历史记录"},{"categories":["blog"],"content":" 压缩/解压 tar # z是使用gzip # v是查看细节 # f是指定文件 # --strip-components=1 去掉一层解压目录 # 打包 tar -czvf dist.tgz dist/ # 解压 tar -xzvf dist.tgz # 解压到指定文件夹 tar Cxzvf /dist dist.tgz # 打包隐藏文件 # 通过 . 可以打包到隐藏文件 tar -czvf dist.tgz /dad/path/. # 通过上级目录来打包 tar -czvf dist.tgz /data/path # 如果是在当前目录，可以手动指定 tar -czvf dist.tgz tar -zcvf dist.tgz .[!.]* * ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:3","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#压缩解压-tar"},{"categories":["blog"],"content":" 配置主机名 hostnamectl set-hostname master1 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:4","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#配置主机名"},{"categories":["blog"],"content":" shell 退出码 # 正常退出 ls EXCODE=$? echo $EXCODE # 0 # 异常错误 ls --- EXCODE=$? echo $EXCODE # 2 # shell脚本 EXCODE=$? if [ \"$EXCODE\" != \"0\" ]; then echo \"有问题！\" exit 1; fi ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:5","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#shell-退出码"},{"categories":["blog"],"content":" 用户, 组, 加入组, 权限 # 创建组dba,组号6001 groupadd -g 6001 dba # 创建用户sam,同时指定主目录 useradd –d /home/sam -m sam # 设置密码 passwd sam #把sam加入dba组 usermod -a -G dba sam # 修改目录拥有者:组 chown -R sam:dba file/folder # 放开权限给所有用户 chmod 777 file/folder ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:6","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#用户-组-加入组-权限"},{"categories":["blog"],"content":" 卸载软件包 # 查看已安装的包 dpkg --list # 查看正则匹配的包 # 查看以dotnet-开头的包 dpkg --list 'dotnet-*' # 卸载匹配的包 sudo apt-get --purge remove \u003cprogramname\u003e # 按照正则卸载匹配的包 # 卸载以dotnet-开头的包 sudo apt-get --purge remove 'dotnet-*' # 如果不想自己手动输入Y确认的话则使用 echo \"Y\" |sudo apt-get --purge remove 'dotnet-*' ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:7","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#卸载软件包"},{"categories":["blog"],"content":" 查看文件 # less 只读超大文件 # 输入F可以滚动输出,刷新当前屏幕,不刷屏.也可以手动输入G,移到底部 # q输出 /搜索 less file.txt # head 文件尾部 head -n 10 file.txt # tail 文件尾部 # tail -f 滚动输出 # 配合 |grep 过滤 tail -f file.txt # 末尾10行 tail -n 10 file.txt ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:8","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#查看文件"},{"categories":["blog"],"content":" 删除 x 天前的文件 find /data/weblog/ -name '*.log.*' -type f -mtime +7 -exec rm -f {} \\; ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:9","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#删除-x-天前的文件"},{"categories":["blog"],"content":" 查看进程启动时间 ps -eo pid,lstart,etime | grep 1310 1310 Sat Aug 10 10:21:25 2019 242-07:26:58 # 前面是启动时间，后面是启动了242天又7小时 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:10","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#查看进程启动时间"},{"categories":["blog"],"content":" 拷贝文件 scp简单高效, 日常使用. # 本地到远程 scp /path/thing root@10.10.10.10:/path/thing # 远程到本地 # -r遍历 # -C压缩 sshpass -p 密码 -o StrictHostKeyChecking=no scp -Cr root@10.10.10.10:/path/folder /path/folder # 使用sshpass免密一条命令 # scp支持所有ssh的参数 # StrictHostKeyChecking 第一次连接会需要输入yes,禁用掉它. # UserKnownHostsFile 这次的配置丢弃掉,表示临时使用.避免安全问题. /usr/bin/sshpass -p 密码 /usr/bin/scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@1.1.1.1:/tmp/t1/1 /tmp/t1/1 rsync通常用于增量传输. # 把1这个文件/文件夹 拷贝到远程的/tmp/t1/下面 # at保持文件信息不变 # VP先是进度 # -z 可以开启压缩 rsync -atvP /tmp/t1/1 root@1.1.1.1:/tmp/t1/ # 也支持sshpass /usr/bin/sshpass -p 密码 rsync -atvP -e \"ssh -o StrictHostKeyChecking=no\" /tmp/t1/1 root@1.1.1.1:/tmp/t1/ ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:11","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#拷贝文件"},{"categories":["blog"],"content":" 拷贝文件 scp简单高效, 日常使用. # 本地到远程 scp /path/thing root@10.10.10.10:/path/thing # 远程到本地 # -r遍历 # -C压缩 sshpass -p 密码 -o StrictHostKeyChecking=no scp -Cr root@10.10.10.10:/path/folder /path/folder # 使用sshpass免密一条命令 # scp支持所有ssh的参数 # StrictHostKeyChecking 第一次连接会需要输入yes,禁用掉它. # UserKnownHostsFile 这次的配置丢弃掉,表示临时使用.避免安全问题. /usr/bin/sshpass -p 密码 /usr/bin/scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@1.1.1.1:/tmp/t1/1 /tmp/t1/1 rsync通常用于增量传输. # 把1这个文件/文件夹 拷贝到远程的/tmp/t1/下面 # at保持文件信息不变 # VP先是进度 # -z 可以开启压缩 rsync -atvP /tmp/t1/1 root@1.1.1.1:/tmp/t1/ # 也支持sshpass /usr/bin/sshpass -p 密码 rsync -atvP -e \"ssh -o StrictHostKeyChecking=no\" /tmp/t1/1 root@1.1.1.1:/tmp/t1/ ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:11","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#scp"},{"categories":["blog"],"content":" 拷贝文件 scp简单高效, 日常使用. # 本地到远程 scp /path/thing root@10.10.10.10:/path/thing # 远程到本地 # -r遍历 # -C压缩 sshpass -p 密码 -o StrictHostKeyChecking=no scp -Cr root@10.10.10.10:/path/folder /path/folder # 使用sshpass免密一条命令 # scp支持所有ssh的参数 # StrictHostKeyChecking 第一次连接会需要输入yes,禁用掉它. # UserKnownHostsFile 这次的配置丢弃掉,表示临时使用.避免安全问题. /usr/bin/sshpass -p 密码 /usr/bin/scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@1.1.1.1:/tmp/t1/1 /tmp/t1/1 rsync通常用于增量传输. # 把1这个文件/文件夹 拷贝到远程的/tmp/t1/下面 # at保持文件信息不变 # VP先是进度 # -z 可以开启压缩 rsync -atvP /tmp/t1/1 root@1.1.1.1:/tmp/t1/ # 也支持sshpass /usr/bin/sshpass -p 密码 rsync -atvP -e \"ssh -o StrictHostKeyChecking=no\" /tmp/t1/1 root@1.1.1.1:/tmp/t1/ ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:11","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#rsync"},{"categories":["blog"],"content":" 清空文件 # 快速清空 \u003efile.txt # 截断任意文件 truncate -s 0 file.txt ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:12","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#清空文件"},{"categories":["blog"],"content":" 筛选替换 # -r遍历 当前目录,筛选所有带有kentxxq的文件 # 替换old-a成new-b sed -i 's/old-a/new-b/g' `grep kentxxq -rl ./` ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:13","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#筛选替换"},{"categories":["blog"],"content":" 系统监控","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:0","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#系统监控"},{"categories":["blog"],"content":" 信息查询 # 系统信息 lsb_release -a LSB Version: :core-4.1-amd64:core-4.1-noarch Distributor ID: CentOS Description: CentOS Linux release 8.0.1905 (Core) Release: 8.0.1905 Codename: Core # cpu信息 cat /proc/cpuinfo # 内存信息,2个16g代表32gb内存,双通道 # 或 cat /proc/meminfo # 或 dmidecode -t memory dmidecode | grep -A16 \"Memory Device\" | grep \"Size\" |sed 's/^[ \\t]*//' # 磁盘信息 fdisk -l # 系统os错误代码查询 perror 24 OS error code 24: Too many open files # 服务器型号 dmidecode | grep 'Product Name' # 主板序列号 dmidecode | grep 'Serial Number' # 系统序列号 dmidecode -s system-serial-number # oem信息 dmidecode -t 11 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:1","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#信息查询"},{"categories":["blog"],"content":" 状态监控 整体概况 top htop 内存 # 查看内存使用状态 free -m # 查看内存变化 vmstat 间隔 监控次数 vmstat 2 2 硬盘 # 磁盘分区等情况 fdisk -l # 硬盘监控 iotop 网络 # 用来进行查看各个网卡的总流量 nload # 用来监控各个进程的流量使用情况 nethogs # 图形化的工具，可以查看具体的端口情况 iptraf-ng # 外部ip连接最多的20条记录 netstat -ant | awk '/^tcp/ {split($5, a, \":\"); count[a[1]]++} END {for (ip in count) print ip \"\\t\" count[ip]}' | sort -nrk2 | head -n 20 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:2","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#状态监控"},{"categories":["blog"],"content":" 状态监控 整体概况 top htop 内存 # 查看内存使用状态 free -m # 查看内存变化 vmstat 间隔 监控次数 vmstat 2 2 硬盘 # 磁盘分区等情况 fdisk -l # 硬盘监控 iotop 网络 # 用来进行查看各个网卡的总流量 nload # 用来监控各个进程的流量使用情况 nethogs # 图形化的工具，可以查看具体的端口情况 iptraf-ng # 外部ip连接最多的20条记录 netstat -ant | awk '/^tcp/ {split($5, a, \":\"); count[a[1]]++} END {for (ip in count) print ip \"\\t\" count[ip]}' | sort -nrk2 | head -n 20 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:2","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#整体概况"},{"categories":["blog"],"content":" 状态监控 整体概况 top htop 内存 # 查看内存使用状态 free -m # 查看内存变化 vmstat 间隔 监控次数 vmstat 2 2 硬盘 # 磁盘分区等情况 fdisk -l # 硬盘监控 iotop 网络 # 用来进行查看各个网卡的总流量 nload # 用来监控各个进程的流量使用情况 nethogs # 图形化的工具，可以查看具体的端口情况 iptraf-ng # 外部ip连接最多的20条记录 netstat -ant | awk '/^tcp/ {split($5, a, \":\"); count[a[1]]++} END {for (ip in count) print ip \"\\t\" count[ip]}' | sort -nrk2 | head -n 20 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:2","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#内存"},{"categories":["blog"],"content":" 状态监控 整体概况 top htop 内存 # 查看内存使用状态 free -m # 查看内存变化 vmstat 间隔 监控次数 vmstat 2 2 硬盘 # 磁盘分区等情况 fdisk -l # 硬盘监控 iotop 网络 # 用来进行查看各个网卡的总流量 nload # 用来监控各个进程的流量使用情况 nethogs # 图形化的工具，可以查看具体的端口情况 iptraf-ng # 外部ip连接最多的20条记录 netstat -ant | awk '/^tcp/ {split($5, a, \":\"); count[a[1]]++} END {for (ip in count) print ip \"\\t\" count[ip]}' | sort -nrk2 | head -n 20 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:2","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#硬盘"},{"categories":["blog"],"content":" 状态监控 整体概况 top htop 内存 # 查看内存使用状态 free -m # 查看内存变化 vmstat 间隔 监控次数 vmstat 2 2 硬盘 # 磁盘分区等情况 fdisk -l # 硬盘监控 iotop 网络 # 用来进行查看各个网卡的总流量 nload # 用来监控各个进程的流量使用情况 nethogs # 图形化的工具，可以查看具体的端口情况 iptraf-ng # 外部ip连接最多的20条记录 netstat -ant | awk '/^tcp/ {split($5, a, \":\"); count[a[1]]++} END {for (ip in count) print ip \"\\t\" count[ip]}' | sort -nrk2 | head -n 20 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:2","series":null,"tags":["blog","linux"],"title":"linux命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#网络"},{"categories":["point"],"content":"vscode 是微软开源的一个文本编辑器, 强大到匹敌 IDE. 要点: 开源免费 插件丰富 社区庞大 跨平台 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/vscode/:0:0","series":null,"tags":["point","vscode"],"title":"vscode","uri":"/posts/%E7%AC%94%E8%AE%B0/point/vscode/#"},{"categories":["point"],"content":"windows 是微软公司开发的操作系统. 要点: 兼容性好 功能最全面 用户最多 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/windows/:0:0","series":null,"tags":["point","windows"],"title":"windows","uri":"/posts/%E7%AC%94%E8%AE%B0/point/windows/#"},{"categories":["blog"],"content":"[[笔记/point/windows|windows]] 现在是我主要使用的桌面平台. 因为我挑选并使用了大量的软件工具, 而且经常会跨多设备工作. 所以这里我记录下来, 也给大家做一个参考.","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/","series":null,"tags":["blog","windows"],"title":"windows的初始化配置","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/"},{"categories":["blog"],"content":" 简介windows 现在是我主要使用的桌面平台. 因为我挑选并使用了大量的软件工具, 而且经常会跨多设备工作. 所以这里我记录下来, 也给大家做一个参考. 与 linux的初始化配置 目的类似. ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","windows"],"title":"windows的初始化配置","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 配置内容 对象 选择 说明 参考 字体 Caskaydia Cove Nerd Font 首先 Cascadia Code 是一个等宽字体, 而 Nerd Font 为其加入了大量图标. GitHub - ryanoasis/nerd-fonts: Iconic font aggregator, collection, \u0026 patcher. 3,600+ icons, 50+ patched fonts: Hack, Source Code Pro, more. Glyph collections: Font Awesome, Material Design Icons, Octicons, \u0026 more ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","windows"],"title":"windows的初始化配置","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/#配置内容"},{"categories":["blog"],"content":" 相关内容 windows系统激活 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["blog","windows"],"title":"windows的初始化配置","uri":"/posts/%E7%AC%94%E8%AE%B0/windows%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/#相关内容"},{"categories":["point"],"content":"wsl 是 windows 下面的 linux 子系统. 方便开发人员在 windows 上使用 linux. 要点: 打通了文件系统 网络互通 支持 linux 图形界面 ","date":"2023-06-29","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/wsl/:0:0","series":null,"tags":["point","wsl"],"title":"wsl","uri":"/posts/%E7%AC%94%E8%AE%B0/point/wsl/#"},{"categories":["point"],"content":"docker 是一个用 golang 编写的容器化工具. 要点: 用户量大, 生态好 常用于软件打包 ","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/docker/:0:0","series":null,"tags":["point","docker"],"title":"docker","uri":"/posts/%E7%AC%94%E8%AE%B0/point/docker/#"},{"categories":["blog"],"content":"起因是国内经常因为网络问题, 无法正常拉取镜像. 需要手动把常用的镜像备份过来 (即使配置了代理源, 因为会请求 dockerhub 的接口, 这里也会导致失败).这里记录一下 [[笔记/point/docker|docker]] 的镜像上传.","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%8A%E4%BC%A0docker%E9%95%9C%E5%83%8F/","series":null,"tags":["blog","docker"],"title":"上传docker镜像","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%8A%E4%BC%A0docker%E9%95%9C%E5%83%8F/"},{"categories":["blog"],"content":" 简介起因是国内经常因为网络问题, 无法正常拉取镜像. 需要手动把常用的镜像备份过来 (即使配置了代理源, 因为会请求 dockerhub 的接口, 这里也会导致失败). 这里记录一下 docker 的镜像上传. ","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%8A%E4%BC%A0docker%E9%95%9C%E5%83%8F/:1:0","series":null,"tags":["blog","docker"],"title":"上传docker镜像","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%8A%E4%BC%A0docker%E9%95%9C%E5%83%8F/#简介"},{"categories":["blog"],"content":" 操作手册 在网络通常的情况下先拉取镜像 docker pull maven:3.6.1-jdk-8 给镜像打 tag docker tag maven:3.6.1-jdk-8 你的镜像仓库地址/命名空间/maven:3.6.1-jdk-8 # 这里拿阿里云的镜像仓库举例 # 镜像仓库命名为msb-images,下面是镜像仓库地址 # msb-images-registry-vpc.cn-zhangjiakou.cr.aliyuncs.com 私网 # msb-images-registry.cn-zhangjiakou.cr.aliyuncs.com 公网 # public 为命名空间 docker tag maven:3.6.1-jdk-8 msb-images-registry-vpc.cn-zhangjiakou.cr.aliyuncs.com/public/maven:3.6.1-jdk-8 登录,推送镜像 # 登录 docker login --username=用户名 -p 密码 msb-images-registry.cn-zhangjiakou.cr.aliyuncs.com # 推送 docker push msb-images-registry-vpc.cn-zhangjiakou.cr.aliyuncs.com/public/maven:3.6.1-jdk-8 ","date":"2023-06-27","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%8A%E4%BC%A0docker%E9%95%9C%E5%83%8F/:2:0","series":null,"tags":["blog","docker"],"title":"上传docker镜像","uri":"/posts/%E7%AC%94%E8%AE%B0/%E4%B8%8A%E4%BC%A0docker%E9%95%9C%E5%83%8F/#操作手册"},{"categories":["point"],"content":"golang 是一个编程语言. 要点如下: 跨平台编译/部署 性能好,内存占用小 静态语言 ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/golang/:0:0","series":null,"tags":["point","golang"],"title":"golang","uri":"/posts/%E7%AC%94%E8%AE%B0/point/golang/#"},{"categories":["blog"],"content":"[[笔记/point/golang|golang]] 用的很少, 记录一下相关的安装, 配置, 构建.","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/","series":null,"tags":["blog","golang"],"title":"golang的使用","uri":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["blog"],"content":" 简介golang 用的很少, 记录一下相关的安装, 配置, 构建. ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/:1:0","series":null,"tags":["blog","golang"],"title":"golang的使用","uri":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/#简介"},{"categories":["blog"],"content":" 操作手册","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/:2:0","series":null,"tags":["blog","golang"],"title":"golang的使用","uri":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/#操作手册"},{"categories":["blog"],"content":" 安装 golang # 去这里下载最新的jar包 # [All releases - The Go Programming Language](https://go.dev/dl/) # 拿 go1.20.5.linux-amd64.tar.gz 举例 # 解压到/usr/local/ tar -C /usr/local/ -xzf go1.20.5.linux-amd64.tar.gz # 文件内容 root@poc:/usr/local/go# ls -l /usr/local/go total 68 drwxr-xr-x 2 root root 4096 Jun 2 01:02 api drwxr-xr-x 2 root root 4096 Jun 2 01:04 bin -rw-r--r-- 1 root root 52 Jun 2 01:01 codereview.cfg -rw-r--r-- 1 root root 1339 Jun 2 01:01 CONTRIBUTING.md drwxr-xr-x 2 root root 4096 Jun 2 01:02 doc drwxr-xr-x 3 root root 4096 Jun 2 01:02 lib -rw-r--r-- 1 root root 1479 Jun 2 01:01 LICENSE drwxr-xr-x 11 root root 4096 Jun 2 01:02 misc -rw-r--r-- 1 root root 1303 Jun 2 01:01 PATENTS drwxr-xr-x 4 root root 4096 Jun 2 01:04 pkg -rw-r--r-- 1 root root 1455 Jun 2 01:01 README.md -rw-r--r-- 1 root root 419 Jun 2 01:01 SECURITY.md drwxr-xr-x 49 root root 4096 Jun 2 01:02 src drwxr-xr-x 26 root root 12288 Jun 2 01:02 test -rw-r--r-- 1 root root 8 Jun 2 01:01 VERSION # 加入 ~/.bashrc,每次生效 export PATH=$PATH:/usr/local/go/bin # 此次终端生效 source ~/.bashrc # 验证效果 go version go version go1.20.5 windows/amd64 ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/:2:1","series":null,"tags":["blog","golang"],"title":"golang的使用","uri":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/#安装-golang"},{"categories":["blog"],"content":" 配置环境变量 # 查看变量 go env # 配置代理 go env -w GOPROXY=https://goproxy.cn,direct # 常用构建配置 # 完整版参考 https://go.dev/doc/install/source#environment $GOOS $GOARCH windows amd64 linux amd64 linux arm64 darwin amd64 darwin amd64 ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/:2:2","series":null,"tags":["blog","golang"],"title":"golang的使用","uri":"/posts/%E7%AC%94%E8%AE%B0/golang%E7%9A%84%E4%BD%BF%E7%94%A8/#配置环境变量"},{"categories":["point"],"content":"hugo 是一个静态网站生成工具, 使用 golang 编写. GitHub - gohugoio/hugo: The world’s fastest framework for building websites. 要点: 速度快 迭代迅速且功能多 ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/hugo/:0:0","series":null,"tags":["point","hugo"],"title":"hugo","uri":"/posts/%E7%AC%94%E8%AE%B0/point/hugo/#"},{"categories":["point"],"content":"MinGW-w64 是一个基于 gcc 的 windows 开发工具集. 让你可以在 windows 上轻松使用 make, gcc 等命令. ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/mingw-w64/:0:0","series":null,"tags":["point","MinGW-w64"],"title":"MinGW-w64","uri":"/posts/%E7%AC%94%E8%AE%B0/point/mingw-w64/#"},{"categories":["point"],"content":"powershell 是一种 shell. 让你使用命令行操作系统. 要点: 跨平台 Windows 上的御用命令行 ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/powershell/:0:0","series":null,"tags":["point","powershell"],"title":"powershell","uri":"/posts/%E7%AC%94%E8%AE%B0/point/powershell/#"},{"categories":["blog"],"content":"这里记录 [[笔记/point/powershell|powershell]] 的常用命令.","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/"},{"categories":["blog"],"content":" 简介这里记录 powershell 的常用命令. ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 操作手册","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#操作手册"},{"categories":["blog"],"content":" 日常操作 # 示例是配置golang,启用cgo编译 # 本地变量 set CGO_ENABLED \"1\" echo $CGO_ENABLED rv CGO_ENABLED # $env 用于访问用户变量和系统变量 echo $env:CGO_ENABLED ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#日常操作"},{"categories":["blog"],"content":" 命令查询 # 查询所有命令 Get-Command # 查询名字包含Process的命令 Get-Command -Name *Process # 查看alias Get-Alias Alias set -\u003e Set-Variable Alias echo -\u003e Write-Output Alias rv -\u003e Remove-Variable Alias ls -\u003e Get-ChildItem Alias cat -\u003e Get-Content Alias cd -\u003e Set-Location Alias clear -\u003e Clear-Host Alias copy -\u003e Copy-Item Alias cp -\u003e Copy-Item Alias mv -\u003e Move-Item ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:2","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#命令查询"},{"categories":["blog"],"content":" 常用配置#todo/笔记 主题配置文件 # 查看配置文件 code $profile # vscode打开 notepad $profile # 记事本打开 # 配置文件的内容 ## 安装oh-my-posh winget install JanDeDobbeleer.OhMyPosh -s winget # 主题配置,主题列表 https://ohmyposh.dev/docs/themes oh-my-posh init pwsh --config \"D:\\OneDrive\\kentxxq\\config\\oh-my-posh\\theme.json\" | Invoke-Expression # vpn命令 function vpn { $Env:http_proxy = \"http://127.0.0.1:7890\"; $Env:https_proxy = \"http://127.0.0.1:7890\"; } function novpn { $Env:http_proxy = \"\"; $Env:https_proxy = \"\"; } # 配合ssh-agent使用 $env:GIT_SSH=\"C:\\Windows\\System32\\OpenSSH\\ssh.exe\" ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:3","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#常用配置"},{"categories":["blog"],"content":" 问题处理 wsl 的网络修复 # 需要管理员权限 netsh winsock reset 接触 powershell 的下载限制 Set-ExecutionPolicy RemoteSigned -Scope CurrentUser ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:4","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#问题处理"},{"categories":["blog"],"content":" 相关资源 官方参考文档 ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["blog","powershell"],"title":"powershell命令与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/powershell%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/#相关资源"},{"categories":["blog"],"content":"快速安装 [[笔记/point/MinGW-w64|MinGW-w64]] 的方法.","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85mingw-w64/","series":null,"tags":["blog"],"title":"安装MinGW-w64","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85mingw-w64/"},{"categories":["blog"],"content":" 简介快速安装 MinGW-w64 的方法. ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85mingw-w64/:1:0","series":null,"tags":["blog"],"title":"安装MinGW-w64","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85mingw-w64/#简介"},{"categories":["blog"],"content":" 操作手册 访问 WinLibs - GCC+MinGW-w64 compiler for Windows 下载 MSVCRT runtime 解压后添加到 系统环境变量 中 测试验证 \u003e gcc --version gcc.exe (MinGW-W64 x86_64-msvcrt-posix-seh, built by Brecht Sanders) 13.1.0 Copyright (C) 2023 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. \u003e make --version GNU Make 3.81 Copyright (C) 2006 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. This program built for i386-pc-mingw32 ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85mingw-w64/:2:0","series":null,"tags":["blog"],"title":"安装MinGW-w64","uri":"/posts/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85mingw-w64/#操作手册"},{"categories":["blog"],"content":"在我决定使用 [[笔记/point/obsidian|obsidian]] 来记录笔记后, 就发现有 `wikilink` 这个东西, 它不是 [CommonMark](https://commonmark.org/) 的一部分, 所以会导致很多的工具链的不兼容. 例如 [[笔记/point/vscode|vscode]] 默认无法读取.而我选择用 [hugo](point/hugo.md) 进行站点的构建发布. 所以这篇博客就如题目所说的, 我要打通 [[笔记/point/hugo|hugo]] 和 [[笔记/point/obsidian|obsidian]] ,所以就有了这一篇文章.我搭建了一个 demo 站点, 你可以看看 [效果](https://doit-demo.kentxxq.com/).","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/","series":null,"tags":["blog","hugo","wikilink"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/"},{"categories":["blog"],"content":" 前情提要在我决定使用 obsidian 来记录笔记后, 就发现有 wikilink 这个东西, 它不是 CommonMark 的一部分, 所以会导致很多的工具链的不兼容. 例如 vscode 默认无法读取. 而我选择用 hugo 进行站点的构建发布. 所以这篇博客就如题目所说的, 我要打通 hugo 和 obsidian ,所以就有了这一篇文章.我搭建了一个 demo 站点, 你可以看看 效果. ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/:1:0","series":null,"tags":["blog","hugo","wikilink"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/#前情提要"},{"categories":["blog"],"content":" 我做了什么","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/:2:0","series":null,"tags":["blog","hugo","wikilink"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/#我做了什么"},{"categories":["blog"],"content":" 原理 hugo 默认使用 goldmark 进行 markdown 的渲染. goldmark 可以通过插件支持 wikilink. abhinav 的 goldmark-wikilink 这个插件与我的主题, 笔记路径, url 配置不兼容, 需要进行调整. 改 hugo 代码, 加入配置, 编译构建. 编写 github actions 发布工具. ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/:2:1","series":null,"tags":["blog","hugo","wikilink"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/#原理"},{"categories":["blog"],"content":" 准备 goldmark-wikilink首先 fork 一份 goldmark-wikilink 代码到 我的仓库. 改动 go.mod module github.com/kentxxq/goldmark-wikilink 改动 resolver.go, 添加解析代码. 下面是伪代码, 讲一下我做了什么: // 默认解析,看起来不错 // [[Foo]] // =\u003e \"Foo.html\" // [[Foo bar]] // =\u003e \"Foo bar.html\" // [[foo/Bar]] // =\u003e \"foo/Bar.html\" // [[foo.pdf]] // =\u003e \"foo.pdf\" // [[foo.png]] // =\u003e \"foo.png\" var DefaultResolver Resolver = defaultResolver{} // hugo默认路径是/Foo/,所以我加了一个PrettyResolver解决这个问题 // 关于url的路径切换可以参考文档 https://gohugo.io/content-management/urls/#appearance // [[Foo]] // =\u003e \"Foo/\" var PrettyResolver Resolver = prettyResolver{} // 当我的obsidian笔记wikilink使用`相对于当前文件的路径`时 // /root/Foo.md url: /root/Foo/ // /root/a.md include [[Foo]] . url: /root/a/ wikilink: /root/a/Foo/ not found! // 所以我加上了RelResolver // [[Foo]] // =\u003e \"../Foo/\" worked! var RelResolver Resolver = relResolver{} // 但其实obsidian中使用这样的格式并不好看.我改成了`相对于项目根路径`后 // when i use pretty url with [[absolute path]] // /Foo.md url: /posts/Foo/ // /a.md include [[root/Foo]] . url: /posts/a/ wikilink: /posts/a/posts/Foo/ not found! // so... // [[Foo]] // =\u003e \"/root/Foo/\" worked! var RootResolver = func(b string) Resolver { return \u0026rootResolver{ base: b, } } var pretty_html = []byte(\"/\") // 相对路径就是在最前面加上../,变成请求上一级目录 var rel_head = []byte(\"../\") type relResolver struct{} func (relResolver) ResolveWikilink(n *Node) ([]byte, error) { dest := make([]byte, len(rel_head)+len(n.Target)+len(pretty_html)+len(_hash)+len(n.Fragment)) var i int if len(n.Target) \u003e 0 { i += copy(dest, rel_head) i += copy(dest[i:], n.Target) if filepath.Ext(string(n.Target)) == \"\" { i += copy(dest[i:], pretty_html) } } if len(n.Fragment) \u003e 0 { i += copy(dest[i:], _hash) i += copy(dest[i:], n.Fragment) } return dest[:i], nil } // 绝对路径就是传入前缀,然后直接加上wikilink的内容即可 type rootResolver struct { base string } func (r rootResolver) ResolveWikilink(n *Node) ([]byte, error) { dest := make([]byte, len(r.base)+len(n.Target)+len(pretty_html)+len(_hash)+len(n.Fragment)) var i int if len(n.Target) \u003e 0 { i += copy(dest, []byte(r.base)) i += copy(dest[i:], n.Target) if filepath.Ext(string(n.Target)) == \"\" { i += copy(dest[i:], pretty_html) } } if len(n.Fragment) \u003e 0 { i += copy(dest[i:], _hash) i += copy(dest[i:], n.Fragment) } return dest[:i], nil } ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/:2:2","series":null,"tags":["blog","hugo","wikilink"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/#准备-goldmark-wikilink"},{"categories":["blog"],"content":" 改动 hugo同样 fork 一份 hugo 代码到 我的仓库. 安装依赖 go get github.com/kentxxq/goldmark-wikilink. 改动 markup/goldmark/goldmark_config/config.go,加入配置参数 type Extensions struct { Typographer Typographer Footnote bool DefinitionList bool // GitHub flavored markdown Table bool Strikethrough bool Linkify bool LinkifyProtocol string TaskList bool // 下面是我们新加的参数 // 采用那种方法解析链接? WikilinkReslover string // ROOT模式下,传入路径前缀 WikilinkRootPath string // 是否启用wikilink EnableWikilink bool } 改动 markup/goldmark/convert.go,让我们的配置和 wikilink 解析器生效. import ( \"bytes\" \"github.com/gohugoio/hugo/identity\" \"github.com/gohugoio/hugo/markup/goldmark/codeblocks\" \"github.com/gohugoio/hugo/markup/goldmark/goldmark_config\" \"github.com/gohugoio/hugo/markup/goldmark/images\" \"github.com/gohugoio/hugo/markup/goldmark/internal/extensions/attributes\" \"github.com/gohugoio/hugo/markup/goldmark/internal/render\" \"github.com/gohugoio/hugo/markup/converter\" \"github.com/gohugoio/hugo/markup/tableofcontents\" wikilink \"github.com/kentxxq/goldmark-wikilink\" //引入解析 \"github.com/yuin/goldmark\" \"github.com/yuin/goldmark/ast\" \"github.com/yuin/goldmark/extension\" \"github.com/yuin/goldmark/parser\" \"github.com/yuin/goldmark/renderer\" \"github.com/yuin/goldmark/renderer/html\" \"github.com/yuin/goldmark/text\" ) extensions = append(extensions, images.New(cfg.Parser.WrapStandAloneImageWithinParagraph)) // 加入 if mcfg.Goldmark.Extensions.EnableWikilink { switch mcfg.Goldmark.Extensions.WikilinkReslover { case \"DefaultResolver\": extensions = append(extensions, \u0026wikilink.Extender{ Resolver: wikilink.DefaultResolver, }) case \"PrettyResolver\": extensions = append(extensions, \u0026wikilink.Extender{ Resolver: wikilink.PrettyResolver, }) case \"RelResolver\": extensions = append(extensions, \u0026wikilink.Extender{ Resolver: wikilink.RelResolver, }) case \"RootResolver\": extensions = append(extensions, \u0026wikilink.Extender{ Resolver: wikilink.RootResolver(mcfg.Goldmark.Extensions.WikilinkRootPath), }) } } ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/:2:3","series":null,"tags":["blog","hugo","wikilink"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/#改动-hugo"},{"categories":["blog"],"content":" 配置 dart-sass下载 Releases · sass/dart-sass 的对应系统版本, 我用的 dart-sass-1.63.6-windows-x64.zip.解压后配置到环境变量里. 打开终端验证效果 sass --version 1.63.6 ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/:2:4","series":null,"tags":["blog","hugo","wikilink"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/#配置-dart-sass"},{"categories":["blog"],"content":" 开始构建代码 $GOOS=windows $GOARCH=amd64 $CGO_ENABLED=1 $CC=\"gcc\" $CXX=\"g++\" # 构建命令 # -v 详细信息 # -x 打印出执行的命令，以及相关的详细信息 # extended是加入sass,release则是hugo自定义 # `-s` 表示禁用符号表，`-w` 表示禁用 DWARF 调试信息，`-extldflags '-static'` 表示使用静态链接方式进行链接。 go build -v -x -tags extended,release -ldflags \"-s -w -extldflags '-static'\" # 文件夹多出一个hugo.exe ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/:2:5","series":null,"tags":["blog","hugo","wikilink"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/#开始构建代码"},{"categories":["blog"],"content":" hugo 预览 # 克隆我的示例代码 git clone https://github.com/kentxxq/doit-demo.git # 注意hugo.toml文件加入了如下配置 EnableWikilink = true WikilinkRootPath = \"/posts/\" WikilinkReslover = \"RootResolver\" # 启动3333端口 cd doit-demo hugo server --disableFastRender -p 3333 访问 http://localhost:3333 看看效果吧. ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/:2:6","series":null,"tags":["blog","hugo","wikilink"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/#hugo-预览"},{"categories":["blog"],"content":" 相关资料 除非 CommonMark 添加对 wikilink 的支持, hugo 可能永远都不会有 wikilink 了. Support wiki-style internal page links · Issue #3606 · gohugoio/hugo · GitHub 除了让 hugo 在渲染阶段支持 wikilink, 还可以再主题内进行 url 的处理,例如 obsidian发布hugo-quartz.但是这样的主题很少… ","date":"2023-06-26","objectID":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/:3:0","series":null,"tags":["blog","hugo","wikilink"],"title":"让hugo支持wikilink","uri":"/posts/%E7%AC%94%E8%AE%B0/%E8%AE%A9hugo%E6%94%AF%E6%8C%81wikilink/#相关资料"},{"categories":["journal"],"content":"2023-06-25 日记","date":"2023-06-25","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-06-25/","series":null,"tags":["journal"],"title":"2023-06-25","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-06-25/"},{"categories":["journal"],"content":" GitHub - mii-key/obsidian-links: manipulate \u0026 manage obisidian links #todo/ob优化 ","date":"2023-06-25","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-06-25/:0:0","series":null,"tags":["journal"],"title":"2023-06-25","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-06-25/#"},{"categories":["point"],"content":"logseq 是一款大纲型的笔记软件. 要点如下: 本地存储 支持 markdown 开源, 且开源 spa-publish ","date":"2023-06-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/logseq/:0:0","series":null,"tags":["point","logseq"],"title":"logseq","uri":"/posts/%E7%AC%94%E8%AE%B0/point/logseq/#"},{"categories":["point"],"content":"openssh 是 ssh 协议的开源实现.而 ssh 可以用来 建立远程连接, 文件传输. 表达时 openssh 和 ssh 通常是等价的. ","date":"2023-06-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/openssh/:0:0","series":null,"tags":["point","openssh"],"title":"openssh","uri":"/posts/%E7%AC%94%E8%AE%B0/point/openssh/#"},{"categories":["point"],"content":"ssh-agent 是 ssh 的一个代理软件. 用来保存秘钥, 方便你日常使用. 要点: Windows 通常自带了此服务 ","date":"2023-06-25","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/ssh-agent/:0:0","series":null,"tags":["point","ssh-agent"],"title":"ssh-agent","uri":"/posts/%E7%AC%94%E8%AE%B0/point/ssh-agent/#"},{"categories":["point"],"content":"git 是一个代码管理工具. 要点: 非常流行, 社区庞大 方便多人的协作办公 人人本地一份代码 ","date":"2023-06-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/git/:0:0","series":null,"tags":["point","git"],"title":"git","uri":"/posts/%E7%AC%94%E8%AE%B0/point/git/#"},{"categories":["point"],"content":"obsidian 是一个笔记软件. 要点: 本地离线, 安全保证 除同步,发布都免费 性能良好 插件丰富 社区活跃 ","date":"2023-06-24","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/obsidian/:0:0","series":null,"tags":["point","obsidian"],"title":"obsidian","uri":"/posts/%E7%AC%94%E8%AE%B0/point/obsidian/#"},{"categories":["journal"],"content":" tag-wragler 创建标签页，配合 add-summary。也可以配合 dataview/text-expander/query 语句. 配合模板一起工作 #todo/dashboard tag summary 的 add-summary 块 Obsidian中的标签，到底该如何使用？（第一集 两种不同的标签与标签汇总）Johnny学Obsidian_哔哩哔哩_bilibili #todo/dashboard kanban 做任务管理 #todo/dashboard ","date":"2023-06-23","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-06-23/:0:0","series":null,"tags":["journal"],"title":"2023-06-23","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-06-23/#"},{"categories":["journal"],"content":" Slides 做 ppt，搞成工作区 #todo/ppt 加入一个 query 语句，每天查询的我的 todo 任务。每周未完成，重要未完成？加入到日记模板中。每天提醒我？ #todo/dashboard GitHub - pyrochlore/obsidian-tracker: A plugin tracks occurrences and numbers in your notes 做出一些很好看的图追踪目标 #todo/dashboard Excalidraw的动态演示效果来了，伟大的匈牙利大叔又放狠招了，你的Obsidian更好用了_哔哩哔哩_bilibili 这个比 slide 幻灯片牛逼多了. #todo/ppt Open gate 添加站点到左边快捷栏 #todo/ob优化 text-expend 是分？还是合？Obsidian中的笔记到底分不分？_哔哩哔哩_bilibili #todo/dashboard 导出图片 export image plugin 没有工作 #todo/ob优化 ","date":"2023-06-22","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-06-22/:0:0","series":null,"tags":["journal"],"title":"2023-06-22","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-06-22/#"},{"categories":["blog"],"content":"我的使用 [[笔记/point/git|git]] 操作代码. 而 git 的通信会用到 [[笔记/point/openssh|openssh]].openssh 为了保证安全. 提供了私钥和公钥. 其中私钥可以密码加密, 保证安全性. 所以我就加密了.导致了什么问题呢?每次我用到 git 的时候, 都提示我输入密码. 所以我今天就来配置 [[笔记/point/ssh-agent|ssh-agent]].","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git-openssh%E7%9A%84%E5%85%8D%E5%AF%86/","series":null,"tags":["openssh","git","ssh-agent","blog"],"title":"git-openssh的免密","uri":"/posts/%E7%AC%94%E8%AE%B0/git-openssh%E7%9A%84%E5%85%8D%E5%AF%86/"},{"categories":["blog"],"content":" 简介我的使用 git 操作代码. 而 git 的通信会用到 openssh. openssh 为了保证安全. 提供了私钥和公钥. 其中私钥可以密码加密, 保证安全性. 所以我就加密了.导致了什么问题呢? 每次我用到 git 的时候, 都提示我输入密码. 所以我今天就来配置 ssh-agent. 我暂时只用 windows, 所以下面主要是 windows 的配置. ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git-openssh%E7%9A%84%E5%85%8D%E5%AF%86/:1:0","series":null,"tags":["openssh","git","ssh-agent","blog"],"title":"git-openssh的免密","uri":"/posts/%E7%AC%94%E8%AE%B0/git-openssh%E7%9A%84%E5%85%8D%E5%AF%86/#简介"},{"categories":["blog"],"content":" 操作流程 启动 windows 的 服务 =\u003e启动 ssh 服务 添加秘钥 ssh-add C:\\Users\\你的用户名\\.ssh\\id_rsa # 输入密码后回车 Enter passphrase for C:\\Users\\你的用户名\\.ssh\\id_rsa: Identity added: C:\\Users\\你的用户名\\.ssh\\id_rsa (kentxxq) # 验证效果 ssh-add -l 3072 SHA256:xxxxxxxxxxxxxxxxxxxxxxxoooooo kentxxq (RSA) 进入终端,编辑 notepad $profile 配置文件 # 加入下面这一行 $env:GIT_SSH=\"C:\\Windows\\System32\\OpenSSH\\ssh.exe\" 终端有效果, 但 vscode 等等软件没有生效? 按照这个老哥的做法, 改全局变量吧 Git: Support git with private key password · Issue #13680 · microsoft/vscode · GitHub 重新打开终端, 这里有一些 git常用命令 可以给你测试验证 ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git-openssh%E7%9A%84%E5%85%8D%E5%AF%86/:2:0","series":null,"tags":["openssh","git","ssh-agent","blog"],"title":"git-openssh的免密","uri":"/posts/%E7%AC%94%E8%AE%B0/git-openssh%E7%9A%84%E5%85%8D%E5%AF%86/#操作流程"},{"categories":["blog"],"content":"这里用来记录一些我可能用到的 [[笔记/point/git|git]] 命令. 每次去网上搜集都很麻烦, 还需要验证. 而这里的命令都经过了我的验证..","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","series":null,"tags":["git","blog"],"title":"git常用命令","uri":"/posts/%E7%AC%94%E8%AE%B0/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["blog"],"content":" 简介这里用来记录一些我可能用到的 git 命令. 每次去网上搜集都很麻烦, 还需要验证. 而这里的命令都经过了我的验证.. ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:0","series":null,"tags":["git","blog"],"title":"git常用命令","uri":"/posts/%E7%AC%94%E8%AE%B0/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#简介"},{"categories":["blog"],"content":" 具体操作","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:0","series":null,"tags":["git","blog"],"title":"git常用命令","uri":"/posts/%E7%AC%94%E8%AE%B0/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#具体操作"},{"categories":["blog"],"content":" 克隆与加速 # clone 特定tag或release git clone -b v111 xxx.git # 深度为1的clone git clone --depth 1 xxx.git # 代理克隆 git clone https://ghproxy.com/https://github.com/kentxxq/hugo.git # 私有仓库配合token使用. git clone https://user:your_token@ghproxy.com/https://ghproxy.com/https://github.com/kentxxq/hugo.git # 修改origin地址 git remote set-url origin https://github.com/kentxxq/hugo.git # 验证效果 git remote -v ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:1","series":null,"tags":["git","blog"],"title":"git常用命令","uri":"/posts/%E7%AC%94%E8%AE%B0/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#克隆与加速"},{"categories":["blog"],"content":" 清空记录 # 新分支 git checkout --orphan new_branch # 添加到暂存区 git add -A # 提交 git commit -am \"文章更新\" # 删除原有的master git branch -D master # 重命名分支 git branch -m master # 强制推送 git push -f origin master ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:2","series":null,"tags":["git","blog"],"title":"git常用命令","uri":"/posts/%E7%AC%94%E8%AE%B0/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#清空记录"},{"categories":["point"],"content":" kentxxq 这是我的个人网名. ken 日常可以叫 “can”, 不是 \" 坑 “! 名字的由来? 我以前给自己起网名, 然后发现 超人 的名字叫 kent. 而日常叫起来的话, 一般都会叫 ken. 但是我买不到这个域名. 一般来说品牌合作都类似 卧龙\u0026凤雏 或者 卧龙X凤雏. 我名字的缩写是 xq,于是就 “kentXxq”=“kentxxq”. 联系方式我:admin@kentxxq.com ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/point/kentxxq/:0:0","series":null,"tags":["point","kentxxq"],"title":"kentxxq","uri":"/posts/%E7%AC%94%E8%AE%B0/point/kentxxq/#"},{"categories":["blog"],"content":"这里是我在确定使用 [[笔记/point/obsidian|obsidian]] 记录笔记以后. 对比选择我的博客发布方案.之前我的博客和笔记内容是割裂的. 一直使用 vscode 编写博客, 然后 [[笔记/point/hugo|hugo]] 发布. 而现在我想重新组合我的工作流.","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/","series":null,"tags":["obsidian","hugo","blog"],"title":"obsidian的发布方案","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/"},{"categories":["blog"],"content":" 简介这里是我在确定使用 obsidian 记录笔记以后. 对比选择我的博客发布方案. 之前我的博客和笔记内容是割裂的. 一直使用 vscode 编写博客, 然后 hugo 发布. 而现在我想重新组合我的工作流. ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/:1:0","series":null,"tags":["obsidian","hugo","blog"],"title":"obsidian的发布方案","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/#简介"},{"categories":["blog"],"content":" 发布方案","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/:2:0","series":null,"tags":["obsidian","hugo","blog"],"title":"obsidian的发布方案","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/#发布方案"},{"categories":["blog"],"content":" 现状先说结果,我选的 HEIGE-PCloud/DoIt: A clean, elegant and advanced blog theme for Hugo..没有哪种方案是十全十美的, 于是我先确定了优先级. seo: 既然是发布系统. 那么发布出去最重要的就是 seo 优化了. 评论: 交流, 反馈都会直接帮助到内容, 重要性排名第二. ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/:2:1","series":null,"tags":["obsidian","hugo","blog"],"title":"obsidian的发布方案","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/#现状"},{"categories":["blog"],"content":" 方案对比 对比项 hugo-quartz hugo-doit 官方 publish #todo标签 无法过滤解析 🚫 无法过滤解析 🚫 支持 ✅ 支持预览页面 支持 wikilink 和普通 link, 但效果一般 ⚠️ 不支持 🚫 支持 ✅ 需要做的改动 obsidian 发布到 quartz ℹ️ 移动 static 文件夹并配置 staticDirc ℹ️ 不需要 ✅ markdown 正常 link 到 head 只能定位到 page⚠️ 通过 goldmark-wiki 支持 ⚠️ 支持 ✅ seo 6 分 10 分 10 分 评论 🚫 ✅ 🚫 在确定了使用 doit 后,其中最让我纠结的就是语法问题. 禁用 wikilink 语法 - 相对于根目录. 需要在主题内修改 md 链接的渲染. 检测到 md 结尾就绕过原有逻辑,去除 md 结尾, 加上 /posts/ 前缀. 禁用 wikilink 语法 - 相对于当前文件, 需要开启 uglyURLs, 同时将 md 改成 html 采用 wikilink 语法, 在我编写笔记的时候好用. 但是发布需要渲染成 uglyURLs. 且要改源码编译 hugo 加入 goldmark-wikilink. 同时改动 wikilink 的渲染逻辑 分析: 2 比 1 要好, 不是绕过原有逻辑, 而是在原有逻辑后加入判断. 同时有兼容性好. 任意 markdown 编辑器都通用 3 比较麻烦, 同时如果 #todo/笔记 ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/:2:2","series":null,"tags":["obsidian","hugo","blog"],"title":"obsidian的发布方案","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/#方案对比"},{"categories":["blog"],"content":" 发布脚本 # 设置源文件夹和目标文件夹的路径 $sourceRootFolder = \"obsidian文档路径\" $targetRootFolder = \"博客路径\" # 切换到目标文件夹 Set-Location -Path $targetRootFolder git pull Write-Host \"github拉取完成\" Get-ChildItem -Path $targetRootFolder | Remove-Item -Force -Recurse Write-Host \"已删除存在的内容\" # 需要拷贝的文件夹 $folders = @(\"笔记\", \"附件\", \"日记\") foreach ($folder in $folders) { Copy-Item -Path \"$sourceRootFolder\\$folder\" -Destination \"$targetRootFolder\\$folder\" -Recurse -Force } Write-Host \"文件拷贝完成\" Write-Host \"查看效果\" Get-ChildItem -Path $targetRootFolder git add -A git commit -am \"文章更新\" git push Write-Host \"推送完成\" ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/:2:3","series":null,"tags":["obsidian","hugo","blog"],"title":"obsidian的发布方案","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/#发布脚本"},{"categories":["blog"],"content":"这里介绍我如何使用 [[笔记/point/obsidian|obsidian]] 来记录, 多总结, 总思考. 让 obsidian 真正成为最后一个笔记软件. (除非有其他革命性的创造, ar? 植入芯片?)","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/","series":null,"tags":["obsidian","blog"],"title":"obsidian的方法论","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/"},{"categories":["blog"],"content":" 简介这里介绍我如何使用 obsidian 来记录, 多总结, 总思考. 让 obsidian 真正成为最后一个笔记软件. (除非有其他革命性的创造, ar? 植入芯片?) ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/:1:0","series":null,"tags":["obsidian","blog"],"title":"obsidian的方法论","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/#简介"},{"categories":["blog"],"content":" 目标这部分是因为我刷到的一个 b 站视频, 我很认同他的观点. 于是想要来实践. 内容 问题点 说明 目标层 目标不明, 迟早要停 运用我的知识, 创造价值. 系统层 体系太乱, 事倍功半 于是我用 obsidian 来进行知识的管理与更新,并且发布出去. 管理和发布都会是价值 行为层 习惯不好, 大旗必倒 定期的整理, 添加新的理解, 关联知识体系. 流程层 流程不畅, 必走不长 使用日记来快速记录, 减少负担. 其他效果留给行为层 基础层 基础不牢, 地动山摇 生活, 工作都会有知识点. 不断探索, 进取是根本. ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/:2:0","series":null,"tags":["obsidian","blog"],"title":"obsidian的方法论","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/#目标"},{"categories":["blog"],"content":" 如何开始","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/:3:0","series":null,"tags":["obsidian","blog"],"title":"obsidian的方法论","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/#如何开始"},{"categories":["blog"],"content":" 开始日记用日记开始每天的笔记. 为什么我的记录越来越少? 因为我发现我要些一篇文章的时候, 需要了解非常透彻, 花费很多的时间. 所以我通过类似 logseq 的日记来开始每一天的协作. 每天都是一个新的开始. 不强制把写的内容记到日记中做双链. 减少无效, 无作用的日记, 减少负担. 或者说换一种形式, 一句话日记比流水账双链更有意义. 日记整理成笔记或 point, 无用的日记应该删除. 例如除了已完成的 todo 没有其他内容. 记录内容: Todo 任务, 不单独记录到一个文件中, 可以减少历史负担产生的干扰 一句话日记. 通过 tag 的方式收集记录 有意思的句子. 通过 tag 的方式收集记录 ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/:3:1","series":null,"tags":["obsidian","blog"],"title":"obsidian的方法论","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/#开始日记"},{"categories":["blog"],"content":" 日记的格式 --- tags: - journal - 标题名称 categories: - journal description: \"\u003c% tp.date.now(\"YYYY-MM-DD\") %\u003e 日记\" --- 输出 --- title: \"2023-06-25\" tags: - journal - date: 2023-06-25 lastmod: 2023-06-25 categories: - journal description: \"2023-06-25 日记\" --- 自己的内容... ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/:3:2","series":null,"tags":["obsidian","blog"],"title":"obsidian的方法论","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/#日记的格式"},{"categories":["blog"],"content":" 笔记的重要组成 - 点 (point)point 是我笔记中的最小原子. 名词就是一个点的最佳诠释, 例如: kentxxq 是我的网名. 这种别人不了解的东西, 就非常适合引用. 多种表达形式? Alias 的头就是用来链接, 别名链接。例如 point 名字叫 ios, 也可以别名 iOS. ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/:3:3","series":null,"tags":["obsidian","blog"],"title":"obsidian的方法论","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/#笔记的重要组成---点-point"},{"categories":["blog"],"content":" 点 (point) 的格式 --- tags: - point - \u003c% tp.file.title %\u003e categories: - point --- 输出 --- title: logseq tags: - point - logseq date: 2023-06-25 lastmod: 2023-06-26 categories: - point --- `logseq` 是一款大纲型的笔记软件. 通常只是很少的简介信息, 没有必要再进行 description. ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/:3:4","series":null,"tags":["obsidian","blog"],"title":"obsidian的方法论","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/#点-point-的格式"},{"categories":["blog"],"content":" 博客的格式 --- tags: - blog categories: - blog description: \"\" --- ## 简介 ## 内容 输出 --- title: git常用命令 tags: - git - 清空历史记录 - 克隆速度 date: 2023-06-21 lastmod: 2023-06-25 --- ## 简介 这里用来记录一些我可能用到的 [git](point/git.md) 命令. 每次去网上搜集都很麻烦, 还需要验证. 而这里的命令都经过了我的验证.. ## 内容 xxx 这里想要特别说明一下: 简介通常用于链接. 一篇文章中, 如果我高频使用了 git 这个词, 我并不希望所有的 git 都变成链接. 更新日志被我去掉了, 因为我觉得更新时间就已经代替了文章的时效性. 而日记又会关联到博客, 这样就有了单链. 而日志和博客之间, 没有必要变成双联. 也就减少了我的写作负担. ","date":"2023-06-21","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/:3:5","series":null,"tags":["obsidian","blog"],"title":"obsidian的方法论","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/#博客的格式"},{"categories":["journal"],"content":" obsidian同步方案对比 #todo/笔记 ","date":"2023-06-20","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-06-20/:0:0","series":null,"tags":["journal"],"title":"2023-06-20","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-06-20/#"},{"categories":["blog"],"content":"这里是用 [[笔记/point/obsidian|obsidian]] 发布到 [[point/hugo|hugo]] 的 quartz 主题详细操作步骤.","date":"2023-06-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/","series":null,"tags":["blog","hugo","obsidian","githubPages"],"title":"obsidian发布hugo-quartz","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/"},{"categories":["blog"],"content":" 简介这里是用 obsidian 发布到 hugo 的 quartz 主题详细操作步骤. quartz 主题优点如下: 支持双链语法 有双链图 ","date":"2023-06-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/:1:0","series":null,"tags":["blog","hugo","obsidian","githubPages"],"title":"obsidian发布hugo-quartz","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/#简介"},{"categories":["blog"],"content":" 操作步骤","date":"2023-06-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/:2:0","series":null,"tags":["blog","hugo","obsidian","githubPages"],"title":"obsidian发布hugo-quartz","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/#操作步骤"},{"categories":["blog"],"content":" fork 代码库 访问 hugo 模板仓库 jackyzha0/quartz: 🌱 host your own second brain and digital garden for free (github.com) fork 仓库 git 克隆到本地 git clone https://github.com/YOUR-USERNAME/quartz ","date":"2023-06-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/:2:1","series":null,"tags":["blog","hugo","obsidian","githubPages"],"title":"obsidian发布hugo-quartz","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/#fork-代码库"},{"categories":["blog"],"content":" 初始化动作 移除 content 内的所有内容 编辑 data/config.yaml 目录下 name: kentxxq enableRecentNotes: true GitHubLink: https://github.com/kentxxq/quartz description: \"kentxxq's digital garden\" page_title: \"🪴 kentxxq's digital garden\" links: - link_name: Blog link: https://www.kentxxq.com - link_name: GitHub link: https://github.com/kentxxq 编辑 config.toml baseURL = \"https://blog.kentxxq.com/\" ignoreFiles = [ \"/content/templates/*\", \"/content/private/*\", \"/content/附件/*.md\", ] 注释掉 .github/workflows/docker-publish.yaml 文件 .gitignore 过滤 private 文件夹 content/private 修改 layouts/partials/date-fmt.html 里的日志格式 {{if .Date}} {{.Date.Format \"2006-01-02\"}} {{else if .Lastmod}} {{.Lastmod.Format \"2006-01-02\"}} {{else}} Unknown {{end}} 修改 .github/workflows/deploy.yaml 文件 name: Deploy to GitHub Pages on: push: branches: - hugo jobs: deploy: runs-on: ubuntu-20.04 steps: - uses: actions/checkout@v2 with: fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Build Link Index uses: jackyzha0/hugo-obsidian@v2.20 with: index: true input: content output: assets/indices root: . - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \"0.96.0\" extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public publish_branch: master # deploying branch cname: blog.kentxxq.com # 先用blog来做测试 ","date":"2023-06-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/:2:2","series":null,"tags":["blog","hugo","obsidian","githubPages"],"title":"obsidian发布hugo-quartz","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/#初始化动作"},{"categories":["blog"],"content":" 配置 githubPage 到你的 quartz 仓库调整配置 进入 Settings \u003e Action \u003e General \u003e Workflow Permissions 并选中 Read and Write Permissions ","date":"2023-06-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/:2:3","series":null,"tags":["blog","hugo","obsidian","githubPages"],"title":"obsidian发布hugo-quartz","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/#配置-githubpage"},{"categories":["blog"],"content":" 使用说明 vault 应该创建在 content 下面 _index.md 是 quartz 的首页 设置 - 编辑器 - 显示 - 显示 frontmatter, 方便我们迅速查看调整 tag, 标题之类的内容 做一个模板,方便你以后用 --- title: \"{{title}}\" tags: - blog --- ","date":"2023-06-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/:2:4","series":null,"tags":["blog","hugo","obsidian","githubPages"],"title":"obsidian发布hugo-quartz","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/#使用说明"},{"categories":["blog"],"content":" 推送代码后 配置自定义域名解析,例如 blog.kentxxq.com 使用 cname 解析到 kentxxq.github.io 进入 Settings \u003e Pages \u003e Custom domain \u003e blog.kentxxq.com 开启 https 证书 Enforce HTTPS ","date":"2023-06-20","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/:2:5","series":null,"tags":["blog","hugo","obsidian","githubPages"],"title":"obsidian发布hugo-quartz","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E5%8F%91%E5%B8%83hugo-quartz/#推送代码后"},{"categories":["journal"],"content":" 车险 #todo/生活 ","date":"2023-06-19","objectID":"/posts/%E6%97%A5%E8%AE%B0/2023-06-19/:0:0","series":null,"tags":["journal"],"title":"2023-06-19","uri":"/posts/%E6%97%A5%E8%AE%B0/2023-06-19/#"},{"categories":["blog"],"content":"这篇文章主要记录我使用 [[笔记/point/obsidian|obsidian]] 的配置和插件.方便自己记录, 也可以让你了解我做了什么让 [[笔记/point/obsidian|obsidian]] 变得更好用.","date":"2023-06-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/","series":null,"tags":["blog","obsidian"],"title":"obsidian插件与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/"},{"categories":["blog"],"content":" 简介这篇文章主要记录我使用 obsidian 的配置和插件. 方便自己记录, 也可以让你了解我做了什么让 obsidian 变得更好用. ","date":"2023-06-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["blog","obsidian"],"title":"obsidian插件与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/#简介"},{"categories":["blog"],"content":" 主要配置","date":"2023-06-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["blog","obsidian"],"title":"obsidian插件与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/#主要配置"},{"categories":["blog"],"content":" 编辑器 ","date":"2023-06-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["blog","obsidian"],"title":"obsidian插件与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/#编辑器"},{"categories":["blog"],"content":" 文件与链接 ","date":"2023-06-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:2","series":null,"tags":["blog","obsidian"],"title":"obsidian插件与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/#文件与链接"},{"categories":["blog"],"content":" 插件","date":"2023-06-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["blog","obsidian"],"title":"obsidian插件与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/#插件"},{"categories":["blog"],"content":" 使用中的插件 插件名称 插件作用 总结说明 Advanced Tables 快速写 markdown 的 table 非常好用 excalidraw 画图的 可以自动生成 svg，并且同步画图改动，兼容性很高 Find orphaned files and broken links 清理文件 整理出无效链接和孤儿文件 tag warpper 加强处理 tag 批量重命名 Linter 格式化笔记 选项很多，需要折腾 Webpage HTML Export 导出 html 兼容性非常好 auto-link-title 自动填写网页标题 挺好的，可以统一 easy-typing 输入时格式化 帮我在英文标点后加上空格 image-toolkit 点击放大图片 蛮好的 emoji-toolbar 插入 emoji 蛮好的 Templater 模板 方便创建日期和文件名模板 ","date":"2023-06-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:1","series":null,"tags":["blog","obsidian"],"title":"obsidian插件与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/#使用中的插件"},{"categories":["blog"],"content":" 放弃了的插件 插件名称 插件作用 总结说明 Diagrams 画图 在 ob 没 excalidraw 好用，没导出 svg 这样的定制化功能 Digital Garden 发布站点 tag 效果不好、和 frontmatter 似乎冲突比较多、代码不是很活跃 Remotely Save 同步备份 全程使用 alist 的 webdav+ 阿里云盘。偶尔无法同步删除，无法删除 .obsidian 里的文件 livesync 同步 同步 需要搭建服务器端、其实没有备份功能 ","date":"2023-06-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:2","series":null,"tags":["blog","obsidian"],"title":"obsidian插件与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/#放弃了的插件"},{"categories":["blog"],"content":" 可能尝试的插件 插件名称 插件作用 总结说明 sliding panes 横向卷动 打开多个标签页，然后配合触摸板横向浏览 ","date":"2023-06-19","objectID":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:3","series":null,"tags":["blog","obsidian"],"title":"obsidian插件与配置","uri":"/posts/%E7%AC%94%E8%AE%B0/obsidian%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE/#可能尝试的插件"},{"categories":null,"content":"About Me","date":"2019-01-02","objectID":"/about/","series":null,"tags":null,"title":"Offline","uri":"/about/"},{"categories":null,"content":"kentxxq,放着我的所有 wechat:kentxxq github:kentxxq email:admin@kentxxq.com ","date":"2019-01-02","objectID":"/about/:0:0","series":null,"tags":null,"title":"Offline","uri":"/about/#"},{"categories":null,"content":" 你没有连接至互联网, 只有缓存的页面可用. ","date":"0001-01-01","objectID":"/offline/:0:0","series":null,"tags":null,"title":"Offline","uri":"/offline/#"}]