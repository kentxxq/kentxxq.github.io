<!doctype html><html lang=zh><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-131319987-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','UA-131319987-1')</script><meta name=author content="kentxxq"><meta name=keywords content="c python c# 数据结构 解析在线视频"><meta name=description content="在之前做爬虫练手的时候，去爬的Porn网站。影片简介其中有一项就是影片时长。而在我后来的一段时间，发现很多影片网站是没有时长信息的。要知道影片的时长信息其实是非常重要的，需要作为一个筛选的条件。于是开始尝试自己来用python编写获取在线视频时长的工具。而后这段时间在看了c和c#相关的知识后，开始有了更为深入的了解。也遇到了一些在python中没有详细了解过的问题"><link rel=prev href=https://kentxxq.com/contents/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/><link rel=next href=https://kentxxq.com/contents/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%A1%E6%81%AF%E6%89%8B%E5%86%8C/><link rel=canonical href=https://kentxxq.com/contents/%E8%A1%A5%E5%85%85%E4%B8%80%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%9F%A5%E8%AF%86/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link rel=icon type=image/png href=/favicon.png><title>补充一些数据结构的知识 | kentxxq Blog</title><meta name=title content="补充一些数据结构的知识 | kentxxq Blog"><link rel=stylesheet href=/font/iconfont.css><link rel=stylesheet href=/css/main.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","image":"https:\/\/kentxxq.com\/images/me/avatar.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/kentxxq.com\/"},"articleSection":"posts","name":"补充一些数据结构的知识","headline":"补充一些数据结构的知识","description":"在之前做爬虫练手的时候，去爬的Porn网站。影片简介其中有一项就是影片时长。而在我后来的一段时间，发现很多影片网站是没有时长信息的。要知道影片的时长信息其实是非常重要的，需要作为一个筛选的条件。于是开始尝试自己来用python编写获取在线视频时长的工具。而后这段时间在看了c和c#相关的知识后，开始有了更为深入的了解。也遇到了一些在python中没有详细了解过的问题","inLanguage":"zh","author":"kentxxq","creator":"kentxxq","publisher":{"@type":"Organization","name":"kentxxq","logo":{"@type":"ImageObject","url":"https:\/\/kentxxq.com\/images/me/avatar.jpg"}},"accountablePerson":"kentxxq","copyrightHolder":"kentxxq","copyrightYear":"2019","datePublished":"2019-11-04 01:10:00","dateModified":"2019-11-04 01:10:00","url":"https:\/\/kentxxq.com\/contents\/%E8%A1%A5%E5%85%85%E4%B8%80%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%9F%A5%E8%AF%86\/","keywords":["c","python","c#","数据结构","解析在线视频"]}</script></head><body><div class=wrapper><nav class=navbar><div class=container><div class="navbar-header header-logo"><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://kentxxq.com/>kentxxq Blog</a></div><div class="menu navbar-right"><a class=menu-item href=/posts/ title>Blog</a>
<a class=menu-item href=/categories/ title>Categories</a>
<a class=menu-item href=/tags/ title>Tags</a>
<a class=menu-item href=/about/ title>About</a></div></div></nav><nav class=navbar-mobile id=nav-mobile style=display:none><div class=container><div class=navbar-header><div><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://kentxxq.com/>kentxxq Blog</a></div><div class=menu-toggle><span></span><span></span><span></span></div></div><div class=menu id=mobile-menu><a class=menu-item href=/posts/ title>Blog</a>
<a class=menu-item href=/categories/ title>Categories</a>
<a class=menu-item href=/tags/ title>Tags</a>
<a class=menu-item href=/about/ title>About</a></div></div></nav><main class=main><div class=container><article class=post-warp><header class=post-header><h1 class=post-title>补充一些数据结构的知识</h1><div class=post-meta>Written by <a href=https://kentxxq.com/ rel=author>kentxxq</a>
with ♥
<span class=post-time>on <time datetime=2019-11-04>November 4, 2019</time></span>
in
<i class="iconfont icon-folder"></i><span class=post-category><a href=https://kentxxq.com/categories/%E7%AC%94%E8%AE%B0/>笔记</a></span>
|
<a href=#gitalk-container><span class=gitalk-comment-count itemprop=commentCount></span></a></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title></h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#在线视频现状>在线视频现状</a></li><li><a href=#我的解决方案>我的解决方案</a><ul><li><a href=#python>python</a></li><li><a href=#c>c#</a></li><li><a href=#20191118日补充>20191118日补充</a></li></ul></li><li><a href=#总结>总结</a></li></ul></nav></div></div><script type=text/javascript>window.onload=function(){var a=$('.post-toc'),b=$('.post-comment'),f=a.offset().top,d=a.height(),g=a[0].offsetTop,e,c;$(window).scroll(function(){var h=Math.max(document.body.scrollTop,document.documentElement.scrollTop);b.length>0&&(c=b.offset().top,e=c-h-d),f<h?(a.css({position:'fixed'}),b.length>0&&c<h+d?a.css({top:e}):a.css({top:0})):(a.css({position:'absolute'}),a.css({top:g}))})}</script><div class=post-content><blockquote><p>在之前做爬虫练手的时候，去爬的Porn网站。影片简介其中有一项就是影片时长。而在我后来的一段时间，发现很多影片网站是没有时长信息的。要知道影片的时长信息其实是非常重要的，需要作为一个筛选的条件。</p><p>于是开始尝试自己来用python编写获取在线视频时长的工具。而后这段时间在看了c和c#相关的知识后，开始有了更为深入的了解。也遇到了一些在python中没有详细了解过的问题。</p></blockquote><h2 id=在线视频现状>在线视频现状</h2><p>现在html5越来越流行，flash则已经确定在2020年后不再更新支持，每次打开chrome都会提醒我这一点。</p><p>而html5钦定的视频文件格式，就是mp4文件。所以从mp4文件来入手是非常好的。</p><p>mp4是一种文件格式。通过规范后的数据结构编排，生成文件。而软件则通过规范来解码文件，进行画面的绘制和输出。几乎所有的文件都是用c/c++的结构体来进行组装的。所以学习c语言对理解文件结构很有帮助。</p><p>可以参考苹果网站的文档<a href=https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFPreface/qtffPreface.html>查阅规范</a></p><h2 id=我的解决方案>我的解决方案</h2><h3 id=python>python</h3><p>一开始我搜索已有的解决方案。</p><p>ffmpeg是一个很强的工具。跨平台且可以解析各种文件，但是ffmpeg需要单独部署，且不方便代码移植。我在用python通过命令行来调用的时候，发现速度奇慢。2小时才解析了200多条信息，且会无故hang住。对程序来说，也算是一个黑箱操作。无法调试。</p><p><img src=/images/c/ffmpeg.jpg alt=使用ffmpeg工具解析></p><p>随后发现<a href=https://github.com/kkroening/ffmpeg-python>ffmpeg-python</a>这个库可以帮我操作，但还是觉得麻烦。我需要了解一套新的api，以及它所对应到的ffmpeg接口。</p><hr><p>当你在在chrome中通过浏览器打开一个mp4文件的时候，会直接播放。且带有时长。</p><p>在之前了解爬虫的过程中，一些难搞的网站，是可以使用selenium来操作的。使用一个真正的浏览器来进行数据采集。于是我进行了尝试。</p><p><img src=/images/c/selenium.jpg alt=使用selenium工具解析></p><p>但是这样的效率同样不高。现在的浏览器越来越复杂和庞大。</p><p>那么浏览器是如何获取到时长的呢？肯定是有方法的。我只要了解原理，然后用python写出来即可。</p><hr><p>首先需要了解http(s)请求中一个非常重要的header头，Range。</p><p>状态码为200系列，代表不同的请求成功了。而你带上<code>"Range":"bytes=0-7"</code>请求去请求一个在线的mp4文件，正常情况下(大部分服务端都支持)会拿到206的状态码。代表你请求的数据成功了。你拿到了这个mp4前8个字节的数据。</p><p>于是我们的需求变成了从mp4文件中获取到存储时长信息的那几个字节。对照之前的苹果文档，我便写出了如下的代码。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># coding:utf-8</span>


<span style=color:#f92672>import</span> struct
<span style=color:#f92672>import</span> requests


<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Mp4info</span>:
    <span style=color:#66d9ef>def</span> __init__(self, file):
        self<span style=color:#f92672>.</span>file <span style=color:#f92672>=</span> file
        self<span style=color:#f92672>.</span>seek <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
        self<span style=color:#f92672>.</span>duration <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
        self<span style=color:#f92672>.</span>s <span style=color:#f92672>=</span> requests<span style=color:#f92672>.</span>session()
        self<span style=color:#f92672>.</span>timeout <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>
        self<span style=color:#f92672>.</span>s<span style=color:#f92672>.</span>headers <span style=color:#f92672>=</span> {
            <span style=color:#e6db74>&#39;Connection&#39;</span>: <span style=color:#e6db74>&#39;keep-alive&#39;</span>,
            <span style=color:#e6db74>&#39;Accept&#39;</span>: <span style=color:#e6db74>&#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&#39;</span>,
            <span style=color:#e6db74>&#39;Accept-Encoding&#39;</span>: <span style=color:#e6db74>&#39;gzip, deflate&#39;</span>,
            <span style=color:#e6db74>&#39;Accept-Language&#39;</span>: <span style=color:#e6db74>&#39;zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7&#39;</span>,
            <span style=color:#e6db74>&#39;User-Agent&#39;</span>: <span style=color:#e6db74>&#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36&#39;</span>
        }

    <span style=color:#75715e># 设置请求头  set request header</span>
    <span style=color:#75715e># 传入的seek表示代表需要跳过的字节数量  use seek to skip initial data</span>
    <span style=color:#75715e># 在这里进行判断是为了后续获取视频的宽高信息预留的  the condition here is for reserving space for getting the media data</span>
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_set_headers</span>(self, seek, type):
        <span style=color:#66d9ef>if</span> type <span style=color:#f92672>in</span> [<span style=color:#e6db74>&#39;moov&#39;</span>, <span style=color:#e6db74>&#39;duration&#39;</span>]:
            self<span style=color:#f92672>.</span>s<span style=color:#f92672>.</span>headers[<span style=color:#e6db74>&#39;Range&#39;</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;bytes={}-{}&#39;</span><span style=color:#f92672>.</span>format(seek, seek <span style=color:#f92672>+</span> <span style=color:#ae81ff>7</span>)

    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_send_request</span>(self):
        <span style=color:#66d9ef>try</span>:
            data <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>s<span style=color:#f92672>.</span>get(url<span style=color:#f92672>=</span>self<span style=color:#f92672>.</span>file, stream<span style=color:#f92672>=</span>True,
                              timeout<span style=color:#f92672>=</span>self<span style=color:#f92672>.</span>timeout)<span style=color:#f92672>.</span>raw<span style=color:#f92672>.</span>read()
        <span style=color:#66d9ef>except</span> requests<span style=color:#f92672>.</span>Timeout:
            <span style=color:#66d9ef>raise</span> <span style=color:#e6db74>&#39;连接超时:超过6秒(默认)服务器没有响应任何数据！&#39;</span>  <span style=color:#75715e># timeout 6 seconds, the server fails to respond and assumes there is no data</span>
        <span style=color:#66d9ef>return</span> data

    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_find_moov_request</span>(self):
        self<span style=color:#f92672>.</span>_set_headers(self<span style=color:#f92672>.</span>seek, type<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;moov&#39;</span>)
        data <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>_send_request()
        size <span style=color:#f92672>=</span> int(struct<span style=color:#f92672>.</span>unpack(<span style=color:#e6db74>&#39;&gt;I&#39;</span>, data[:<span style=color:#ae81ff>4</span>])[<span style=color:#ae81ff>0</span>])
        flag <span style=color:#f92672>=</span> data[<span style=color:#f92672>-</span><span style=color:#ae81ff>4</span>:]<span style=color:#f92672>.</span>decode(<span style=color:#e6db74>&#39;ascii&#39;</span>)
        <span style=color:#66d9ef>return</span> size, flag

    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_find_duration_request</span>(self):
        <span style=color:#75715e># 4+4是moov的大小和标识,跳过20个字符，直接读到time_scale，duration  # 4+4 is the first 8 characters denoting charset, skip the next 20 to time_scale and duration</span>
        self<span style=color:#f92672>.</span>_set_headers(seek<span style=color:#f92672>=</span>self<span style=color:#f92672>.</span>seek<span style=color:#f92672>+</span><span style=color:#ae81ff>4</span><span style=color:#f92672>+</span><span style=color:#ae81ff>4</span><span style=color:#f92672>+</span><span style=color:#ae81ff>20</span>, type<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;duration&#39;</span>)
        data <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>_send_request()
        time_scale <span style=color:#f92672>=</span> int(struct<span style=color:#f92672>.</span>unpack(<span style=color:#e6db74>&#39;&gt;I&#39;</span>, data[:<span style=color:#ae81ff>4</span>])[<span style=color:#ae81ff>0</span>])
        duration <span style=color:#f92672>=</span> int(struct<span style=color:#f92672>.</span>unpack(<span style=color:#e6db74>&#39;&gt;I&#39;</span>, data[<span style=color:#f92672>-</span><span style=color:#ae81ff>4</span>:])[<span style=color:#ae81ff>0</span>])
        <span style=color:#66d9ef>return</span> time_scale, duration

    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_duration</span>(self):
        <span style=color:#66d9ef>while</span> True:
            size, flag <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>_find_moov_request()
            <span style=color:#66d9ef>if</span> flag <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;moov&#39;</span>:
                time_scale, duration <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>_find_duration_request()
                self<span style=color:#f92672>.</span>duration <span style=color:#f92672>=</span> duration<span style=color:#f92672>/</span>time_scale
                <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>duration
            <span style=color:#66d9ef>else</span>:
                self<span style=color:#f92672>.</span>seek <span style=color:#f92672>+=</span> size


<span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
    url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;http://tekeye.uk/html/images/Joren_Falls_Izu_Japan.mp4&#39;</span>
    file <span style=color:#f92672>=</span> Mp4info(url)
    a <span style=color:#f92672>=</span> file<span style=color:#f92672>.</span>get_duration()
    <span style=color:#66d9ef>print</span>(a)
</code></pre></div><p>在代码中有几个关键点:</p><ul><li>requests用来请求数据。加上请求头信息防止服务器认为是无效访问。使用session是因为我们在过程中会有多次请求，介绍tcp连接的次数，加快连接速度。</li><li>struct是python的标准库之一，用来解析c结构类型的数据块。</li><li>可以看到这个类实现的功能非常单一。如果获取更多信息的需求，应该使用<a href=https://github.com/construct/construct>construct</a>来帮助你。</li></ul><p>另外说一句，我写了一个<a href=https://www.github.com/kentxxq/VideoInfo>VideoInfo</a>的库，你可以用pip进行安装使用。用的是construct来解析文件。通过少数几次的请求，来下载整个元数据(因此更注重网络带宽而不是连接速度)。来帮助你在需要获得更多信息的时候来使用。</p><h3 id=c>c#</h3><p>在完成了python版本以后，我学了一些c#的知识。</p><p>发现python作为一种高级、动态语言，是用纯c写的，且一直兼容这c-api。于是不但有了高级语言的oop特性，又有了通过c工具来操作数据的便利性。</p><p>而c#算是一个纯面向对象的语言了。很多底层的东西，你是需要完全改变思想来处理问题。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=color:#66d9ef>var</span> req = <span style=color:#66d9ef>new</span> HttpClient();
req.DefaultRequestHeaders.Add(<span style=color:#e6db74>&#34;Range&#34;</span>, <span style=color:#e6db74>&#34;bytes=9737-9740&#34;</span>);
<span style=color:#66d9ef>var</span> bytes = <span style=color:#66d9ef>await</span> req.GetByteArrayAsync(<span style=color:#e6db74>&#34;http://clips.vorwaerts-gmbh.debig_buck_bunny.mp4&#34;</span>);
<span style=color:#66d9ef>var</span> size = bytes.Take(<span style=color:#ae81ff>2</span>).ToArray();
<span style=color:#66d9ef>if</span> (BitConverter.IsLittleEndian)
    Array.Reverse(size);
<span style=color:#66d9ef>var</span> size2 = BitConverter.ToInt16(size);
Console.WriteLine(size2);
</code></pre></div><p>上面这段代码中，让我理解了更多的不同之处:</p><ul><li>c#可以很方便的进行异步。且有多种形式。可以通过异步流或者字节等方式，方便的取拿到各种形式的返回值。</li><li>补充了大小端的知识。之前只知道使用大端来转换数据。而不知道其实是按照byte字节来排序的。而不是用二进制的bit。所以在转换的时候直接转换bytes数组，而不是单独的bit。</li><li>如果你需要转换成8位的int，直接拿到byte后进行tostring来转成十进制即可。而int16和int32等格式需要用到BitConverter。</li></ul><h3 id=20191118日补充>20191118日补充</h3><p>之前用c#写的解析部分，相比python而言，麻烦了很多。于是有了新的方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=color:#75715e>// 字节数组转结构体
</span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> T BytesToStuct&lt;T&gt;(<span style=color:#66d9ef>byte</span>[] bytes)
{
    <span style=color:#75715e>//得到结构体的大小
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> size = Marshal.SizeOf&lt;T&gt;();
    <span style=color:#75715e>//byte数组长度小于结构体的大小
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (size &gt; bytes.Length)
    {
        <span style=color:#75715e>//返回空
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>default</span>(T);
    }
    <span style=color:#75715e>//分配结构体大小的内存空间
</span><span style=color:#75715e></span>    IntPtr structPtr = Marshal.AllocHGlobal(size);
    <span style=color:#75715e>//将byte数组拷到分配好的内存空间
</span><span style=color:#75715e></span>    Marshal.Copy(bytes, <span style=color:#ae81ff>0</span>, structPtr, size);
    <span style=color:#75715e>//将内存空间转换为目标结构体
</span><span style=color:#75715e></span>    T obj = Marshal.PtrToStructure&lt;T&gt;(structPtr);
    <span style=color:#75715e>//释放内存空间
</span><span style=color:#75715e></span>    Marshal.FreeHGlobal(structPtr);
    <span style=color:#75715e>//返回结构体
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> obj;
}

<span style=color:#75715e>// 结构体
</span><span style=color:#75715e></span><span style=color:#a6e22e>[StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 1)]</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>DataStruct</span>
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> size;
<span style=color:#a6e22e>    [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>char</span>[] flag;
}

<span style=color:#75715e>// 由于大小端的问题，你必须先综合我前面的c#部分代码，把size部分先反转顺序
</span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> bytes2 = size.Concat(flag).ToArray();
<span style=color:#66d9ef>var</span> dataStruct = BytesToStuct&lt;DataStruct&gt;(bytes2);
</code></pre></div><p>关于大小端的问题，在<a href=https://stackoverflow.com/questions/2480116/marshalling-a-big-endian-byte-collection-into-a-struct-in-order-to-pull-out-valu>stackoverflow</a>的这个回答里也有解决方案。</p><h2 id=总结>总结</h2><p>写日志真的是一个巩固知识，以及加深理解的好方法。哪怕只是半桶水，也会比某些人的那半桶水要好。</p><p>可以看到python的construct非常好用。而c#这样完全自举且面向对象的语言,则麻烦不少。对于不定长的字段以及嵌套的数据结构，更加麻烦。</p></div><div class=post-copyright><p class=copyright-item><span>Author:</span>
<span>kentxxq</span></p><p class=copyright-item><span>Link:</span>
<a href=https://kentxxq.com/contents/%E8%A1%A5%E5%85%85%E4%B8%80%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%9F%A5%E8%AF%86/><script>document.write(decodeURI(location.origin+location.pathname))</script></a></p><p class="copyright-item lincese">本文采用<a rel=license href=http://creativecommons.org/licenses/by-nc/4.0/ target=_blank>知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p></div><div class=post-tags><section><i class="iconfont icon-tag"></i>Tag(s):
<span class=tag><a href=https://kentxxq.com/tags/%E7%AC%94%E8%AE%B0/>#笔记</a></span>
<span class=tag><a href=https://kentxxq.com/tags/c/>#c</a></span></section><section><a href=javascript:window.history.back();>back</a></span> ·
<span><a href=https://kentxxq.com/>home</a></span></section></div><div class=post-nav><a href=https://kentxxq.com/contents/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/ class=prev rel=prev title=起码要能看懂c系列的代码><i class="iconfont icon-left"></i>&nbsp;起码要能看懂c系列的代码</a>
<a href=https://kentxxq.com/contents/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%A1%E6%81%AF%E6%89%8B%E5%86%8C/ class=next rel=next title=常用的信息手册>常用的信息手册&nbsp;<i class="iconfont icon-right"></i></a></div></article><div class=post-comment><div id=disqus_thread></div><script>var disqus_config=function(){this.page.title="补充一些数据结构的知识",this.page.url="https://kentxxq.com/contents/%E8%A1%A5%E5%85%85%E4%B8%80%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%9F%A5%E8%AF%86/"};(function(){var a=document,b=a.createElement('script');b.src='https://kentxxq.disqus.com/embed.js',b.setAttribute('data-timestamp',+new Date),(a.head||a.body).appendChild(b)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by
Disqus.</a></noscript></div></div></main><footer class=footer><a href=https://beian.miit.gov.cn/ target=_blank rel="external nofollow">湘ICP备2021002319号-1</a></footer><link href=//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css rel=stylesheet><script src=/js/vendor_gallery.min.js async></script><script src=https://cdn.bootcss.com/mermaid/8.0.0-rc.8/mermaid.min.js></script></div></body></html>