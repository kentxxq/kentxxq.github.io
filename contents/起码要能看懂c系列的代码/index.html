<!doctype html><html lang=zh><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-131319987-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','UA-131319987-1')</script><meta name=author content="kentxxq"><meta name=keywords content="c c++ python 指针 动态库 静态库 入门"><meta name=description content="之前在一些文章里面就有说过。程序员是绕不过JavaScript的，即使有时候会恶心到人。。而很多硬件的嵌入式开发，算法工程师，底层开发人员则真的可以做一辈子，而免疫JavaScript的侵扰。而JavaScript的每一个改动，都多多少少与c/c++有关。可以说大神们用c/c++构建了现在数字化的底层逻辑。比c更底层的，晦涩难懂且开发效率低下，甚至人写的代码经常不如c编译器优化后的代码。比c高级的，性能下降且概念繁多。和c同级别的，都没有c混得好。c是事实标准"><meta property="og:title" content="起码要能看懂c系列的代码"><meta property="og:description" content="之前在一些文章里面就有说过。程序员是绕不过JavaScript的，即使有时候会恶心到人。。而很多硬件的嵌入式开发，算法工程师，底层开发人员则真的可以做一辈子，而免疫JavaScript的侵扰。而JavaScript的每一个改动，都多多少少与c/c++有关。可以说大神们用c/c++构建了现在数字化的底层逻辑。比c更底层的，晦涩难懂且开发效率低下，甚至人写的代码经常不如c编译器优化后的代码。比c高级的，性能下降且概念繁多。和c同级别的，都没有c混得好。c是事实标准"><meta property="og:type" content="article"><meta property="og:url" content="https://kentxxq.com/contents/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-08-29T11:35:00+08:00"><meta property="article:modified_time" content="2021-02-26T00:06:04+08:00"><link rel=prev href=https://kentxxq.com/contents/%E6%88%91%E7%9A%84k8s%E4%B9%8B%E8%B7%AF1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/><link rel=next href=https://kentxxq.com/contents/%E8%A1%A5%E5%85%85%E4%B8%80%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%9F%A5%E8%AF%86/><link rel=canonical href=https://kentxxq.com/contents/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link rel=icon type=image/png href=/favicon.png><title>起码要能看懂c系列的代码 | kentxxq Blog</title><meta name=title content="起码要能看懂c系列的代码 | kentxxq Blog"><link rel=stylesheet href=/font/iconfont.css><link rel=stylesheet href=/css/main.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","image":"https:\/\/kentxxq.com\/images/me/avatar.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/kentxxq.com\/"},"articleSection":"posts","name":"起码要能看懂c系列的代码","headline":"起码要能看懂c系列的代码","description":"之前在一些文章里面就有说过。程序员是绕不过JavaScript的，即使有时候会恶心到人。。而很多硬件的嵌入式开发，算法工程师，底层开发人员则真的可以做一辈子，而免疫JavaScript的侵扰。而JavaScript的每一个改动，都多多少少与c\/c\u002b\u002b有关。可以说大神们用c\/c\u002b\u002b构建了现在数字化的底层逻辑。比c更底层的，晦涩难懂且开发效率低下，甚至人写的代码经常不如c编译器优化后的代码。比c高级的，性能下降且概念繁多。和c同级别的，都没有c混得好。c是事实标准","inLanguage":"zh","author":"kentxxq","creator":"kentxxq","publisher":{"@type":"Organization","name":"kentxxq","logo":{"@type":"ImageObject","url":"https:\/\/kentxxq.com\/images/me/avatar.jpg"}},"accountablePerson":"kentxxq","copyrightHolder":"kentxxq","copyrightYear":"2019","datePublished":"2019-08-29 11:35:00","dateModified":"2021-02-26 00:06:04","url":"https:\/\/kentxxq.com\/contents\/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81\/","keywords":["c","c++","python","指针","动态库","静态库","入门"]}</script></head><body><div class=wrapper><nav class=navbar><div class=container><div class="navbar-header header-logo"><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://kentxxq.com/>kentxxq Blog</a></div><div class="menu navbar-right"><a class=menu-item href=/posts/ title>Blog</a>
<a class=menu-item href=/categories/ title>Categories</a>
<a class=menu-item href=/tags/ title>Tags</a>
<a class=menu-item href=/about/ title>About</a></div></div></nav><nav class=navbar-mobile id=nav-mobile style=display:none><div class=container><div class=navbar-header><div><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://kentxxq.com/>kentxxq Blog</a></div><div class=menu-toggle><span></span><span></span><span></span></div></div><div class=menu id=mobile-menu><a class=menu-item href=/posts/ title>Blog</a>
<a class=menu-item href=/categories/ title>Categories</a>
<a class=menu-item href=/tags/ title>Tags</a>
<a class=menu-item href=/about/ title>About</a></div></div></nav><main class=main><div class=container><article class=post-warp><header class=post-header><h1 class=post-title>起码要能看懂c系列的代码</h1><div class=post-meta>Written by <a href=https://kentxxq.com/ rel=author>kentxxq</a>
with ♥
<span class=post-time>on <time datetime=2019-08-29>August 29, 2019</time></span>
in
<i class="iconfont icon-folder"></i>
<span class=post-category><a href=https://kentxxq.com/categories/%E7%AC%94%E8%AE%B0/>笔记</a></span>
|
<a href=#gitalk-container><span class=gitalk-comment-count itemprop=commentCount></span></a></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title></h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#前言>前言</a></li><li><a href=#基本了解>基本了解</a><ul><li><a href=#类型>类型</a></li><li><a href=#函数部分>函数部分</a></li><li><a href=#预处理命令>预处理命令</a></li><li><a href=#指针>指针</a></li><li><a href=#结构体>结构体</a></li><li><a href=#动态分配>动态分配</a></li><li><a href=#typedef>typedef</a></li><li><a href=#位运算>位运算</a></li><li><a href=#文件操作>文件操作</a></li></ul></li><li><a href=#编译>编译</a><ul><li><a href=#linux>linux</a></li><li><a href=#mac>mac</a></li><li><a href=#windows>windows</a></li></ul></li><li><a href=#难点>难点</a><ul><li><a href=#指针数组和数组指针>指针数组和数组指针</a></li><li><a href=#第一点c中没有字符串类型字符串是由字符数组组成以0结尾字符串又有2个声明的方式>第一点，c中没有字符串类型。字符串是由字符数组组成，以\0结尾。字符串又有2个声明的方式。</a></li><li><a href=#第二点要彻底了解的是数组作为参数的传递>第二点，要彻底了解的是<strong>数组作为参数的传递</strong>。</a></li><li><a href=#第三点再来说一下我自己理解错误>第三点，再来说一下我自己理解错误。</a></li><li><a href=#文件读取>文件读取</a></li><li><a href=#代码示例>代码示例</a></li><li><a href=#eof和feof>EOF和feof</a></li><li><a href=#静态库和动态库>静态库和动态库</a></li></ul></li><li><a href=#总结>总结</a></li></ul></nav></div></div><script type=text/javascript>window.onload=function(){var a=$('.post-toc'),b=$('.post-comment'),f=a.offset().top,d=a.height(),g=a[0].offsetTop,e,c;$(window).scroll(function(){var h=Math.max(document.body.scrollTop,document.documentElement.scrollTop);b.length>0&&(c=b.offset().top,e=c-h-d),f<h?(a.css({position:'fixed'}),b.length>0&&c<h+d?a.css({top:e}):a.css({top:0})):(a.css({position:'absolute'}),a.css({top:g}))})}</script><div class=post-content><blockquote><p>之前在一些文章里面就有说过。程序员是绕不过JavaScript的，即使有时候会恶心到人。。</p><p>而很多硬件的嵌入式开发，算法工程师，底层开发人员则真的可以做一辈子，而免疫JavaScript的侵扰。而JavaScript的每一个改动，都多多少少与c/c++有关。</p><p>可以说大神们用c/c++构建了现在数字化的底层逻辑。比c更底层的，晦涩难懂且开发效率低下，甚至人写的代码经常不如c编译器优化后的代码。比c高级的，性能下降概念繁多。和c同级别的，都没有c混得好。事实上c是事实标准。</p></blockquote><h2 id=前言>前言</h2><p>如果你从来没有了解过编程，而想学习c。那么去搜新手教程慢慢上手。</p><p>如果你有其他编程的基础。这篇文章能用来让你快速了解c代码。可以在你不得不去看c代码的时候，看懂他的意图。</p><h2 id=基本了解>基本了解</h2><h3 id=类型>类型</h3><p>二进制的c表达，需要用代码实现</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># python用0b开头</span>
a <span style=color:#f92672>=</span> <span style=color:#ae81ff>0b101</span>
</code></pre></div><p>八进制</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// c用0开头
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>08</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># python用0o开头  数字0和字母o</span>
a <span style=color:#f92672>=</span> <span style=color:#ae81ff>0o516</span>
</code></pre></div><p>十六进制</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// c用0x开头
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x2A</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># python用0x开头</span>
a <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x2A</span>
</code></pre></div><p>其中int是2个字节。long int是4个字节。</p><p>而float是4个字节。double是8个字节。long double是16个字节。注意在计算的时候，可能存在舍入误差。</p><p>char一个字符一个字节。</p><p>字符串则会比char多出来一个尾部的<code>\0</code>字节。</p><p>unsigned则代表没有符号位。例如int类型前面都会有一个符号位。没有符号位则会扩大int的可存储范围</p><p>附带补充一点知识。
<img src=/images/c/C_%E8%A1%A5%E7%A0%81.png alt=C_补码></p><p>数组</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> a[<span style=color:#ae81ff>10</span>];
<span style=color:#75715e>// 10个长度，空位补0
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> b[<span style=color:#ae81ff>10</span>]<span style=color:#f92672>=</span>{<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span>};
<span style=color:#75715e>// 自动检测到长度
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> b[]<span style=color:#f92672>=</span>{<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span>};
</code></pre></div><p>而字符串就这样表示</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// 长度会是4，因为后面还有一个\0
</span><span style=color:#75715e></span><span style=color:#66d9ef>char</span> c[]<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;C a&#34;</span>;
</code></pre></div><p>说几个常用的字符串函数吧</p><ol><li><code>strcat</code>合并</li><li><code>strcpy</code>拷贝</li><li><code>strcmp</code>比较</li><li><code>strlen</code>拿到字符串长度</li></ol><h3 id=函数部分>函数部分</h3><ol><li>函数其实没什么好说的。记得除了库函数(自带标准库),都要定义一下。才能用。</li><li>全局变量默认在静态存储区。</li><li>加了<code>static</code>的局部变量也在静态存储区。</li><li><code>register</code>的变量会放在寄存器，会提高性能。</li><li>外部变量用<code>extern</code>声明，则可以在代码中使用。</li></ol><h3 id=预处理命令>预处理命令</h3><ol><li><code>#define PI 3.1415</code>用PI替代代码中的3.1415。<code>#undef PI</code>取消。</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// 可以带参数。
</span><span style=color:#75715e></span><span style=color:#75715e>#define SQ(y) (y)*(y)
</span><span style=color:#75715e></span><span style=color:#75715e>/* 但注意扩起来。否则可能结果有误 */</span>
<span style=color:#75715e>/* 例如sq=SQ(a+1)会变成sq=a+1*a+1 */</span>
</code></pre></div><ol start=2><li><code>#include "stdio.h"</code>引入头文件。一般都用双引号先从当前目录查找。</li><li><code>#ifdef #else #endif</code>用来判断执行。<code>#if</code>则非0则为true。</li></ol><h3 id=指针>指针</h3><p>示例代码</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// 声明int变量a和int指针*p
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> a,<span style=color:#f92672>*</span>p;
a<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>;
<span style=color:#75715e>// 把a的地址给p
</span><span style=color:#75715e></span>p<span style=color:#f92672>=&amp;</span>a;
<span style=color:#75715e>// 现在用*p即可取到a的值
</span><span style=color:#75715e></span>printf(<span style=color:#960050;background-color:#1e0010>&#39;</span><span style=color:#f92672>%</span>d<span style=color:#960050;background-color:#1e0010>&#39;</span>,<span style=color:#f92672>*</span>p);
</code></pre></div><ol><li>指针如果指向数组，则默认指向数组的第一个元素。可以通过<code>*(p+1)</code>取到第二个元素的值。字符串同理。</li><li>函数也是占用连续的内存段。则<code>int (*pf)();</code>代表指向一个返回值是int的函数。当指针赋值后，通过<code>(*pmax)(a)</code>调用。</li><li><code>int *ap(int x,int y)</code>代表返回指针。</li></ol><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td>int i;</td><td>定义整型变量 i</td></tr><tr><td>int *p;</td><td>p 为指向整型数据的指针变量</td></tr><tr><td>int a[n];</td><td>定义整型数组 a，它有 n 个元素</td></tr><tr><td>int *p[n];</td><td>定义指针数组 p，它由 n 个指向整型数据的指针元素组成</td></tr><tr><td>int (*p)[n];</td><td>p 为指向含 n 个元素的一维数组的指针变量</td></tr><tr><td>int f();</td><td>f 为带回整型函数值的函数</td></tr><tr><td>int *p();</td><td>p 为带回一个指针的函数，该指针指向整型数据</td></tr><tr><td>int (*p)();</td><td>p 为指向函数的指针，该函数返回一个整型值</td></tr><tr><td>int **p;</td><td>P 是一个指针变量，它指向一个指向整型数据的指针变量</td></tr></tbody></table><p>优先级为：()>[]>*。然后从左往右看。</p><h3 id=结构体>结构体</h3><p>如果你理解了前面所说的指针，那么指针就会很好理解。其实就是一系列的基本类型放在一个连续的内存段中。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// 声明一个结构体
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> human {
    <span style=color:#66d9ef>int</span> num;
    <span style=color:#66d9ef>char</span> name[<span style=color:#ae81ff>20</span>];
    <span style=color:#66d9ef>char</span> sex;
};
<span style=color:#75715e>// human结构的变量
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> human {
        <span style=color:#66d9ef>int</span> num;
        <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name;
        <span style=color:#66d9ef>char</span> sex;
}boy;
<span style=color:#75715e>// 5个human结构组成的数组变量
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> human {
        <span style=color:#66d9ef>int</span> num;
        <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name;
        <span style=color:#66d9ef>char</span> sex;
}boy[<span style=color:#ae81ff>5</span>];
<span style=color:#75715e>// 带上初始化的值
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> human
{
    <span style=color:#66d9ef>int</span> num;
    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name;
    <span style=color:#66d9ef>char</span> sex;
}boy[<span style=color:#ae81ff>5</span>]<span style=color:#f92672>=</span>{
          {<span style=color:#ae81ff>101</span>,<span style=color:#e6db74>&#34;Li ping&#34;</span>,<span style=color:#e6db74>&#39;M&#39;</span>},
          {<span style=color:#ae81ff>102</span>,<span style=color:#e6db74>&#34;Zhang ping&#34;</span>,<span style=color:#e6db74>&#39;M&#39;</span>},
          {<span style=color:#ae81ff>103</span>,<span style=color:#e6db74>&#34;He fang&#34;</span>,<span style=color:#e6db74>&#39;F&#39;</span>},
          {<span style=color:#ae81ff>104</span>,<span style=color:#e6db74>&#34;Cheng ling&#34;</span>,<span style=color:#e6db74>&#39;F&#39;</span>},
          {<span style=color:#ae81ff>105</span>,<span style=color:#e6db74>&#34;Wang ming&#34;</span>,<span style=color:#e6db74>&#39;M&#39;</span>},
};
</code></pre></div><p>取值赋值:boy.num
数组类似普通数组:boy[i].num
指针:struct human *ph
指针取值:ph->num或(*ph).num</p><h3 id=动态分配>动态分配</h3><p>很多时候不确定需要多大空间的时候，通过传参来实现。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// 分配一个100字节长度字符数组，pc为指向这个字符数组
</span><span style=color:#75715e></span>pc<span style=color:#f92672>=</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)malloc(<span style=color:#ae81ff>100</span>);
<span style=color:#75715e>// 分配2个struct human结构体的长度。ps为指针且指向这个数组
</span><span style=color:#75715e></span>ps<span style=color:#f92672>=</span>(struet human<span style=color:#f92672>*</span>)calloc(<span style=color:#ae81ff>2</span>,<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> human));
<span style=color:#75715e>// 接收指针变量，释放它
</span><span style=color:#75715e></span>free(pc);
free(ps);
</code></pre></div><h3 id=typedef>typedef</h3><p>用typedef加在struct前面，变量名写HUMAN，就可以用HUMAN h1,h2来声明变量了！简洁明了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>int</span> INTEGER;
INTEGER a,b;
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>char</span> NAME[<span style=color:#ae81ff>20</span>];
<span style=color:#75715e>// 在和预定义不同的是，这是在编译器进行的。
</span><span style=color:#75715e></span>NAME a1,a2,s1,s2;
<span style=color:#75715e>// 等效
</span><span style=color:#75715e></span><span style=color:#66d9ef>char</span> a1[<span style=color:#ae81ff>20</span>],a2[<span style=color:#ae81ff>20</span>],s1[<span style=color:#ae81ff>20</span>],s2[<span style=color:#ae81ff>20</span>]
</code></pre></div><h3 id=位运算>位运算</h3><p>位运算方面其实和其他语言的区别不大。看到应用最多的地方是权限方面的。自己对着文档看吧。我反正是觉得不好理解，不爱用。</p><h3 id=文件操作>文件操作</h3><p>其实到了文件操作部分，就开始用前面学到的知识来进行延伸了。</p><ul><li><code>File *fp;</code>声明一个指针变量，文件类型。这并不是一个特殊的语法。我的mac上可以看到定义，是一个结构体。</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>typedef</span>	<span style=color:#66d9ef>struct</span> __sFILE {
	<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>_p;	<span style=color:#75715e>/* current position in (some) buffer */</span>
	<span style=color:#66d9ef>int</span>	_r;		<span style=color:#75715e>/* read space left for getc() */</span>
	<span style=color:#66d9ef>int</span>	_w;		<span style=color:#75715e>/* write space left for putc() */</span>
	<span style=color:#66d9ef>short</span>	_flags;		<span style=color:#75715e>/* flags, below; this FILE is free if 0 */</span>
	<span style=color:#66d9ef>short</span>	_file;		<span style=color:#75715e>/* fileno, if Unix descriptor, else -1 */</span>
	<span style=color:#66d9ef>struct</span>	__sbuf _bf;	<span style=color:#75715e>/* the buffer (at least 1 byte, if !NULL) */</span>
	<span style=color:#66d9ef>int</span>	_lbfsize;	<span style=color:#75715e>/* 0 or -_bf._size, for inline putc */</span>

	<span style=color:#75715e>/* operations */</span>
	<span style=color:#66d9ef>void</span>	<span style=color:#f92672>*</span>_cookie;	<span style=color:#75715e>/* cookie passed to io functions */</span>
	<span style=color:#66d9ef>int</span>	(<span style=color:#f92672>*</span> _Nullable _close)(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>);
	<span style=color:#66d9ef>int</span>	(<span style=color:#f92672>*</span> _Nullable _read) (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>, <span style=color:#66d9ef>int</span>);
	fpos_t	(<span style=color:#f92672>*</span> _Nullable _seek) (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>, fpos_t, <span style=color:#66d9ef>int</span>);
	<span style=color:#66d9ef>int</span>	(<span style=color:#f92672>*</span> _Nullable _write)(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>, <span style=color:#66d9ef>int</span>);

	<span style=color:#75715e>/* separate buffer for long sequences of ungetc() */</span>
	<span style=color:#66d9ef>struct</span>	__sbuf _ub;	<span style=color:#75715e>/* ungetc buffer */</span>
	<span style=color:#66d9ef>struct</span> __sFILEX <span style=color:#f92672>*</span>_extra; <span style=color:#75715e>/* additions to FILE to not break ABI */</span>
	<span style=color:#66d9ef>int</span>	_ur;		<span style=color:#75715e>/* saved _r when _r is counting ungetc data */</span>

	<span style=color:#75715e>/* tricks to meet minimum requirements even when malloc() fails */</span>
	<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> _ubuf[<span style=color:#ae81ff>3</span>];	<span style=color:#75715e>/* guarantee an ungetc() buffer */</span>
	<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> _nbuf[<span style=color:#ae81ff>1</span>];	<span style=color:#75715e>/* guarantee a getc() buffer */</span>

	<span style=color:#75715e>/* separate buffer for fgetln() when line crosses buffer boundary */</span>
	<span style=color:#66d9ef>struct</span>	__sbuf _lb;	<span style=color:#75715e>/* buffer for fgetln() */</span>

	<span style=color:#75715e>/* Unix stdio files get aligned to block boundaries on fseek() */</span>
	<span style=color:#66d9ef>int</span>	_blksize;	<span style=color:#75715e>/* stat.st_blksize (may be != _bf._size) */</span>
	fpos_t	_offset;	<span style=color:#75715e>/* current lseek offset (see WARNING) */</span>
} FILE;
</code></pre></div><ul><li><p><code>fp=("/home/a.txt","r");</code>只读方式打开制定文件，后面的参数类似python。</p></li><li><p><code>ch=fgetc(fp);</code>取第一个字符赋值给ch。</p></li><li><p><code>fputc('a',fp);</code>弄一个字符串到到指针位置。</p></li><li><p><code>fgets(str,n,fp);</code>从fp中取n-1个字符(即字符串)到str这个char数组中。为什么是n-1(一般也是str长度-1)，因为字符串后面要有一个'\0&rsquo;啊！ 它读取到换行符或者文件结尾会停止。
str这个数组我试过几个不同的大小。发现4096(4k)是一个门槛，小于它可能会影响性能。而我看到python默认使用的是系统buffer大小8192(8k即2个block)。现在的文件系统多数都是4k为一个block，而io一般最少存取一个block。那么设置成2个block，也有助于更快的对下一个block数据块进行操作，而更大的话就没有太大意义了，可能会浪费磁盘io导致占用过多的资源。</p></li><li><p><code>fputs(“abcd“,fp);</code>把字符串放到指针位置。这里传递的是字符串，其实传递的就是字符数组首地址。所以如果是char *b=&ldquo;abcd"要进行传递，直接传递fputs(b,fp)即可！</p></li><li><p><code>fread(qq,sizeof(struct stu),2,fp);</code>qq是一个指针，表示数据的首地址(在这里指向一个stu结构体)，qq+1会移动到第二个stu结构体。第二个是数据块的大小,第三个是读取几个数据块，fp是文件指针。</p></li><li><p><code>fwrite(qq,sizeof(struct stu),2,fp);</code>参数同上，只不过是写数据。</p></li><li><p><code>fscanf(fp,"%d %s",&i,s);</code>和<code>fprintf(fp,"%d %c",j,ch);</code>用来通过第二个参数指定的方式，存放或者打印数据。主义第二个参数中的空格也是会生效的！</p></li><li><p><code>rewind</code>函数把文件指针重新指向头部。</p></li><li><p><code>fseek(fp,100L,0);</code>类似python的指针偏移。0文件首地址，1当前位置，2文件末尾。常量表示偏移量必须带上&rsquo;L'。移动到离文件首100字节距离的位置。也可以直接填写数字。负号前移，正号后移。</p></li></ul><p><strong>最后说明</strong>EOF是一个隐藏字符。在读取完了数据以后，才会遇到EOF。</p><p>而feof()是通过返回错误来判断是否结束。所以需要先取值，后判断。遇到了EOF(即-1)就会出错。停止下一个循环。</p><p>0是false，非0位true。</p><h2 id=编译>编译</h2><p>简单来说，编译就是使用<code>gcc</code>,<code>make</code>,<code>cmake</code>等工具来进行的。</p><p>如果使用vs或者clion这样的工具，需要了解的是工具的使用方法。而下面我要简单说明的是手工编译。</p><ol><li>在项目目录下新建build文件夹。</li><li>进入build文件夹使用<code>cmake ..</code>生成Makefile</li><li>运行make命令编译成功，找到输出文件即可。</li></ol><h3 id=linux>linux</h3><p>我在centos7上运行<code>gcc</code>,<code>make</code>,<code>cmake</code>都可以正常使用。</p><h3 id=mac>mac</h3><p>用brew安装cmake后，也可以跑通。</p><h3 id=windows>windows</h3><p>我是用的<a href=https://scoop.sh/>scoop</a>安装cmake。</p><p>然后安装最新的vs。下载<code>mingw-get</code>，然后安装<code>mingw32-make</code>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cmake -G   <span style=color:#e6db74>&#34;MinGW Makefiles&#34;</span> . <span style=color:#75715e># .为当前目录, &#34;MinGW Makefiles&#34;为makefile类型，如果编译器为vs的话使用&#34;NMake Makefiles&#34;</span>
</code></pre></div><p>看到了Makefile后mingw32-make即可。</p><h2 id=难点>难点</h2><p>记录一下难以理解的地方。</p><h3 id=指针数组和数组指针>指针数组和数组指针</h3><p>在看书的时候，了解到main函数可以接受2个参数。而main函数不能被其他函数调用(有一些编译器不管你这么多，也能编译通过。但是制定标准的委员会明确表明了<strong>不行</strong>)。</p><p><code>int argc</code>代表单数的个数。包括程序自己本身。</p><p><code>char *argv[]</code>代表一个指向字符串的指针数组。</p><p>先说一下我之前的<strong>错误想法</strong>吧。</p><p>一个指针数组。那么我拿到的就是一个数组。</p><p>那么我应该先用<code>argv[i]</code>拿到数组中的第i个指针。然后如何取值呢？用<code>*(argv[i])</code>取第一个值。可是报错了。</p><p>那么我的理解错误在哪呢？下面用<code>./helloworld a=1</code>来举例。</p><h3 id=第一点c中没有字符串类型字符串是由字符数组组成以0结尾字符串又有2个声明的方式>第一点，c中没有字符串类型。字符串是由字符数组组成，以\0结尾。字符串又有2个声明的方式。</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>//可以修改指针的地址，但是无法修改原有的值。存储在内存只读段。只要程序在运行，那么就不会释放。
</span><span style=color:#75715e></span><span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>a<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;hehe&#34;</span>;
<span style=color:#75715e>//可以修改。在函数内接收，用完就会释放掉。
</span><span style=color:#75715e></span><span style=color:#66d9ef>char</span> b[]<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;hehe&#34;</span>;
</code></pre></div><p>c是如何读取字符串的呢？</p><p>在c语言中，指向字符和指向字符串的区别只是在于取值，根本就没有指向字符串的指针。从字符串(字符数组)的首地址开始取值，一直到\0结束，那么这个字符串就读完了。</p><p>于是根据例子，系统传递给main函数的就是2个字符数组。也就变成了传递1个包含有2个char*类型指针的指针数组即可。取第n个值，就从数组中第n个指针所指向的地址取值到\0即可。</p><p>所以<code>printf("%s",*a)</code>中。*a取到的值&rsquo;h'。而printf中指明了要取一个字符串。所以它打印的结果会一直读到\0才会停止。</p><h3 id=第二点要彻底了解的是数组作为参数的传递>第二点，要彻底了解的是<strong>数组作为参数的传递</strong>。</h3><ol><li>我的main会得到一个长度为2的数组。如果用户还输入了b=2，c=3呢？我的的程序是无法预测到用户参数的具体个数。所以main函数无法写死数组长度，所以还会有一个<code>int argc</code>参数告诉我才行。</li><li>数组在传递的时候，传递的只是首地址。用一小段代码来理解一下发生了什么。</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>test3</span>(<span style=color:#66d9ef>int</span> ac,<span style=color:#66d9ef>char</span> av[]){
    printf(<span style=color:#e6db74>&#34;%p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,av);
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> ac; <span style=color:#f92672>++</span>i) {
        printf(<span style=color:#e6db74>&#34;%c&#34;</span>,av[i]);
    }
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>test4</span>(<span style=color:#66d9ef>char</span> a){
    printf(<span style=color:#e6db74>&#34;%p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,<span style=color:#f92672>&amp;</span>a);
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>test5</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>qt[]){
    printf(<span style=color:#e6db74>&#34;%p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, qt);
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[]) {
    <span style=color:#66d9ef>char</span> p<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;p&#39;</span>;
    printf(<span style=color:#e6db74>&#34;%p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,<span style=color:#f92672>&amp;</span>p);
    test4(p);

    <span style=color:#66d9ef>char</span> pch[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;pch&#34;</span>;
    printf(<span style=color:#e6db74>&#34;%p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, pch);
    test3(strlen(pch), pch);

    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>qq[]<span style=color:#f92672>=</span>{<span style=color:#e6db74>&#34;q&#34;</span>,<span style=color:#e6db74>&#34;w&#34;</span>};
    <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>qq2<span style=color:#f92672>=</span>qq;
    printf(<span style=color:#e6db74>&#34;%p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, qq);
    test5(qq);

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
<span style=color:#75715e>// 结果
</span><span style=color:#75715e>// 0x7ffee0afc77f
</span><span style=color:#75715e>// 0x7ffee0afc75f
</span><span style=color:#75715e>// 0x7ffee0afc77b
</span><span style=color:#75715e>// 0x7ffee0afc77b
</span><span style=color:#75715e>// pch
</span><span style=color:#75715e>// 0x7ffee81d0770
</span><span style=color:#75715e>// 0x7ffee81d0770
</span></code></pre></div><p><strong>先看test3和test4的结果</strong>。</p><p>可以发现2个变量的数据存在不同的内存区域，char类型传递的是<code>具体值</code>，也就是给形参a赋值。也即是我在test4中修改a的值，不会影响到p的值。</p><p>test3中2个变量的数据为同一内存区域，数组类型传递的是<code>值的地址</code>，也就是让av也指向pch所指向的地方，于是相同的地址指向同一个值。当我使用*av修改值，对应的pch值也会变动。</p><p>而通过打印，我们会知道。地址指向字符串(字符数组)第一个char。可以用*av直接取值。</p><p><strong>C语言规定，数组名代表数组的首地址，也就是第0号元素的地址</strong>。说明我们在声明了pch以后，就可以把数组名pch看成是一个指针。</p><p>那么我们在test3函数中，形参也可以写成char *av(你可以验证看)。</p><p><strong>再看test5的结果。发现地址也是一样的</strong>。</p><p>同理就可以推断出，传递的是地址，所以qt是指针类型。根据结果，指针数组传递的就是第一个指针所指向值的地址。直接*qt即可取值。</p><p>前面在传递数组的时候，数组名代表着一个指针。同样在传递指针数组的时候，数组名就是第一个元素的地址，而第一个元素是指针。所以数组名qt是指针的指针！</p><p>那么我们在test5函数中，形参也可以写成char **qt(char **qq2=qq也侧面验证了<code>char**类型</code>接收数组变量名qq)。这也是为什么main函数中char *argv[]也可以写的char **argv的原因了！</p><p>得到结论：数组在传递的时候，形参char*和char[]等效。char**与char *[]等效。</p><p>同时也说明，数组[i]只不过是指针的一个语法糖，相当于*(指针+i)。</p><p>所以取值如下：</p><p><code>char **qt</code>强调自己是指针。取值常用<code>**qt</code>。</p><p><code>char *qt[]</code>强调自己是数组。取值常用<code>qt[0]</code>。</p><p>虽然你的形参是<code>char **qt</code>也可以用<code>qt[0]</code>取值。但是不方便理解，且容易出错。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// 你的第一感觉应该是用**rrr取值。
</span><span style=color:#75715e></span><span style=color:#66d9ef>char</span> r<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;a&#39;</span>;
<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>rr<span style=color:#f92672>=&amp;</span>r;
<span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>rrr<span style=color:#f92672>=&amp;</span>rr;
<span style=color:#75715e>// 下面报错
</span><span style=color:#75715e></span>printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,rrr[<span style=color:#ae81ff>0</span>]);
<span style=color:#75715e>// 说明要分情况的，char **qt不等同于char *qt[]
</span></code></pre></div><h3 id=第三点再来说一下我自己理解错误>第三点，再来说一下我自己理解错误。</h3><p>由于之前所接触到的语言，基本的逻辑都是面向对象且没有指针。都是值传递，而不是地址传递。</p><p>写过一篇go语言的文章，可我没有深入了解过它的指针。经过翻查，发现go在数组传递的时候也是值传递。在go中，指针是为了减少性能开销存在的。而很少见到有人做指针运算。</p><p>而c的指针贯穿了整个语言。在进行值传递的时候，形参可以拿到所有信息，因为要进行赋值操作。值传递会让变量名直接取到值。</p><p>而地址传递只有一个地址和类型，需要用到取值符*。且在一个指针指向数组的时候*p和p[0]等价。</p><p>只有搞清楚传递的过程中是值还是地址，才能正确的分析问题。</p><h3 id=文件读取>文件读取</h3><h3 id=代码示例>代码示例</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/*文本内容如下
</span><span style=color:#75715e>123
</span><span style=color:#75715e>哈哈
</span><span style=color:#75715e>*/</span>

<span style=color:#75715e>/* 下面这段代码会正确打印文本内容直到结束 */</span>
<span style=color:#66d9ef>int</span> str3;
<span style=color:#66d9ef>while</span> ((str3 <span style=color:#f92672>=</span> fgetc(f1)) <span style=color:#f92672>!=</span> EOF) {
    printf(<span style=color:#e6db74>&#34;%c&#34;</span>, str3);
}

<span style=color:#75715e>/* 下面这段代码会多打印一个奇怪的问号符 */</span>
<span style=color:#66d9ef>int</span> str2;
<span style=color:#66d9ef>while</span> (str2 <span style=color:#f92672>!=</span> EOF) {
    str2 <span style=color:#f92672>=</span> fgetc(f1);
    printf(<span style=color:#e6db74>&#34;%c&#34;</span>, str2);
}

<span style=color:#75715e>/* 下面这段代码会把最后的哈哈打印两次 */</span>
<span style=color:#66d9ef>char</span> str[<span style=color:#ae81ff>4096</span>];
<span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>feof(f1)) {
    fgets(str, <span style=color:#ae81ff>4096</span>, f1);
    printf(<span style=color:#e6db74>&#34;%s&#34;</span>, str);
}

</code></pre></div><p>下面来说说为什么。</p><ol><li>先看第一个。首先把数据用fgetc取出，然后判断是否为EOF，选择是否打印。没毛病。</li><li>第二个则是先判断是否为EOF，当我们读取到&rsquo;哈&rsquo;的时候，先打印出来。然后再判断依旧!=EOF，就会导致把EOF读取出来后进行了打印。</li><li>feof是通过返回错误<code>-1</code>来停止循环的。所以在使用的时候先进行读取。在循环了2次以后，feof仍然没有收到错误信息。第三次循环的时候fgets其实没有读取到数据。但是下面的语句还是得要执行。</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/* 改成这样，最后一次读取到了错误，但是下面没有代码了，什么都没发生。循环条件进行判断后跳出循环。 */</span>
<span style=color:#66d9ef>char</span> str[<span style=color:#ae81ff>4096</span>];
<span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
fgets(str, <span style=color:#ae81ff>4096</span>, f1);
<span style=color:#66d9ef>if</span> (feof(f1)) {
    printf(<span style=color:#e6db74>&#34;空文件</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
} <span style=color:#66d9ef>else</span> {
    <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>feof(f1)) {
        printf(<span style=color:#e6db74>&#34;%s&#34;</span>, str);
        fgets(str, <span style=color:#ae81ff>4096</span>, f1);
    }
}
</code></pre></div><h3 id=eof和feof>EOF和feof</h3><p>EOF和foef什么时候用呢？</p><p>EOF主要用于文本文件进行判断结尾。不适合或者说不适用于读取二进制文件。</p><p>foef则都可以使用。</p><p><strong>那么我到底应该怎么读取文件呢？</strong></p><p>下面这个应该是通用版本。无论是二进制还是文本。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>FILE <span style=color:#f92672>*</span>fp,<span style=color:#f92672>*</span>xx;
<span style=color:#66d9ef>int</span> c;
fp<span style=color:#f92672>=</span>fopen(<span style=color:#e6db74>&#34;/Users/kentxxq/test.txt&#34;</span>,<span style=color:#e6db74>&#34;rb&#34;</span>);
xx<span style=color:#f92672>=</span>fopen(<span style=color:#e6db74>&#34;/Users/kentxxq/xx.txt&#34;</span>,<span style=color:#e6db74>&#34;wb&#34;</span>);
<span style=color:#66d9ef>if</span>(fp<span style=color:#f92672>==</span>NULL) {
    printf(<span style=color:#e6db74>&#34;文件打开错误&#34;</span>);
}<span style=color:#66d9ef>else</span>{
    c <span style=color:#f92672>=</span> fgetc(fp);
    <span style=color:#66d9ef>if</span>(ferror(fp)){
        printf(<span style=color:#e6db74>&#34;文件读取失败！&#34;</span>);
    }<span style=color:#66d9ef>else</span>{
        <span style=color:#66d9ef>if</span>(feof(fp)){
            printf(<span style=color:#e6db74>&#34;这是一个空文件&#34;</span>);
        } <span style=color:#66d9ef>else</span>{
            <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>feof(fp)){
                printf(<span style=color:#e6db74>&#34;%c&#34;</span>,c);
                fputc(c, xx);
                c <span style=color:#f92672>=</span> fgetc(fp);
            }
        }
    }
}
</code></pre></div><h3 id=静态库和动态库>静态库和动态库</h3><p>其实我来学c相关的知识，最大的动力就是性能以及c/c++有很多的轮子。而我爱用Python，它与c结合非常紧密。</p><p><code>静态库</code>编译完成以后就不需要lib和头文件了，所以是打包到了一起。不方便增量更新、且编译速度会慢一些。</p><p><code>动态库</code>编译完成以后其实还是需要从指定的路径取引用库文件。二进制分发的你在通过包管理工具安装以后(例如sqlite)会在系统的include和lib之类的文件夹存放。源码则可以你自己通过编译放在系统或者自己指定的文件夹内。只要能引用到就好了。</p><p>windows下的静态库为<code>.lib</code>文件。如果需要使用它，就包含它的头文件。然后<code>#pragma comment(lib,"xxx.lib")</code>即可直接通过函数名调用。打包后的文件不再lib静态库。这是标准做法。</p><p>不过我在vs2019的实际操作中，略有不同。可参考<a href="https://docs.microsoft.com/zh-cn/cpp/build/walkthrough-creating-and-using-a-static-library-cpp?view=vs-2019">微软官方文档</a></p><p>类*unix静态库为<code>.a</code>文件。用法同上。</p><p>windows下的动态库为<code>.dll</code>文件。</p><p>动态库有2种用法。第一种是隐式调用。第二种是显式调用。注:隐式调用若主函数是C++程序,需要extern &ldquo;C&rdquo;{}包含被调用函数(add.c)的头文件。动态库的文档可以参考这个<a href="https://docs.microsoft.com/zh-cn/cpp/build/walkthrough-creating-and-using-a-dynamic-link-library-cpp?view=vs-2019">微软官方文档</a></p><ol><li><p>我现在常见的是通过<code>LoadLibrary</code>来直接加载dll文件，然后通过typedef来定义一个函数指针声明出被调用函数的返回类型和参数类型，最后通过<code>GetProcAddress</code>来指定内部函数名得到函数赋值给指针。可以看到我们需要有dll文件、函数名、函数指针声明函数。而python的ctypes通过把传入的参数一一转换成了c的对应类型，所以函数指针可以自己推断出来是什么样，而我们给ctypes提供了必要的dll地址和函数名。所以直接传参即可调用。如果传入的参数错误，就直接报错呗~</p></li><li><p>通过包含头文件、使用<code>#pragma comment(lib,"xxx.lib")</code>包含lib、以及dll，同静态库也直接通过函数名调用。这里的lib文件内部存放的是函数位置和索引。让程序在编译期间使用的。具体的函数体还是存放在dll中。</p></li></ol><p>所以动态库两种方法都说明，在打包完程序以后，依旧需要dll文件。</p><p>类*unix动态库为<code>.so</code>文件。则对应<code>dlopen</code>和<code>dlsym</code>来加载和指定函数名。其他原理相同。</p><p>我们也知道，windows一脉相承，提供比较强的兼容性。所以在windows上编译后的库，可以兼容多个windows版本。</p><p>而类*unix则不然。多数的做法都是在各个平台上各自编译后分发。</p><p>所以也就解决了我对如何使用别人代码库的疑惑。</p><ol><li>有源码就下载下来，编译以后你用静态库或者动态库的方式都取决于你。</li><li>别人通过二进制分发(注意选择对应平台的包)，除了dll也都会提供.h的头文件。如果只有一个dll呢？那你就对着文档写就一个头文件或者函数指针用。头文件其实和typedef函数指针的目的是一样的，让c/c++的代码能获取到函数的相关信息，从而正确编译。因此调用dll不用包含头文件也是可以的。只是如果别人做好了库给你用，肯定也会提供给你这个库的调用方法，不提供h头文件是他懒！</li></ol><h2 id=总结>总结</h2><p>在写这篇文章之前。好久没有写博客了。。偶尔更新一些影片记录而已。</p><p>最近也弄了一个域名邮箱，把联系地址改成了邮箱地址。</p><p>我大概看了1个月的c相关的东西。。才写完这点点东西。过程感觉还是很痛苦的，c语言很简单，但是经常会涉及到系统、编译、环境、调试方面的问题。但是写完以后觉得豁然开朗。对以后的编码也有了更加清晰的理解。</p><p>不得不说一句，微软的文档是真的强。。我正在准备彻底抛弃苹果，面向微软。。如果你看不懂这篇文章，取参考微软的文档。毕竟那是windows的标准文档啊，绝不会错！</p></div><div class=post-copyright><p class=copyright-item><span>Author:</span>
<span>kentxxq</span></p><p class=copyright-item><span>Link:</span>
<a href=https://kentxxq.com/contents/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/><script>document.write(decodeURI(location.origin+location.pathname))</script></a></p><p class="copyright-item lincese">本文采用<a rel=license href=http://creativecommons.org/licenses/by-nc/4.0/ target=_blank>知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p></div><div class=post-tags><section><i class="iconfont icon-tag"></i>Tag(s):
<span class=tag><a href=https://kentxxq.com/tags/c/>#c</a></span></section><section><a href=javascript:window.history.back();>back</a></span> ·
<span><a href=https://kentxxq.com/>home</a></span></section></div><div class=post-nav><a href=https://kentxxq.com/contents/%E6%88%91%E7%9A%84k8s%E4%B9%8B%E8%B7%AF1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/ class=prev rel=prev title=我的k8s之路1-基本概念><i class="iconfont icon-left"></i>&nbsp;我的k8s之路1-基本概念</a>
<a href=https://kentxxq.com/contents/%E8%A1%A5%E5%85%85%E4%B8%80%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%9F%A5%E8%AF%86/ class=next rel=next title=补充一些数据结构的知识>补充一些数据结构的知识&nbsp;<i class="iconfont icon-right"></i></a></div></article></div></main><footer class=footer><div style="text-align:center;width:600px;margin:0 auto;padding:20px 0"><a href=https://beian.miit.gov.cn/ target=_blank style=display:inline-block;text-decoration:none;height:20px;line-height:20px rel="external nofollow"><p style="float:left;height:20px;line-height:20px;margin:0 0 0 5px">湘ICP备2021002319号-1</p></a><a>&nbsp;&nbsp;&nbsp;&nbsp;</a>
<a target=_blank href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=43010402000934" style=display:inline-block;text-decoration:none;height:20px;line-height:20px><img src=/images/备案图标.png style=float:left><p style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">湘公网安备
43010402000934号</p></a></div></footer><link href=//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css rel=stylesheet><script src=/js/vendor_gallery.min.js async></script><script src=https://cdn.bootcss.com/mermaid/8.0.0-rc.8/mermaid.min.js></script></div></body></html>