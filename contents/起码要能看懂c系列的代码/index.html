<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>起码要能看懂c系列的代码 - 运维个人技术栈</title><meta name=Description content="之前在一些文章里面就有说过。程序员是绕不过JavaScript的，即使有时候会恶心到人。。而很多硬件的嵌入式开发，算法工程师，底层开发人员则真的可以做一辈子，而免疫JavaScript的侵扰。而JavaScript的每一个改动，都多多少少与c/c++有关。可以说大神们用c/c++构建了现在数字化的底层逻辑。比c更底层的，晦涩难懂且开发效率低下，甚至人写的代码经常不如c编译器优化后的代码。比c高级的，性能下降且概念繁多。和c同级别的，都没有c混得好。c是事实标准"><meta property="og:title" content="起码要能看懂c系列的代码"><meta property="og:description" content="之前在一些文章里面就有说过。程序员是绕不过JavaScript的，即使有时候会恶心到人。。而很多硬件的嵌入式开发，算法工程师，底层开发人员则真的可以做一辈子，而免疫JavaScript的侵扰。而JavaScript的每一个改动，都多多少少与c/c++有关。可以说大神们用c/c++构建了现在数字化的底层逻辑。比c更底层的，晦涩难懂且开发效率低下，甚至人写的代码经常不如c编译器优化后的代码。比c高级的，性能下降且概念繁多。和c同级别的，都没有c混得好。c是事实标准"><meta property="og:type" content="article"><meta property="og:url" content="https://kentxxq.com/contents/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-08-29T11:35:00+08:00"><meta property="article:modified_time" content="2021-08-23T00:57:19+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="起码要能看懂c系列的代码"><meta name=twitter:description content="之前在一些文章里面就有说过。程序员是绕不过JavaScript的，即使有时候会恶心到人。。而很多硬件的嵌入式开发，算法工程师，底层开发人员则真的可以做一辈子，而免疫JavaScript的侵扰。而JavaScript的每一个改动，都多多少少与c/c++有关。可以说大神们用c/c++构建了现在数字化的底层逻辑。比c更底层的，晦涩难懂且开发效率低下，甚至人写的代码经常不如c编译器优化后的代码。比c高级的，性能下降且概念繁多。和c同级别的，都没有c混得好。c是事实标准"><meta name=application-name content="kentxxq"><meta name=apple-mobile-web-app-title content="kentxxq"><meta name=theme-color content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://kentxxq.com/contents/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/><link rel=prev href=https://kentxxq.com/contents/%E6%88%91%E7%9A%84k8s%E4%B9%8B%E8%B7%AF1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/><link rel=next href=https://kentxxq.com/contents/%E8%A1%A5%E5%85%85%E4%B8%80%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%9F%A5%E8%AF%86/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/color.css><link rel=stylesheet href=/css/style.min.css><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/fontawesome-free/all.min.css><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/animate/animate.min.css><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"起码要能看懂c系列的代码","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/kentxxq.com\/contents\/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81\/"},"genre":"posts","keywords":"c","wordcount":7928,"url":"https:\/\/kentxxq.com\/contents\/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81\/","datePublished":"2019-08-29T11:35:00+08:00","dateModified":"2021-08-23T00:57:19+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"kentxxq"},"description":"之前在一些文章里面就有说过。程序员是绕不过JavaScript的，即使有时候会恶心到人。。而很多硬件的嵌入式开发，算法工程师，底层开发人员则真的可以做一辈子，而免疫JavaScript的侵扰。而JavaScript的每一个改动，都多多少少与c/c++有关。可以说大神们用c/c++构建了现在数字化的底层逻辑。比c更底层的，晦涩难懂且开发效率低下，甚至人写的代码经常不如c编译器优化后的代码。比c高级的，性能下降且概念繁多。和c同级别的，都没有c混得好。c是事实标准"}</script><script src=//instant.page/5.1.1 defer type=module integrity=sha384-MWfCL6g1OTGsbSwfuMHc8+8J2u71/LA8dzlIN3ycajckxuZZmF+DNjdm7O6H3PSq></script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>function setTheme(e){document.body.setAttribute("theme",e),document.documentElement.style.setProperty("color-scheme",e==="light"?"light":"dark"),window.theme=e,window.isDark=window.theme!=="light"}function saveTheme(e){window.localStorage&&localStorage.setItem("theme",e)}function getMeta(e){const t=document.getElementsByTagName("meta");for(let n=0;n<t.length;n++)if(t[n].getAttribute("name")===e)return t[n];return""}if(window.localStorage&&localStorage.getItem("theme")){let e=localStorage.getItem("theme");e==="light"||e==="dark"||e==="black"?setTheme(e):setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")}else""==="light"||""==="dark"||""==="black"?(setTheme(""),saveTheme("")):(saveTheme("auto"),setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"));let metaColors={light:"#f8f8f8",dark:"#252627",black:"#000000"};getMeta("theme-color").content=metaColors[document.body.getAttribute("theme")],window.switchThemeEventSet=new Set</script><div id=back-to-top></div><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=运维个人技术栈>运维个人技术栈</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>Blog </a><a class=menu-item href=/categories/>Categories </a><a class=menu-item href=/tags/>Tags </a><a class=menu-item href=/about/>About </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=# class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=# class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span>
</span><a href=# class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=运维个人技术栈>运维个人技术栈</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=# class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=# class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=# class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title>Blog</a><a class=menu-item href=/categories/ title>Categories</a><a class=menu-item href=/tags/ title>Tags</a><a class=menu-item href=/about/ title>About</a><a href=# class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto><nav id=TableOfContents><ul><li><a href=#前言>前言</a></li><li><a href=#基本了解>基本了解</a><ul><li><a href=#类型>类型</a></li><li><a href=#函数部分>函数部分</a></li><li><a href=#预处理命令>预处理命令</a></li><li><a href=#指针>指针</a></li><li><a href=#结构体>结构体</a></li><li><a href=#动态分配>动态分配</a></li><li><a href=#typedef>typedef</a></li><li><a href=#位运算>位运算</a></li><li><a href=#文件操作>文件操作</a></li></ul></li><li><a href=#编译>编译</a><ul><li><a href=#linux>linux</a></li><li><a href=#mac>mac</a></li><li><a href=#windows>windows</a></li></ul></li><li><a href=#难点>难点</a><ul><li><a href=#指针数组和数组指针>指针数组和数组指针</a></li><li><a href=#第一点c中没有字符串类型字符串是由字符数组组成以0结尾字符串又有2个声明的方式>第一点，c中没有字符串类型。字符串是由字符数组组成，以\0结尾。字符串又有2个声明的方式。</a></li><li><a href=#第二点要彻底了解的是数组作为参数的传递>第二点，要彻底了解的是<strong>数组作为参数的传递</strong>。</a></li><li><a href=#第三点再来说一下我自己理解错误>第三点，再来说一下我自己理解错误。</a></li><li><a href=#文件读取>文件读取</a></li><li><a href=#代码示例>代码示例</a></li><li><a href=#eof和feof>EOF和feof</a></li><li><a href=#静态库和动态库>静态库和动态库</a></li></ul></li><li><a href=#总结>总结</a></li></ul></nav></div></div><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC","true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">起码要能看懂c系列的代码</h1><div class=post-meta><div class=post-meta-line><span class=post-author><i class="author fas fa-user-circle fa-fw"></i><a href=https://kentxxq.com title=Author target=_blank rel="noopener noreferrer author" class=author>kentxxq</a>
</span>&nbsp;<span class=post-category>收录于 </span>&nbsp;<span class=post-category>类别 <a href=/categories/%E7%AC%94%E8%AE%B0/><i class="far fa-folder fa-fw"></i>笔记</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2019-08-29>2019-08-29</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime=2021-08-23>2021-08-23</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 7928 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 16 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#前言>前言</a></li><li><a href=#基本了解>基本了解</a><ul><li><a href=#类型>类型</a></li><li><a href=#函数部分>函数部分</a></li><li><a href=#预处理命令>预处理命令</a></li><li><a href=#指针>指针</a></li><li><a href=#结构体>结构体</a></li><li><a href=#动态分配>动态分配</a></li><li><a href=#typedef>typedef</a></li><li><a href=#位运算>位运算</a></li><li><a href=#文件操作>文件操作</a></li></ul></li><li><a href=#编译>编译</a><ul><li><a href=#linux>linux</a></li><li><a href=#mac>mac</a></li><li><a href=#windows>windows</a></li></ul></li><li><a href=#难点>难点</a><ul><li><a href=#指针数组和数组指针>指针数组和数组指针</a></li><li><a href=#第一点c中没有字符串类型字符串是由字符数组组成以0结尾字符串又有2个声明的方式>第一点，c中没有字符串类型。字符串是由字符数组组成，以\0结尾。字符串又有2个声明的方式。</a></li><li><a href=#第二点要彻底了解的是数组作为参数的传递>第二点，要彻底了解的是<strong>数组作为参数的传递</strong>。</a></li><li><a href=#第三点再来说一下我自己理解错误>第三点，再来说一下我自己理解错误。</a></li><li><a href=#文件读取>文件读取</a></li><li><a href=#代码示例>代码示例</a></li><li><a href=#eof和feof>EOF和feof</a></li><li><a href=#静态库和动态库>静态库和动态库</a></li></ul></li><li><a href=#总结>总结</a></li></ul></nav></div></div><div class=content id=content><blockquote><p>之前在一些文章里面就有说过。程序员是绕不过JavaScript的，即使有时候会恶心到人。。</p><p>而很多硬件的嵌入式开发，算法工程师，底层开发人员则真的可以做一辈子，而免疫JavaScript的侵扰。而JavaScript的每一个改动，都多多少少与c/c++有关。</p><p>可以说大神们用c/c++构建了现在数字化的底层逻辑。比c更底层的，晦涩难懂且开发效率低下，甚至人写的代码经常不如c编译器优化后的代码。比c高级的，性能下降概念繁多。和c同级别的，都没有c混得好。事实上c是事实标准。</p></blockquote><h2 id=前言 class=headerLink><a href=#%e5%89%8d%e8%a8%80 class=header-mark></a>前言</h2><p>如果你从来没有了解过编程，而想学习c。那么去搜新手教程慢慢上手。</p><p>如果你有其他编程的基础。这篇文章能用来让你快速了解c代码。可以在你不得不去看c代码的时候，看懂他的意图。</p><h2 id=基本了解 class=headerLink><a href=#%e5%9f%ba%e6%9c%ac%e4%ba%86%e8%a7%a3 class=header-mark></a>基本了解</h2><h3 id=类型 class=headerLink><a href=#%e7%b1%bb%e5%9e%8b class=header-mark></a>类型</h3><p>二进制的c表达，需要用代码实现</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># python用0b开头</span>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=mb>0b101</span>
</span></span></code></pre></td></tr></table></div></div><p>八进制</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// c用0开头
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>08</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># python用0o开头  数字0和字母o</span>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=mo>0o516</span>
</span></span></code></pre></td></tr></table></div></div><p>十六进制</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// c用0x开头
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mh>0x2A</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># python用0x开头</span>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=mh>0x2A</span>
</span></span></code></pre></td></tr></table></div></div><p>其中int是2个字节。long int是4个字节。</p><p>而float是4个字节。double是8个字节。long double是16个字节。注意在计算的时候，可能存在舍入误差。</p><p>char一个字符一个字节。</p><p>字符串则会比char多出来一个尾部的<code>\0</code>字节。</p><p>unsigned则代表没有符号位。例如int类型前面都会有一个符号位。没有符号位则会扩大int的可存储范围</p><p>附带补充一点知识。<figure><a class=lightgallery href=/images/c/C_%e8%a1%a5%e7%a0%81.png title=C_补码 data-thumbnail=/images/c/C_补码.png><img loading=lazy src=/images/c/C_%e8%a1%a5%e7%a0%81.png srcset="/images/c/C_%e8%a1%a5%e7%a0%81.png, /images/c/C_%e8%a1%a5%e7%a0%81.png 1.5x, /images/c/C_%e8%a1%a5%e7%a0%81.png 2x" sizes=auto alt=/images/c/C_补码.png></a></figure></p><p>数组</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=c1>// 10个长度，空位补0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>b</span><span class=p>[</span><span class=mi>10</span><span class=p>]</span><span class=o>=</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>,</span><span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// 自动检测到长度
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>b</span><span class=p>[]</span><span class=o>=</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>,</span><span class=mi>5</span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>而字符串就这样表示</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 长度会是4，因为后面还有一个\0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=n>c</span><span class=p>[]</span><span class=o>=</span><span class=s>&#34;C a&#34;</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>说几个常用的字符串函数吧</p><ol><li><code>strcat</code>合并</li><li><code>strcpy</code>拷贝</li><li><code>strcmp</code>比较</li><li><code>strlen</code>拿到字符串长度</li></ol><h3 id=函数部分 class=headerLink><a href=#%e5%87%bd%e6%95%b0%e9%83%a8%e5%88%86 class=header-mark></a>函数部分</h3><ol><li>函数其实没什么好说的。记得除了库函数(自带标准库),都要定义一下。才能用。</li><li>全局变量默认在静态存储区。</li><li>加了<code>static</code>的局部变量也在静态存储区。</li><li><code>register</code>的变量会放在寄存器，会提高性能。</li><li>外部变量用<code>extern</code>声明，则可以在代码中使用。</li></ol><h3 id=预处理命令 class=headerLink><a href=#%e9%a2%84%e5%a4%84%e7%90%86%e5%91%bd%e4%bb%a4 class=header-mark></a>预处理命令</h3><ol><li><code>#define PI 3.1415</code>用PI替代代码中的3.1415。<code>#undef PI</code>取消。</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 可以带参数。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define SQ(y) (y)*(y)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* 但注意扩起来。否则可能结果有误 */</span>
</span></span><span class=line><span class=cl><span class=cm>/* 例如sq=SQ(a+1)会变成sq=a+1*a+1 */</span>
</span></span></code></pre></td></tr></table></div></div><ol start=2><li><code>#include "stdio.h"</code>引入头文件。一般都用双引号先从当前目录查找。</li><li><code>#ifdef #else #endif</code>用来判断执行。<code>#if</code>则非0则为true。</li></ol><h3 id=指针 class=headerLink><a href=#%e6%8c%87%e9%92%88 class=header-mark></a>指针</h3><p>示例代码</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 声明int变量a和int指针*p
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span><span class=o>*</span><span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=o>=</span><span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// 把a的地址给p
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>p</span><span class=o>=&amp;</span><span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// 现在用*p即可取到a的值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>printf</span><span class=p>(</span><span class=err>&#39;</span><span class=o>%</span><span class=n>d</span><span class=err>&#39;</span><span class=p>,</span><span class=o>*</span><span class=n>p</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><ol><li>指针如果指向数组，则默认指向数组的第一个元素。可以通过<code>*(p+1)</code>取到第二个元素的值。字符串同理。</li><li>函数也是占用连续的内存段。则<code>int (*pf)();</code>代表指向一个返回值是int的函数。当指针赋值后，通过<code>(*pmax)(a)</code>调用。</li><li><code>int *ap(int x,int y)</code>代表返回指针。</li></ol><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td>int i;</td><td>定义整型变量 i</td></tr><tr><td>int *p;</td><td>p 为指向整型数据的指针变量</td></tr><tr><td>int a[n];</td><td>定义整型数组 a，它有 n 个元素</td></tr><tr><td>int *p[n];</td><td>定义指针数组 p，它由 n 个指向整型数据的指针元素组成</td></tr><tr><td>int (*p)[n];</td><td>p 为指向含 n 个元素的一维数组的指针变量</td></tr><tr><td>int f();</td><td>f 为带回整型函数值的函数</td></tr><tr><td>int *p();</td><td>p 为带回一个指针的函数，该指针指向整型数据</td></tr><tr><td>int (*p)();</td><td>p 为指向函数的指针，该函数返回一个整型值</td></tr><tr><td>int **p;</td><td>P 是一个指针变量，它指向一个指向整型数据的指针变量</td></tr></tbody></table><p>优先级为：()>[]>*。然后从左往右看。</p><h3 id=结构体 class=headerLink><a href=#%e7%bb%93%e6%9e%84%e4%bd%93 class=header-mark></a>结构体</h3><p>如果你理解了前面所说的指针，那么指针就会很好理解。其实就是一系列的基本类型放在一个连续的内存段中。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 声明一个结构体
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>human</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>num</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>name</span><span class=p>[</span><span class=mi>20</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>sex</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// human结构的变量
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>human</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>num</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=n>sex</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=n>boy</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// 5个human结构组成的数组变量
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>human</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>num</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=n>sex</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=n>boy</span><span class=p>[</span><span class=mi>5</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=c1>// 带上初始化的值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>human</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>num</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>sex</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=n>boy</span><span class=p>[</span><span class=mi>5</span><span class=p>]</span><span class=o>=</span><span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=p>{</span><span class=mi>101</span><span class=p>,</span><span class=s>&#34;Li ping&#34;</span><span class=p>,</span><span class=sc>&#39;M&#39;</span><span class=p>},</span>
</span></span><span class=line><span class=cl>          <span class=p>{</span><span class=mi>102</span><span class=p>,</span><span class=s>&#34;Zhang ping&#34;</span><span class=p>,</span><span class=sc>&#39;M&#39;</span><span class=p>},</span>
</span></span><span class=line><span class=cl>          <span class=p>{</span><span class=mi>103</span><span class=p>,</span><span class=s>&#34;He fang&#34;</span><span class=p>,</span><span class=sc>&#39;F&#39;</span><span class=p>},</span>
</span></span><span class=line><span class=cl>          <span class=p>{</span><span class=mi>104</span><span class=p>,</span><span class=s>&#34;Cheng ling&#34;</span><span class=p>,</span><span class=sc>&#39;F&#39;</span><span class=p>},</span>
</span></span><span class=line><span class=cl>          <span class=p>{</span><span class=mi>105</span><span class=p>,</span><span class=s>&#34;Wang ming&#34;</span><span class=p>,</span><span class=sc>&#39;M&#39;</span><span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>取值赋值:boy.num
数组类似普通数组:boy[i].num
指针:struct human *ph
指针取值:ph->num或(*ph).num</p><h3 id=动态分配 class=headerLink><a href=#%e5%8a%a8%e6%80%81%e5%88%86%e9%85%8d class=header-mark></a>动态分配</h3><p>很多时候不确定需要多大空间的时候，通过传参来实现。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 分配一个100字节长度字符数组，pc为指向这个字符数组
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>pc</span><span class=o>=</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=mi>100</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 分配2个struct human结构体的长度。ps为指针且指向这个数组
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ps</span><span class=o>=</span><span class=p>(</span><span class=n>struet</span> <span class=n>human</span><span class=o>*</span><span class=p>)</span><span class=nf>calloc</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>human</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=c1>// 接收指针变量，释放它
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>free</span><span class=p>(</span><span class=n>pc</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>free</span><span class=p>(</span><span class=n>ps</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=typedef class=headerLink><a href=#typedef class=header-mark></a>typedef</h3><p>用typedef加在struct前面，变量名写HUMAN，就可以用HUMAN h1,h2来声明变量了！简洁明了。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>int</span> <span class=n>INTEGER</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>INTEGER</span> <span class=n>a</span><span class=p>,</span><span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>char</span> <span class=n>NAME</span><span class=p>[</span><span class=mi>20</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=c1>// 在和预定义不同的是，这是在编译器进行的。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>NAME</span> <span class=n>a1</span><span class=p>,</span><span class=n>a2</span><span class=p>,</span><span class=n>s1</span><span class=p>,</span><span class=n>s2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// 等效
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=n>a1</span><span class=p>[</span><span class=mi>20</span><span class=p>],</span><span class=n>a2</span><span class=p>[</span><span class=mi>20</span><span class=p>],</span><span class=n>s1</span><span class=p>[</span><span class=mi>20</span><span class=p>],</span><span class=n>s2</span><span class=p>[</span><span class=mi>20</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=位运算 class=headerLink><a href=#%e4%bd%8d%e8%bf%90%e7%ae%97 class=header-mark></a>位运算</h3><p>位运算方面其实和其他语言的区别不大。看到应用最多的地方是权限方面的。自己对着文档看吧。我反正是觉得不好理解，不爱用。</p><h3 id=文件操作 class=headerLink><a href=#%e6%96%87%e4%bb%b6%e6%93%8d%e4%bd%9c class=header-mark></a>文件操作</h3><p>其实到了文件操作部分，就开始用前面学到的知识来进行延伸了。</p><ul><li><code>File *fp;</code>声明一个指针变量，文件类型。这并不是一个特殊的语法。我的mac上可以看到定义，是一个结构体。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span>	<span class=k>struct</span> <span class=n>__sFILE</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>_p</span><span class=p>;</span>	<span class=cm>/* current position in (some) buffer */</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span>	<span class=n>_r</span><span class=p>;</span>		<span class=cm>/* read space left for getc() */</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span>	<span class=n>_w</span><span class=p>;</span>		<span class=cm>/* write space left for putc() */</span>
</span></span><span class=line><span class=cl>	<span class=kt>short</span>	<span class=n>_flags</span><span class=p>;</span>		<span class=cm>/* flags, below; this FILE is free if 0 */</span>
</span></span><span class=line><span class=cl>	<span class=kt>short</span>	<span class=n>_file</span><span class=p>;</span>		<span class=cm>/* fileno, if Unix descriptor, else -1 */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span>	<span class=n>__sbuf</span> <span class=n>_bf</span><span class=p>;</span>	<span class=cm>/* the buffer (at least 1 byte, if !NULL) */</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span>	<span class=n>_lbfsize</span><span class=p>;</span>	<span class=cm>/* 0 or -_bf._size, for inline putc */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/* operations */</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span>	<span class=o>*</span><span class=n>_cookie</span><span class=p>;</span>	<span class=cm>/* cookie passed to io functions */</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span>	<span class=p>(</span><span class=o>*</span> <span class=n>_Nullable</span> <span class=n>_close</span><span class=p>)(</span><span class=kt>void</span> <span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span>	<span class=p>(</span><span class=o>*</span> <span class=n>_Nullable</span> <span class=n>_read</span><span class=p>)</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>fpos_t</span>	<span class=p>(</span><span class=o>*</span> <span class=n>_Nullable</span> <span class=n>_seek</span><span class=p>)</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>,</span> <span class=kt>fpos_t</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span>	<span class=p>(</span><span class=o>*</span> <span class=n>_Nullable</span> <span class=n>_write</span><span class=p>)(</span><span class=kt>void</span> <span class=o>*</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/* separate buffer for long sequences of ungetc() */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span>	<span class=n>__sbuf</span> <span class=n>_ub</span><span class=p>;</span>	<span class=cm>/* ungetc buffer */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>__sFILEX</span> <span class=o>*</span><span class=n>_extra</span><span class=p>;</span> <span class=cm>/* additions to FILE to not break ABI */</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span>	<span class=n>_ur</span><span class=p>;</span>		<span class=cm>/* saved _r when _r is counting ungetc data */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/* tricks to meet minimum requirements even when malloc() fails */</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>_ubuf</span><span class=p>[</span><span class=mi>3</span><span class=p>];</span>	<span class=cm>/* guarantee an ungetc() buffer */</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>_nbuf</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>	<span class=cm>/* guarantee a getc() buffer */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/* separate buffer for fgetln() when line crosses buffer boundary */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span>	<span class=n>__sbuf</span> <span class=n>_lb</span><span class=p>;</span>	<span class=cm>/* buffer for fgetln() */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/* Unix stdio files get aligned to block boundaries on fseek() */</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span>	<span class=n>_blksize</span><span class=p>;</span>	<span class=cm>/* stat.st_blksize (may be != _bf._size) */</span>
</span></span><span class=line><span class=cl>	<span class=kt>fpos_t</span>	<span class=n>_offset</span><span class=p>;</span>	<span class=cm>/* current lseek offset (see WARNING) */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>FILE</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p><code>fp=("/home/a.txt","r");</code>只读方式打开制定文件，后面的参数类似python。</p></li><li><p><code>ch=fgetc(fp);</code>取第一个字符赋值给ch。</p></li><li><p><code>fputc('a',fp);</code>弄一个字符串到到指针位置。</p></li><li><p><code>fgets(str,n,fp);</code>从fp中取n-1个字符(即字符串)到str这个char数组中。为什么是n-1(一般也是str长度-1)，因为字符串后面要有一个&rsquo;\0&rsquo;啊！ 它读取到换行符或者文件结尾会停止。
str这个数组我试过几个不同的大小。发现4096(4k)是一个门槛，小于它可能会影响性能。而我看到python默认使用的是系统buffer大小8192(8k即2个block)。现在的文件系统多数都是4k为一个block，而io一般最少存取一个block。那么设置成2个block，也有助于更快的对下一个block数据块进行操作，而更大的话就没有太大意义了，可能会浪费磁盘io导致占用过多的资源。</p></li><li><p><code>fputs(“abcd“,fp);</code>把字符串放到指针位置。这里传递的是字符串，其实传递的就是字符数组首地址。所以如果是char *b=&ldquo;abcd"要进行传递，直接传递fputs(b,fp)即可！</p></li><li><p><code>fread(qq,sizeof(struct stu),2,fp);</code>qq是一个指针，表示数据的首地址(在这里指向一个stu结构体)，qq+1会移动到第二个stu结构体。第二个是数据块的大小,第三个是读取几个数据块，fp是文件指针。</p></li><li><p><code>fwrite(qq,sizeof(struct stu),2,fp);</code>参数同上，只不过是写数据。</p></li><li><p><code>fscanf(fp,"%d %s",&amp;i,s);</code>和<code>fprintf(fp,"%d %c",j,ch);</code>用来通过第二个参数指定的方式，存放或者打印数据。主义第二个参数中的空格也是会生效的！</p></li><li><p><code>rewind</code>函数把文件指针重新指向头部。</p></li><li><p><code>fseek(fp,100L,0);</code>类似python的指针偏移。0文件首地址，1当前位置，2文件末尾。常量表示偏移量必须带上&rsquo;L&rsquo;。移动到离文件首100字节距离的位置。也可以直接填写数字。负号前移，正号后移。</p></li></ul><p><strong>最后说明</strong>EOF是一个隐藏字符。在读取完了数据以后，才会遇到EOF。</p><p>而feof()是通过返回错误来判断是否结束。所以需要先取值，后判断。遇到了EOF(即-1)就会出错。停止下一个循环。</p><p>0是false，非0位true。</p><h2 id=编译 class=headerLink><a href=#%e7%bc%96%e8%af%91 class=header-mark></a>编译</h2><p>简单来说，编译就是使用<code>gcc</code>,<code>make</code>,<code>cmake</code>等工具来进行的。</p><p>如果使用vs或者clion这样的工具，需要了解的是工具的使用方法。而下面我要简单说明的是手工编译。</p><ol><li>在项目目录下新建build文件夹。</li><li>进入build文件夹使用<code>cmake ..</code>生成Makefile</li><li>运行make命令编译成功，找到输出文件即可。</li></ol><h3 id=linux class=headerLink><a href=#linux class=header-mark></a>linux</h3><p>我在centos7上运行<code>gcc</code>,<code>make</code>,<code>cmake</code>都可以正常使用。</p><h3 id=mac class=headerLink><a href=#mac class=header-mark></a>mac</h3><p>用brew安装cmake后，也可以跑通。</p><h3 id=windows class=headerLink><a href=#windows class=header-mark></a>windows</h3><p>我是用的<a href=https://scoop.sh/ target=_blank rel="noopener noreferrer">scoop</a>安装cmake。</p><p>然后安装最新的vs。下载<code>mingw-get</code>，然后安装<code>mingw32-make</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>cmake -G   <span class=s2>&#34;MinGW Makefiles&#34;</span> . <span class=c1># .为当前目录, &#34;MinGW Makefiles&#34;为makefile类型，如果编译器为vs的话使用&#34;NMake Makefiles&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>看到了Makefile后mingw32-make即可。</p><h2 id=难点 class=headerLink><a href=#%e9%9a%be%e7%82%b9 class=header-mark></a>难点</h2><p>记录一下难以理解的地方。</p><h3 id=指针数组和数组指针 class=headerLink><a href=#%e6%8c%87%e9%92%88%e6%95%b0%e7%bb%84%e5%92%8c%e6%95%b0%e7%bb%84%e6%8c%87%e9%92%88 class=header-mark></a>指针数组和数组指针</h3><p>在看书的时候，了解到main函数可以接受2个参数。而main函数不能被其他函数调用(有一些编译器不管你这么多，也能编译通过。但是制定标准的委员会明确表明了<strong>不行</strong>)。</p><p><code>int argc</code>代表单数的个数。包括程序自己本身。</p><p><code>char *argv[]</code>代表一个指向字符串的指针数组。</p><p>先说一下我之前的<strong>错误想法</strong>吧。</p><p>一个指针数组。那么我拿到的就是一个数组。</p><p>那么我应该先用<code>argv[i]</code>拿到数组中的第i个指针。然后如何取值呢？用<code>*(argv[i])</code>取第一个值。可是报错了。</p><p>那么我的理解错误在哪呢？下面用<code>./helloworld a=1</code>来举例。</p><h3 id=第一点c中没有字符串类型字符串是由字符数组组成以0结尾字符串又有2个声明的方式 class=headerLink><a href=#%e7%ac%ac%e4%b8%80%e7%82%b9c%e4%b8%ad%e6%b2%a1%e6%9c%89%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%b1%bb%e5%9e%8b%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%98%af%e7%94%b1%e5%ad%97%e7%ac%a6%e6%95%b0%e7%bb%84%e7%bb%84%e6%88%90%e4%bb%a50%e7%bb%93%e5%b0%be%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%8f%88%e6%9c%892%e4%b8%aa%e5%a3%b0%e6%98%8e%e7%9a%84%e6%96%b9%e5%bc%8f class=header-mark></a>第一点，c中没有字符串类型。字符串是由字符数组组成，以\0结尾。字符串又有2个声明的方式。</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//可以修改指针的地址，但是无法修改原有的值。存储在内存只读段。只要程序在运行，那么就不会释放。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=o>*</span><span class=n>a</span><span class=o>=</span><span class=s>&#34;hehe&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>//可以修改。在函数内接收，用完就会释放掉。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=n>b</span><span class=p>[]</span><span class=o>=</span><span class=s>&#34;hehe&#34;</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>c是如何读取字符串的呢？</p><p>在c语言中，指向字符和指向字符串的区别只是在于取值，根本就没有指向字符串的指针。从字符串(字符数组)的首地址开始取值，一直到\0结束，那么这个字符串就读完了。</p><p>于是根据例子，系统传递给main函数的就是2个字符数组。也就变成了传递1个包含有2个char*类型指针的指针数组即可。取第n个值，就从数组中第n个指针所指向的地址取值到\0即可。</p><p>所以<code>printf("%s",*a)</code>中。*a取到的值&rsquo;h&rsquo;。而printf中指明了要取一个字符串。所以它打印的结果会一直读到\0才会停止。</p><h3 id=第二点要彻底了解的是数组作为参数的传递 class=headerLink><a href=#%e7%ac%ac%e4%ba%8c%e7%82%b9%e8%a6%81%e5%bd%bb%e5%ba%95%e4%ba%86%e8%a7%a3%e7%9a%84%e6%98%af%e6%95%b0%e7%bb%84%e4%bd%9c%e4%b8%ba%e5%8f%82%e6%95%b0%e7%9a%84%e4%bc%a0%e9%80%92 class=header-mark></a>第二点，要彻底了解的是<strong>数组作为参数的传递</strong>。</h3><ol><li>我的main会得到一个长度为2的数组。如果用户还输入了b=2，c=3呢？我的的程序是无法预测到用户参数的具体个数。所以main函数无法写死数组长度，所以还会有一个<code>int argc</code>参数告诉我才行。</li><li>数组在传递的时候，传递的只是首地址。用一小段代码来理解一下发生了什么。</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>test3</span><span class=p>(</span><span class=kt>int</span> <span class=n>ac</span><span class=p>,</span><span class=kt>char</span> <span class=n>av</span><span class=p>[]){</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>av</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>ac</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%c&#34;</span><span class=p>,</span><span class=n>av</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>test4</span><span class=p>(</span><span class=kt>char</span> <span class=n>a</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=o>&amp;</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>test5</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>qt</span><span class=p>[]){</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>qt</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>p</span><span class=o>=</span><span class=sc>&#39;p&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=o>&amp;</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>test4</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>pch</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;pch&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pch</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>test3</span><span class=p>(</span><span class=nf>strlen</span><span class=p>(</span><span class=n>pch</span><span class=p>),</span> <span class=n>pch</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>qq</span><span class=p>[]</span><span class=o>=</span><span class=p>{</span><span class=s>&#34;q&#34;</span><span class=p>,</span><span class=s>&#34;w&#34;</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>**</span><span class=n>qq2</span><span class=o>=</span><span class=n>qq</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>qq</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>test5</span><span class=p>(</span><span class=n>qq</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 结果
</span></span></span><span class=line><span class=cl><span class=c1>// 0x7ffee0afc77f
</span></span></span><span class=line><span class=cl><span class=c1>// 0x7ffee0afc75f
</span></span></span><span class=line><span class=cl><span class=c1>// 0x7ffee0afc77b
</span></span></span><span class=line><span class=cl><span class=c1>// 0x7ffee0afc77b
</span></span></span><span class=line><span class=cl><span class=c1>// pch
</span></span></span><span class=line><span class=cl><span class=c1>// 0x7ffee81d0770
</span></span></span><span class=line><span class=cl><span class=c1>// 0x7ffee81d0770
</span></span></span></code></pre></td></tr></table></div></div><p><strong>先看test3和test4的结果</strong>。</p><p>可以发现2个变量的数据存在不同的内存区域，char类型传递的是<code>具体值</code>，也就是给形参a赋值。也即是我在test4中修改a的值，不会影响到p的值。</p><p>test3中2个变量的数据为同一内存区域，数组类型传递的是<code>值的地址</code>，也就是让av也指向pch所指向的地方，于是相同的地址指向同一个值。当我使用*av修改值，对应的pch值也会变动。</p><p>而通过打印，我们会知道。地址指向字符串(字符数组)第一个char。可以用*av直接取值。</p><p><strong>C语言规定，数组名代表数组的首地址，也就是第0号元素的地址</strong>。说明我们在声明了pch以后，就可以把数组名pch看成是一个指针。</p><p>那么我们在test3函数中，形参也可以写成char *av(你可以验证看)。</p><p><strong>再看test5的结果。发现地址也是一样的</strong>。</p><p>同理就可以推断出，传递的是地址，所以qt是指针类型。根据结果，指针数组传递的就是第一个指针所指向值的地址。直接*qt即可取值。</p><p>前面在传递数组的时候，数组名代表着一个指针。同样在传递指针数组的时候，数组名就是第一个元素的地址，而第一个元素是指针。所以数组名qt是指针的指针！</p><p>那么我们在test5函数中，形参也可以写成char **qt(char **qq2=qq也侧面验证了<code>char**类型</code>接收数组变量名qq)。这也是为什么main函数中char *argv[]也可以写的char **argv的原因了！</p><p>得到结论：数组在传递的时候，形参char*和char[]等效。char**与char *[]等效。</p><p>同时也说明，数组[i]只不过是指针的一个语法糖，相当于*(指针+i)。</p><p>所以取值如下：</p><p><code>char **qt</code>强调自己是指针。取值常用<code>**qt</code>。</p><p><code>char *qt[]</code>强调自己是数组。取值常用<code>qt[0]</code>。</p><p>虽然你的形参是<code>char **qt</code>也可以用<code>qt[0]</code>取值。但是不方便理解，且容易出错。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 你的第一感觉应该是用**rrr取值。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=n>r</span><span class=o>=</span><span class=sc>&#39;a&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span><span class=n>rr</span><span class=o>=&amp;</span><span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=o>**</span><span class=n>rrr</span><span class=o>=&amp;</span><span class=n>rr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// 下面报错
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>rrr</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=c1>// 说明要分情况的，char **qt不等同于char *qt[]
</span></span></span></code></pre></td></tr></table></div></div><h3 id=第三点再来说一下我自己理解错误 class=headerLink><a href=#%e7%ac%ac%e4%b8%89%e7%82%b9%e5%86%8d%e6%9d%a5%e8%af%b4%e4%b8%80%e4%b8%8b%e6%88%91%e8%87%aa%e5%b7%b1%e7%90%86%e8%a7%a3%e9%94%99%e8%af%af class=header-mark></a>第三点，再来说一下我自己理解错误。</h3><p>由于之前所接触到的语言，基本的逻辑都是面向对象且没有指针。都是值传递，而不是地址传递。</p><p>写过一篇go语言的文章，可我没有深入了解过它的指针。经过翻查，发现go在数组传递的时候也是值传递。在go中，指针是为了减少性能开销存在的。而很少见到有人做指针运算。</p><p>而c的指针贯穿了整个语言。在进行值传递的时候，形参可以拿到所有信息，因为要进行赋值操作。值传递会让变量名直接取到值。</p><p>而地址传递只有一个地址和类型，需要用到取值符*。且在一个指针指向数组的时候*p和p[0]等价。</p><p>只有搞清楚传递的过程中是值还是地址，才能正确的分析问题。</p><h3 id=文件读取 class=headerLink><a href=#%e6%96%87%e4%bb%b6%e8%af%bb%e5%8f%96 class=header-mark></a>文件读取</h3><h3 id=代码示例 class=headerLink><a href=#%e4%bb%a3%e7%a0%81%e7%a4%ba%e4%be%8b class=header-mark></a>代码示例</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*文本内容如下
</span></span></span><span class=line><span class=cl><span class=cm>123
</span></span></span><span class=line><span class=cl><span class=cm>哈哈
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* 下面这段代码会正确打印文本内容直到结束 */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>str3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>((</span><span class=n>str3</span> <span class=o>=</span> <span class=nf>fgetc</span><span class=p>(</span><span class=n>f1</span><span class=p>))</span> <span class=o>!=</span> <span class=n>EOF</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%c&#34;</span><span class=p>,</span> <span class=n>str3</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* 下面这段代码会多打印一个奇怪的问号符 */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>str2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>str2</span> <span class=o>!=</span> <span class=n>EOF</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>str2</span> <span class=o>=</span> <span class=nf>fgetc</span><span class=p>(</span><span class=n>f1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%c&#34;</span><span class=p>,</span> <span class=n>str2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* 下面这段代码会把最后的哈哈打印两次 */</span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=n>str</span><span class=p>[</span><span class=mi>4096</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=nf>feof</span><span class=p>(</span><span class=n>f1</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>fgets</span><span class=p>(</span><span class=n>str</span><span class=p>,</span> <span class=mi>4096</span><span class=p>,</span> <span class=n>f1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s&#34;</span><span class=p>,</span> <span class=n>str</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>下面来说说为什么。</p><ol><li>先看第一个。首先把数据用fgetc取出，然后判断是否为EOF，选择是否打印。没毛病。</li><li>第二个则是先判断是否为EOF，当我们读取到&rsquo;哈&rsquo;的时候，先打印出来。然后再判断依旧!=EOF，就会导致把EOF读取出来后进行了打印。</li><li>feof是通过返回错误<code>-1</code>来停止循环的。所以在使用的时候先进行读取。在循环了2次以后，feof仍然没有收到错误信息。第三次循环的时候fgets其实没有读取到数据。但是下面的语句还是得要执行。</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* 改成这样，最后一次读取到了错误，但是下面没有代码了，什么都没发生。循环条件进行判断后跳出循环。 */</span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=n>str</span><span class=p>[</span><span class=mi>4096</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>c</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>fgets</span><span class=p>(</span><span class=n>str</span><span class=p>,</span> <span class=mi>4096</span><span class=p>,</span> <span class=n>f1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>feof</span><span class=p>(</span><span class=n>f1</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;空文件</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=nf>feof</span><span class=p>(</span><span class=n>f1</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s&#34;</span><span class=p>,</span> <span class=n>str</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>fgets</span><span class=p>(</span><span class=n>str</span><span class=p>,</span> <span class=mi>4096</span><span class=p>,</span> <span class=n>f1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=eof和feof class=headerLink><a href=#eof%e5%92%8cfeof class=header-mark></a>EOF和feof</h3><p>EOF和foef什么时候用呢？</p><p>EOF主要用于文本文件进行判断结尾。不适合或者说不适用于读取二进制文件。</p><p>foef则都可以使用。</p><p><strong>那么我到底应该怎么读取文件呢？</strong></p><p>下面这个应该是通用版本。无论是二进制还是文本。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>FILE</span> <span class=o>*</span><span class=n>fp</span><span class=p>,</span><span class=o>*</span><span class=n>xx</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>fp</span><span class=o>=</span><span class=nf>fopen</span><span class=p>(</span><span class=s>&#34;/Users/kentxxq/test.txt&#34;</span><span class=p>,</span><span class=s>&#34;rb&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>xx</span><span class=o>=</span><span class=nf>fopen</span><span class=p>(</span><span class=s>&#34;/Users/kentxxq/xx.txt&#34;</span><span class=p>,</span><span class=s>&#34;wb&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span><span class=p>(</span><span class=n>fp</span><span class=o>==</span><span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;文件打开错误&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>c</span> <span class=o>=</span> <span class=nf>fgetc</span><span class=p>(</span><span class=n>fp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=nf>ferror</span><span class=p>(</span><span class=n>fp</span><span class=p>)){</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;文件读取失败！&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span><span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=nf>feof</span><span class=p>(</span><span class=n>fp</span><span class=p>)){</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;这是一个空文件&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=nf>feof</span><span class=p>(</span><span class=n>fp</span><span class=p>)){</span>
</span></span><span class=line><span class=cl>                <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%c&#34;</span><span class=p>,</span><span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=nf>fputc</span><span class=p>(</span><span class=n>c</span><span class=p>,</span> <span class=n>xx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>c</span> <span class=o>=</span> <span class=nf>fgetc</span><span class=p>(</span><span class=n>fp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=静态库和动态库 class=headerLink><a href=#%e9%9d%99%e6%80%81%e5%ba%93%e5%92%8c%e5%8a%a8%e6%80%81%e5%ba%93 class=header-mark></a>静态库和动态库</h3><p>其实我来学c相关的知识，最大的动力就是性能以及c/c++有很多的轮子。而我爱用Python，它与c结合非常紧密。</p><p><code>静态库</code>编译完成以后就不需要lib和头文件了，所以是打包到了一起。不方便增量更新、且编译速度会慢一些。</p><p><code>动态库</code>编译完成以后其实还是需要从指定的路径取引用库文件。二进制分发的你在通过包管理工具安装以后(例如sqlite)会在系统的include和lib之类的文件夹存放。源码则可以你自己通过编译放在系统或者自己指定的文件夹内。只要能引用到就好了。</p><p>windows下的静态库为<code>.lib</code>文件。如果需要使用它，就包含它的头文件。然后<code>#pragma comment(lib,"xxx.lib")</code>即可直接通过函数名调用。打包后的文件不再lib静态库。这是标准做法。</p><p>不过我在vs2019的实际操作中，略有不同。可参考<a href="https://docs.microsoft.com/zh-cn/cpp/build/walkthrough-creating-and-using-a-static-library-cpp?view=vs-2019" target=_blank rel="noopener noreferrer">微软官方文档</a></p><p>类*unix静态库为<code>.a</code>文件。用法同上。</p><p>windows下的动态库为<code>.dll</code>文件。</p><p>动态库有2种用法。第一种是隐式调用。第二种是显式调用。注:隐式调用若主函数是C++程序,需要extern &ldquo;C&rdquo;{}包含被调用函数(add.c)的头文件。动态库的文档可以参考这个<a href="https://docs.microsoft.com/zh-cn/cpp/build/walkthrough-creating-and-using-a-dynamic-link-library-cpp?view=vs-2019" target=_blank rel="noopener noreferrer">微软官方文档</a></p><ol><li><p>我现在常见的是通过<code>LoadLibrary</code>来直接加载dll文件，然后通过typedef来定义一个函数指针声明出被调用函数的返回类型和参数类型，最后通过<code>GetProcAddress</code>来指定内部函数名得到函数赋值给指针。可以看到我们需要有dll文件、函数名、函数指针声明函数。而python的ctypes通过把传入的参数一一转换成了c的对应类型，所以函数指针可以自己推断出来是什么样，而我们给ctypes提供了必要的dll地址和函数名。所以直接传参即可调用。如果传入的参数错误，就直接报错呗~</p></li><li><p>通过包含头文件、使用<code>#pragma comment(lib,"xxx.lib")</code>包含lib、以及dll，同静态库也直接通过函数名调用。这里的lib文件内部存放的是函数位置和索引。让程序在编译期间使用的。具体的函数体还是存放在dll中。</p></li></ol><p>所以动态库两种方法都说明，在打包完程序以后，依旧需要dll文件。</p><p>类*unix动态库为<code>.so</code>文件。则对应<code>dlopen</code>和<code>dlsym</code>来加载和指定函数名。其他原理相同。</p><p>我们也知道，windows一脉相承，提供比较强的兼容性。所以在windows上编译后的库，可以兼容多个windows版本。</p><p>而类*unix则不然。多数的做法都是在各个平台上各自编译后分发。</p><p>所以也就解决了我对如何使用别人代码库的疑惑。</p><ol><li>有源码就下载下来，编译以后你用静态库或者动态库的方式都取决于你。</li><li>别人通过二进制分发(注意选择对应平台的包)，除了dll也都会提供.h的头文件。如果只有一个dll呢？那你就对着文档写就一个头文件或者函数指针用。头文件其实和typedef函数指针的目的是一样的，让c/c++的代码能获取到函数的相关信息，从而正确编译。因此调用dll不用包含头文件也是可以的。只是如果别人做好了库给你用，肯定也会提供给你这个库的调用方法，不提供h头文件是他懒！</li></ol><h2 id=总结 class=headerLink><a href=#%e6%80%bb%e7%bb%93 class=header-mark></a>总结</h2><p>在写这篇文章之前。好久没有写博客了。。偶尔更新一些影片记录而已。</p><p>最近也弄了一个域名邮箱，把联系地址改成了邮箱地址。</p><p>我大概看了1个月的c相关的东西。。才写完这点点东西。过程感觉还是很痛苦的，c语言很简单，但是经常会涉及到系统、编译、环境、调试方面的问题。但是写完以后觉得豁然开朗。对以后的编码也有了更加清晰的理解。</p><p>不得不说一句，微软的文档是真的强。。我正在准备彻底抛弃苹果，面向微软。。如果你看不懂这篇文章，取参考微软的文档。毕竟那是windows的标准文档啊，绝不会错！</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2021-08-23</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=# title="分享到 Twitter" data-sharer=twitter data-url=https://kentxxq.com/contents/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/ data-title=起码要能看懂c系列的代码 data-hashtags=c><i class="fab fa-twitter fa-fw"></i></a><a href=# title="分享到 Facebook" data-sharer=facebook data-url=https://kentxxq.com/contents/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/ data-hashtag=c><i class="fab fa-facebook-square fa-fw"></i></a><a href=# title="分享到 WhatsApp" data-sharer=whatsapp data-url=https://kentxxq.com/contents/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/ data-title=起码要能看懂c系列的代码 data-web><i class="fab fa-whatsapp fa-fw"></i></a><a href=# title="分享到 Line" data-sharer=line data-url=https://kentxxq.com/contents/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/ data-title=起码要能看懂c系列的代码><i data-svg-src=/lib/simple-icons/icons/line.min.svg></i></a><a href=# title="分享到 微博" data-sharer=weibo data-url=https://kentxxq.com/contents/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/ data-title=起码要能看懂c系列的代码><i class="fab fa-weibo fa-fw"></i></a><a href=# title="分享到 Myspace" data-sharer=myspace data-url=https://kentxxq.com/contents/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/ data-title=起码要能看懂c系列的代码 data-description=之前在一些文章里面就有说过。程序员是绕不过JavaScript的，即使有时候会恶心到人。。而很多硬件的嵌入式开发，算法工程师，底层开发人员则真的可以做一辈子，而免疫JavaScript的侵扰。而JavaScript的每一个改动，都多多少少与c/c++有关。可以说大神们用c/c++构建了现在数字化的底层逻辑。比c更底层的，晦涩难懂且开发效率低下，甚至人写的代码经常不如c编译器优化后的代码。比c高级的，性能下降且概念繁多。和c同级别的，都没有c混得好。c是事实标准><i data-svg-src=/lib/simple-icons/icons/myspace.min.svg></i></a><a href=# title="分享到 Blogger" data-sharer=blogger data-url=https://kentxxq.com/contents/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/ data-title=起码要能看懂c系列的代码 data-description=之前在一些文章里面就有说过。程序员是绕不过JavaScript的，即使有时候会恶心到人。。而很多硬件的嵌入式开发，算法工程师，底层开发人员则真的可以做一辈子，而免疫JavaScript的侵扰。而JavaScript的每一个改动，都多多少少与c/c++有关。可以说大神们用c/c++构建了现在数字化的底层逻辑。比c更底层的，晦涩难懂且开发效率低下，甚至人写的代码经常不如c编译器优化后的代码。比c高级的，性能下降且概念繁多。和c同级别的，都没有c混得好。c是事实标准><i class="fab fa-blogger fa-fw"></i></a><a href=# title="分享到 Evernote" data-sharer=evernote data-url=https://kentxxq.com/contents/%E8%B5%B7%E7%A0%81%E8%A6%81%E8%83%BD%E7%9C%8B%E6%87%82c%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81/ data-title=起码要能看懂c系列的代码><i class="fab fa-evernote fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/c/>c</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/contents/%E6%88%91%E7%9A%84k8s%E4%B9%8B%E8%B7%AF1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/ class=prev rel=prev title=我的k8s之路1-基本概念><i class="fas fa-angle-left fa-fw"></i>我的k8s之路1-基本概念</a>
<a href=/contents/%E8%A1%A5%E5%85%85%E4%B8%80%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%9F%A5%E8%AF%86/ class=next rel=next title=补充一些数据结构的知识>补充一些数据结构的知识<i class="fas fa-angle-right fa-fw"></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>1993 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://kentxxq.com target=_blank rel="noopener noreferrer">kentxxq</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a> | <a target=_blank href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=43010402000934"><img src=/备案图标.png style=display:inline-block>湘公网安备 43010402000934号</a></span><span class=icp-splitter>&nbsp;|&nbsp;</span><br class=icp-br><span class=icp><a target=_blank href=https://beian.miit.gov.cn>湘ICP备2021002319号-1</a></span></div><div class=footer-line></div><div class=footer-line></div></div><script>"serviceWorker"in navigator&&(navigator.serviceWorker.register("/sw.min.js",{scope:"/"}).then(function(){}),navigator.serviceWorker.ready.then(function(){}))</script></footer></div><div id=fixed-buttons><a href=#back-to-top id=back-to-top-button class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><div class=assets><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/katex/copy-tex.min.css><noscript><link rel=stylesheet href=/lib/katex/copy-tex.min.css></noscript><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:18},comment:{},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{distance:100,findAllMatches:!1,highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:50,threshold:.3,useExtendedSearch:!1},sharerjs:!0,twemoji:!0}</script><script type=text/javascript src=/lib/twemoji/twemoji.min.js defer></script><script type=text/javascript src=/js/twemoji.min.js defer></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js defer></script><script type=text/javascript src=/lib/katex/auto-render.min.js defer></script><script type=text/javascript src=/lib/katex/copy-tex.min.js defer></script><script type=text/javascript src=/lib/katex/mhchem.min.js defer></script><script type=text/javascript src=/js/katex.min.js defer></script><script type=text/javascript src=/js/theme.min.js defer></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-131319987-1",{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=UA-131319987-1" async></script></div></body></html>