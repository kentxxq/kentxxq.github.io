<!doctype html><html lang=zh><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-131319987-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','UA-131319987-1')</script><meta name=author content="kentxxq"><meta name=keywords content="k8s kubectl kubernetes Pod Deployments ReplicaSet Job Cronjob DaemonSet"><meta name=description content="这是k8s的第二篇，但是已经时隔一年了。也不知道是k8s变化了，还是我之前的理解不够正确。不过我看了一眼，觉得上一篇写的一些内容，还是比较浅显易懂的，作为入门速览还不错。不过从这一篇开始，要好好抠细节了"><meta property="og:title" content="我的k8s之路2-应用部署"><meta property="og:description" content="这是k8s的第二篇，但是已经时隔一年了。也不知道是k8s变化了，还是我之前的理解不够正确。不过我看了一眼，觉得上一篇写的一些内容，还是比较浅显易懂的，作为入门速览还不错。不过从这一篇开始，要好好抠细节了"><meta property="og:type" content="article"><meta property="og:url" content="https://kentxxq.com/contents/%E6%88%91%E7%9A%84k8s%E4%B9%8B%E8%B7%AF2-%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-08-01T11:08:00+08:00"><meta property="article:modified_time" content="2021-02-26T00:06:04+08:00"><link rel=prev href=https://kentxxq.com/contents/linux%E4%B9%8Blimit%E9%99%90%E5%88%B6/><link rel=next href=https://kentxxq.com/contents/%E6%88%91%E7%9A%84k8s%E4%B9%8B%E8%B7%AF0-%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/><link rel=canonical href=https://kentxxq.com/contents/%E6%88%91%E7%9A%84k8s%E4%B9%8B%E8%B7%AF2-%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link rel=icon type=image/png href=/favicon.png><title>我的k8s之路2-应用部署 | kentxxq Blog</title><meta name=title content="我的k8s之路2-应用部署 | kentxxq Blog"><link rel=stylesheet href=/font/iconfont.css><link rel=stylesheet href=/css/main.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","image":"https:\/\/kentxxq.com\/images/me/avatar.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/kentxxq.com\/"},"articleSection":"posts","name":"我的k8s之路2-应用部署","headline":"我的k8s之路2-应用部署","description":"这是k8s的第二篇，但是已经时隔一年了。也不知道是k8s变化了，还是我之前的理解不够正确。不过我看了一眼，觉得上一篇写的一些内容，还是比较浅显易懂的，作为入门速览还不错。不过从这一篇开始，要好好抠细节了","inLanguage":"zh","author":"kentxxq","creator":"kentxxq","publisher":{"@type":"Organization","name":"kentxxq","logo":{"@type":"ImageObject","url":"https:\/\/kentxxq.com\/images/me/avatar.jpg"}},"accountablePerson":"kentxxq","copyrightHolder":"kentxxq","copyrightYear":"2020","datePublished":"2020-08-01 11:08:00","dateModified":"2021-02-26 00:06:04","url":"https:\/\/kentxxq.com\/contents\/%E6%88%91%E7%9A%84k8s%E4%B9%8B%E8%B7%AF2-%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2\/","keywords":["k8s","kubectl","kubernetes","Pod","Deployments","ReplicaSet","Job","Cronjob","DaemonSet"]}</script></head><body><div class=wrapper><nav class=navbar><div class=container><div class="navbar-header header-logo"><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://kentxxq.com/>kentxxq Blog</a></div><div class="menu navbar-right"><a class=menu-item href=/posts/ title>Blog</a>
<a class=menu-item href=/categories/ title>Categories</a>
<a class=menu-item href=/tags/ title>Tags</a>
<a class=menu-item href=/about/ title>About</a></div></div></nav><nav class=navbar-mobile id=nav-mobile style=display:none><div class=container><div class=navbar-header><div><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://kentxxq.com/>kentxxq Blog</a></div><div class=menu-toggle><span></span><span></span><span></span></div></div><div class=menu id=mobile-menu><a class=menu-item href=/posts/ title>Blog</a>
<a class=menu-item href=/categories/ title>Categories</a>
<a class=menu-item href=/tags/ title>Tags</a>
<a class=menu-item href=/about/ title>About</a></div></div></nav><main class=main><div class=container><article class=post-warp><header class=post-header><h1 class=post-title>我的k8s之路2-应用部署</h1><div class=post-meta>Written by <a href=https://kentxxq.com/ rel=author>kentxxq</a>
with ♥
<span class=post-time>on <time datetime=2020-08-01>August 1, 2020</time></span>
in
<i class="iconfont icon-folder"></i>
<span class=post-category><a href=https://kentxxq.com/categories/%E7%AC%94%E8%AE%B0/>笔记</a></span>
|
<a href=#gitalk-container><span class=gitalk-comment-count itemprop=commentCount></span></a></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title></h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#pod细节>pod细节</a></li><li><a href=#replicaset和deployments>ReplicaSet和Deployments</a></li><li><a href=#实例操作>实例操作</a><ul><li><a href=#简单示例>简单示例</a></li><li><a href=#模板示例>模板示例</a></li></ul></li><li><a href=#job>Job</a></li><li><a href=#cronjob>Cronjob</a></li><li><a href=#daemonset>DaemonSet</a></li><li><a href=#拓展知识>拓展知识</a></li><li><a href=#更新>更新</a></li></ul></nav></div></div><script type=text/javascript>window.onload=function(){var a=$('.post-toc'),b=$('.post-comment'),f=a.offset().top,d=a.height(),g=a[0].offsetTop,e,c;$(window).scroll(function(){var h=Math.max(document.body.scrollTop,document.documentElement.scrollTop);b.length>0&&(c=b.offset().top,e=c-h-d),f<h?(a.css({position:'fixed'}),b.length>0&&c<h+d?a.css({top:e}):a.css({top:0})):(a.css({position:'absolute'}),a.css({top:g}))})}</script><div class=post-content><blockquote><p>这是k8s的第二篇，但是已经时隔一年了。也不知道是k8s变化了，还是我之前的理解不够正确。
不过我看了一眼，觉得上一篇写的一些内容，还是比较浅显易懂的，作为入门速览还不错。不过从这一篇开始，要好好抠细节了。</p></blockquote><h2 id=pod细节>pod细节</h2><p>修正上一篇文章说的pod推荐内部只包含单个docker用法。因为一个pod内部拥有多个docker，在很多场景下是非常不错的解决方案。</p><p>首先要说明一件事情，既然pod允许内部包含多个docker，而pod内的资源是可以互访的。没有手动挂在共享内容，是如何实现的呢？</p><p>pod内部就是一个小集群。通过infra-container来进行连接，也称之为sidecar设计模式。这样设计有一些有点。</p><p><img src=/images/server/sidecar.png alt=sidecar></p><ol><li>单个image的更新，不会让整个pod重启。从而减少了开销。</li><li>解决了pod内容器共享资源的问题。pod内的容器读取到的ip，mac地址等网络相关信息，其实都是infra-container的。</li><li>方便拓展功能。例如我要加入一个nginx的转发。拿到一个/a的请求，可以在pod内新增一个用来代理的容器。把请求转发到应用容器的/b上。</li></ol><h2 id=replicaset和deployments>ReplicaSet和Deployments</h2><p>这里一次讲2种kind:<code>ReplicaSet</code>,<code>Deployments</code>。</p><p>ReplicaSet是用来创建pod的，控制pod的数量、使用的pod版本。</p><p>Deployments是一个无状态的应用。他是用来控制各个版本的ReplicaSet。</p><p>通过上面来匹配呢？label。</p><p><img src=/images/server/deployment.png alt=deployment></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># 查看运行的pods</span>
kubectl get pods
<span style=color:#75715e># 查看运行的replicasets</span>
kubectl get replicasets
<span style=color:#75715e># 查看运行的deployments</span>
kubectl get deployments
</code></pre></div><h2 id=实例操作>实例操作</h2><h3 id=简单示例>简单示例</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
<span style=color:#f92672>metadata</span>:
  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>myapp</span>
  <span style=color:#f92672>labels</span>:
    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>myapp</span>
<span style=color:#f92672>spec</span>:
  <span style=color:#f92672>containers</span>:
  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>myapp</span>
    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx:1.11.1</span>
    <span style=color:#f92672>resources</span>:
      <span style=color:#f92672>limits</span>:
        <span style=color:#f92672>memory</span>: <span style=color:#e6db74>&#34;128Mi&#34;</span>
        <span style=color:#f92672>cpu</span>: <span style=color:#e6db74>&#34;500m&#34;</span>
    <span style=color:#f92672>ports</span>:
      - <span style=color:#f92672>containerPort</span>: <span style=color:#ae81ff>80</span>
</code></pre></div><p>在上面我们写了一个最简单的pod模板：</p><ol><li>一个名为myapp的无状态应用，同时通过label:myapp来匹配内容</li><li>指定要用nginx:1.11.1镜像</li><li>限制了使用的资源</li><li>制定了要对集群暴露的端口</li></ol><h3 id=模板示例>模板示例</h3><p>模板示例不会把所有的参数都列出来。只是会把日常会用到的写出来。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Deployment</span>
<span style=color:#f92672>metadata</span>:
  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx-deployment</span>
  <span style=color:#f92672>labels</span>:
    <span style=color:#f92672>app</span>: <span style=color:#ae81ff>nginx</span>
    <span style=color:#f92672>env</span>: <span style=color:#ae81ff>test</span>
<span style=color:#f92672>spec</span>:
  <span style=color:#f92672>selector</span>:
    <span style=color:#f92672>matchLabels</span>:
      <span style=color:#f92672>app</span>: <span style=color:#ae81ff>nginx</span>
  <span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>2</span>
  <span style=color:#75715e># 进入ready状态20秒后，才判断容器为available</span>
  <span style=color:#f92672>minReadySeconds</span>: <span style=color:#ae81ff>20</span>
  <span style=color:#75715e># 超过这个时间deployment还没有完全部署成功，就会失败！默认600</span>
  <span style=color:#75715e># 必须必上面的值大。同时卡住后需要使用kubectl rollout undo回滚</span>
  <span style=color:#f92672>progressDeadlineSeconds</span>: <span style=color:#ae81ff>100</span>
  <span style=color:#75715e># 暂停部署deployment，这样可以通过set命令修改模板参数</span>
  <span style=color:#75715e># paused: true</span>
  <span style=color:#f92672>strategy</span>:
    <span style=color:#f92672>rollingUpdate</span>:
      <span style=color:#75715e># 默认25%的最大增长，100个pods，则升级时最多不能有125个</span>
      <span style=color:#75715e># 我这里改成一次最多起5个pod</span>
      <span style=color:#f92672>maxSurge</span>: <span style=color:#ae81ff>5</span>
      <span style=color:#75715e># 最大不可用，100个pods，则最少要有75个随时能提供服务</span>
      <span style=color:#f92672>maxUnavailable</span>: <span style=color:#ae81ff>25</span><span style=color:#ae81ff>%</span>
    <span style=color:#f92672>type</span>: <span style=color:#ae81ff>RollingUpdate</span>
  <span style=color:#75715e># 默认是10，保留的10个副本</span>
  <span style=color:#f92672>revisionHistoryLimit</span>: <span style=color:#ae81ff>0</span>
  <span style=color:#f92672>template</span>:
    <span style=color:#f92672>metadata</span>:
      <span style=color:#f92672>labels</span>:
        <span style=color:#f92672>app</span>: <span style=color:#ae81ff>nginx</span>
        <span style=color:#f92672>env</span>: <span style=color:#ae81ff>test</span>
    <span style=color:#f92672>spec</span>:
      <span style=color:#f92672>containers</span>:
        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx</span>
          <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx:1.18</span>
          <span style=color:#f92672>resources</span>:
            <span style=color:#f92672>requests</span>:
              <span style=color:#f92672>cpu</span>: <span style=color:#ae81ff>100m</span>
              <span style=color:#f92672>memory</span>: <span style=color:#ae81ff>100Mi</span>
            <span style=color:#f92672>limits</span>:
              <span style=color:#f92672>cpu</span>: <span style=color:#ae81ff>100m</span>
              <span style=color:#f92672>memory</span>: <span style=color:#ae81ff>100Mi</span>
          <span style=color:#f92672>ports</span>:
            - <span style=color:#f92672>containerPort</span>: <span style=color:#ae81ff>80</span>
          <span style=color:#75715e># 存活检测</span>
          <span style=color:#f92672>livenessProbe</span>:
            <span style=color:#f92672>tcpSocket</span>:
              <span style=color:#f92672>port</span>: <span style=color:#ae81ff>80</span>
            <span style=color:#75715e># 初始化等待，例如jvm启动需要一定可预见的时间</span>
            <span style=color:#f92672>initialDelaySeconds</span>: <span style=color:#ae81ff>5</span>
            <span style=color:#75715e># 超时时间</span>
            <span style=color:#f92672>timeoutSeconds</span>: <span style=color:#ae81ff>5</span>
            <span style=color:#75715e># 失败以后，需要成功几次才能判定真的成功了</span>
            <span style=color:#f92672>successThreshold</span>: <span style=color:#ae81ff>1</span>
            <span style=color:#75715e># 失败的重试次数</span>
            <span style=color:#f92672>failureThreshold</span>: <span style=color:#ae81ff>3</span>
            <span style=color:#75715e># 检测间隔时间</span>
            <span style=color:#f92672>periodSeconds</span>: <span style=color:#ae81ff>10</span>
          <span style=color:#f92672>readinessProbe</span>:
            <span style=color:#f92672>httpGet</span>:
              <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/</span>
              <span style=color:#f92672>port</span>: <span style=color:#ae81ff>80</span>
            <span style=color:#f92672>initialDelaySeconds</span>: <span style=color:#ae81ff>5</span>
            <span style=color:#f92672>timeoutSeconds</span>: <span style=color:#ae81ff>2</span>
            <span style=color:#f92672>successThreshold</span>: <span style=color:#ae81ff>1</span>
            <span style=color:#f92672>failureThreshold</span>: <span style=color:#ae81ff>3</span>
            <span style=color:#f92672>periodSeconds</span>: <span style=color:#ae81ff>10</span>
          <span style=color:#75715e># 总是从服务器拉取image，会检验digest。所以其实也很快</span>
          <span style=color:#f92672>imagePullPolicy</span>: <span style=color:#ae81ff>Always</span>
</code></pre></div><p>其实也没什么复杂的，也只有一点点细节设计：</p><ol><li>我们使用2个pod来提供服务。</li><li>加上了一些常用参数，具体说明都在注释里。</li></ol><p><strong>操作效果</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># 先观察pods情况</span>
kubectl get pods --watch
<span style=color:#75715e># 通过tt.yml文件创建或者更新集群</span>
kubectl apply -f tt.yml
<span style=color:#75715e># 查看deployments</span>
kubectl get deployments
<span style=color:#75715e># 通过label过滤查询</span>
kubectl.exe get deployments -l env<span style=color:#f92672>=</span>test



<span style=color:#75715e># 改动一次replicas的数量，查看rs状态</span>
kubectl get rs
<span style=color:#75715e># 发现有多个replicas版本，默认是10个，说明默认自带回退10个版本的功能</span>
<span style=color:#75715e># 默认回退上一个版本，指定参数可回退到指定版本，但是不推荐使用！！！！</span>
<span style=color:#75715e># 应该用apply应用声明的方式来进行，因为命令式存在重复操作的可能性。而声明式是修改最终状态！！！！</span>
kubectl rollout undo deployment/nginx-deployment --to-revision<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>
</code></pre></div><h2 id=job>Job</h2><p>一次性任务就是job。应用场景：突然有很多的任务堆积，临时加服务消费掉任务。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>batch/v1</span>
<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Job</span>
<span style=color:#f92672>metadata</span>:
  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>myjob</span>
  <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>default</span>
  <span style=color:#f92672>labels</span>:
    <span style=color:#f92672>app</span>: <span style=color:#ae81ff>myjob</span>
<span style=color:#f92672>spec</span>:
  <span style=color:#75715e># 执行8次这个镜像</span>
  <span style=color:#f92672>completions</span>: <span style=color:#ae81ff>8</span>
  <span style=color:#75715e># 每次可以2个并发</span>
  <span style=color:#f92672>parallelism</span>: <span style=color:#ae81ff>2</span>
  <span style=color:#f92672>template</span>:
    <span style=color:#f92672>metadata</span>:
      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>myjob</span>
      <span style=color:#f92672>labels</span>:
        <span style=color:#f92672>app</span>: <span style=color:#ae81ff>myjob</span>
    <span style=color:#f92672>spec</span>:
      <span style=color:#f92672>containers</span>:
      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>myjob</span>
        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>ubuntu</span>
        <span style=color:#f92672>command</span>: [<span style=color:#e6db74>&#39;/bin/sh&#39;</span>]
        <span style=color:#f92672>args</span>:
          - -<span style=color:#ae81ff>c</span>
          - <span style=color:#ae81ff>echo hello from myjob</span>
      <span style=color:#f92672>restartPolicy</span>: <span style=color:#ae81ff>OnFailure</span>
</code></pre></div><h2 id=cronjob>Cronjob</h2><p>定时任务就是cronjob。应用场景：日志清理，日常跑批。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>batch/v1beta1</span>
<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>CronJob</span>
<span style=color:#f92672>metadata</span>:
  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>hello</span>
  <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>default</span>
<span style=color:#f92672>spec</span>:
  <span style=color:#75715e># 和linux的crontab一致</span>
  <span style=color:#f92672>schedule</span>: <span style=color:#e6db74>&#34;*/1 * * * *&#34;</span>
  <span style=color:#75715e># Pod最长启动或者运行时间</span>
  <span style=color:#f92672>startingDeadlineSeconds</span>: <span style=color:#ae81ff>10</span>
  <span style=color:#75715e># 是否允许并行</span>
  <span style=color:#f92672>concurrencyPolicy</span>: <span style=color:#ae81ff>Allow</span>
  <span style=color:#75715e># 允许保留job的历史个数</span>
  <span style=color:#f92672>successfulJobHistoryLimit</span>: <span style=color:#ae81ff>4</span>
  <span style=color:#f92672>jobTemplate</span>:
    <span style=color:#f92672>spec</span>:
      <span style=color:#f92672>template</span>:
        <span style=color:#f92672>spec</span>:
          <span style=color:#f92672>containers</span>:
          - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>hello</span>
            <span style=color:#f92672>image</span>: <span style=color:#ae81ff>busybox</span>
            <span style=color:#f92672>args</span>: [<span style=color:#e6db74>&#39;/bin/sh&#39;</span>, <span style=color:#e6db74>&#39;-c&#39;</span>, <span style=color:#e6db74>&#39;date; echo Hello from the Kubernetes cluster&#39;</span>]
          <span style=color:#f92672>restartPolicy</span>: <span style=color:#ae81ff>OnFailure</span>
</code></pre></div><h2 id=daemonset>DaemonSet</h2><p>在每一个节点或指定节点上运行一个pod服务。应用场景：加入一个新机器需要执行一个骚操作。例如加入rds的白名单。或者node节点自动伸缩，每次拓展的时候推送通知。还有node节点日志收集等内容</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>DaemonSet</span>
<span style=color:#f92672>metadata</span>:
  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>MYAPP</span>
  <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>default</span>
  <span style=color:#f92672>labels</span>:
    <span style=color:#f92672>app</span>: <span style=color:#ae81ff>MYAPP</span>
<span style=color:#f92672>spec</span>:
  <span style=color:#f92672>selector</span>:
    <span style=color:#f92672>matchLabels</span>:
      <span style=color:#f92672>app</span>: <span style=color:#ae81ff>MYAPP</span>
  <span style=color:#f92672>template</span>:
    <span style=color:#f92672>metadata</span>:
      <span style=color:#f92672>labels</span>:
        <span style=color:#f92672>app</span>: <span style=color:#ae81ff>MYAPP</span>
    <span style=color:#f92672>spec</span>:
      <span style=color:#f92672>tolerations</span>:
      <span style=color:#75715e># 这里的tolerations是在master节点上也要指定。不要的话就删掉它</span>
      - <span style=color:#f92672>key</span>: <span style=color:#ae81ff>node-role.kubernetes.io/master</span>
        <span style=color:#f92672>effect</span>: <span style=color:#ae81ff>NoSchedule</span>
      <span style=color:#f92672>containers</span>:
      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>MYAPP</span>
        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>debian</span>
        <span style=color:#f92672>resources</span>:
          <span style=color:#f92672>limits</span>:
            <span style=color:#f92672>memory</span>: <span style=color:#ae81ff>200Mi</span>
          <span style=color:#f92672>requests</span>:
            <span style=color:#f92672>cpu</span>: <span style=color:#ae81ff>100m</span>
            <span style=color:#f92672>memory</span>: <span style=color:#ae81ff>200Mi</span>
      <span style=color:#f92672>terminationGracePeriodSeconds</span>: <span style=color:#ae81ff>30</span>
</code></pre></div><h2 id=拓展知识>拓展知识</h2><p><a href=https://github.com/mziyabo/PSKubectlCompletion>PSKubectlCompletion</a>：提供powershell的自动补全</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># 声明式，推荐使用</span>
kubectl apply -f test.yml
<span style=color:#75715e># 命令式则更适用于job。create是立即干掉pod后执行job</span>
kubectl create -f test.yml
</code></pre></div><h2 id=更新>更新</h2><p><strong>20200805</strong>：在deployment新加参数<code>imagePullPolicy</code>,修改参数示例，修改http存活请求地址</p></div><div class=post-copyright><p class=copyright-item><span>Author:</span>
<span>kentxxq</span></p><p class=copyright-item><span>Link:</span>
<a href=https://kentxxq.com/contents/%E6%88%91%E7%9A%84k8s%E4%B9%8B%E8%B7%AF2-%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/><script>document.write(decodeURI(location.origin+location.pathname))</script></a></p><p class="copyright-item lincese">本文采用<a rel=license href=http://creativecommons.org/licenses/by-nc/4.0/ target=_blank>知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p></div><div class=post-tags><section><i class="iconfont icon-tag"></i>Tag(s):
<span class=tag><a href=https://kentxxq.com/tags/k8s/>#k8s</a></span></section><section><a href=javascript:window.history.back();>back</a></span> ·
<span><a href=https://kentxxq.com/>home</a></span></section></div><div class=post-nav><a href=https://kentxxq.com/contents/linux%E4%B9%8Blimit%E9%99%90%E5%88%B6/ class=prev rel=prev title=linux之limit限制><i class="iconfont icon-left"></i>&nbsp;linux之limit限制</a>
<a href=https://kentxxq.com/contents/%E6%88%91%E7%9A%84k8s%E4%B9%8B%E8%B7%AF0-%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/ class=next rel=next title=我的k8s之路0-集群部署>我的k8s之路0-集群部署&nbsp;<i class="iconfont icon-right"></i></a></div></article></div></main><footer class=footer><a href=https://beian.miit.gov.cn/ target=_blank rel="external nofollow">湘ICP备2021002319号-1</a></footer><link href=//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css rel=stylesheet><script src=/js/vendor_gallery.min.js async></script><script src=https://cdn.bootcss.com/mermaid/8.0.0-rc.8/mermaid.min.js></script></div></body></html>